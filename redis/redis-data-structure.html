<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.66" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.ixlymsy.top/redis/redis-data-structure.html"><meta property="og:site_name" content="个人成长全记录-码说256"><meta property="og:title" content="Redis中的数据结构"><meta property="og:description" content="原文地址 Redis中的数据结构 (https://www.cnblogs.com/neooelric/p/9621736.html) 1. 底层数据结构, 与Redis Value Type之间的关系 对于Redis的使用者来说, Redis作为Key-Value型的内存数据库, 其Value有多种类型. String; Hash; List; Se..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-07-14T13:51:32.000Z"><meta property="article:author" content="码说256"><meta property="article:tag" content="redis"><meta property="article:tag" content="面试"><meta property="article:tag" content="面试总结"><meta property="article:modified_time" content="2023-07-14T13:51:32.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Redis中的数据结构","image":[""],"dateModified":"2023-07-14T13:51:32.000Z","author":[{"@type":"Person","name":"码说256","url":"https://www.ixlymsy.top"}]}</script><title>Redis中的数据结构 | 个人成长全记录-码说256</title><meta name="description" content="原文地址 Redis中的数据结构 (https://www.cnblogs.com/neooelric/p/9621736.html) 1. 底层数据结构, 与Redis Value Type之间的关系 对于Redis的使用者来说, Redis作为Key-Value型的内存数据库, 其Value有多种类型. String; Hash; List; Se...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-3401b203.css" as="style"><link rel="stylesheet" href="/assets/style-3401b203.css">
    <link rel="modulepreload" href="/assets/app-23d1540c.js"><link rel="modulepreload" href="/assets/redis-data-structure.html-f17ec180.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js"><link rel="modulepreload" href="/assets/redis-data-structure.html-59274fd6.js"><link rel="prefetch" href="/assets/index.html-922fd467.js" as="script"><link rel="prefetch" href="/assets/css.html-b21625c4.js" as="script"><link rel="prefetch" href="/assets/channel.html-56bc92db.js" as="script"><link rel="prefetch" href="/assets/gin1.html-f70aec91.js" as="script"><link rel="prefetch" href="/assets/go-gpm.html-84092e76.js" as="script"><link rel="prefetch" href="/assets/go-scheduler-base.html-ab2c0534.js" as="script"><link rel="prefetch" href="/assets/map1.html-80822925.js" as="script"><link rel="prefetch" href="/assets/map2.html-3c6862cf.js" as="script"><link rel="prefetch" href="/assets/mux1.html-d00b7c2b.js" as="script"><link rel="prefetch" href="/assets/slice1.html-afc59263.js" as="script"><link rel="prefetch" href="/assets/mysql-index-b-plus.html-e3bf5f3d.js" as="script"><link rel="prefetch" href="/assets/mysql-interview.html-e15234c1.js" as="script"><link rel="prefetch" href="/assets/mysql-mvcc.html-afb62414.js" as="script"><link rel="prefetch" href="/assets/mysql1.html-fd732ed4.js" as="script"><link rel="prefetch" href="/assets/mysql2.html-057df47a.js" as="script"><link rel="prefetch" href="/assets/mysql3.html-763e2f0e.js" as="script"><link rel="prefetch" href="/assets/interview1.html-25acba31.js" as="script"><link rel="prefetch" href="/assets/redis-basic.html-8c1e52da.js" as="script"><link rel="prefetch" href="/assets/redis-cache-things.html-aa1b2d73.js" as="script"><link rel="prefetch" href="/assets/redis-master-slave.html-d07fc20c.js" as="script"><link rel="prefetch" href="/assets/redis-mem.html-44f8ce2d.js" as="script"><link rel="prefetch" href="/assets/redis-policy.html-c787cfc1.js" as="script"><link rel="prefetch" href="/assets/redis-rdb.html-572e9eeb.js" as="script"><link rel="prefetch" href="/assets/docker-ignore.html-a8fcccc7.js" as="script"><link rel="prefetch" href="/assets/docker-log-clean.html-d3900bbc.js" as="script"><link rel="prefetch" href="/assets/ruoyi-nginx-web.html-81e17d0f.js" as="script"><link rel="prefetch" href="/assets/ruoyi-nginx.html-7964605e.js" as="script"><link rel="prefetch" href="/assets/index.html-3f7f8c20.js" as="script"><link rel="prefetch" href="/assets/q001.html-8e389a13.js" as="script"><link rel="prefetch" href="/assets/q002.html-c0c829db.js" as="script"><link rel="prefetch" href="/assets/q003.html-4220f483.js" as="script"><link rel="prefetch" href="/assets/q004.html-809539b3.js" as="script"><link rel="prefetch" href="/assets/q005.html-70b6b7d8.js" as="script"><link rel="prefetch" href="/assets/q006.html-27d981e9.js" as="script"><link rel="prefetch" href="/assets/q007.html-c781cb31.js" as="script"><link rel="prefetch" href="/assets/q008.html-e8cab93e.js" as="script"><link rel="prefetch" href="/assets/q009.html-fd757ae6.js" as="script"><link rel="prefetch" href="/assets/q010.html-43826eb8.js" as="script"><link rel="prefetch" href="/assets/q011.html-bbcab30b.js" as="script"><link rel="prefetch" href="/assets/q012.html-c2544b0e.js" as="script"><link rel="prefetch" href="/assets/q013.html-e14d5842.js" as="script"><link rel="prefetch" href="/assets/q014.html-29e78c8f.js" as="script"><link rel="prefetch" href="/assets/q015.html-f82061e2.js" as="script"><link rel="prefetch" href="/assets/q016.html-f4e54281.js" as="script"><link rel="prefetch" href="/assets/q017.html-e6600f3d.js" as="script"><link rel="prefetch" href="/assets/q018.html-be5c0827.js" as="script"><link rel="prefetch" href="/assets/q019.html-c72f9ed6.js" as="script"><link rel="prefetch" href="/assets/q020.html-46b9b293.js" as="script"><link rel="prefetch" href="/assets/q021.html-143bcf92.js" as="script"><link rel="prefetch" href="/assets/q022.html-d98b0f93.js" as="script"><link rel="prefetch" href="/assets/404.html-f436630f.js" as="script"><link rel="prefetch" href="/assets/index.html-b8532a1a.js" as="script"><link rel="prefetch" href="/assets/index.html-ea7bc083.js" as="script"><link rel="prefetch" href="/assets/index.html-12a72a9d.js" as="script"><link rel="prefetch" href="/assets/index.html-f426ccc2.js" as="script"><link rel="prefetch" href="/assets/index.html-2d516e00.js" as="script"><link rel="prefetch" href="/assets/index.html-ebb5a7cb.js" as="script"><link rel="prefetch" href="/assets/index.html-6838ed1f.js" as="script"><link rel="prefetch" href="/assets/index.html-d388366c.js" as="script"><link rel="prefetch" href="/assets/index.html-f3228ffb.js" as="script"><link rel="prefetch" href="/assets/index.html-3930c269.js" as="script"><link rel="prefetch" href="/assets/index.html-a3e7c6a2.js" as="script"><link rel="prefetch" href="/assets/index.html-370a637c.js" as="script"><link rel="prefetch" href="/assets/index.html-5248b738.js" as="script"><link rel="prefetch" href="/assets/index.html-af09bfde.js" as="script"><link rel="prefetch" href="/assets/index.html-17d8ccc7.js" as="script"><link rel="prefetch" href="/assets/index.html-09ccade7.js" as="script"><link rel="prefetch" href="/assets/index.html-af0783b2.js" as="script"><link rel="prefetch" href="/assets/index.html-a056508c.js" as="script"><link rel="prefetch" href="/assets/index.html-aaeaedee.js" as="script"><link rel="prefetch" href="/assets/index.html-854468ab.js" as="script"><link rel="prefetch" href="/assets/index.html-bd12a324.js" as="script"><link rel="prefetch" href="/assets/index.html-969e50dd.js" as="script"><link rel="prefetch" href="/assets/index.html-f556bdcc.js" as="script"><link rel="prefetch" href="/assets/index.html-e0b5ee80.js" as="script"><link rel="prefetch" href="/assets/index.html-0343f13d.js" as="script"><link rel="prefetch" href="/assets/index.html-ea512c41.js" as="script"><link rel="prefetch" href="/assets/index.html-2ac1bd2f.js" as="script"><link rel="prefetch" href="/assets/index.html-19de9490.js" as="script"><link rel="prefetch" href="/assets/index.html-03a0eba2.js" as="script"><link rel="prefetch" href="/assets/index.html-c641581c.js" as="script"><link rel="prefetch" href="/assets/index.html-c95be32e.js" as="script"><link rel="prefetch" href="/assets/index.html-e65aa1a0.js" as="script"><link rel="prefetch" href="/assets/index.html-bd24f074.js" as="script"><link rel="prefetch" href="/assets/index.html-df6c7292.js" as="script"><link rel="prefetch" href="/assets/index.html-688ffbe1.js" as="script"><link rel="prefetch" href="/assets/index.html-925b173f.js" as="script"><link rel="prefetch" href="/assets/index.html-920bf324.js" as="script"><link rel="prefetch" href="/assets/index.html-12a919ca.js" as="script"><link rel="prefetch" href="/assets/index.html-e8ce1c80.js" as="script"><link rel="prefetch" href="/assets/index.html-67b749c8.js" as="script"><link rel="prefetch" href="/assets/index.html-875f5f54.js" as="script"><link rel="prefetch" href="/assets/index.html-94ceb22a.js" as="script"><link rel="prefetch" href="/assets/index.html-a192210a.js" as="script"><link rel="prefetch" href="/assets/css.html-12f147e9.js" as="script"><link rel="prefetch" href="/assets/channel.html-193d2513.js" as="script"><link rel="prefetch" href="/assets/gin1.html-230824aa.js" as="script"><link rel="prefetch" href="/assets/go-gpm.html-cf971b73.js" as="script"><link rel="prefetch" href="/assets/go-scheduler-base.html-149845e0.js" as="script"><link rel="prefetch" href="/assets/map1.html-8139113a.js" as="script"><link rel="prefetch" href="/assets/map2.html-f70ce77b.js" as="script"><link rel="prefetch" href="/assets/mux1.html-46111e70.js" as="script"><link rel="prefetch" href="/assets/slice1.html-51cad7b7.js" as="script"><link rel="prefetch" href="/assets/mysql-index-b-plus.html-0fbbeae7.js" as="script"><link rel="prefetch" href="/assets/mysql-interview.html-b9c9eb2c.js" as="script"><link rel="prefetch" href="/assets/mysql-mvcc.html-f3b850c7.js" as="script"><link rel="prefetch" href="/assets/mysql1.html-ea261248.js" as="script"><link rel="prefetch" href="/assets/mysql2.html-c4f20516.js" as="script"><link rel="prefetch" href="/assets/mysql3.html-ad6d0b55.js" as="script"><link rel="prefetch" href="/assets/interview1.html-ed501bc1.js" as="script"><link rel="prefetch" href="/assets/redis-basic.html-f6b10e07.js" as="script"><link rel="prefetch" href="/assets/redis-cache-things.html-d7f82e59.js" as="script"><link rel="prefetch" href="/assets/redis-master-slave.html-3ebfd629.js" as="script"><link rel="prefetch" href="/assets/redis-mem.html-0dcd63ca.js" as="script"><link rel="prefetch" href="/assets/redis-policy.html-60717eeb.js" as="script"><link rel="prefetch" href="/assets/redis-rdb.html-b2c96e5e.js" as="script"><link rel="prefetch" href="/assets/docker-ignore.html-8401a01d.js" as="script"><link rel="prefetch" href="/assets/docker-log-clean.html-09a8b6b1.js" as="script"><link rel="prefetch" href="/assets/ruoyi-nginx-web.html-417bf90a.js" as="script"><link rel="prefetch" href="/assets/ruoyi-nginx.html-2a1f0731.js" as="script"><link rel="prefetch" href="/assets/index.html-8e7684c2.js" as="script"><link rel="prefetch" href="/assets/q001.html-e52cb5d1.js" as="script"><link rel="prefetch" href="/assets/q002.html-a352ad54.js" as="script"><link rel="prefetch" href="/assets/q003.html-78604f43.js" as="script"><link rel="prefetch" href="/assets/q004.html-c0e7db2b.js" as="script"><link rel="prefetch" href="/assets/q005.html-a5630039.js" as="script"><link rel="prefetch" href="/assets/q006.html-7f0ab1d3.js" as="script"><link rel="prefetch" href="/assets/q007.html-7b20307d.js" as="script"><link rel="prefetch" href="/assets/q008.html-7be07723.js" as="script"><link rel="prefetch" href="/assets/q009.html-9c13a637.js" as="script"><link rel="prefetch" href="/assets/q010.html-07b6aee0.js" as="script"><link rel="prefetch" href="/assets/q011.html-f8494b77.js" as="script"><link rel="prefetch" href="/assets/q012.html-0daf9a09.js" as="script"><link rel="prefetch" href="/assets/q013.html-6f11e2b8.js" as="script"><link rel="prefetch" href="/assets/q014.html-1dfd463a.js" as="script"><link rel="prefetch" href="/assets/q015.html-ebb5b1f1.js" as="script"><link rel="prefetch" href="/assets/q016.html-007c901f.js" as="script"><link rel="prefetch" href="/assets/q017.html-943cf04b.js" as="script"><link rel="prefetch" href="/assets/q018.html-79603ed6.js" as="script"><link rel="prefetch" href="/assets/q019.html-171d276a.js" as="script"><link rel="prefetch" href="/assets/q020.html-9d56dcb6.js" as="script"><link rel="prefetch" href="/assets/q021.html-5cd26e78.js" as="script"><link rel="prefetch" href="/assets/q022.html-da38fc31.js" as="script"><link rel="prefetch" href="/assets/404.html-a23197da.js" as="script"><link rel="prefetch" href="/assets/index.html-405a35ec.js" as="script"><link rel="prefetch" href="/assets/index.html-dc3dc710.js" as="script"><link rel="prefetch" href="/assets/index.html-9f6e473f.js" as="script"><link rel="prefetch" href="/assets/index.html-03b91847.js" as="script"><link rel="prefetch" href="/assets/index.html-da08583b.js" as="script"><link rel="prefetch" href="/assets/index.html-fc022083.js" as="script"><link rel="prefetch" href="/assets/index.html-290512f6.js" as="script"><link rel="prefetch" href="/assets/index.html-e7d95b8f.js" as="script"><link rel="prefetch" href="/assets/index.html-00be96f6.js" as="script"><link rel="prefetch" href="/assets/index.html-62bda041.js" as="script"><link rel="prefetch" href="/assets/index.html-e3829f30.js" as="script"><link rel="prefetch" href="/assets/index.html-09d78ffa.js" as="script"><link rel="prefetch" href="/assets/index.html-ba69863f.js" as="script"><link rel="prefetch" href="/assets/index.html-4e37150d.js" as="script"><link rel="prefetch" href="/assets/index.html-ef608082.js" as="script"><link rel="prefetch" href="/assets/index.html-0a6f2472.js" as="script"><link rel="prefetch" href="/assets/index.html-5834afed.js" as="script"><link rel="prefetch" href="/assets/index.html-84d3abc6.js" as="script"><link rel="prefetch" href="/assets/index.html-bb048a2a.js" as="script"><link rel="prefetch" href="/assets/index.html-b5160f99.js" as="script"><link rel="prefetch" href="/assets/index.html-4b98553b.js" as="script"><link rel="prefetch" href="/assets/index.html-e3117177.js" as="script"><link rel="prefetch" href="/assets/index.html-a771085c.js" as="script"><link rel="prefetch" href="/assets/index.html-4030c60f.js" as="script"><link rel="prefetch" href="/assets/index.html-67b6516f.js" as="script"><link rel="prefetch" href="/assets/index.html-3388b29c.js" as="script"><link rel="prefetch" href="/assets/index.html-21d4ce08.js" as="script"><link rel="prefetch" href="/assets/index.html-19389ec6.js" as="script"><link rel="prefetch" href="/assets/index.html-a38cfbc7.js" as="script"><link rel="prefetch" href="/assets/index.html-32e04ea8.js" as="script"><link rel="prefetch" href="/assets/index.html-b9e04fd7.js" as="script"><link rel="prefetch" href="/assets/index.html-1ecfedf8.js" as="script"><link rel="prefetch" href="/assets/index.html-eee83ca8.js" as="script"><link rel="prefetch" href="/assets/index.html-87ce81e5.js" as="script"><link rel="prefetch" href="/assets/index.html-c9f98c0d.js" as="script"><link rel="prefetch" href="/assets/index.html-a3f2572b.js" as="script"><link rel="prefetch" href="/assets/index.html-36277a94.js" as="script"><link rel="prefetch" href="/assets/index.html-5a78011c.js" as="script"><link rel="prefetch" href="/assets/index.html-c838fbcd.js" as="script"><link rel="prefetch" href="/assets/index.html-499d2722.js" as="script"><link rel="prefetch" href="/assets/index.html-e8d293b2.js" as="script"><link rel="prefetch" href="/assets/index.html-9190a6db.js" as="script"><link rel="prefetch" href="/assets/giscus-765fdce2.js" as="script"><link rel="prefetch" href="/assets/auto-fa8841cf.js" as="script"><link rel="prefetch" href="/assets/index-a7d1ee58.js" as="script"><link rel="prefetch" href="/assets/flowchart-c441f34d.js" as="script"><link rel="prefetch" href="/assets/mermaid.core-b767ba60.js" as="script"><link rel="prefetch" href="/assets/highlight.esm-75b11b9d.js" as="script"><link rel="prefetch" href="/assets/markdown.esm-abe06b83.js" as="script"><link rel="prefetch" href="/assets/math.esm-70a288c8.js" as="script"><link rel="prefetch" href="/assets/notes.esm-a106bb2c.js" as="script"><link rel="prefetch" href="/assets/reveal.esm-ec5549c1.js" as="script"><link rel="prefetch" href="/assets/search.esm-7e6792e2.js" as="script"><link rel="prefetch" href="/assets/zoom.esm-b83b91d0.js" as="script"><link rel="prefetch" href="/assets/VuePlayground-8135bd92.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-5794cde2.js" as="script"><link rel="prefetch" href="/assets/SearchResult-afd3b3b3.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand" href="/"><img class="vp-nav-logo" src="/logo.png" alt="个人成长全记录-码说256"><!----><span class="vp-site-name hide-in-pad">个人成长全记录-码说256</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>首页<!----></a></div><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/golang/"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>Golang<!----></a></div><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/php/"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>PHP<!----></a></div><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/mysql/"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>MySQL<!----></a></div><div class="nav-item hide-in-mobile"><a class="vp-link nav-link active" href="/redis/"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>Redis<!----></a></div><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/fe/"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>前端<!----></a></div><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/yunwei/"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>运维<!----></a></div><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/tag/%E9%9D%A2%E8%AF%95/"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>面试总结<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>首页<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">Golang</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/golang/gin1.html"><!---->Golang通过Gin框架创建http服务源码剖析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/golang/slice1.html"><!---->Go面试之Slice<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/golang/map1.html"><!---->Go面试之map、struct、interface<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/golang/map2.html"><!---->Go面试之并发安全的map<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/golang/channel.html"><!---->Go面试之Channel的使用<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/golang/mux1.html"><!---->Go面试之sync.Mutex和sync.RWMutex<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/golang/go-scheduler-base.html"><!---->goroutine调度器概述<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/golang/go-gpm.html"><!---->Go语言的GPM调度器是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Golang 常见面试题目解析</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">PHP</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/php/interview1.html"><!---->PHP面试总结 v20180824<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">MySQL</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/mysql/mysql1.html"><!---->MySQL相关知识点浅析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/mysql/mysql2.html"><!---->MySQL笔记之基础篇<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/mysql/mysql3.html"><!---->MySQL笔记之实践篇<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/mysql/mysql-interview.html"><!---->MySQL数据库经典面试题解析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/mysql/mysql-mvcc.html"><!---->MySQL InnoDB MVCC 机制的原理及实现<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/mysql/mysql-index-b-plus.html"><!---->为什么MySQL使用B+树做索引？<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading active"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">Redis</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/redis/redis-basic.html"><!---->Redis 基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/redis/redis-data-structure.html"><!---->Redis中的数据结构<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/redis/redis-data-structure.html#_1-底层数据结构-与redis-value-type之间的关系"><!---->1. 底层数据结构, 与Redis Value Type之间的关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/redis/redis-data-structure.html#_2-底层数据结构"><!---->2. 底层数据结构<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/redis/redis-data-structure.html#_2-1-sds-simple-dynamic-string"><!---->2.1 SDS - simple dynamic string<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/redis/redis-data-structure.html#_2-2-list"><!---->2.2 list<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/redis/redis-data-structure.html#_2-3-dict"><!---->2.3 dict<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/redis/redis-data-structure.html#_2-4-zskiplist"><!---->2.4 zskiplist<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/redis/redis-data-structure.html#_2-5-intset"><!---->2.5 intset<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/redis/redis-data-structure.html#_2-6-ziplist"><!---->2.6 ziplist<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/redis/redis-data-structure.html#_2-7-quicklist"><!---->2.7 quicklist<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/redis/redis-data-structure.html#_2-8-zipmap"><!---->2.8 zipmap<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/redis/redis-master-slave.html"><!---->Redis主从复制原理<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/redis/redis-policy.html"><!---->Redis中内存淘汰算法实现<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/redis/redis-rdb.html"><!---->Redis持久化的原理及优化<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/redis/redis-mem.html"><!---->Redis内存分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/redis/redis-cache-things.html"><!---->缓存系统中面临的雪崩/穿透/一致性问题<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">前端</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe/css.html"><!---->文本超出宽度省略号<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">运维</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/yunwei/ruoyi-nginx.html"><!---->若依前端配置<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/yunwei/docker-ignore.html"><!---->docker忽略相关文件<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/yunwei/docker-log-clean.html"><!---->docker清理日志<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/yunwei/ruoyi-nginx-web.html"><!---->若依Nginx配置示例<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Redis中的数据结构</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://www.ixlymsy.top" target="_blank" rel="noopener noreferrer">码说256</a></span><span property="author" content="码说256"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-07-14T13:51:32.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 39 分钟</span><meta property="timeRequired" content="PT39M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category5 clickable" role="navigation">redis</span><!--]--><meta property="articleSection" content="redis"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag5 clickable" role="navigation">redis</span><span class="page-tag-item tag2 clickable" role="navigation">面试</span><span class="page-tag-item tag3 clickable" role="navigation">面试总结</span><!--]--><meta property="keywords" content="redis,面试,面试总结"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#_1-底层数据结构-与redis-value-type之间的关系">1. 底层数据结构, 与Redis Value Type之间的关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#_2-底层数据结构">2. 底层数据结构</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2-1-sds-simple-dynamic-string">2.1 SDS - simple dynamic string</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2-2-list">2.2 list</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2-3-dict">2.3 dict</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2-4-zskiplist">2.4 zskiplist</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2-5-intset">2.5 intset</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2-6-ziplist">2.6 ziplist</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2-7-quicklist">2.7 quicklist</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2-8-zipmap">2.8 zipmap</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="redis中的数据结构" tabindex="-1"><a class="header-anchor" href="#redis中的数据结构" aria-hidden="true">#</a> Redis中的数据结构</h1><p>原文地址 <a href="https://www.cnblogs.com/neooelric/p/9621736.html" target="_blank" rel="noopener noreferrer">Redis中的数据结构<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_1-底层数据结构-与redis-value-type之间的关系" tabindex="-1"><a class="header-anchor" href="#_1-底层数据结构-与redis-value-type之间的关系" aria-hidden="true">#</a> 1. 底层数据结构, 与Redis Value Type之间的关系</h2><p>对于Redis的使用者来说, Redis作为Key-Value型的内存数据库, 其Value有多种类型.</p><ul><li>String</li><li>Hash</li><li>List</li><li>Set</li><li>ZSet</li></ul><p>这些Value的类型, 只是&quot;Redis的用户认为的, Value存储数据的方式&quot;. 而在具体实现上, 各个Type的Value到底如何存储, 这对于Redis的使用者来说是不公开的.</p><p>举个粟子: 使用下面的命令创建一个Key-Value</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SET <span class="token string">&quot;Hello&quot;</span> <span class="token string">&quot;World&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于Redis的使用者来说, <code>Hello</code>这个Key, 对应的Value是String类型, 其值为五个ASCII字符组成的二进制数据. 但具体在底层实现上, 这五个字节是如何存储的, 是不对用户公开的. 即, Value的Type, 只是表象, 具体数据在内存中以何种数据结构存放, 这对于用户来说是不必要了解的.</p><p>Redis对使用者暴露了五种<code>Value Type</code>, 其底层实现的数据结构有8种, 分别是:</p><ul><li>SDS - simple synamic string - 支持自动动态扩容的字节数组</li><li>list - 平平无奇的链表</li><li>dict - 使用双哈希表实现的, 支持平滑扩容的字典</li><li>zskiplist - 附加了后向指针的跳跃表</li><li>intset - 用于存储整数数值集合的自有结构</li><li>ziplist - 一种实现上类似于TLV, 但比TLV复杂的, 用于存储任意数据的有序序列的数据结构</li><li>quicklist - 一种以ziplist作为结点的双链表结构, 实现的非常苟</li><li>zipmap - 一种用于在小规模场合使用的轻量级字典结构</li></ul><p>而衔接&quot;底层数据结构&quot;与&quot;Value Type&quot;的桥梁的, 则是Redis实现的另外一种数据结构: <code>redisObject</code>. Redis中的Key与Value在表层都是一个<code>redisObject</code>实例, 故该结构有所谓的&quot;类型&quot;, 即是<code>ValueType</code>. 对于每一种<code>Value Type</code>类型的<code>redisObject</code>, 其底层至少支持两种不同的底层数据结构来实现. 以应对在不同的应用场景中, Redis的运行效率, 或内存占用.</p><h2 id="_2-底层数据结构" tabindex="-1"><a class="header-anchor" href="#_2-底层数据结构" aria-hidden="true">#</a> 2. 底层数据结构</h2><h3 id="_2-1-sds-simple-dynamic-string" tabindex="-1"><a class="header-anchor" href="#_2-1-sds-simple-dynamic-string" aria-hidden="true">#</a> 2.1 SDS - simple dynamic string</h3><p>这是一种用于存储二进制数据的一种结构, 具有动态扩容的特点. 其实现位于src/sds.h与src/sds.c中, 其关键定义如下:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>typedef char *sds;

/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SDS的总体概览如下图:</p><figure><img src="data:image/png;base64,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" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>其中sdshdr是头部, buf是真实存储用户数据的地方. 另外注意, 从命名上能看出来, 这个数据结构除了能存储二进制数据, 显然是用于设计作为字符串使用的, 所以在buf中, 用户数据后总跟着一个\0. 即图中 &quot;数据&quot; + &quot;\0&quot; 是为所谓的buf</p><p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的头部, 分别如下:</p><figure><img src="/assets/668722-20180910183940043-66166526-60c4131a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>len分别以uint8, uint16, uint32, uint64表示用户数据的长度(不包括末尾的\0)</li><li>alloc分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数.</li><li>flag始终为一字节, 以低三位标示着头部的类型, 高5位未使用.</li></ul><p>当在程序中持有一个SDS实例时, 直接持有的是数据区的头指针, 这样做的用意是: 通过这个指针, 向前偏一个字节, 就能取到flag, 通过判断flag低三位的值, 能迅速判断: 头部的类型, 已用字节数, 总字节数, 剩余字节数. 这也是为什么sds类型即是char *指针类型别名的原因.</p><p>创建一个SDS实例有三个接口, 分别是:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>// 创建一个不含数据的sds: 
//  头部    3字节 sdshdr8
//  数据区  0字节
//  末尾    \0 占一字节
sds sdsempty(void);
// 带数据创建一个sds:
//  头部    按initlen的值, 选择最小的头部类型
//  数据区  从入参指针init处开始, 拷贝initlen个字节
//  末尾    \0 占一字节
sds sdsnewlen(const void *init, size_t initlen);
// 带数据创建一个sds:
//  头部    按strlen(init)的值, 选择最小的头部类型
//  数据区  入参指向的字符串中的所有字符, 不包括末尾 \0
//  末尾    \0 占一字节
sds sdsnew(const char *init);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>所有创建sds实例的接口, 都不会额外分配预留内存空间</li><li><code>sdsnewlen</code>用于带二进制数据创建sds实例, sdsnew用于带字符串创建sds实例. 接口返回的sds可以直接传入libc中的字符串输出函数中进行操作, 由于无论其中存储的是用户的二进制数据, 还是字符串, 其末尾都带一个\0, 所以至少调用libc中的字符串输出函数是安全的.</li></ul><p>在对SDS中的数据进行修改时, 若剩余空间不足, 会调用sdsMakeRoomFor函数用于扩容空间, 这是一个很低级的API, 通常情况下不应当由SDS的使用者直接调用. 其实现中核心的几行如下:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>sds sdsMakeRoomFor(sds s, size_t addlen) {
    ...
    /* Return ASAP if there is enough space left. */
    if (avail &gt;= addlen) return s;

    len = sdslen(s);
    sh = (char*)s-sdsHdrSize(oldtype);
    newlen = (len+addlen);
    if (newlen &lt; SDS_MAX_PREALLOC)
        newlen *= 2;
    else
        newlen += SDS_MAX_PREALLOC;
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到, 在扩充空间时</p><ul><li>先保证至少有addlen可用</li><li>然后再进一步扩充, 在总体占用空间不超过阈值<code>SDS_MAC_PREALLOC</code>时, 申请空间再翻一倍. 若总体空间已经超过了阈值, 则步进增长<code>SDS_MAC_PREALLOC</code>. 这个阈值的默认值为 <code>1024 * 1024</code></li></ul><p>SDS也提供了接口用于移除所有未使用的内存空间. <code>sdsRemoveFreeSpace</code>, 该接口没有间接的被任何SDS其它接口调用, 即默认情况下, SDS不会自动回收预留空间. 在SDS的使用者需要节省内存时, 由使用者自行调用:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>sds sdsRemoveFreeSpace(sds s);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>总结:</p><ul><li>SDS除了是某些Value Type的底层实现, 也被大量使用在Redis内部, 用于替代C-Style字符串. 所以默认的创建SDS实例接口, 不分配额外的预留空间. 因为多数字符串在程序运行期间是不变的. 而对于变更数据区的API, 其内部则是调用了 sdsMakeRoomFor, 每一次扩充空间, 都会预留大量的空间. 这样做的考量是: 如果一个SDS实例中的数据被变更了, 那么很有可能会在后续发生多次变更.</li><li>SDS的API内部不负责清除未使用的闲置内存空间, 因为内部API无法判断这样做的合适时机. 即便是在操作数据区的时候导致数据区占用内存减少时, 内部API也不会清除闲置内在空间. 清除闲置内存空间责任应当由SDS的使用者自行担当.</li><li>用SDS替代C-Style字符串时, 由于其头部额外存储了数据区的长度信息, 所以字符串的求长操作时间复杂度为O(1)</li></ul><h3 id="_2-2-list" tabindex="-1"><a class="header-anchor" href="#_2-2-list" aria-hidden="true">#</a> 2.2 list</h3><p>这是普通的链表实现, 链表结点不直接持有数据, 而是通过void *指针来间接的指向数据. 其实现位于 src/adlist.h与src/adlist.c中, 关键定义如下:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct listIter {
    listNode *next;
    int direction;
} listIter;

typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其内存布局如下图所示:</p><figure><img src="/assets/668722-20180910184001095-98860783-01513d23.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这是一个平平无奇的链表的实现. list在Redis除了作为一些Value Type的底层实现外, 还广泛用于Redis的其它功能实现中, 作为一种数据结构工具使用. 在list的实现中, 除了基本的链表定义外, 还额外增加了:</p><ul><li>迭代器<code>listIter</code>的定义, 与相关接口的实现.</li><li>由于list中的链表结点本身并不直接持有数据, 而是通过value字段, 以void *指针的形式间接持有, 所以数据的生命周期并不完全与链表及其结点一致. 这给了list的使用者相当大的灵活性. 比如可以多个结点持有同一份数据的地址. 但与此同时, 在对链表进行销毁, 结点复制以及查找匹配时, 就需要list的使用者将相关的函数指针赋值于list.dup, list.free, list.match字段.</li></ul><h3 id="_2-3-dict" tabindex="-1"><a class="header-anchor" href="#_2-3-dict" aria-hidden="true">#</a> 2.3 dict</h3><p>dict是Redis底层数据结构中实现最为复杂的一个数据结构, 其功能类似于C++标准库中的std::unordered_map, 其实现位于 src/dict.h 与 src/dict.c中, 其关键定义如下:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;

typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(void *privdata, const void *key);
    void *(*valDup)(void *privdata, const void *obj);
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    void (*keyDestructor)(void *privdata, void *key);
    void (*valDestructor)(void *privdata, void *obj);
} dictType;

/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;

typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    unsigned long iterators; /* number of iterators currently running */
} dict;

/* If safe is set to 1 this is a safe iterator, that means, you can call
 * dictAdd, dictFind, and other functions against the dictionary even while
 * iterating. Otherwise it is a non safe iterator, and only dictNext()
 * should be called while iterating. */
typedef struct dictIterator {
    dict *d;
    long index;
    int table, safe;
    dictEntry *entry, *nextEntry;
    /* unsafe iterator fingerprint for misuse detection. */
    long long fingerprint;
} dictIterator;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其内存布局如下所示:</p><figure><img src="/assets/668722-20180910184019522-1324296109-326bbf8e.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>dict中存储的键值对, 是通过dictEntry这个结构间接持有的, k通过指针间接持有键, v通过指针间接持有值. 注意, 若值是整数值的话, 是直接存储在v字段中的, 而不是间接持有. 同时next指针用于指向, 在bucket索引值冲突时, 以链式方式解决冲突, 指向同索引的下一个dictEntry结构.</p></li><li><p>传统的哈希表实现, 是一块连续空间的顺序表, 表中元素即是结点. 在dictht.table中, 结点本身是散布在内存中的, 顺序表中存储的是dictEntry的指针</p></li><li><p>哈希表即是dictht结构, 其通过table字段间接的持有顺序表形式的bucket, bucket的容量存储在size字段中, 为了加速将散列值转化为bucket中的数组索引, 引入了sizemask字段, 计算指定键在哈希表中的索引时, 执行的操作类似于dict-&gt;type-&gt;hashFunction(键) &amp; dict-&gt;ht[x].sizemask. 从这里也可以看出来, bucket的容量适宜于为2的幂次, 这样计算出的索引值能覆盖到所有bucket索引位.</p></li><li><p>dict即为字典. 其中type字段中存储的是本字典使用到的各种函数指针, 包括散列函数, 键与值的复制函数, 释放函数, 以及键的比较函数. privdata是用于存储用户自定义数据. 这样, 字典的使用者可以最大化的自定义字典的实现, 通过自定义各种函数实现, 以及可以附带私有数据, 保证了字典有很大的调优空间.</p></li><li><p>字典为了支持平滑扩容, 定义了ht[2]这个数组字段. 其用意是这样的:</p><ol><li>一般情况下, 字典dict仅持有一个哈希表dictht的实例, 即整个字典由一个bucket实现.</li><li>随着插入操作, bucket中出现冲突的概率会越来越大, 当字典中存储的结点数目, 与bucket数组长度的比值达到一个阈值(1:1)时, 字典为了缓解性能下降, 就需要扩容</li><li>扩容的操作是平滑的, 即在扩容时, 字典会持有两个dictht的实例, ht[0]指向旧哈希表, ht[1]指向扩容后的新哈希表. 平滑扩容的重点在于两个策略:</li><li>后续每一次的插入, 替换, 查找操作, 都插入到ht[1]指向的哈希表中</li><li>每一次插入, 替换, 查找操作执行时, 会将旧表ht[0]中的一个bucket索引位持有的结点链表, 迁移到ht[1]中去. 迁移的进度保存在rehashidx这个字段中.在旧表中由于冲突而被链接在同一索引位上的结点, 迁移到新表后, 可能会散布在多个新表索引中去.</li><li>当迁移完成后, ht[0]指向的旧表会被释放, 之后会将新表的持有权转交给ht[0], 再重置ht[1]指向NULL</li></ol></li><li><p>这种平滑扩容的优点有两个:</p><ol><li>平滑扩容过程中, 所有结点的实际数据, 即dict-&gt;ht[0]-&gt;table[rehashindex]-&gt;k与dict-&gt;ht[0]-&gt;table[rehashindex]-&gt;v分别指向的实际数据, 内存地址都不会变化. 没有发生键数据与值数据的拷贝或移动, 扩容整个过程仅是各种指针的操作. 速度非常快</li><li>扩容操作是步进式的, 这保证任何一次插入操作都是顺畅的, dict的使用者是无感知的. 若扩容是一次性的, 当新旧bucket容量特别大时, 迁移所有结点必然会导致耗时陡增.</li></ol></li></ul><p>除了字典本身的实现外, 其中还顺带实现了一个迭代器, 这个迭代器中有字段safe以标示该迭代器是&quot;安全迭代器&quot;还是&quot;非安全迭代器&quot;, 所谓的安全与否, 指是的这种场景:<br> 设想在运行迭代器的过程中, 字典正处于平滑扩容的过程中. 在平滑扩容的过程中时, 旧表一个索引位上的, 由冲突而链起来的多个结点, 迁移到新表后, 可能会散布到新表的多个索引位上. 且新的索引位的值可能比旧的索引位要低.</p><p>遍历操作的重点是, 保证在迭代器遍历操作开始时, 字典中持有的所有结点, 都会被遍历到. 而若在遍历过程中, 一个未遍历的结点, 从旧表迁移到新表后, 索引值减小了, 那么就可能会导致这个结点在遍历过程中被遗漏.</p><p>所以, 所谓的&quot;安全&quot;迭代器, 其在内部实现时: 在迭代过程中, 若字典正处于平滑扩容过程, 则暂停结点迁移, 直至迭代器运行结束. 这样虽然不能保证在迭代过程中插入的结点会被遍历到, 但至少保证在迭代起始时, 字典中持有的所有结点都会被遍历到.</p><p>这也是为什么dict结构中有一个iterators字段的原因: 该字段记录了运行于该字典上的安全迭代器的数目. 若该数目不为0, 字典是不会继续进行结点迁移平滑扩容的.</p><p>下面是字典的扩容操作中的核心代码, 我们以插入操作引起的扩容为例:</p><p><strong>先是插入操作的外部逻辑:</strong></p><ol><li>如果插入时, 字典正处于平滑扩容过程中, 那么无论本次插入是否成功, 先迁移一个bucket索引中的结点至新表</li><li>在计算新插入结点键的bucket索引值时, 内部会探测哈希表是否需要扩容(若当前不在平滑扩容过程中)</li></ol><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>int dictAdd(dict *d, void *key, void *val)
{
    dictEntry *entry = dictAddRaw(d,key,NULL);          // 调用dictAddRaw

    if (!entry) return DICT_ERR;
    dictSetVal(d, entry, val);
    return DICT_OK;
}

dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
{
    long index;
    dictEntry *entry;
    dictht *ht;

    if (dictIsRehashing(d)) _dictRehashStep(d); // 若在平滑扩容过程中, 先步进迁移一个bucket索引

    /* Get the index of the new element, or -1 if
     * the element already exists. */

    // 在计算键在bucket中的索引值时, 内部会检查是否需要扩容
    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
        return NULL;

    /* Allocate the memory and store the new entry.
     * Insert the element in top, with the assumption that in a database
     * system it is more likely that recently added entries are accessed
     * more frequently. */
    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];
    entry = zmalloc(sizeof(*entry));
    entry-&gt;next = ht-&gt;table[index];
    ht-&gt;table[index] = entry;
    ht-&gt;used++;

    /* Set the hash entry fields. */
    dictSetKey(d, entry, key);
    return entry;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是计算bucket索引值的函数, 内部会探测该哈希表是否需要扩容, 如果需要扩容(结点数目与bucket数组长度比例达到1:1), 就使字典进入平滑扩容过程:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>static long _dictKeyIndex(dict *d, const void *key, uint64_t hash, dictEntry **existing)
{
    unsigned long idx, table;
    dictEntry *he;
    if (existing) *existing = NULL;

    /* Expand the hash table if needed */
    if (_dictExpandIfNeeded(d) == DICT_ERR) // 探测是否需要扩容, 如果需要, 则开始扩容
        return -1;
    for (table = 0; table &lt;= 1; table++) {
        idx = hash &amp; d-&gt;ht[table].sizemask;
        /* Search if this slot does not already contain the given key */
        he = d-&gt;ht[table].table[idx];
        while(he) {
            if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) {
                if (existing) *existing = he;
                return -1;
            }
            he = he-&gt;next;
        }
        if (!dictIsRehashing(d)) break;
    }
    return idx;
}

/* Expand the hash table if needed */
static int _dictExpandIfNeeded(dict *d)
{
    /* Incremental rehashing already in progress. Return. */
    if (dictIsRehashing(d)) return DICT_OK; // 如果正在扩容过程中, 则什么也不做

    /* If the hash table is empty expand it to the initial size. */
    // 若字典中本无元素, 则初始化字典, 初始化时的bucket数组长度为4
    if (d-&gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    /* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling
     * the number of buckets. */
    // 若字典中元素的个数与bucket数组长度比值大于1:1时, 则调用dictExpand进入平滑扩容状态
    if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp;
        (dict_can_resize ||
         d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio))
    {
        return dictExpand(d, d-&gt;ht[0].used*2);
    }
    return DICT_OK;
}

int dictExpand(dict *d, unsigned long size)
{
    dictht n; /* the new hash table */  // 新建一个dictht结构
    unsigned long realsize = _dictNextPower(size);  

    /* the size is invalid if it is smaller than the number of
     * elements already inside the hash table */
    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size)
        return DICT_ERR;

    /* Rehashing to the same table size is not useful. */
    if (realsize == d-&gt;ht[0].size) return DICT_ERR;

    /* Allocate the new hash table and initialize all pointers to NULL */
    n.size = realsize;
    n.sizemask = realsize-1;
    n.table = zcalloc(realsize*sizeof(dictEntry*));// 初始化dictht下的table, 即bucket数组
    n.used = 0;

    /* Is this the first initialization? If so it&#39;s not really a rehashing
     * we just set the first hash table so that it can accept keys. */
    // 若是新字典初始化, 直接把dictht结构挂在ht[0]中
    if (d-&gt;ht[0].table == NULL) {
        d-&gt;ht[0] = n;
        return DICT_OK;
    }

    // 否则, 把新dictht结构挂在ht[1]中, 并开启平滑扩容(置rehashidx为0, 字典处于非扩容状态时, 该字段值为-1)
    /* Prepare a second hash table for incremental rehashing */
    d-&gt;ht[1] = n;
    d-&gt;rehashidx = 0;
    return DICT_OK;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是平滑扩容的实现:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>static void _dictRehashStep(dict *d) {
    // 若字典上还运行着安全迭代器, 则不迁移结点
    // 否则每次迁移一个旧bucket索引上的所有结点
    if (d-&gt;iterators == 0) dictRehash(d,1); 
}

int dictRehash(dict *d, int n) {
    int empty_visits = n*10; /* Max number of empty buckets to visit. */
    if (!dictIsRehashing(d)) return 0;

    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can&#39;t overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);
        // 在旧bucket中, 找到下一个非空的索引位
        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) {
            d-&gt;rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        // 取出该索引位上的结点链表
        de = d-&gt;ht[0].table[d-&gt;rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT */
        // 把所有结点迁移到新bucket中去
        while(de) {
            uint64_t h;

            nextde = de-&gt;next;
            /* Get the index in the new hash table */
            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;
            de-&gt;next = d-&gt;ht[1].table[h];
            d-&gt;ht[1].table[h] = de;
            d-&gt;ht[0].used--;
            d-&gt;ht[1].used++;
            de = nextde;
        }
        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;
        d-&gt;rehashidx++;
    }

    /* Check if we already rehashed the whole table... */
    // 检查是否旧表中的所有结点都被迁移到了新表
    // 如果是, 则置先释放原旧bucket数组, 再置ht[1]为ht[0]
    // 最后再置rehashidx=-1, 以示字典不处于平滑扩容状态
    if (d-&gt;ht[0].used == 0) {
        zfree(d-&gt;ht[0].table);
        d-&gt;ht[0] = d-&gt;ht[1];
        _dictReset(&amp;d-&gt;ht[1]);
        d-&gt;rehashidx = -1;
        return 0;
    }

    /* More to rehash... */
    return 1;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结:</strong></p><p>字典的实现很复杂, 主要是实现了平滑扩容逻辑<br> 用户数据均是以指针形式间接由dictEntry结构持有, 故在平滑扩容过程中, 不涉及用户数据的拷贝<br> 有安全迭代器可用, 安全迭代器保证, 在迭代起始时, 字典中的所有结点, 都会被迭代到, 即使在迭代过程中对字典有插入操作<br> 字典内部使用的默认散列函数其实也非常有讲究, 不过限于篇幅, 这里不展开讲. 并且字典的实现给了使用者非常大的灵活性(dictType结构与dict.privdata字段), 对于一些特定场合使用的键数据, 用户可以自行选择更高效更特定化的散列函数</p><h3 id="_2-4-zskiplist" tabindex="-1"><a class="header-anchor" href="#_2-4-zskiplist" aria-hidden="true">#</a> 2.4 zskiplist</h3><p>zskiplist是Redis实现的一种特殊的跳跃表. 跳跃表是一种基于线性表实现简单的搜索结构, 其最大的特点就是: 实现简单, 性能能逼近各种搜索树结构. 血统纯正的跳跃表的介绍在维基百科中即可查阅. 在Redis中, 在原版跳跃表的基础上, 进行了一些小改动, 即是现在要介绍的zskiplist结构.</p><p>其定义在src/server.h中, 如下:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>/* ZSETs use a specialized version of Skiplists */
typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned int span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其内存布局如下图:</p><figure><img src="/assets/668722-20180910184047816-693646977-f9c0c3f6.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>zskiplist的核心设计要点为:</p><ol><li>头结点不持有任何数据, 且其level[]的长度为32</li><li>每个结点, 除了持有数据的ele字段, 还有一个字段score, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</li><li>每个结点持有一个backward指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</li><li>每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段.</li><li>forward字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在level[]中的索引为X, 则其forward字段指向的结点, 其level[]字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li><li>span字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1.</li><li>zskiplist中持有字段level, 用以记录所有结点(除过头结点外), level[]数组最长的长度.</li></ol><p>跳跃表主要用于, 在给定一个分值的情况下, 查找与该分值最接近的结点. 搜索时, 伪代码如下:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>int level = zskiplist-&gt;level - 1;
zskiplistNode p = zskiplist-&gt;head;

while(1 &amp;&amp; p)
{
    zskiplistNode q = (p-&gt;level)[level]-&gt;forward:
    if(q-&gt;score &gt; 分值)
    {
        if(level &gt; 0)
        {
            level--;
        }
        else
        {
            return :
                q为整个跳跃表中, 分值大于指定分值的第一个结点
                q-&gt;backward为整个跳跃表中, 分值小于或等于指定分值的最后一个结点
        }
    }
    else
    {
        p = q;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>跳跃表的实现比较简单, 最复杂的操作即是插入与删除结点, 需要仔细处理邻近结点的所有level[]中的所有zskiplistLevel结点中的forward与span的值的变更.</p><p>另外, 关于新创建的结点, 其<code>level[]</code>数组长度的随机算法, 在接口zslInsert的实现中, 核心代码片断如下:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    //...

    level = zslRandomLevel();   // 随机生成新结点的, level[]数组的长度
        if (level &gt; zsl-&gt;level) {   
        // 若生成的新结点的level[]数组的长度比当前表中所有结点的level[]的长度都大
        // 那么头结点中需要新增几个指向该结点的指针
        // 并刷新ziplist中的level字段
        for (i = zsl-&gt;level; i &lt; level; i++) {
            rank[i] = 0;
            update[i] = zsl-&gt;header;
            update[i]-&gt;level[i].span = zsl-&gt;length;
        }
        zsl-&gt;level = level;
    }
    x = zslCreateNode(level,score,ele); // 创建新结点
    //... 执行插入操作
}

// 按幂次定律生成小于32的随机数的函数
// 宏 ZSKIPLIST_MAXLEVEL 的定义为32, 宏 ZSKIPLIST_P 被设定为 0.25
// 即 
//      level == 1的概率为 75%
//      level == 2的概率为 75% * 25%
//      level == 3的概率为 75% * 25% * 25%
//      ...
//      level == 31的概率为 0.75 * 0.25^30
//      而
//      level == 32的概率为 0.75 * sum(i = 31 ~ +INF){ 0.25^i }
int zslRandomLevel(void) {
    int level = 1;
    while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))
        level += 1;
    return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-5-intset" tabindex="-1"><a class="header-anchor" href="#_2-5-intset" aria-hidden="true">#</a> 2.5 intset</h3><p>这是一个用于存储在序的整数的数据结构, 也底层数据结构中最简单的一个, 其定义与实现在src/intest.h与src/intset.c中, 关键定义如下:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;

#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>inset结构中的encoding的取值有三个, 分别是宏INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64. length代表其中存储的整数的个数, contents指向实际存储数值的连续内存区域. 其内存布局如下图所示:</p><figure><img src="data:image/png;base64,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" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>intset中各字段, 包括contents中存储的数值, 都是以主机序(小端字节序)存储的. 这意味着Redis若运行在PPC这样的大端字节序的机器上时, 存取数据都会有额外的字节序转换开销</li><li>当encoding == INTSET_ENC_INT16时, contents中以int16_t的形式存储着数值. 类似的, 当encoding == INTSET_ENC_INT32时, contents中以int32_t的形式存储着数值.</li><li>但凡有一个数值元素的值超过了int32_t的取值范围, 整个intset都要进行升级, 即所有的数值都需要以int64_t的形式存储. 显然升级的开销是很大的.</li><li>intset中的数值是以升序排列存储的, 插入与删除的复杂度均为O(n). 查找使用二分法, 复杂度为O(log_2(n))</li><li>intset的代码实现中, 不预留空间, 即每一次插入操作都会调用zrealloc接口重新分配内存. 每一次删除也会调用zrealloc接口缩减占用的内存. 省是省了, 但内存操作的时间开销上升了.</li><li>intset的编码方式一经升级, 不会再降级.</li></ul><p>总之, intset适合于如下数据的存储:</p><ul><li>所有数据都位于一个稳定的取值范围中. 比如均位于int16_t或int32_t的取值范围中</li><li>数据稳定, 插入删除操作不频繁. 能接受O(lgn)级别的查找开销</li></ul><h3 id="_2-6-ziplist" tabindex="-1"><a class="header-anchor" href="#_2-6-ziplist" aria-hidden="true">#</a> 2.6 ziplist</h3><p>ziplist是Redis底层数据结构中, 最苟的一个结构. 它的设计宗旨就是: 省内存, 从牙缝里省内存. 设计思路和TLV一致, 但为了从牙缝里节省内存, 做了很多额外工作.</p><p>ziplist的内存布局与intset一样: 就是一块连续的内存空间. 但区域划分比较复杂, 概览如下图:</p><figure><img src="data:image/png;base64,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" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>和intset一样, ziplist中的所有值都是以小端序存储的</li><li>zlbytes字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</li><li>zltail字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</li><li>zllen字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占16位, 所以蛋疼的地方就来了: 如果ziplist中entry的数目小于65535, 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</li><li>zlend是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</li></ul><p>在画图展示entry的内存布局之前, 先讲一下entry中都存储了哪些信息:</p><ul><li>每个entry中存储了它前一个entry所占用的字节数. 这样支持ziplist反向遍历.</li><li>每个entry用单独的一块区域, 存储着当前结点的类型: 所谓的类型, 包括当前结点存储的数据是什么(二进制, 还是数值), 如何编码(如果是数值, 数值如何存储, 如果是二进制数据, 二进制数据的长度)</li><li>最后就是真实的数据了</li></ul><p>entry的内存布局如下所示:</p><figure><img src="data:image/png;base64,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" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>prevlen</code>即是&quot;前一个entry所占用的字节数&quot;, 它本身是一个变长字段, 规约如下:</p><ul><li>若前一个entry占用的字节数小于 254, 则prevlen字段占一字节</li><li>若前一个entry占用的字节数等于或大于 254, 则prevlen字段占五字节: 第一个字节值为 254, 即0xfe, 另外四个字节, 以uint32_t存储着值.</li></ul><p><code>encoding</code>字段的规约就复杂了许多</p><ul><li>若数据是二进制数据, 且二进制数据长度小于64字节(不包括64), 那么encoding占一字节. 在这一字节中, 高两位值固定为0, 低六位值以无符号整数的形式存储着二进制数据的长度. 即 00xxxxxx, 其中低六位bitxxxxxx是用二进制保存的数据长度.</li><li>若数据是二进制数据, 且二进制数据长度大于或等于64字节, 但小于16384(不包括16384)字节, 那么encoding占用两个字节. 在这两个字节16位中, 第一个字节的高两位固定为01, 剩余的14个位, 以小端序无符号整数的形式存储着二进制数据的长度, 即 01xxxxxx, yyyyyyyy, 其中yyyyyyyy是高八位, xxxxxx是低六位.</li><li>若数据是二进制数据, 且二进制数据的长度大于或等于16384字节, 但小于2^32-1字节, 则encoding占用五个字节. 第一个字节是固定值10000000, 剩余四个字节, 按小端序uint32_t的形式存储着二进制数据的长度. 这也是ziplist能存储的二进制数据的最大长度, 超过2^32-1字节的二进制数据, ziplist无法存储.</li><li>若数据是整数值, 则encoding和data的规约如下: <ol><li>首先, 所有存储数值的entry, 其encoding都仅占用一个字节. 并且最高两位均是11</li><li>若数值取值范围位于[0, 12]中, 则encoding和data挤在同一个字节中. 即为1111 0001~1111 1101, 高四位是固定值, 低四位的值从0001至1101, 分别代表 0 ~ 12这十五个数值</li><li>若数值取值范围位于[-128, -1] [13, 127]中, 则encoding == 0b 1111 1110. 数值存储在紧邻的下一个字节, 以int8_t形式编码</li><li>若数值取值范围位于[-32768, -129] [128, 32767]中, 则encoding == 0b 1100 0000. 数值存储在紧邻的后两个字节中, 以小端序int16_t形式编码</li><li>若数值取值范围位于[-8388608, -32769] [32768, 8388607]中, 则encoding == 0b 1111 0000. 数值存储在紧邻的后三个字节中, 以小端序存储, 占用三个字节.</li><li>若数值取值范围位于[-2^31, -8388609] [8388608, 2^31 - 1]中, 则encoding == 0b 1101 0000. 数值存储在紧邻的后四个字节中, 以小端序int32_t形式编码</li><li>若数值取值均不在上述范围, 但位于int64_t所能表达的范围内, 则encoding == 0b 1110 0000, 数值存储在紧邻的后八个字节中, 以小端序int64_t形式编码</li></ol></li></ul><p>在大规模数值存储中, ziplist几乎不浪费内存空间, 其苟的程序到达了字节级别, 甚至对于[0, 12]区间的数值, 连data里的那一个字节也要省下来. 显然, ziplist是一种特别节省内存的数据结构, 但它的缺点也十分明显:</p><ul><li>和intset一样, ziplist也不预留内存空间, 并且在移除结点后, 也是立即缩容, 这代表每次写操作都会进行内存分配操作.</li><li>ziplist最蛋疼的一个问题是: 结点如果扩容, 导致结点占用的内存增长, 并且超过254字节的话, 可能会导致链式反应: 其后一个结点的entry.prevlen需要从一字节扩容至五字节. 最坏情况下, 第一个结点的扩容, 会导致整个ziplist表中的后续所有结点的entry.prevlen字段扩容. 虽然这个内存重分配的操作依然只会发生一次, 但代码中的时间复杂度是o(N)级别, 因为链式扩容只能一步一步的计算. 但这种情况的概率十分的小, 一般情况下链式扩容能连锁反映五六次就很不幸了. 之所以说这是一个蛋疼问题, 是因为, 这样的坏场景下, 其实时间复杂度并不高: 依次计算每个entry新的空间占用, 也就是o(N), 总体占用计算出来后, 只执行一次内存重分配, 与对应的memmove操作, 就可以了. 蛋疼说的是: 代码特别难写, 难读. 下面放一段处理插入结点时处理链式反应的代码片断, 大家自行感受一下:</li></ul><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;
    unsigned int prevlensize, prevlen = 0;
    size_t offset;
    int nextdiff = 0;
    unsigned char encoding = 0;
    long long value = 123456789; /* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized. */
    zlentry tail;

    /* Find out prevlen for the entry that is inserted. */
    if (p[0] != ZIP_END) {
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
    } else {
        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
        if (ptail[0] != ZIP_END) {
            prevlen = zipRawEntryLength(ptail);
        }
    }

    /* See if the entry can be encoded */
    if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) {
        /* &#39;encoding&#39; is set to the appropriate integer encoding */
        reqlen = zipIntSize(encoding);
    } else {
        /* &#39;encoding&#39; is untouched, however zipStoreEntryEncoding will use the
         * string length to figure out how to encode it. */
        reqlen = slen;
    }
    /* We need space for both the length of the previous entry and
     * the length of the payload. */
    reqlen += zipStorePrevEntryLength(NULL,prevlen);
    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);

    /* When the insert position is not equal to the tail, we need to
     * make sure that the next entry can hold this entry&#39;s length in
     * its prevlen field. */
    int forcelarge = 0;
    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;
    if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) {
        nextdiff = 0;
        forcelarge = 1;
    }

    /* Store offset because a realloc may change the address of zl. */
    offset = p-zl;
    zl = ziplistResize(zl,curlen+reqlen+nextdiff);
    p = zl+offset;

    /* Apply memory move when necessary and update tail offset. */
    if (p[0] != ZIP_END) {
        /* Subtract one because of the ZIP_END bytes */
        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);

        /* Encode this entry&#39;s raw length in the next entry. */
        if (forcelarge)
            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
        else
            zipStorePrevEntryLength(p+reqlen,reqlen);

        /* Update offset for tail */
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);

        /* When the tail contains more than one entry, we need to take
         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the
         * size of prevlen doesn&#39;t have an effect on the *tail* offset. */
        zipEntry(p+reqlen, &amp;tail);
        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
            ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
        }
    } else {
        /* This element will be the new tail. */
        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);
    }

    /* When nextdiff != 0, the raw length of the next entry has changed, so
     * we need to cascade the update throughout the ziplist */
    if (nextdiff != 0) {
        offset = p-zl;
        zl = __ziplistCascadeUpdate(zl,p+reqlen);
        p = zl+offset;
    }

    /* Write the entry */
    p += zipStorePrevEntryLength(p,prevlen);
    p += zipStoreEntryEncoding(p,encoding,slen);
    if (ZIP_IS_STR(encoding)) {
        memcpy(p,s,slen);
    } else {
        zipSaveInteger(p,value,encoding);
    }
    ZIPLIST_INCR_LENGTH(zl,1);
    return zl;
}

unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
    size_t offset, noffset, extra;
    unsigned char *np;
    zlentry cur, next;

    while (p[0] != ZIP_END) {
        zipEntry(p, &amp;cur);
        rawlen = cur.headersize + cur.len;
        rawlensize = zipStorePrevEntryLength(NULL,rawlen);

        /* Abort if there is no next entry. */
        if (p[rawlen] == ZIP_END) break;
        zipEntry(p+rawlen, &amp;next);

        /* Abort when &quot;prevlen&quot; has not changed. */
        if (next.prevrawlen == rawlen) break;

        if (next.prevrawlensize &lt; rawlensize) {
            /* The &quot;prevlen&quot; field of &quot;next&quot; needs more bytes to hold
             * the raw length of &quot;cur&quot;. */
            offset = p-zl;
            extra = rawlensize-next.prevrawlensize;
            zl = ziplistResize(zl,curlen+extra);
            p = zl+offset;

            /* Current pointer and offset for next element. */
            np = p+rawlen;
            noffset = np-zl;

            /* Update tail offset when next element is not the tail element. */
            if ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {
                ZIPLIST_TAIL_OFFSET(zl) =
                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);
            }

            /* Move the tail to the back. */
            memmove(np+rawlensize,
                np+next.prevrawlensize,
                curlen-noffset-next.prevrawlensize-1);
            zipStorePrevEntryLength(np,rawlen);

            /* Advance the cursor */
            p += rawlen;
            curlen += extra;
        } else {
            if (next.prevrawlensize &gt; rawlensize) {
                /* This would result in shrinking, which we want to avoid.
                 * So, set &quot;rawlen&quot; in the available bytes. */
                zipStorePrevEntryLengthLarge(p+rawlen,rawlen);
            } else {
                zipStorePrevEntryLength(p+rawlen,rawlen);
            }

            /* Stop here, as the raw length of &quot;next&quot; has not changed. */
            break;
        }
    }
    return zl;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种代码的特点就是: 最好由作者去维护, 最好一次性写对. 因为读起来真的费劲, 改起来也很费劲.</p><h3 id="_2-7-quicklist" tabindex="-1"><a class="header-anchor" href="#_2-7-quicklist" aria-hidden="true">#</a> 2.7 quicklist</h3><p>如果说ziplist是整个Redis中为了节省内存, 而写的最苟的数据结构, 那么称quicklist就是在最苟的基础上, 再苟了一层. 这个结构是Redis在3.2版本后新加的, 在3.2版本之前, 我们可以讲, dict是最复杂的底层数据结构, ziplist是最苟的底层数据结构. 在3.2版本之后, 这两个记录被双双刷新了.</p><p>这是一种, 以ziplist为结点的, 双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist.</p><p>它的定义与实现分别在src/quicklist.h与src/quicklist.c中, 其中关键定义如下:</p><div class="language-cgo line-numbers-mode" data-ext="cgo"><pre class="language-cgo"><code>/* Node, quicklist, and Iterator are the only data structures used currently. */

/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.
 * We use bit fields keep the quicklistNode at 32 bytes.
 * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).
 * encoding: 2 bits, RAW=1, LZF=2.
 * container: 2 bits, NONE=1, ZIPLIST=2.
 * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.
 * attempted_compress: 1 bit, boolean, used for verifying during testing.
 * extra: 12 bits, free for future use; pads out the remainder of 32 bits */
typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *zl;
    unsigned int sz;             /* ziplist size in bytes */
    unsigned int count : 16;     /* count of items in ziplist */
    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */
    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */
    unsigned int recompress : 1; /* was this node previous compressed? */
    unsigned int attempted_compress : 1; /* node can&#39;t compress; too small */
    unsigned int extra : 10; /* more bits to steal for future usage */
} quicklistNode;

/* quicklistLZF is a 4+N byte struct holding &#39;sz&#39; followed by &#39;compressed&#39;.
 * &#39;sz&#39; is byte length of &#39;compressed&#39; field.
 * &#39;compressed&#39; is LZF data with total (compressed) length &#39;sz&#39;
 * NOTE: uncompressed length is stored in quicklistNode-&gt;sz.
 * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */
typedef struct quicklistLZF {
    unsigned int sz; /* LZF size in bytes*/
    char compressed[];
} quicklistLZF;

/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.
 * &#39;count&#39; is the number of total entries.
 * &#39;len&#39; is the number of quicklist nodes.
 * &#39;compress&#39; is: -1 if compression disabled, otherwise it&#39;s the number
 *                of quicklistNodes to leave uncompressed at ends of quicklist.
 * &#39;fill&#39; is the user-requested (or default) fill factor. */
typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all ziplists */
    unsigned long len;          /* number of quicklistNodes */
    int fill : 16;              /* fill factor for individual nodes */
    unsigned int compress : 16; /* depth of end nodes not to compress;0=off */
} quicklist;

typedef struct quicklistIter {
    const quicklist *quicklist;
    quicklistNode *current;
    unsigned char *zi;
    long offset; /* offset in current ziplist */
    int direction;
} quicklistIter;

typedef struct quicklistEntry {
    const quicklist *quicklist;
    quicklistNode *node;
    unsigned char *zi;
    unsigned char *value;
    long long longval;
    unsigned int sz;
    int offset;
} quicklistEntry;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里定义了五个结构体:</p><ul><li>quicklistNode, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例</li><li>quicklistLZF, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li><li>quicklist. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li><li>quicklistIter是一个迭代器</li><li>quicklistEntry是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下.</li></ul><p>quicklist的内存布局图如下所示:</p><figure><img src="/assets/668722-20180910184206679-1690711957-5faded75.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>下面是有关quicklist的更多额外信息:</p><p>quicklist.fill的值影响着每个链表结点中, ziplist的长度.</p><ol><li>当数值为负数时, 代表以字节数限制单个ziplist的最大长度. 具体为: <ol><li>-1 不超过4kb</li><li>-2 不超过 8kb</li><li>-3 不超过 16kb</li><li>-4 不超过 32kb</li><li>-5 不超过 64kb</li><li>当数值为正数时, 代表以entry数目限制单个ziplist的长度. 值即为数目. 由于该字段仅占16位, 所以以entry数目限制ziplist的容量时, 最大值为2^15个</li></ol></li><li>quicklist.compress的值影响着quicklistNode.zl字段指向的是原生的ziplist, 还是经过压缩包装后的quicklistLZF <ol><li>0 表示不压缩, zl字段直接指向ziplist</li><li>1 表示quicklist的链表头尾结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>2 表示quicklist的链表头两个, 与末两个结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF</li><li>以此类推, 最大值为2^16</li></ol></li><li>quicklistNode.encoding字段, 以指示本链表结点所持有的ziplist是否经过了压缩. 1代表未压缩, 持有的是原生的ziplist, 2代表压缩过</li><li>quicklistNode.container字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</li><li>quicklistNode.recompress字段指示的是当前结点所持有的ziplist是否经过了解压. 如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</li></ol><p><code>quicklist</code>的具体实现代码篇幅很长, 这里就不贴代码片断了, 从内存布局上也能看出来, 由于每个结点持有的ziplist是有上限长度的, 所以在与操作时要考虑的分支情况比较多. 想想都蛋疼.</p><p>quicklist有自己的优点, 也有缺点, 对于使用者来说, 其使用体验类似于线性数据结构, list作为最传统的双链表, 结点通过指针持有数据, 指针字段会耗费大量内存. ziplist解决了耗费内存这个问题. 但引入了新的问题: 每次写操作整个ziplist的内存都需要重分配. quicklist在两者之间做了一个平衡. 并且使用者可以通过自定义quicklist.fill, 根据实际业务情况, 经验主义调参.</p><h3 id="_2-8-zipmap" tabindex="-1"><a class="header-anchor" href="#_2-8-zipmap" aria-hidden="true">#</a> 2.8 zipmap</h3><p>dict作为字典结构, 优点很多, 扩展性强悍, 支持平滑扩容等等, 但对于字典中的键值均为二进制数据, 且长度都很小时, dict的中的一坨指针会浪费不少内存, 因此Redis又实现了一个轻量级的字典, 即为zipmap.</p><p>zipmap适合使用的场合是:</p><ul><li>键值对量不大, 单个键, 单个值长度小</li><li>键值均是二进制数据, 而不是复合结构或复杂结构. dict支持各种嵌套, 字典本身并不持有数据, 而仅持有数据的指针. 但zipmap是直接持有数据的.</li></ul><p>zipmap的定义与实现在src/zipmap.h与src/zipmap.c两个文件中, 其定义与实现均未定义任何struct结构体, 因为zipmap的内存布局就是一块连续的内存空间. 其内存布局如下所示:</p><figure><img src="/assets/668722-20180910184223910-1797391394-0c29f7e1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>zipmap起始的第一个字节存储的是zipmap中键值对的个数. 如果键值对的个数大于254的话, 那么这个字节的值就是固定值254, 真实的键值对个数需要遍历才能获得.</li><li>zipmap的最后一个字节是固定值0xFF</li><li>zipmap中的每一个键值对, 称为一个entry, 其内存占用如上图, 分别六部分: <ol><li>len_of_key, 一字节或五字节. 存储的是键的二进制长度. 如果长度小于254, 则用1字节存储, 否则用五个字节存储, 第一个字节的值固定为0xFE, 后四个字节以小端序uint32_t类型存储着键的二进制长度.</li><li>key_data为键的数据</li><li>len_of_val, 一字节或五字节, 存储的是值的二进制长度. 编码方式同len_of_key</li><li>len_of_free, 固定值1字节, 存储的是entry中未使用的空间的字节数. 未使用的空间即为图中的free, 它一般是由于键值对中的值被替换发生的. 比如, 键值对hello &lt;-&gt; word被修改为hello &lt;-&gt; w后, 就空了四个字节的闲置空间</li><li>val_data, 为值的数据</li><li>free, 为闲置空间. 由于len_of_free的值最大只能是254, 所以如果值的变更导致闲置空间大于254的话, zipmap就会回收内存空间.</li></ol></li></ul></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1549169735@qq.com">xdc</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="vp-link nav-link prev" href="/redis/redis-basic.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->Redis 基础</div></a><a class="vp-link nav-link next" href="/redis/redis-master-slave.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">Redis主从复制原理<!----></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:none;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">备案号：皖ICP备2023001912号</div><div class="vp-copyright">Copyright © 2023-present 码说256</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-23d1540c.js" defer></script>
  </body>
</html>
