const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":76,\"nextId\":76,\"documentIds\":{\"0\":\"v-55325e94\",\"1\":\"v-55325e94#channel\",\"2\":\"v-55325e94#声明和创建\",\"3\":\"v-55325e94#channel的两种分类\",\"4\":\"v-55325e94#死锁-deadlock\",\"5\":\"v-55325e94#无缓冲同步通信示例\",\"6\":\"v-55325e94#有缓冲chan\",\"7\":\"v-55325e94#select多路监听\",\"8\":\"v-55325e94#准确使用定时器\",\"9\":\"v-55325e94@0\",\"10\":\"v-55325e94@1\",\"11\":\"v-197289d8\",\"12\":\"v-197289d8#构建servemux\",\"13\":\"v-197289d8@0\",\"14\":\"v-197289d8@1\",\"15\":\"v-d0b736b8\",\"16\":\"v-d0b736b8#map\",\"17\":\"v-d0b736b8#struct\",\"18\":\"v-d0b736b8#struct的方法\",\"19\":\"v-d0b736b8#struct的比较\",\"20\":\"v-d0b736b8#interface\",\"21\":\"v-d0b736b8#方法集\",\"22\":\"v-d0b736b8#空interface\",\"23\":\"v-d0b736b8#interface类型断言和type-switch\",\"24\":\"v-d0b736b8@0\",\"25\":\"v-d0b736b8@1\",\"26\":\"v-cd4d857a\",\"27\":\"v-cd4d857a#并发安全的map\",\"28\":\"v-cd4d857a#channel实现并发安全的map\",\"29\":\"v-cd4d857a@0\",\"30\":\"v-cd4d857a@1\",\"31\":\"v-5c6dc018\",\"32\":\"v-5c6dc018#sync-mutex互斥锁\",\"33\":\"v-5c6dc018#sync-rwmutex读写锁\",\"34\":\"v-5c6dc018#sync-mutex和sync-rwmutex如何选择\",\"35\":\"v-5c6dc018@0\",\"36\":\"v-5c6dc018@1\",\"37\":\"v-747d3c5a\",\"38\":\"v-747d3c5a#切片\",\"39\":\"v-747d3c5a@0\",\"40\":\"v-747d3c5a@1\",\"41\":\"v-255721be\",\"42\":\"v-255721be#myisam和innodb的区别\",\"43\":\"v-255721be#mysql优化相关\",\"44\":\"v-255721be#mysql修改表相关\",\"45\":\"v-255721be#关闭索引\",\"46\":\"v-255721be#开启索引\",\"47\":\"v-255721be#索引相关\",\"48\":\"v-255721be#前缀索引\",\"49\":\"v-255721be#多列索引\",\"50\":\"v-255721be#myisam和innodb的索引总结。\",\"51\":\"v-255721be#查询优化相关\",\"52\":\"v-255721be#mysql高级特性\",\"53\":\"v-255721be#分区\",\"54\":\"v-255721be#视图\",\"55\":\"v-255721be#绑定变量\",\"56\":\"v-255721be#配置优化\",\"57\":\"v-255721be#复制\",\"58\":\"v-255721be@0\",\"59\":\"v-255721be@1\",\"60\":\"v-4b4371d9\",\"61\":\"v-4b4371d9#php的命令模式实现\",\"62\":\"v-4b4371d9#php的错误和异常处理\",\"63\":\"v-4b4371d9#错误处理\",\"64\":\"v-4b4371d9#会话管理-跨域-单点登录\",\"65\":\"v-4b4371d9#会话管理\",\"66\":\"v-4b4371d9#会话跨域和单点登录\",\"67\":\"v-4b4371d9#负载均衡\",\"68\":\"v-4b4371d9#秒杀活动和超卖\",\"69\":\"v-4b4371d9#秒杀设计\",\"70\":\"v-4b4371d9#超卖问题\",\"71\":\"v-4b4371d9@0\",\"72\":\"v-4b4371d9@1\",\"73\":\"v-7630e300\",\"74\":\"v-14f0d3a9\",\"75\":\"v-744b4c30\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,27],\"2\":[1,38],\"3\":[1,86],\"4\":[3,48],\"5\":[1,32],\"6\":[1,91],\"7\":[1,102],\"8\":[1,74],\"9\":[null,null,1],\"10\":[null,null,7],\"11\":[1],\"12\":[1,333],\"13\":[null,null,1],\"14\":[null,null,5],\"15\":[3],\"16\":[1,76],\"17\":[1,89],\"18\":[1,71],\"19\":[1,46],\"20\":[1,34],\"21\":[1,25],\"22\":[1,49],\"23\":[2,66],\"24\":[null,null,1],\"25\":[null,null,8],\"26\":[1],\"27\":[1,79],\"28\":[1,77],\"29\":[null,null,1],\"30\":[null,null,7],\"31\":[3,6],\"32\":[2,112],\"33\":[2,128],\"34\":[3,8],\"35\":[null,null,1],\"36\":[null,null,7],\"37\":[1],\"38\":[1,126],\"39\":[null,null,1],\"40\":[null,null,6],\"41\":[1],\"42\":[1,31],\"43\":[1,35],\"44\":[1,9],\"45\":[1,6],\"46\":[1,7],\"47\":[1,24],\"48\":[1,32],\"49\":[1,55],\"50\":[2,23],\"51\":[1,18],\"52\":[1],\"53\":[1,76],\"54\":[1,21],\"55\":[1,14],\"56\":[2,28],\"57\":[1,105],\"58\":[null,null,1],\"59\":[null,null,3],\"60\":[2,7],\"61\":[1,29],\"62\":[1],\"63\":[1,216],\"64\":[3],\"65\":[1,100],\"66\":[1,59],\"67\":[1,101],\"68\":[1,6],\"69\":[1,108],\"70\":[1,24],\"71\":[null,null,1],\"72\":[null,null,4],\"73\":[1],\"74\":[1],\"75\":[1]},\"averageFieldLength\":[1.266733377010929,62.45439898401932,1.7321411011575156],\"storedFields\":{\"0\":{\"h\":\"Go面试之Channel的使用\"},\"1\":{\"h\":\"channel\",\"t\":[\"channel是Golang在语言层面提供的goroutine间的通信方式。channel 是一个通道，用于端到端的数据传输，这有点像我们平常使用的消息队列，只不过 channel 的发送方和接受方是 goroutine 对象，属于内存级别的通信。\",\"这里涉及到了 goroutine 概念，goroutine 是轻量级的协程，有属于自己的栈空间。 我们可以把它理解为线程，只不过 goroutine 的性能开销很小，并且在用户态上实现了属于自己的调度模型。\",\"channel 是引用类型，在多并发操作里是属于协程安全的，并且遵循了 FIFO 特性。即先执行读取的 goroutine 会先获取到数据，先发送数据的 goroutine 会先输入数据。\"]},\"2\":{\"h\":\"声明和创建\",\"t\":[\"var ch chan int // 声明一个chan，此时ch是一个nil chan ch := make(chan int) // 创建一个无缓冲的chan \",\"上面的代码我们看到首先声明了一个chan，此时ch是一个nil chan，对nil chan进行send(写、发送)，recv(读、接收)都将会阻塞。\",\"每个channel都有3种操作：send、receive和close\",\"send：表示sender端的goroutine向channel中投放数据\",\"receive：表示receiver端的goroutine从channel中读取数据\",\"close：表示关闭channel \",\"关闭channel后，send操作将导致painc\",\"关闭channel后，若没有缓冲数据，recv操作将返回对应类型的0值以及一个状态码false\",\"close并非强制需要使用close(ch)来关闭channel，在某些时候可以自动被关闭\",\"只在sender端上显式使用close()关闭channel。因为关闭通道意味着没有数据再需要发送\",\"如果使用close()，建议条件允许的情况下加上defer\"]},\"3\":{\"h\":\"channel的两种分类\",\"t\":[\"channel分为两种：unbuffered channel(无缓冲)和buffered channel（有缓冲）\",\"ch1 := make(chan int) // 无缓冲 ch2 := make(chan int, 10) // 有缓冲 \",\"unbuffered channel(无缓冲)：阻塞，同步模式\",\"sender端向channel中send一个数据，然后阻塞，直到receiver端将此数据receive\",\"receiver端一直阻塞，直到sender端向channel发送了一个数据\",\"func main(){ ch := make(chan int) go func(){ fmt.Println(\\\"go send\\\") ch<-1 close(ch) }() i := <-ch fmt.Println(\\\"ch val: \\\", i) } \",\"buffered channel（有缓冲）：非阻塞，异步模式\",\"sender端可以向channel中send多个数据(只要channel容量未满)，容量满之前不会阻塞\",\"receiver端按照队列的方式(FIFO,先进先出)从buffered channel中按序receive其中数据\",\"func main() { ch := make(chan int, 10) go func() { fmt.Println(\\\"go send\\\") for i := 0; i < 20; i++ { ch <- i } close(ch) }() for { i, ok := <-ch if !ok { fmt.Println(\\\"ch close\\\") return } fmt.Println(\\\"ch val: \\\", i) } } \",\"unbuffered channel可以认为是容量为0的buffered channel，所以每发送一个数据就被阻塞。注意，不是容量为1的buffered channel，因为容量为1的channel，是在channel中已有一个数据，并发送第二个数据的时候才被阻塞。\",\"阻塞和不阻塞是由channel控制的，无论是send还是recv操作，都是在向channel发送请求：\",\"对于unbuffered channel，sender发送一个数据，channel暂时不会向sender的请求返回ok消息，而是等到receiver准备接收channel数据了，channel才会向sender和receiver双方发送ok消息。在sender和receiver接收到ok消息之前，两者一直处于阻塞。\",\"对于buffered channel，sender每发送一个数据，只要channel容量未满，channel都会向sender的请求直接返回一个ok消息，使得sender不会阻塞，直到channel容量已满，channel不会向sender返回ok，于是sender被阻塞。对于receiver也一样，只要channel非空，receiver每次请求channel时，channel都会向其返回ok消息，直到channel为空，channel不会返回ok消息，receiver被阻塞。\",\"在Go的内部行为中，send和recv是一个整体行为，数据未读就表示未send成功。所以对已经关闭的chan进行send操作会引发panic\"]},\"4\":{\"h\":\"死锁(deadlock)\",\"t\":[\"当channel的某一端(sender/receiver)期待另一端的(receiver/sender)操作，另一端正好在期待本端的操作时，也就是说两端都因为对方而使得自己当前处于阻塞状态，这时将会出现死锁问题。更通俗地说，只要所有goroutine都被阻塞，就会出现死锁。\",\"func main() { ch := make(chan int) ch <- 1 fmt.Println(\\\"recv\\\") <-ch } \",\"在上面的示例中，向unbuffered channel中send数据的操作ch <- 1是在main goroutine中进行的，此channel中recv的操作<-ch也是在main goroutine中进行的。send的时候会直接阻塞main goroutine，使得recv操作无法被执行，go将探测到此问题，并报错：\",\"fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: \",\"解决方法，只需将send操作放在另一个goroutine中执行即可：\",\"func main() { ch := make(chan int) go func() { fmt.Println(\\\"send\\\") ch <- 1 }() fmt.Println(\\\"recv\\\") <-ch } \",\"或者讲无缓冲chan设置为有缓冲chan：\",\"func main() { ch := make(chan int, 1) fmt.Println(\\\"send\\\") ch <- 1 fmt.Println(\\\"recv\\\") <-ch } \"]},\"5\":{\"h\":\"无缓冲同步通信示例\",\"t\":[\"func main() { ch := make(chan int) defer close(ch) wg := sync.WaitGroup{} wg.Add(2) f1 := func() { defer wg.Done() time.Sleep(3 * time.Second) fmt.Println(\\\"f1 end.\\\") ch <- 1 } f2 := func() { defer wg.Done() <-ch fmt.Println(\\\"f2 end\\\") } go f1() go f2() wg.Wait() } \",\"上面的代码表示必须f1函数执行完成才能执行f2函数，否则f2一直阻塞，两个协程之间通过ch进行通信。\"]},\"6\":{\"h\":\"有缓冲chan\",\"t\":[\"有缓冲chan一般在进行并发限制的时候用的较多，案例：\",\"type Task struct { TaskId int64 Status string } func (t *Task) Do(ch <-chan int) { time.Sleep(time.Second * 3) t.Status = \\\"Success\\\" log.Printf(\\\"task %d done.\\\\n\\\", t.TaskId) <-ch } func main() { ch := make(chan int, 10) wg := sync.WaitGroup{} for i := 1; i < 100; i++ { wg.Add(1) ch <- i go func(i int) { defer wg.Done() task := &Task{TaskId: int64(i)} task.Do(ch) }(i) } wg.Wait() } \",\"案例中我们生成100个任务，每次最多并发执行10个，使用了有缓冲的chan，在任务执行之前对chan进行写操作，任务完成后对chan进行读操作，这样就限制了goruntine的个数。 同时上面的案例中，在task的Do方法中我们使用指向的chan，这个是Go中特有的，表明这个chan参数只能进行读取操作。\",\"in <-chan int：表示channel in通道只用于接收数据\",\"out chan<- int：表示channel out通道只用于发送数据\",\"只用于接收数据的通道<-chan不可被关闭，因为关闭通道是针对发送数据而言的，表示无数据再需发送。对于recv来说，关闭通道是没有意义的。\",\"案例：\",\"func main() { ch := make(chan int, 10) go func() { for i := 0; i < 100; i++ { ch <- i } close(ch) // 若没有此操作，使用range读取ch将会发生panic，产生死锁 }() for i := range ch { fmt.Println(\\\"i: \\\", i) } } \",\"前面都是在for无限循环中读取channel中的数据，但也可以使用range来迭代channel，它会返回每次迭代过程中所读取的数据，直到channel被关闭。必须注意，只要channel未关闭，range迭代channel就会一直被阻塞。\",\"fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: \"]},\"7\":{\"h\":\"select多路监听\",\"t\":[\"很多时候想要同时操作多个channel，比如从ch1、ch2读数据。Go提供了一个select语句块，它像switch一样工作，里面放一些case语句块，用来轮询每个case语句块的send或recv情况。\",\"用法示例：\",\"select{ case <-ch1: // do case v := <-ch2: // do default: // 所有case都不满足条件时，执行default } \",\"defalut语句是可选的，不允许fall through行为，但允许case语句块为空块。select会被return、break关键字中断：return是退出整个函数，break是退出当前select。\",\"select的行为模式主要是对channel是否可读进行轮询，但也可以用来向channel发送数据。它的行为如下：\",\"如果所有的case语句块评估时都被阻塞，则阻塞直到某个语句块可以被处理\",\"如果多个case同时满足条件，则随机选择一个进行处理，对于这一次的选择，其它的case都不会被阻塞，而是处理完被选中的case后进入下一轮select(如果select在循环中)或者结束select(如果select不在循环中或循环次数结束)\",\"如果存在default且其它case都不满足条件，则执行default。所以default必须要可执行而不能阻塞\",\"所有的case块都是按源代码书写顺序进行评估的。当select未在循环中时，它将只对所有case评估一次，这次结束后就结束select。某次评估过程中如果有满足条件的case，则所有其它case都直接结束评估，并退出此次select。\",\"其实如果注意到select语句是在某一个goroutine中评估的，就不难理解只有所有case都不满足条件时，select所在goroutine才会被阻塞，只要有一个case满足条件，本次select就不会出现阻塞的情况。\",\"需要注意的是，如果在select中执行send操作，则可能会永远被send阻塞。所以，在使用send的时候，应该也使用defalut语句块，保证send不会被阻塞。如果没有default，或者能确保select不阻塞的语句块，则迟早会被send阻塞。\",\"一般来说，select会放在一个无限循环语句中，一直轮询channel的可读事件。\",\"案例：\",\"func main() { ch1 := make(chan int) ch2 := make(chan int, 10) wg := sync.WaitGroup{} go func() { for { select { case v, ok := <-ch1: if !ok { fmt.Println(\\\"ch1 close\\\") ch1 = nil } fmt.Println(\\\"ch1: \\\", v) case v, ok := <-ch2: if !ok { fmt.Println(\\\"ch2 close\\\") ch2 = nil } fmt.Println(\\\"ch2: \\\", v) } } }() for i := 0; i < 10; i++ { wg.Add(2) go func(i int) { defer wg.Done() ch2 <- i }(i) go func(i int) { defer wg.Done() ch1 <- i }(i) } wg.Wait() close(ch1) close(ch2) } \",\"执行这段代码，select确实是随机选择case进行执行，同时我们在检测到chan关闭时，对chan进行了nil赋值，这个操作可以让当前case禁用，当select中的case都在禁用状态，select将会结束，达到终止循环的效果\"]},\"8\":{\"h\":\"准确使用定时器\",\"t\":[\"在Go中提供了定时器功能，一般都是通过 for-select的方式进行使用，在使用的时候要正确使用，防止内存泄漏\",\"func main() { ch := make(chan int, 10) go func() { i := 0 for { ch <- i i++ } }() for { select { case <-time.After(3 * time.Second): log.Println(\\\"timeout.\\\") return case v := <-ch: log.Println(\\\"ch: \\\", v) } } } \",\"看上面的案例，我们本意是在3秒之后停止main goruntine，但是我们代码运行下来发现是一直输出数据，并且不会推出main goruntine。原因在于 for+select，再加上 time.After 的组合会导致内存泄露。因为 for在循环时，就会调用都 select 语句，因此在每次进行 select 时，都会重新初始化一个全新的计时器（Timer）。我们这个计时器，是在 3秒后才会被触发去执行某些事，但重点在于计时器激活后，却又发现和 select 之间没有引用关系了，因此很合理的也就被 GC 给清理掉了，因为没有人需要 “我” 了。\",\"要命的还在后头，被抛弃的 time.After 的定时任务还是在时间堆中等待触发，在定时任务未到期之前，是不会被 GC 清除的。这就会导致严重的内存泄漏。改进方法如下：\",\"func main() { ch := make(chan int, 10) go func() { i := 0 for { ch <- i i++ } }() timer := time.After(3 * time.Second) for { select { case <-timer: log.Println(\\\"timeout.\\\") return case v := <-ch: log.Println(\\\"ch: \\\", v) } } } \",\"将延时器放到for循环之外定义，这样每次循环的时候就不会对time.After进行初始化，防止了内存泄漏，同时达到了3秒程序结束的效果.\"]},\"9\":{\"c\":[\"golang\"]},\"10\":{\"c\":[\"go\",\"golang\",\"channel\",\"并发安全\",\"源码\",\"面试\",\"面试总结\"]},\"11\":{\"h\":\"Golang通过Gin框架创建http服务源码剖析\"},\"12\":{\"h\":\"构建ServeMux\",\"t\":[\"net/http包中有默认的DefaultServeMux，gin框架也实现了这个，主要是实现 http.Handler接口，接口只包含一个方法 ServeHTTP(ResponseWriter, *Request)\",\"我们看下gin中怎么实现的\",\" // ServeHTTP conforms to the http.Handler interface. func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) // 具体的执行请求返回响应的方法 engine.pool.Put(c) } \",\"gin框架构建ServeMux流程如下：\",\" engine := gin.New() // 初始化gin，实现了http.Handler接口，是一个合格的ServeMux了 engine.Use() // 初始化全局中间件 engine.Get(\\\"/path\\\", function(ctx *gin.Context){}) // 添加路由 构建Server http服务的底层走的是tcp协议，需要监听端口 srv := http.Server{ Handler: engine, // http.Handler接口的实现者 Addr: \\\":8080\\\", // 监听http端口 } srv.ListenAndServe() \",\"上面的代码监听了8080端口来提供http服务，服务的具体执行者就是我们的gin框架，那么具体是怎么执行一个http请求的呢，具体要看 net/http包中Server.ListenAndServe()的实现，代码如下：\",\"func (srv *Server) ListenAndServe() error { if srv.shuttingDown() { return ErrServerClosed } addr := srv.Addr if addr == \\\"\\\" { addr = \\\":http\\\" } ln, err := net.Listen(\\\"tcp\\\", addr) if err != nil { return err } return srv.Serve(ln) } \",\"我们看到这个方法两个步骤，tcp协议监听端口，处理监听serve，我们主要看serve，代码如下：\",\"func (srv *Server) Serve(l net.Listener) error { ····· ..... baseCtx := context.Background() if srv.BaseContext != nil { baseCtx = srv.BaseContext(origListener) if baseCtx == nil { panic(\\\"BaseContext returned a nil context\\\") } } var tempDelay time.Duration // how long to sleep on accept failure ctx := context.WithValue(baseCtx, ServerContextKey, srv) for { rw, err := l.Accept() if err != nil { ····· ····· return err } connCtx := ctx if cc := srv.ConnContext; cc != nil { connCtx = cc(connCtx, rw) if connCtx == nil { panic(\\\"ConnContext returned nil\\\") } } tempDelay = 0 c := srv.newConn(rw) c.setState(c.rwc, StateNew, runHooks) // before Serve can return go c.serve(connCtx) } } \",\"我们通过代码可以看到，监听端口，然后accept阻塞直到返回下一个链接，经过一系列相关处理，创建一个新的连接，然后开一个goruntine处理这个连接，即每次一个http请求都会建立一个连接，每个连接中都会被赋予Server的信息，并通过goruntine来处理这个连接，这个就是go高并发的原理，具体连接的处理在conn.serve中，我们看到这个方法的参数是一个连接的上下文，方法代码如下：\",\" func (c *conn) serve(ctx context.Context) { c.remoteAddr = c.rwc.RemoteAddr().String() ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr()) defer func() { if err := recover(); err != nil && err != ErrAbortHandler { const size = 64 << 10 buf := make([]byte, size) buf = buf[:runtime.Stack(buf, false)] c.server.logf(\\\"http: panic serving %v: %v\\\\n%s\\\", c.remoteAddr, err, buf) } if !c.hijacked() { c.close() c.setState(c.rwc, StateClosed, runHooks) } }() ........ ........ // HTTP/1.x from here on. ctx, cancelCtx := context.WithCancel(ctx) c.cancelCtx = cancelCtx defer cancelCtx() c.r = &connReader{conn: c} c.bufr = newBufioReader(c.r) c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4<<10) for { w, err := c.readRequest(ctx) if c.r.remain != c.server.initialReadLimitSize() { // If we read any bytes off the wire, we're active. c.setState(c.rwc, StateActive, runHooks) } if err != nil { ....... ....... return } // Expect 100 Continue support req := w.req if req.expectsContinue() { if req.ProtoAtLeast(1, 1) && req.ContentLength != 0 { // Wrap the Body reader with one that replies on the connection req.Body = &expectContinueReader{readCloser: req.Body, resp: w} w.canWriteContinue.setTrue() } } else if req.Header.get(\\\"Expect\\\") != \\\"\\\" { w.sendExpectationFailed() return } c.curReq.Store(w) if requestBodyRemains(req.Body) { registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead) } else { w.conn.r.startBackgroundRead() } // HTTP cannot have multiple simultaneous active requests.[*] // Until the server replies to this request, it can't read another, // so we might as well run the handler in this goroutine. // [*] Not strictly true: HTTP pipelining. We could let them all process // in parallel even if their responses need to be serialized. // But we're not going to implement HTTP pipelining because it // was never deployed in the wild and the answer is HTTP/2. serverHandler{c.server}.ServeHTTP(w, w.req) w.cancelCtx() if c.hijacked() { return } w.finishRequest() .......... .......... c.rwc.SetReadDeadline(time.Time{}) } } \",\"我们看到这个方法中做了哪些事，方法执行完毕关闭当前连接，读取请求内容，处理并相应。具体处理请求的代码是这个 serverHandler{c.server}.ServeHTTP(w, w.req)我们看到实例化了一个serverHandler并调用了其ServeHTTP方法来处理，我看下这个serverHandler，代码如下：\",\" // serverHandler delegates to either the server's Handler or // DefaultServeMux and also handles \\\"OPTIONS *\\\" requests. type serverHandler struct { srv *Server } func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { handler := sh.srv.Handler if handler == nil { handler = DefaultServeMux } if req.RequestURI == \\\"*\\\" && req.Method == \\\"OPTIONS\\\" { handler = globalOptionsHandler{} } handler.ServeHTTP(rw, req) } \",\"我们看到代码里serverHandler中的 srv即为Server，在serverHandler的ServeHTTP方法中判断Server的Handler是否为nil，如果是nil则使用默认的DefaultServeMux，这里我们的Handler是由gin框架实现的一个ServeMux，调用ServeMux的ServeHTTP方法来处理请求，即交由gin来处理请求。gin中主要通过context.Next()方法来执行具体的gin.HandlerFunc函数，代码如下\",\" func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) engine.pool.Put(c) } func (engine *Engine) handleHTTPRequest(c *Context) { ........ ........ // Find root of the tree for the given HTTP method t := engine.trees for i, tl := 0, len(t); i < tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // Find route in tree value := root.getValue(rPath, c.Params, unescape) if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() c.writermem.WriteHeaderNow() return } ...... ...... break } ...... ...... c.handlers = engine.allNoRoute serveError(c, http.StatusNotFound, default404Body) } func (c *Context) Next() { c.index++ for c.index < int8(len(c.handlers)) { c.handlers[c.index](c) // 执行具体的HandlerFunc c.index++ } } \"]},\"13\":{\"c\":[\"golang\"]},\"14\":{\"c\":[\"go\",\"gin\",\"源码\",\"面试\",\"面试总结\"]},\"15\":{\"h\":\"Go面试之map、struct、interface\"},\"16\":{\"h\":\"map\",\"t\":[\"Go里的map用于存放key/value对，在其它地方常称为hash、dictionary、关联数组，这几种称呼都是对同一种数据结构的不同称呼，它们都用于将key经过hash函数处理，然后映射到value，实现一一对应的关系。\",\"在Go中map的元素是无序的，遍历时是随机的。map是一个指针，底层是数组，所以map是引用类型。在函数中map作为参数传递时，若函数内部对map做了相关修改，函数外的map也会被修改。\",\"通过下面的示例对map进行声明和创建\",\"var m map[string]int // 声明一个map类型的变量,nil map，它将不会做任何初始化，不会指向任何数据结构 m := make(map[string]int) // 初始化，创建一个map m := map[string]int{} // 空map， 初始化，创建一个map \",\"len()函数用于获取map中元素的个数，即有多个少key。delete()用于删除map中的某个key。\",\"map的key可以是任意内置的数据类型(如int)，或者其它可以通过\\\"==\\\" 进行等值比较的数据类型，如interface和指针可以。slice、数组、map、struct类型都不能作为key。map的值可以是任意对象，包括函数、指针、stuct等等。下面的示例将会展示map的相关操作\",\"func main() { var m map[string]int // 声明一个map类型的变量 m = make(map[string]int) // 初始化一个map m[\\\"a\\\"] = 1 // 更新一个key/value值 i, ok := m[\\\"b\\\"] // 获取一个key值，ok是一个bool值，用来判断key是否存在 l := len(m) // 获取map的长度，即元素个数 delete(m, \\\"a\\\") // 删除指定的key for k, v := range m{ } // 遍历map } \",\"map同slice一样都是线程不安全的数据类型，多协程操作时需要注意。\"]},\"17\":{\"h\":\"struct\",\"t\":[\"struct定义结构，结构由字段(field)组成，每个field都有所属数据类型，在一个struct中，每个字段名都必须唯一。每个字段都有类型，可以是任意类型，包括内置简单数据类型、其它自定义的struct类型、当前struct类型本身、接口、函数、channel等等。声明如下：\",\"type User struct{ Name string Age int } 构造struct实例 var u User // 初始化一个实例 // 除此之外，还可以使用new()函数或&TYPE{}的方式来构造struct实例，它会为struct分配内存，为各个字段做好默认的赋0初始化。它们是等价的，都返回数据对象的指针给变量， // 实际上&TYPE{}的底层会调用new()。 var u *User u = &User{} \",\"从上面的代码示例我们可以看到struct实例可以是一个值也可以是一个指针。尽管一个是数据对象值，一个是指针，它们都是数据对象的实例。\",\"在函数中我们传递一个对象的实例可以是对象的值也可以是对象的指针，Go中的参数传递其本质都是以复制的方式传递的。若对象实例中数据比较复杂，建议使用指针作为参数值进行传递。\",\"在struct中，field除了名称和数据类型，还可以有一个tag属性。tag属性用于\\\"注释\\\"各个字段，除了reflect包，正常的程序中都无法使用这个tag属性。\",\"type User struct{ Name string `json:\\\"user\\\"` Age int `json:\\\"age\\\"` } \",\"struct中的字段可以不用给名称，这时称为匿名字段。匿名字段的名称强制和类型相同。例如：\",\"type animal struct { name string age int } type Horse struct{ inter animal sound string } \",\"上面的Horse中有两个匿名段inter和animal，它的名称和类型都是inter和animal。 在上面Horse中嵌套了其它的struct(如animal)。其中animal称为内部struct，Horse称为外部struct。\",\"假如外部struct中的字段名和内部struct的字段名相同，会如何？\",\"有以下两个名称冲突的规则：\",\"外部struct覆盖内部struct的同名字段、同名方法\",\"同级别的struct出现同名字段、方法将报错 第一个规则使得Go struct能够实现面向对象中的重写(override)，而且可以重写字段、重写方法。 第二个规则使得同名属性不会出现歧义。 struct可以嵌套自身的特性使之在实现树和链表上更加方便。\"]},\"18\":{\"h\":\"struct的方法\",\"t\":[\"type Person struct{ Name string Age int } func (u Person)SetName(name string){ u.Name = name } func (u *Person)SetAge(age int){ u.Age = age } \",\"除了实例有值类型和指针类型的区别，方法也有值类型的方法和指针类型的区别 setname()方法中是值类型的receiver，setage()方法中是指针类型的receiver。它们是有区别的。\",\"首先，setage()方法的p是一个指针类型的person实例，所以方法体中的p.age实际上等价于(*p).age。\",\"再者，方法就是函数，Go中所有需要传值的时候，都是按值传递的，也就是拷贝一个副本。\",\"setname()中，除了参数name string需要拷贝，receiver部分(p person)也会拷贝，而且它明确了要拷贝的对象是值类型的实例，也就是拷贝完整的person数据结构。但实例有两种类型：值类型和指针类型。(p person) 无视它们的类型，因为receiver严格规定p是一个值类型的实例。所以无论是指针类型的p1实例还是值类型的p2实例，都会拷贝整个实例对象。对于指针类型的实例p1，前面说了，在需要的时候，Go会自动解除引用，所以p1.setname() 等价于(*p1).setname()。\",\"也就是说，只要receiver是值类型的，无论是使用值类型的实例还是指针类型的实例，都是拷贝整个底层数据结构的，方法内部访问的和修改的都是实例的副本。所以，如果有修改操作，不会影响外部原始实例。\",\"setage()中，receiver部分(p *person)明确指定了要拷贝的对象是指针类型的实例，无论是指针类型的实例p1还是值类型的p2，都是拷贝指针。所以p2.setage()等价于(&p2).setage()。\",\"也就是说，只要receiver是指针类型的，无论是使用值类型的实例还是指针类型的实例，都是拷贝指针，方法内部访问的和修改的都是原始的实例数据结构。所以，如果有修改操作，会影响外部原始实例。\",\"那么选择值类型的receiver还是指针类型的receiver？一般来说选择指针类型的receiver。\"]},\"19\":{\"h\":\"struct的比较\",\"t\":[\"struct是可以比较，但同时也是不可以比较的，这个要看struct的场景。在 Go 语言中，Go 结构体有时候并不能直接比较，当其基本类型包含：slice、map、function 时，是不能比较的。若强行比较，就会导致出现例子中的直接报错的情况。而指针引用，其虽然都是 new(string)，从表象来看是一个东西，但其具体返回的地址是不一样的。\",\"如果我们被迫无奈，被要求一定要用结构体比较怎么办？这时候可以使用反射方法 reflect.DeepEqual，如下：\",\"func main() { v1 := Value{Name: \\\"对\\\", GoodAt: []string{\\\"的\\\", \\\"额\\\", \\\"我\\\"}} v2 := Value{Name: \\\"对\\\", GoodAt: []string{\\\"的\\\", \\\"额\\\", \\\"我\\\"}} if reflect.DeepEqual(v1, v2) { fmt.Println(\\\"yes\\\") return } fmt.Println(\\\"no\\\") } \"]},\"20\":{\"h\":\"interface\",\"t\":[\"接口(interface)是一种类型，用来定义行为(方法)。\",\" type User interface{ GetName() string SetName(name string) } type Person struct{ Name string } func (p *Person) GetName()string { return p.Name } func (p *Person) SetName(name string){ p.Name = name } var u User p := &Person{} u = p // 当接口实例中保存了自定义类型的实例后，就可以直接从接口上调用它所保存的实例的方法 u.SetName(\\\"dddd\\\") fmt.Println(u.GetName()) \",\"上面的示例，Person实例实现了User接口。\",\"接口类型是指针类型，但是它到底存放了什么东西？接口类型的数据结构是2个指针，占用2个机器字长。第一个是指针指向实例的类型信息和方法集，第二个指针就是实例的指针地址。\"]},\"21\":{\"h\":\"方法集\",\"t\":[\"方法集是类型的方法集合，对于非接口类型，每个类型都分两个Method Set：值类型实例是一个Method Set，指针类型的实例是另一个Method Set。两个Method Set由不同receiver类型的方法组成。\",\"值类型的实例的Method Set只由值类型的receiver(T Type)组成\",\"指针类型的实例的Method Set由值类型和指针类型的receiver共同组成，即(T Type)和(T *Type)\",\"从实现接口方法的角度上看：\",\"如果某类型实现接口的方法的receiver是(T Type)类型的，那么只有指针类型的实例T才算是实现了这个接口，因为这个方法不在值类型的实例T方法集中\",\"如果某类型实现接口的方法的receiver是(T Type)类型的，那么值类型的实例T和指针类型的实例T都算实现了这个接口，因为这个方法既在值类型的实例T方法集中，也在指针类型的实例T方法集中\"]},\"22\":{\"h\":\"空interface\",\"t\":[\"空接口是指没有定义任何接口方法的接口。没有定义任何接口方法，意味着Go中的任意对象都可以实现空接口(因为没方法需要实现)，任意对象都可以保存到空接口实例变量中。\",\"type empty_int interface{} // 声明一个空接口实例 var i interface{} \",\"可以定义一个空接口类型的array、slice、map、struct等，这样它们就可以用来存放任意类型的对象，因为任意类型都实现了空接口。\",\"any := make([]interface{}, 5) any[0] = 11 any[1] = \\\"hello world\\\" any[2] = []int{11, 22, 33, 44} for _, value := range any { fmt.Println(value) } \",\"显然，通过空接口类型，Go也能像其它动态语言一样，在数据结构中存储任意类型的数据。\",\"空接口是一种接口，它是一种指针类型的数据类型，虽然不严谨，但它确实保存了两个指针，一个是对象的类型(或iTable)，一个是对象的值。所以上面的赋值过程是让空接口any保存各个数据对象的类型和对象的值。\"]},\"23\":{\"h\":\"interface类型断言和type-switch\",\"t\":[\"接口实例中可以存放各种实现了接口的类型实例，在有需要的时候，还可以通过ins.(Type)或ins.(*Type)的方式将接口实例ins直接转回Type类型的实例。\",\"var i int = 30 var ins interface{} \",\"// 接口实例ins中保存的是int类型\",\"ins = i x := ins.(int) // 接口转回int类型的实例i println(x) //输出30 \",\"注意，接口实例转回时，接口实例中存放的是什么类型，才能转换成什么类型。同类型的值类型实例和指针类型实例不能互转，不同类型更不能互转。\",\"在不能转换时，Golang将直接以Panic的方式终止程序。但可以处理转换失败时的panic，这时需要类型断言，也即类型检测。\",\"// 如果ins保存的是值类型的Type，则输出 if t, ok := ins.(Type); ok { fmt.Printf(\\\"%T\\\\n\\\", v) } // 如果ins保存的是指针类型的*Type，则输出 if t, ok := ins.(*Type); ok { fmt.Printf(\\\"%T\\\\n\\\", v) } // 一个返回值的探测 t := ins.(Type) t := ins.(*Type) \",\"直接用if v,ok := ins.(Type);ok {}的方式做类型探测在探测类型数量多时不是很方便，需要重复写if结构。\",\"Golang提供了switch...case结构用于做多种类型的探测，所以这种结构也称为type-switch。这是比较方便的语法，比如可以判断某接口如果是A类型，就执行A类型里的特有方法，如果是B类型，就执行B类型里的特有方法。\",\"switch v := ins.(type) { case *Square: fmt.Printf(\\\"Type Square %T\\\\n\\\", v) case *Circle: fmt.Printf(\\\"Type Circle %T\\\\n\\\", v) case nil: fmt.Println(\\\"nil value: nothing to check?\\\") default: fmt.Printf(\\\"Unexpected type %T\\\", v) } \"]},\"24\":{\"c\":[\"golang\"]},\"25\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"26\":{\"h\":\"Go面试之并发安全的map\"},\"27\":{\"h\":\"并发安全的map\",\"t\":[\"在上一个总结中我们知道map是引用类型的，并且是非线程安全的。这个时候杠精面试官问，我就是要使用Go提供的原生map，你怎么来保证这个map是线程安全的呢？\",\"众所周知Go中有提供线程安全的map，那就是标准包里的sync.Map类型。那面试官要使用原生map，那他到底想从你这面获取什么呢？我们来思考这个问题。\",\"怎么保证线程安全的原生map，我们首先想到的是使用互斥锁或读写锁。案例：\",\"type myMap struct { l sync.RWMutex m map[string]int } func NewMyMap() *myMap { return &myMap{ m: make(map[string]int), } } func (m *myMap) Add(key string, val int) { m.l.Lock() defer m.l.Unlock() m.m[key] = val } func (m *myMap) Delete(key string) { m.l.Lock() defer m.l.Unlock() delete(m.m, key) } func (m *myMap) Find(key string) (int, bool) { m.l.RLock() defer m.l.RUnlock() val, ok := m.m[key] return val, ok } func main() { wg := sync.WaitGroup{} m := NewMyMap() for i := 1; i < 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() key := \\\"a\\\" m.Add(key, i) val, ok := m.Find(key) m.Delete(key) log.Println(val, ok) }(i) } wg.Wait() } \",\"案例中我们定义了一个结构体，结构体中有两个字段，l代表锁，这里我们选择的是读写锁，m代表的是一个map类型，key是string类型，val是int类型。对于这个结构体我们添加了三个方法，分别是Add，Delete，Find，添加、删除和查找。我们看到在这三个操作中都使用到了锁机制。main函数中我们利用for语句生成了9个goruntine，对同一个map下的key进行并发读写，运行程序正常输出，没有发生panic。说明锁起到了作用。\",\"从上面的案例中我们通过锁机制实现了并发安全的map，那我们还有其他的方式来实现吗？答案是有的，那就是通过channel机制来实现。\"]},\"28\":{\"h\":\"channel实现并发安全的map\",\"t\":[\"案例:\",\"type myMap struct { m map[string]int ch chan func() } func NewMyMap() *myMap { m := &myMap{ m: make(map[string]int), ch: make(chan func()), } go func() { for { (<-m.ch)() } }() return m } func (m *myMap) Add(key string, val int) { m.ch <- func() { log.Println(\\\"add\\\", key, val) m.m[key] = val } } func (m *myMap) Delete(key string) { m.ch <- func() { delete(m.m, key) } } func (m *myMap) Find(key string) (int, bool) { ch := make(chan int) m.ch <- func() { val, ok := m.m[key] log.Println(\\\"find\\\", val, ok) if !ok { close(ch) } else { ch <- val } } r, k := <-ch return r, k } func main() { wg := sync.WaitGroup{} m := NewMyMap() for i := 1; i < 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() key := \\\"a\\\" + strconv.Itoa(i) m.Add(key, i) val, ok := m.Find(key) m.Delete(key) log.Println(i, val, ok) }(i) } wg.Wait() } \",\"案例中我们定义了一个结构体，两个字段，ch代表chan，对应的是一个匿名函数，m定义map类型，在对实例初始化的时候，我们开启了一个go协程用来读取ch中的方法并执行。我们同样是通过for循环开了9个协程来对map进行增删改查，但是和上个锁的案例有个不同的地方是多个协程之间不再是对同一个key进行操作，而是对不同的key进行操作。这两者有什么区别呢？如果我们多协程对同一个key进行操作，我们输出的结果和我们预想的将大相径庭。大家可以对代码进行修改试一试。\",\"如果杠精面试官说我就想要多协程对同一个key进行操作，那咋办呢？我个人建议是使用锁进行实现，channel的实现只能保证这个map在并发读写的时候不会panic，但达不到我们预想的要求。\",\"下面是多协程在channel方法下对同一个key进行操作的结果，大家可以参考下。\",\"至于为什么面试官不想用sync.map我想大家心中已经有了答案，主要就是考察面试者对锁和channel的知识，至于sync.map的相关知识大家可以读这篇文章：\"]},\"29\":{\"c\":[\"golang\"]},\"30\":{\"c\":[\"go\",\"golang\",\"map\",\"并发安全\",\"源码\",\"面试\",\"面试总结\"]},\"31\":{\"h\":\"Go面试之sync.Mutex和sync.RWMutex\",\"t\":[\"在上一个总结中我们在实现线程安全的map的时候用到了锁的概念，面试官听到这个锁的实现方法之后双眼冒光，开始了新一轮的攻势。问：互斥锁和读写锁有啥区别？\"]},\"32\":{\"h\":\"sync.Mutex互斥锁\",\"t\":[\"Go中标准包提供sync.Mutex类型实现mutex(排他锁、互斥锁)。定义：\",\"// A Mutex is a mutual exclusion lock. // The zero value for a Mutex is an unlocked mutex. // // A Mutex must not be copied after first use. type Mutex struct { state int32 sema uint32 } \",\"sync.Mutex提供两个方法，Lock()方法获取锁，UnLock()释放锁。一旦被锁住，其他的Lock操作将无法进行，直到其被UnLock。在goruntine中已有的锁在没有被释放前去获取锁，那么这个gorutine将会被阻塞，只有在UnLock后才会解除阻塞。案例：\",\"var i int var m sync.Mutex func add() { m.Lock() defer m.Unlock() i++ } func read() int { m.Lock() defer m.Unlock() return i } func noLockRead() int { return i } func main() { var wg sync.WaitGroup for j := 0; j < 10; j++ { wg.Add(1) go func(j int) { defer wg.Done() add() log.Println(\\\"nolock\\\", j, noLockRead()) log.Println(j, read()) }(j) } wg.Wait() } \",\"我们看到在代码案例中我们对共享的变量i进行加和读操作，add方法中使用了互斥锁，记住：**在Lock()和Unlock()之间的代码段称为资源的临界区(critical section)，在这一区间内的代码是严格被Lock()保护的，是线程安全的，任何一个时间点都只能有一个goroutine执行这段区间的代码。**由于add和read操作都会使用到锁，所以20个goruntine将会产生40个资源临界区，Lock保证了在一个时间点只有其中一个goruntine可以访问其中一个临界区，当释放了释放了一个临界区，其他的Lock将会竞争互斥锁，这个叫做锁竞争。因为竞争的存在，这40个临界区是随机被访问的，所以是无序的，总结下来就是：Mutex保证了每个资源临界区的安全，某一时间点只有一个goroutine访问到这部分，但也因此而出现了随机性。\",\"在Go中允许这样：如果在一个地方Lock()，在另一个地方不Lock()而是直接修改或访问共享数据，这对于sync.Mutex类型来说是允许的，因为mutex不会和goroutine进行关联。\",\"根据上述的结论，在上个总结的线程安全的map一文中是有一处错误的，那就是使用锁机制实现的线程安全的map，也是无法保证操作顺序的，只能保证map是线程安全的。\"]},\"33\":{\"h\":\"sync.RWMutex读写锁\",\"t\":[\"看下这个结构的定义：\",\"type RWMutex struct { w Mutex // held if there are pending writers writerSem uint32 // 写锁需要等待读锁释放的信号量 readerSem uint32 // 读锁需要等待写锁释放的信号量 readerCount int32 // 表示当前启用的读者数量，包括了所有正在临界区里面的读者或者被写锁阻塞的等待进入临界区读者的数量。相当于是当前调用了 RLock 函数并且还没调用 RUnLock 函数的读者的数量。 readerWait int32 // 用来记录在获取写锁之前，需要等待多少读锁释放的数量。 } \",\"从上面的代码我们可以看出：\",\"Go中的读写锁是基于互斥锁的\",\"读写锁允许有多个读锁和一个写锁 \",\"可以同时申请多个读锁\",\"有写锁时，申请读锁和写锁将会阻塞\",\"读写锁常被用于读多写少的场景\",\"func (rw *RWMutex) Lock() 写锁，如果在添加写锁之前已经有其他的读锁和写锁，则lock就会阻塞直到该锁可用，为确保该锁最终可用，已阻塞的 Lock 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定。\",\"func (rw *RWMutex) Unlock() 写锁解锁，如果没有进行写锁定，则就会引起一个运行时错误\",\"func (rw *RWMutex) RLock() 读锁，当有写锁时，无法加载读锁，当只有读锁或者没有锁时，可以加载读锁，读锁可以加载多个，所以适用于＂读多写少＂的场景\",\"func (rw *RWMutex)RUnlock() 读锁解锁，RUnlock 撤销单次 RLock 调用，一次RUnlock()操作只是对读锁数量减1，即减少一次读锁的引用计数，如果没有进行写锁定，则就会引起一个运行时错误\",\"案例：\",\"package main import ( \\\"log\\\" \\\"sync\\\" ) type myMap struct { rw sync.RWMutex m sync.Mutex data map[string]int } func (m *myMap) add(key string, val int) { m.rw.Lock() log.Println(\\\"add\\\", key, val) //time.Sleep(time.Second * 3) defer m.rw.Unlock() m.data[key] = val } func (m *myMap) mFind(key string) int { m.m.Lock() log.Println(\\\"mfind\\\", key) //time.Sleep(time.Second) defer m.m.Unlock() return m.data[key] } func (m *myMap) rwFind(key string) int { m.rw.RLock() log.Println(\\\"rwfind\\\", key) //time.Sleep(time.Second) defer m.rw.RUnlock() return m.data[key] } func main() { wg := sync.WaitGroup{} m := &myMap{data: make(map[string]int)} key := \\\"a\\\" for i := 0; i < 5; i++ { wg.Add(3) go func(i int) { defer wg.Done() m.add(key, i) }(i) go func(i int) { defer wg.Done() log.Println(\\\"mfor\\\", i, m.mFind(key)) }(i) go func(i int) { defer wg.Done() log.Println(\\\"rwfor\\\", i, m.rwFind(key)) }(i) } wg.Wait() } \",\"上述代码中我们定义了一个结构体，里面的属性一个是互斥锁，一个是读写锁，还有个map结构。mFind方法通过互斥锁去读map数据，rwFind方法通过读写锁去读取数据。当使用mFind读取数据时，我们发现读数据和写数据互不冲突，读和读却是冲突的，因为是互斥锁。使用rwFind读取数据，虽然读锁不冲突，因为读写锁可以多次获取读锁，但是若一个写锁在占用锁，那多个读锁就都会阻塞，要等待写锁完成释放后，读锁才会继续执行。\"]},\"34\":{\"h\":\"sync.Mutex和sync.RWMutex如何选择\",\"t\":[\"Mutex和RWMutex都不关联goroutine，它们的锁申请行为可以在一个goroutine中操作，释放锁行为可以在另一个goroutine中操作。但RWMutex显然更适用于读多写少的场景。仅针对读的性能来说，RWMutex要高于Mutex，因为rwmutex的多个读可以并存。\"]},\"35\":{\"c\":[\"golang\"]},\"36\":{\"c\":[\"go\",\"golang\",\"mutex\",\"并发安全\",\"源码\",\"面试\",\"面试总结\"]},\"37\":{\"h\":\"MySQL相关知识点浅析\"},\"38\":{\"h\":\"切片\",\"t\":[\"切片是Golang中特有的数据类型。在Go语言中数组是固定长度的，不能动态扩容的，在编译器会固定大小。而切片是对数组的抽象，是一种灵活地\\\"动态数组\\\"，切片可以追加元素。切片是一种数据结构，切片不是数组，切片描述的是一块数据。切片声明如下：\",\"var ints []int // 直接声明 ints := []int{1, 2, 3, 4} // 字面量声明 ints := make([]int{}, 2, 4) // make创建 ints := arr[1:5] // 下表截取创建 ints := *new([]int) // new一个 \",\"其中最常用的是make创建和下标截取。切片可以通过Go内置append方法进行追加元素，当cap不够时进行动态扩容。一般cap是切片长度的两倍。切片是引用类型。\",\"切片的内置结构：\",\"type SliceHeader struct { Data uintptr // 表示该slice结构从底层数组的哪一个元素开始，该指针指向该元素 Len int // 表示slice当前的长度，如果追加元素，长度不够时会扩展，最大扩展到Capacity的长度 Cap int // 即底层数组的长度，表示这个slice目前最多能扩展到这么长 } \",\"切片的Data属性是指向切片数组的指针，这个概念很重要。若切片发生拷贝，其实质是对当前三个属性的拷贝，不管当前slice具体有多少个元素，其拷贝时间都是大差不差的。\",\"切片的扩容 切片在扩容时会进行内存对齐，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于老 slice 容量的 2倍或者1.25倍，当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。\",\"我们来关注下面的代码：\",\"func main() { ints := make([]int, 2, 4) fmt.Println(ints) // [0 0] int1 := ints[1:] fmt.Println(int1, cap(int1)) // [0] 3 int1[0] = 1 fmt.Println(ints) // [0 1] int1 = append(int1, 2) fmt.Println(int1, cap(int1)) // [1 2] 3 fmt.Println(ints) // [0 1] int1[0] = 2 fmt.Println(ints, int1, cap(int1)) // [0 2] [2 2] 3 ints = append(ints, 3) fmt.Println(ints, int1, cap(int1)) // [0 2 3] [2 3] 3 } \",\"首先我们声明了一个长度为2，cap为4的int类型切片，这是个零切片。接着我们通过下标截取的方式声明了一个int类型的切片， 这个时候 int1切片的data属性的指针地址和ints的指针地址是一样的，长度为1，容量为3。我们对int1进行下标修改，同时ints对应的元素值也会修改。\",\"接着我们使用Go内置的append函数对int1进行追加，使之长度发生了改变，这个时候int1的长度小于容量，指针不会被重新分配，但是追加数据不会影响ints，因为ints的长度为2，下标未满足条件，访问不了int1追加的元素。\",\"接着我们使用Go内置的append函数对ints进行追加，使之长度发生了改变，这个时候ints的长度小于容量，指针不会被重新分配，但是追加数据会影响int1，在底层数组上int1是ints的子集。\",\"range遍历切片有什么要注意的？\",\"func main() { users := []User{ {\\\"张三\\\", 18}, {\\\"李四\\\", 34}, {\\\"王五\\\", 21}, } for _, v := range users{ if v.Age != 20{ v.Age = 20 } } fmt.Println(users) // [{张三 18} {李四 34} {王五 21}] } \",\"使用range遍历切片users，变量v是拷贝切片中的数据，修改拷贝数据不会对原切片有影响。\"]},\"39\":{\"c\":[\"golang\"]},\"40\":{\"c\":[\"go\",\"golang\",\"slice\",\"面试\",\"面试总结\",\"源码\"]},\"41\":{\"h\":\"MySQL相关知识点浅析\"},\"42\":{\"h\":\"Myisam和Innodb的区别\",\"t\":[\"innodb支持事务，锁级别是行级锁，支持四个事务隔离级别，分别是未提交读、提交读、可重复读、串行化\",\"innodb的索引策略是聚簇索引\",\"innodb使用MVCC实现并发控制、也就是多版本并发控制，同时也支持索引间隙锁\",\"innodb支持热备份\",\"myisam支持全文索引、表压缩\",\"myisam的锁不支持行级锁，支持表级锁，这个特性会导致，在并发高的情况下进行读写操作的时候性能很差。\",\"myisam支持延迟更新索引键\",\"myisam崩溃的概率比innodb要大很多，MySQL的数据恢复相较于innodb较差\",\"数据存储方式不一样，innodb采用聚簇索引的方式存储数据，myisam采用索引和列的值分离的方式存储数据。\",\"读锁又被称为共享锁，写锁被称为排它锁。\",\"ACID指：原子性、一致性、隔离性、持久性\"]},\"43\":{\"h\":\"mysql优化相关\",\"t\":[\"慢查询日志，对优化MySQL查询至关重要。可以通过long_query_time参数来设置日志记录行为，当值为0时，记录所有的查询\",\"使用show global status SQL语句查看当前连接数(threads_connected)、查询线程数(threads_running)、查询数(queries)\",\"使用 show processlist SQL语句查看当前连接线程是否有废线程，比如locked、free 状态的\",\"设计表的时候选择合适的数据类型，尽量使用NOT NULL，列不要太多\",\"主键最好使用整数类型，避免使用字符串类型\",\"查询SQL数据表关联不要过多，一般最多12个表\",\"根据实际业务创建相关汇总表和缓存表\",\"使用索引。\"]},\"44\":{\"h\":\"mysql修改表相关\",\"t\":[\"alter table 操作在大多数情况下都会锁表，并且重建整表，慎用\",\"对于引擎是myisam的数据表在迁移或转入大量数据的时候，可以先关闭索引，等待数据载入之后开启索引，相关操作如下\"]},\"45\":{\"h\":\"关闭索引\",\"t\":[\"alter table table_name disable keys; \"]},\"46\":{\"h\":\"开启索引\",\"t\":[\"alter table table_name enable keys; \",\"这个方法对主键、唯一索引无效\"]},\"47\":{\"h\":\"索引相关\",\"t\":[\"大多数MySQL存储引擎都实现了b-tree索引，b-tree索引是有序的，在order by 和group by语句中也会用到索引\",\"索引总是遵循最左前缀\",\"索引中的列不能被跳过，如果一个查询中有范围查询，那么只能用到范围查询之前的列，右边的用不到。\",\"可以通过伪哈希索引的手段来优化查询语句\",\"查询中的条件的列不能是一个表达式或函数的参数，要是单独的列，这样才能用到索引\",\"索引中列的顺序不同效果也不一样，在实际业务中可以通过使用相同的列不同的顺序来创建更多的索引\",\"索引可以减少服务器扫描的数据量，避免排序和临时表，索引可以将随机I/O变为顺序I/O\"]},\"48\":{\"h\":\"前缀索引\",\"t\":[\"前缀索引主要是对字符串类型的列取公共前缀进行索引。可以通过不断比较公共前缀出现的次数和总记录的商来取前缀，方法如下：\",\"假设表名为testcity，字符串列名为'city',可以通过如下语句来计算\",\"select count(distinct left(city,3)) /count(*) as sel from testcity;\",\"sel的值越接近1越好。\",\"下面添加一个前缀索引\",\"alter table testcity add key(city(3));\",\"前缀索引更小，更快，不过在order by 和group by中无法使用。\",\"当使用explain分析查询语句时，如果索引类型为index_merge则说明表的索引策略很糟糕，要优化了\"]},\"49\":{\"h\":\"多列索引\",\"t\":[\"选择合适的索引顺序至关重要。我们同样可以使用前缀索引中的方法来比较，不过这次我们不是比较前缀出现的次数而是整个列的记录不重复的次数：\",\"表：testcity 列：cityid, xianid。\",\"select count(distinct cityid) /count(*) as c, count(distinct xianid) /count(*) as x from testcity;\",\"计算的结果中值越接近1的就越往前，比如 c>x,那么索引应该这样加\",\"alter table testcity add key(cityid, xianid);\",\"如果一个索引包含所有要查询字段的值，那这个索引就被称之为覆盖索引。比如下面这个语句：\",\"select cityid from testcity where cityid = 10;\",\"其中 idx_cityid_xianid就是cityid的覆盖索引\",\"select cityid,id, xianid from testcity where cityid = 10;这个时候idx_cityid_xianid就不是覆盖索引\",\"聚簇索引是一种数据存储方式，innodb存储引擎支持，主要是通过主键来实现，如果表中没有定义主键，那就会喧杂一个唯一的非空索引替代，如果没有符合条件的，会自行创建一个隐式主键。它将索引和列的值存储在一起。使数据访问更快，但是特消耗存储空间，二级索引访问需要两次查找，而不是一次（首先二级索引先找到主键，然后通过主键找到具体的值，两次索引查找）\",\"在设计innodb主键的时候，建议使用单调顺序自增类型，比如自增ID，因为innodb是顺序插入的。\"]},\"50\":{\"h\":\"myisam和innodb的索引总结。\",\"t\":[\"两者都支持，主键索引、唯一索引、单列、多列索引及前缀索引，不同的是两者实现的存储方式不一样，innodb中使用聚簇索引的方式存储数据，也就是把索引和列的值存在一起，myisam却不同，索引和值分离；：因为myisam的索引和数据是分开存储存储的，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因 ；innodb的数据和索引放在一起，当找到索引也就找到了数据。\"]},\"51\":{\"h\":\"查询优化相关\",\"t\":[\"减少不必要列的查询\",\"尽量优化查询，使之可以使用到覆盖索引\",\"建立合适的索引，减少查询时扫描的行数\",\"拆分复杂的查询，分解关联查询，简单的查询可以减少锁的竞争，易缓存，减少冗余记录查询\",\"在select查询中加上limit关键字，可以减少资源占用\",\"子查询尽量少用，合理使用子查询，可以使用表连接代替（MySQL版本5.6及以上可以放心大胆的去用子查询）\"]},\"52\":{\"h\":\"MySQL高级特性\"},\"53\":{\"h\":\"分区\",\"t\":[\"range 分区\",\"CREATE TABLE `request_log` ( `id` int(11) NOT NULL AUTO_INCREMENT, `ip` int(11) NOT NULL, `uri` varchar(30) DEFAULT NULL, `request_time` int(11) NOT NULL, PRIMARY KEY (`id`,`request_time`), UNIQUE KEY `ip` (`ip`,`request_time`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 partition BY RANGE (request_time) (partition p0 VALUES LESS THAN (1400000000) ENGINE = InnoDB, partition p1 VALUES LESS THAN (1500000000) ENGINE = InnoDB, PARTITION pall VALUES LESS THAN MAXVALUE ENGINE = InnoDB); \",\"同时还有别的分区，比如，list分区，hash分区，key分区。具体可以参考：https://www.cnblogs.com/mliudong/p/3625522.html 简单了解下\",\"分区的时候最好不要选择默认为NULL的列，选择的列最好有索引（分区列和索引列匹配），分区在查询的时候需要锁住所有的底层表，这会带来很多的开销，要控制合适的分区的个数。分区的维护成本比较高\",\"在进行分区查询的时候，where条件要包含分区列，分区列不能在表达式中，这样可以在查询的时候减少分区的扫描。\",\"比如：partitions select * from request_log where request_time between 1400000000 and 1500000000;\"]},\"54\":{\"h\":\"视图\",\"t\":[\"具体视图相关可以参考：https://blog.csdn.net/moxigandashu/article/details/63254901\",\"全文索引\",\"MySQL5.6版本innodb开始支持全文索引，之前的版本只有myisam支持，具体可以参考：https://www.cnblogs.com/PaulMa/p/5238682.html\"]},\"55\":{\"h\":\"绑定变量\",\"t\":[\"以二进制的方式向服务端发送参数和句柄，节约内存和网络开销。服务器也只对器进行一次解析。\",\"相对安全，减少了SQL注入和攻击\",\"在高并发的情况下建议关闭查询缓存，如果非要使用的话不要设置太大的内存占用，相关参数：query_cache_type是否开启缓存；query_cache_size查询缓存的总内存空间，单位字节。\"]},\"56\":{\"h\":\"配置优化：\",\"t\":[\"对于innodb来说最重要的两个配置为：\",\"innodb_buffer_pool_size缓冲池大小\",\"innodb_log_file_size 日志文件大小\",\"基本配置\",\"slow_query_log 慢查询是否开启\",\"long_query_time 慢查询衡量标准，单位秒\",\"max-connections 最大连接数\",\"read-only 是否只读\",\"table_cache_size\",\"sql_mode 服务器模式\"]},\"57\":{\"h\":\"复制\",\"t\":[\"二进制日志（binlog）建议指定确切路径和文件名，同时在备库上也建议指定中继日志（relay_log）的路径和文件名\",\"相关参数：\",\"主库：\",\"log_bin = /var/lib/mysql/mysql-bin\",\"备库：\",\"relay_log = /var/lib/mysql/relay-bin\",\"复制模式，两种，基于语句(statement)，基于行(row)。\",\"基于语句消耗资源少，执行速度快，但是很多情况下无法正确复制数据。比如有存储过程的语句，语句里有变量的\",\"基于行的复制，顾名思义就是一行一行复制，但是在数据更改比较大的情况下，消耗资源多，复制慢。\",\"一般都是在实际应用中采用混合模式复制(mixed)，即基于行和基于语句一起使用，5.7.7之前默认是基于语句，之后基于行，可以通过参数设置：\",\"binlog_format = mixed|row|statement\",\"参考文章：https://www.cnblogs.com/ivictor/p/5764978.html\",\"主从复制开启步骤\",\"1、在主服务器上创建一个复制账号\",\"2、主库从库配置server_id选项，一般是机器IP32位的后八位，主库配置二进制文件地址，从库配置中继日志文件地址，可以通过show master status 查看binlog日志的名字\",\"3、从库启动复制：\",\"命令： change master to master_host='hostip',master_user='masteruser',master_password='password',master_log_file='binlogname',master_log_pos=0;\",\"master_log_pos设置为0表示从日志开头读起，配置好之后，开始执行命令start slave;\",\"sphinx全文索引\",\"主索引和增量索引都要定时维护。具体相关实现可以参考：bbc，相关知识点，搞清楚文档、属性、关联字段。\",\"相关参考文章：https://blog.csdn.net/soar_away/article/details/52035072\",\"https://blog.csdn.net/adparking/article/details/7080278\",\"手册地址：http://sphinxsearch.com/docs/\"]},\"58\":{\"c\":[\"mysql\"]},\"59\":{\"c\":[\"mysql\",\"面试\",\"面试总结\"]},\"60\":{\"h\":\"PHP面试总结 v20180824\",\"t\":[\"今天面试主要和面试官讨论这些问题，我自我感觉回答的很渣。不错，我就是个技术混子，嗯，是的。\"]},\"61\":{\"h\":\"PHP的命令模式实现\",\"t\":[\"PHP的命令模式也就是cli模式，就是把PHP文件当做脚本执行的一种方式。一般最简单的实现就是如下：\",\"php file.php \",\"上面的列子很简单，但是这个问题不是那么简单的。通常我们在web模式下都会有个入口文件，这个入口文件叫 index.php，那么命令模式下是不是也可以有个入口文件呢？答案是可以的，比如ThinkPHP5和yii框架都实现了这个功能。比如：\",\"php think list \",\"上面例子中，think 这个就是命令模式下的入口文件，list 是在换个文件的参数，可以通过 $SERVER['argv'] 获取，获取到参数之后，执行响应的逻辑。一般的框架都会实现命令的注册，每个框架的处理机制不一样，这个可以通过阅读框架的源码看下。\"]},\"62\":{\"h\":\"PHP的错误和异常处理\"},\"63\":{\"h\":\"错误处理\",\"t\":[\"一般编程语言都有自己的错误处理机制，这个机制对调试应用程序，处理业务逻辑有很大的帮助。 PHP提供了 error_reporting() 函数来设置错误级别。一般PHP常见的错误级别有这几种：E_ALL, E_ERROR, E_WARNING, E_NOTICE, E_STRICT, E_DEPRECATED。下面是对这几种错误级别的介绍。\",\"E_ERROR：致命错误，会导致脚本终止运行\",\"E_WARNING：运行时警告 (非致命错误)。仅给出提示信息，但是脚本不会终止运行\",\"E_NOTICE：运行时通知。表示脚本遇到可能会表现为错误的情况，但是在可以正常运行的脚本里面也可能会有类似的通知。\",\"E_STRICT：启用 PHP 对代码的修改建议，以确保代码具有最佳的互操作性和向前兼容性。\",\"E_DEPRECATED：运行时通知。启用后将会对在未来版本中可能无法正常工作的代码给出警告。（可忽略）\",\"E_ALL：E_STRICT 除外的所有错误和警告信息。\",\"同时用户也可以设置自身的错误级别，主要通过 trigger_error() 函数实现。用户级别的错误有：E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE, E_USER_DEPRECATED。\",\"上面的错误级别可以参考PHP官方文档：http://php.net/manual/zh/errorfunc.constants.php\",\"有的时候PHP本身对错误的处理难以满足我们的业务需求，这个时候我们可以自定义一个错误处理方法来接管PHP本身的错误处理方式。我们可以通过set_error_handler(callable $error_handler [, int $error_types = E_ALL | E_STRICT ]) 函数来注册这个方法。需要注意的是要记住 error_types 里指定的错误类型都会绕过 PHP 标准错误处理程序， 除非回调函数返回了 FALSE。 error_reporting() 设置将不会起到作用而你的错误处理函数继续会被调用 —— 不过你仍然可以获取 error_reporting 的当前值，并做适当处理。 需要特别注意的是带 @ error-control operator 前缀的语句发生错误时，这个值会是 0。 以下级别的错误不能由用户定义的函数来处理： E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，和在 调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT。可在 register_shutdown_function() 中处理( 但脚本仍会结束 )\",\"error_get_last()获取最后发生的错误，返回了一个关联数组，描述了最后错误的信息，以该错误的 “type”、 “message”、”file” 和 “line” 为数组的键。 如果该错误由 PHP 内置函数导致的，”message”会以该函数名开头。 如果还没有错误则返回 NULL。\",\"Array ( [type] => 8 [message] => Undefined variable: a [file] => C:\\\\WWW\\\\index.php [line] => 2 ) \",\"一般在做错误处理的时候这个函数会被register_shutdown_function()注册到脚本运行结束前。\",\"具体使用方法可以参考PHP官方手册：http://php.net/manual/zh/function.set-error-handler.php\",\"异常处理 在PHP中采用 try...catch 模式来处理异常，使用 throw关键字抛出异常。PHP的异常处理基类是 Exception，所有的异常处理类都继承它。官方手册地址：http://php.net/manual/zh/class.exception.php\",\"同时PHP也提供了 ErrorException 错误异常处理类，可以使用set_error_handler()函数将错误信息托管至ErrorException：\",\"<?php function exception_error_handler($errno, $errstr, $errfile, $errline ) { throw new ErrorException($errstr, 0, $errno, $errfile, $errline); } set_error_handler(\\\"exception_error_handler\\\"); /* Trigger exception */ strpos(); ?> \",\"具体可参考PHP官方手册：http://php.net/manual/zh/class.errorexception.php\",\"除了上述两个标准异常之外，SPL提供了一系列标准异常。具体可参考：http://php.net/manual/zh/spl.exceptions.php\",\"PHP官方提供了 set_exception_handler() 函数来帮助开发者自定义异常处理行为。手册地址：http://php.net/manual/zh/function.set-exception-handler.php\",\"错误和异常统一处理 一般在框架中都会封装一套属于框架自身的错误和异常处理模块，通常错误会被转化为异常进行统一处理。以下是简单的实现思路\",\"<?php class handleExceptions { public function init() { // 致命错误和语法错误 error_reporting(E_ERROR | E_USER_ERROR | E_PARSE | E_COMPILE_ERROR); set_error_handler([$this, 'errorHandler']); set_exception_handler([$this, 'exceptionHandler']); // 获取最后一次错误 register_shutdown_function([$this, 'handlerShutdown']); } public function errorHandler($level, $message, $file = '', $line = 0, $context = array()) { // 判断错误级别是否是设置的 if (error_reporting() & $level) { throw new \\\\ErrorException($message, 0, $level, $file, $line); } } public function exceptionHandler(Exception $e) { // 所有的错误和异常都在这里进行处理,一般处理错误的时候需要进行以下几点 // 1、根据错误级别记录错误日志，有利于后期排查 // 2、根据当前业务场景做出相应的动作，比如在开发模式下，就把错误全面的展现出来，如果是生产模式下就要进行优雅的错误处理。 } public function handlerShutdown() { $error = error_get_last(); if ( ! is_null($error) && $this->isFatal($error['type'])) { $this->exceptionHandler($this->fatalExceptionFromError($error, 0)); } } protected function fatalExceptionFromError(array $error, $traceOffset = null) { return new \\\\ErrorException( $error['message'], 0, $error['type'], $error['file'], $error['line'] ); } protected function isFatal($type) { $a = in_array($type, [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE]); return $a; } } \",\"上面的例子中，我们自定义了一个处理类，这个类只对致命性错误和语法错误进行防范处理，其他的错误进行了忽略。（可重写errorHandler方法，让其对其他级别的错误进行处理）handleExceptions::exceptionHandler()方法让错误和异常都在这里进行处理。 一般处理错误的时候需要进行：\",\"1、根据错误级别记录错误日志，有利于后期排查\",\"2、根据当前业务场景做出相应的动作，比如在开发模式下，就把错误全面的展现出来，如果是生产模式下就要进行优雅的错误处理。（比如错误页面啊，Ajax模式下错误响应，错误恢复脚本继续执行等等）\",\"在PHP7以上，E_ERROR的错误可以交由set_exception_handler，即自定义异常来捕获。具体参考：http://php.net/manual/en/class.error.php 和 http://php.net/manual/en/class.throwable.php 及 http://php.net/manual/zh/function.set-exception-handler.php\"]},\"64\":{\"h\":\"会话管理，跨域，单点登录\"},\"65\":{\"h\":\"会话管理\",\"t\":[\"在web开发中，总是会用到会话管理。所谓会话管理指的是因为HTTP协议是无状态的一种协议，为了识别当前用户而创建的一种技术手段。会话管理主要有两个部分组成，客户端和服务器端。一般客户端指的是COOKIE，服务器端指的是SESSION。\",\"Session和cookie的关系。会话是由客户端发起请求，服务器端响应。比如用户登录，用户发起登录请求，服务器校验请求是否正确，正确的话就在服务器端生成一个唯一sessionID，然后通过HTTP协议把这个sessionID放到cookie里返回给客户端，客户端收到cookie后会在每次请求的时候带上cookie。格式如下：\",\"Cookie: PHPSESSID=q0fm8up72q58ne1b6khf37dlos\",\"PHP提供了很简单两个全局变量来操作cookie和session，分别是 $_COOKIE 和 $_SESSION，开发者不需要考虑sessionID的问题。PHP默认会把session存储在服务器的临时目录中，并在每次运行时进行GC操作。你可以通过配置 php.ini 文件改变它。同时你也可以通过自定义会话管理器来管理会话。自定义会话管理可以实现共享session。下面是利用 Redis 来实现 session 的存储的例子。\",\" class sysSession implements SessionHandlerInterface { private $client; private $exprie; public function __construct($client) { $this->client = $client; } public function setExprie($exprie) { $this->exprie = $exprie; } public function open($savePath, $sessionName) { return true; } public function close() { return true; } public function read($id) { return $this->client->get($id); } public function write($id, $data) { return $this->client->setsetEx($id, $this->exprie, $data); } public function destroy($id) { return $this->client->delete($id); } public function gc($lifetime) { return true; } } \",\"使用示例：\",\" $redis = new Redis; $redis->open(\\\"ip\\\", \\\"port\\\", \\\"timeout\\\"); $handler = new sysSession($redis); $handler->setExprie(3600); session_set_save_handler($handler, true); register_shutdown_function('session_write_close'); session_start(); \",\"你可以把session存储到一个公共的服务器或集群中，这样就可以实现共享session了\",\"关于session相关知识可以阅读PHP官方手册：http://php.net/manual/zh/session.examples.php 会话安全方面PHP官方手册进行了说明，地址：http://php.net/manual/zh/session.security.php 和 http://php.net/manual/zh/features.session.security.management.php\"]},\"66\":{\"h\":\"会话跨域和单点登录\",\"t\":[\"有的时候我们一个网站有很多服务模块，每个模块都有一个域名，这个时候我们想实现多个域名之间的会话管理，那应该怎么办呢？首先我们要知道跨域，浏览器有一种同源策略。比如： a.domin.com 不能访问 b.explame.com 下的cookie，因为他们不同源，如果是这两个域名 a.domain.com 和 b.domain.com 呢？这两个是同源域名，都属于 domain.com，看下列代码：\",\"<?php setcookie(\\\"TestCookie\\\", \\\"\\\", time() - 3600, \\\"/\\\", \\\"domain.com\\\", false, true); \",\"在PHP中通过上述代码就可以让a.domain.com 和 b.domain.com进行cookie之间的相互传递，然后在每次请求的时候把cookie相关信息带上，服务端实现session共享，就可以实现会话的跨域了。这个解决方案是解决了主域名和子域名下的会话管理问题，如果是多个不同的域名呢，应该怎么办？这个时候我们就要考虑到单点登录了\",\"关于单点登录，可以参考这篇文章：https://www.cnblogs.com/ywlaker/p/6113927.html 一般单点登录的使用场景是多系统之间。比如淘宝和天猫。淘宝和天猫是两种不同的系统，域名也不一样，但是你在淘宝上登录之后在天猫上也可以访问自己的个人中心。（所有的一切都是基于统一浏览器上）\",\"同样PHP有个比较好的项目叫做 UCenter，这个产品很好的实现了单点登录，可以自己动手实现下。\"]},\"67\":{\"h\":\"负载均衡\",\"t\":[\"当业务发展到一定程度之后，单台服务器就无法满足业务需求，这个时候就要考虑到使用集群方案。负载均衡是集群方案中的一种策略。负载均衡的主要作用就是根据不同的算法分发请求至服务集群中的某个节点。在PHP web开发中主要使用 Nginx或者 Apache 来做负载均衡执行者。在 Nginx 中主要采用反向代理的方式来实现负载均衡。Nginx默认采用轮询算法。同时还用 IP_hash 算法。Nginx 默认提供这两种算法，同时也支持第三方的算法。下面是这些算法的介绍。\",\"轮询算法(默认)\",\"每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\",\"upstream backserver { server 192.168.0.14; server 192.168.0.15; } \",\"同时也可以指定权重，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\",\"upstream backserver { server 192.168.0.14 weight=10; server 192.168.0.15 weight=10; } \",\"IP绑定 ip_hash\",\"每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\",\"upstream backserver { ip_hash; server 192.168.0.14:88; server 192.168.0.15:80; } \",\"当ip hash失效时，会退化为轮询策略，因此不会有丢失流量的情况。从这个层面上说，ip hash也可以看成是轮询的升级版。\",\"fair（第三方）\",\"按后端服务器的响应时间来分配请求，响应时间短的优先分配。\",\"upstream backserver { server server1; server server2; fair; } \",\"url_hash（第三方）\",\"按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\",\"upstream backserver { server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32; } \",\"关于Nginx负责均衡算法策略的选择，要根据业务场景来选择,一般选择的标准可以参考这三个指标：\",\"均衡性：是否能够将请求均匀的发送给后端\",\"一致性：同一个key的请求，是否能落到同一台机器\",\"容灾性：当部分后端机器挂掉时，是否能够正常工作 可以参考这篇文章：https://www.cnblogs.com/wpjamer/articles/6443332.html\",\"负载均衡相关知识可参考：https://blog.csdn.net/qq_27093465/article/details/78273656 关于Nginx轮询算法的解释可以看这篇文章：https://blog.csdn.net/itkingone/article/details/80365212\"]},\"68\":{\"h\":\"秒杀活动和超卖\",\"t\":[\"一般做程序开发都会遇到这种业务需求：秒杀活动。比如双十一的商品秒杀，某游戏的内测号等等。一般面试的时候问这个问题主要是考察候选人的综合能力。\"]},\"69\":{\"h\":\"秒杀设计\",\"t\":[\"首先考虑秒杀的场景，秒杀是指在指定时间范围内有限库存限制下的售卖行为。在时间范围内，随着请求的增加怎么保持服务的快速响应，怎么限制用户的下单行为，商品库存的增减等等都是要考虑的。我们一一分析下。\",\"高并发下的秒杀活动页面快速响应\",\"从前端来讲可以这样搞：\",\"页面静态化：像秒杀活动页面一般都是访问比较高的，商品信息和库存都是固定的。所以把页面进行静态化处理是一种很好的方法，同时可以使用JS异步请求服务端，做一些简单的逻辑处理。比如倒计时、购买按钮禁止，库存修改、禁止重复提交和无限刷新等。\",\"CDN加速：静态资源可以使用CDN加速。\",\"用户限流：在某一时间段内只允许用户提交一次请求，比如可以采取IP限流\",\"后端的角度可以这样搞：\",\"-在前端和后端服务之间增加一个中间层。一般这个中间层就是我们上文提到的负载均衡，通过负载均衡把请求分发到不同的节点。\",\"-限制同一UserID访问频率：尽量拦截浏览器请求，在服务端控制层需要针对同一个访问uid，限制访问频率。\",\"-业务分离:将秒杀业务系统和其他业务分离，单独放在专门用来做秒杀活动的服务器集群上。\",\"-采用消息队列缓存请求：将大流量请求写到消息队列缓存，利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求\",\"-利用缓存应对读请求：对于读多写少业务，大部分请求是查询请求，所以可以读写分离，利用缓存分担数据库压力\",\"-利用缓存应对写请求：缓存也是可以应对写请求的，可把数据库中的库存数据转移到Redis缓存中，所有减库存操作都在Redis中进行，然后再通过后台进程把Redis中的用户秒杀请求同步到数据库中。\",\"-随机选取用户执行秒杀逻辑，没有选取到的用户返回秒杀失败\",\"我们在创建秒杀活动的时候就要把商品相关信息写入到缓存中，比如商品实际库存、秒杀限制库存，商品相关信息等。\",\"我们可以采用Redis 最简单的key-value数据结构，用一个原子类型的变量值(AtomicInteger)作为key，把用户id作为value，库存数量便是原子变量的最大值。对于每个用户的秒杀，我们使用 RPUSH key value插入秒杀请求， 当插入的秒杀请求数达到上限时，停止所有后续插入。下面是简单样例：\",\"// 假设商品库存有10个,key键名为 goods.store $nums = $redis->get('goods.store'); if($nums<=0){ return false; } if ($redis->decr('goods.store')<0){ return false; } $redis->rpush('sale:1', 'uid') \",\"上面的示例中，我们定义了几个key，分别是：goods.store(商品库存)、sale:1(秒杀队列的key)，开始的时候我们判断商品库存是否小于等于0，成立的话就说明秒杀失败，不成立的话就对商品库存进行 decr 操作并判断是否小于0，成立说明秒杀失败，不成立的话就把秒杀用户ID加入到秒杀队列中，然后去消费秒杀队列，用户在对订单付完款之后减商品数据库库存，然后把用户ID加入到秒杀购买成功队列,如果订单在一定时间内不付款就把此订单状态改为失败然后redis里的 goods.store进行 incr 操作。\"]},\"70\":{\"h\":\"超卖问题\",\"t\":[\"关于超卖问题，一般都是在并发下，对库存的判断出现了问题，上个例子中已经采用了原子操作，可以极大可能的避免超卖，但是会导致少卖，同时也可以使用redis的乐观锁和事务实现：\",\"$redis->watch(key) if(redis->get(key) < 0){ echo '抢购失败';return false; } $redis->multi(); $redis->decr(key); $redis->rpush(); $redis-exec(); \"]},\"71\":{\"c\":[\"golang\"]},\"72\":{\"c\":[\"php\",\"面试\",\"面试总结\",\"php面试总结\"]},\"73\":{\"h\":\"Golang\"},\"74\":{\"h\":\"Mark\"},\"75\":{\"h\":\"Php\"}},\"dirtCount\":0,\"index\":[[\"抢购失败\",{\"1\":{\"70\":1}}],[\"超卖问题\",{\"0\":{\"70\":1}}],[\"成立说明秒杀失败\",{\"1\":{\"69\":1}}],[\"成立的话就说明秒杀失败\",{\"1\":{\"69\":1}}],[\"停止所有后续插入\",{\"1\":{\"69\":1}}],[\"库存数量便是原子变量的最大值\",{\"1\":{\"69\":1}}],[\"库存修改\",{\"1\":{\"69\":1}}],[\"把用户id作为value\",{\"1\":{\"69\":1}}],[\"作为key\",{\"1\":{\"69\":1}}],[\"最简单的key\",{\"1\":{\"69\":1}}],[\"最大连接数\",{\"1\":{\"56\":1}}],[\"最大扩展到capacity的长度\",{\"1\":{\"38\":1}}],[\"随机选取用户执行秒杀逻辑\",{\"1\":{\"69\":1}}],[\"随着请求的增加怎么保持服务的快速响应\",{\"1\":{\"69\":1}}],[\"缓存也是可以应对写请求的\",{\"1\":{\"69\":1}}],[\"利用缓存应对写请求\",{\"1\":{\"69\":1}}],[\"利用缓存应对读请求\",{\"1\":{\"69\":1}}],[\"利用缓存分担数据库压力\",{\"1\":{\"69\":1}}],[\"利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求\",{\"1\":{\"69\":1}}],[\"采用消息队列缓存请求\",{\"1\":{\"69\":1}}],[\"将大流量请求写到消息队列缓存\",{\"1\":{\"69\":1}}],[\"将秒杀业务系统和其他业务分离\",{\"1\":{\"69\":1}}],[\"将延时器放到for循环之外定义\",{\"1\":{\"8\":1}}],[\"业务分离\",{\"1\":{\"69\":1}}],[\"限制访问频率\",{\"1\":{\"69\":1}}],[\"限制同一userid访问频率\",{\"1\":{\"69\":1}}],[\"后端的角度可以这样搞\",{\"1\":{\"69\":1}}],[\"后端服务器为缓存时比较有效\",{\"1\":{\"67\":1}}],[\"静态资源可以使用cdn加速\",{\"1\":{\"69\":1}}],[\"禁止重复提交和无限刷新等\",{\"1\":{\"69\":1}}],[\"购买按钮禁止\",{\"1\":{\"69\":1}}],[\"做一些简单的逻辑处理\",{\"1\":{\"69\":1}}],[\"商品库存\",{\"1\":{\"69\":1}}],[\"商品库存的增减等等都是要考虑的\",{\"1\":{\"69\":1}}],[\"商品相关信息等\",{\"1\":{\"69\":1}}],[\"商品信息和库存都是固定的\",{\"1\":{\"69\":1}}],[\"像秒杀活动页面一般都是访问比较高的\",{\"1\":{\"69\":1}}],[\"页面静态化\",{\"1\":{\"69\":1}}],[\"高并发下的秒杀活动页面快速响应\",{\"1\":{\"69\":1}}],[\"怎么限制用户的下单行为\",{\"1\":{\"69\":1}}],[\"怎么保证线程安全的原生map\",{\"1\":{\"27\":1}}],[\"秒杀队列的key\",{\"1\":{\"69\":1}}],[\"秒杀限制库存\",{\"1\":{\"69\":1}}],[\"秒杀是指在指定时间范围内有限库存限制下的售卖行为\",{\"1\":{\"69\":1}}],[\"秒杀设计\",{\"0\":{\"69\":1}}],[\"秒杀活动\",{\"1\":{\"68\":1}}],[\"秒杀活动和超卖\",{\"0\":{\"68\":1}}],[\"qq\",{\"1\":{\"67\":1}}],[\"queries\",{\"1\":{\"43\":1}}],[\"query\",{\"1\":{\"43\":1,\"55\":2,\"56\":2}}],[\"容灾性\",{\"1\":{\"67\":1}}],[\"容量为3\",{\"1\":{\"38\":1}}],[\"容量超过\",{\"1\":{\"38\":1}}],[\"容量变成原来的1\",{\"1\":{\"38\":1}}],[\"容量变成原来的\",{\"1\":{\"38\":1}}],[\"容量小于\",{\"1\":{\"38\":1}}],[\"容量的\",{\"1\":{\"38\":1}}],[\"容量满之前不会阻塞\",{\"1\":{\"3\":1}}],[\"均衡性\",{\"1\":{\"67\":1}}],[\"按访问url的hash结果来分配请求\",{\"1\":{\"67\":1}}],[\"按后端服务器的响应时间来分配请求\",{\"1\":{\"67\":1}}],[\"响应时间短的优先分配\",{\"1\":{\"67\":1}}],[\"指定轮询几率\",{\"1\":{\"67\":1}}],[\"指针不会被重新分配\",{\"1\":{\"38\":2}}],[\"指针类型的实例的method\",{\"1\":{\"21\":1}}],[\"指针类型的实例是另一个method\",{\"1\":{\"21\":1}}],[\"指针\",{\"1\":{\"16\":1}}],[\"能自动剔除\",{\"1\":{\"67\":1}}],[\"默认\",{\"1\":{\"67\":1}}],[\"默认提供这两种算法\",{\"1\":{\"67\":1}}],[\"轮询算法\",{\"1\":{\"67\":1}}],[\"算法\",{\"1\":{\"67\":1}}],[\"负载均衡相关知识可参考\",{\"1\":{\"67\":1}}],[\"负载均衡的主要作用就是根据不同的算法分发请求至服务集群中的某个节点\",{\"1\":{\"67\":1}}],[\"负载均衡是集群方案中的一种策略\",{\"1\":{\"67\":1}}],[\"负载均衡\",{\"0\":{\"67\":1}}],[\"域名也不一样\",{\"1\":{\"66\":1}}],[\"淘宝和天猫是两种不同的系统\",{\"1\":{\"66\":1}}],[\"ywlaker\",{\"1\":{\"66\":1}}],[\"yes\",{\"1\":{\"19\":1}}],[\"应该怎么办\",{\"1\":{\"66\":1}}],[\"应该也使用defalut语句块\",{\"1\":{\"7\":1}}],[\"呢\",{\"1\":{\"66\":1}}],[\"浏览器有一种同源策略\",{\"1\":{\"66\":1}}],[\"地址\",{\"1\":{\"65\":1}}],[\"来做负载均衡执行者\",{\"1\":{\"67\":1}}],[\"来实现\",{\"1\":{\"65\":1}}],[\"来关闭channel\",{\"1\":{\"2\":1}}],[\"自定义会话管理可以实现共享session\",{\"1\":{\"65\":1}}],[\"文件改变它\",{\"1\":{\"65\":1}}],[\"你可以把session存储到一个公共的服务器或集群中\",{\"1\":{\"65\":1}}],[\"你可以通过配置\",{\"1\":{\"65\":1}}],[\"你怎么来保证这个map是线程安全的呢\",{\"1\":{\"27\":1}}],[\"格式如下\",{\"1\":{\"65\":1}}],[\"客户端收到cookie后会在每次请求的时候带上cookie\",{\"1\":{\"65\":1}}],[\"客户端和服务器端\",{\"1\":{\"65\":1}}],[\"正确的话就在服务器端生成一个唯一sessionid\",{\"1\":{\"65\":1}}],[\"正常的程序中都无法使用这个tag属性\",{\"1\":{\"17\":1}}],[\"总是会用到会话管理\",{\"1\":{\"65\":1}}],[\"总结下来就是\",{\"1\":{\"32\":1}}],[\"跨域\",{\"0\":{\"64\":1}}],[\"及\",{\"1\":{\"63\":1}}],[\"让其对其他级别的错误进行处理\",{\"1\":{\"63\":1}}],[\"判断错误级别是否是设置的\",{\"1\":{\"63\":1}}],[\">multi\",{\"1\":{\"70\":1}}],[\">watch\",{\"1\":{\"70\":1}}],[\">rpush\",{\"1\":{\"69\":1,\"70\":1}}],[\">decr\",{\"1\":{\"69\":1,\"70\":1}}],[\">delete\",{\"1\":{\"65\":1}}],[\">setexprie\",{\"1\":{\"65\":1}}],[\">setsetex\",{\"1\":{\"65\":1}}],[\">open\",{\"1\":{\"65\":1}}],[\">get\",{\"1\":{\"65\":1,\"69\":1,\"70\":1}}],[\">exprie\",{\"1\":{\"65\":2}}],[\">exceptionhandler\",{\"1\":{\"63\":1}}],[\">client\",{\"1\":{\"65\":4}}],[\">fatalexceptionfromerror\",{\"1\":{\"63\":1}}],[\">isfatal\",{\"1\":{\"63\":1}}],[\">\",{\"1\":{\"63\":1}}],[\"错误恢复脚本继续执行等等\",{\"1\":{\"63\":1}}],[\"错误和异常统一处理\",{\"1\":{\"63\":1}}],[\"错误异常处理类\",{\"1\":{\"63\":1}}],[\"错误处理\",{\"0\":{\"63\":1}}],[\"官方手册地址\",{\"1\":{\"63\":1}}],[\"模式来处理异常\",{\"1\":{\"63\":1}}],[\"异常处理\",{\"1\":{\"63\":1}}],[\"异步模式\",{\"1\":{\"3\":1}}],[\"80365212\",{\"1\":{\"67\":1}}],[\"80\",{\"1\":{\"67\":1}}],[\"8080\",{\"1\":{\"12\":1}}],[\"88\",{\"1\":{\"67\":1}}],[\"8\",{\"1\":{\"63\":1}}],[\"内置函数导致的\",{\"1\":{\"63\":1}}],[\"描述了最后错误的信息\",{\"1\":{\"63\":1}}],[\"返回了一个关联数组\",{\"1\":{\"63\":1}}],[\"设置将不会起到作用而你的错误处理函数继续会被调用\",{\"1\":{\"63\":1}}],[\"设计表的时候选择合适的数据类型\",{\"1\":{\"43\":1}}],[\"标准错误处理程序\",{\"1\":{\"63\":1}}],[\"里指定的错误类型都会绕过\",{\"1\":{\"63\":1}}],[\"里面的属性一个是互斥锁\",{\"1\":{\"33\":1}}],[\"里面放一些case语句块\",{\"1\":{\"7\":1}}],[\"|\",{\"1\":{\"63\":4}}],[\"$nums<=0\",{\"1\":{\"69\":1}}],[\"$nums\",{\"1\":{\"69\":1}}],[\"$request\",{\"1\":{\"67\":1}}],[\"$redis\",{\"1\":{\"65\":3,\"69\":3,\"70\":5}}],[\"$handler\",{\"1\":{\"65\":3}}],[\"$data\",{\"1\":{\"65\":2}}],[\"$id\",{\"1\":{\"65\":6}}],[\"$sessionname\",{\"1\":{\"65\":1}}],[\"$server\",{\"1\":{\"61\":1}}],[\"$savepath\",{\"1\":{\"65\":1}}],[\"$client\",{\"1\":{\"65\":3}}],[\"$context\",{\"1\":{\"63\":1}}],[\"$\",{\"1\":{\"65\":2}}],[\"$a\",{\"1\":{\"63\":2}}],[\"$type\",{\"1\":{\"63\":2}}],[\"$traceoffset\",{\"1\":{\"63\":1}}],[\"$this\",{\"1\":{\"63\":6,\"65\":6}}],[\"$exprie\",{\"1\":{\"65\":3}}],[\"$e\",{\"1\":{\"63\":1}}],[\"$errline\",{\"1\":{\"63\":2}}],[\"$errfile\",{\"1\":{\"63\":2}}],[\"$errstr\",{\"1\":{\"63\":2}}],[\"$errno\",{\"1\":{\"63\":2}}],[\"$error\",{\"1\":{\"63\":11}}],[\"$lifetime\",{\"1\":{\"65\":1}}],[\"$line\",{\"1\":{\"63\":2}}],[\"$level\",{\"1\":{\"63\":3}}],[\"$file\",{\"1\":{\"63\":2}}],[\"$message\",{\"1\":{\"63\":2}}],[\"zh\",{\"1\":{\"63\":7,\"65\":3}}],[\"zero\",{\"1\":{\"32\":1}}],[\"以下是简单的实现思路\",{\"1\":{\"63\":1}}],[\"以下级别的错误不能由用户定义的函数来处理\",{\"1\":{\"63\":1}}],[\"以该错误的\",{\"1\":{\"63\":1}}],[\"以确保代码具有最佳的互操作性和向前兼容性\",{\"1\":{\"63\":1}}],[\"以二进制的方式向服务端发送参数和句柄\",{\"1\":{\"55\":1}}],[\"启用后将会对在未来版本中可能无法正常工作的代码给出警告\",{\"1\":{\"63\":1}}],[\"启用\",{\"1\":{\"63\":1}}],[\"仅给出提示信息\",{\"1\":{\"63\":1}}],[\"仅针对读的性能来说\",{\"1\":{\"34\":1}}],[\"非致命错误\",{\"1\":{\"63\":1}}],[\"非阻塞\",{\"1\":{\"3\":1}}],[\"运行时通知\",{\"1\":{\"63\":2}}],[\"运行时警告\",{\"1\":{\"63\":1}}],[\"运行程序正常输出\",{\"1\":{\"27\":1}}],[\"致命错误和语法错误\",{\"1\":{\"63\":1}}],[\"致命错误\",{\"1\":{\"63\":1}}],[\"答案是可以的\",{\"1\":{\"61\":1}}],[\"答案是有的\",{\"1\":{\"27\":1}}],[\"通常错误会被转化为异常进行统一处理\",{\"1\":{\"63\":1}}],[\"通常我们在web模式下都会有个入口文件\",{\"1\":{\"61\":1}}],[\"通过负载均衡把请求分发到不同的节点\",{\"1\":{\"69\":1}}],[\"通过索引访问数据\",{\"1\":{\"50\":1}}],[\"通过空接口类型\",{\"1\":{\"22\":1}}],[\"通过下面的示例对map进行声明和创建\",{\"1\":{\"16\":1}}],[\"嗯\",{\"1\":{\"60\":1}}],[\"今天面试主要和面试官讨论这些问题\",{\"1\":{\"60\":1}}],[\"手册地址\",{\"1\":{\"57\":1,\"63\":1}}],[\"属性\",{\"1\":{\"57\":1}}],[\"属于内存级别的通信\",{\"1\":{\"1\":1}}],[\"搞清楚文档\",{\"1\":{\"57\":1}}],[\"配置好之后\",{\"1\":{\"57\":1}}],[\"配置优化\",{\"0\":{\"56\":1}}],[\"命令\",{\"1\":{\"57\":1}}],[\"查看binlog日志的名字\",{\"1\":{\"57\":1}}],[\"查询优化相关\",{\"0\":{\"51\":1}}],[\"查询中的条件的列不能是一个表达式或函数的参数\",{\"1\":{\"47\":1}}],[\"查询sql数据表关联不要过多\",{\"1\":{\"43\":1}}],[\"查询数\",{\"1\":{\"43\":1}}],[\"查询线程数\",{\"1\":{\"43\":1}}],[\"参考文章\",{\"1\":{\"57\":1}}],[\"78273656\",{\"1\":{\"67\":1}}],[\"7080278\",{\"1\":{\"57\":1}}],[\"7之前默认是基于语句\",{\"1\":{\"57\":1}}],[\"7\",{\"1\":{\"57\":1}}],[\"消耗资源多\",{\"1\":{\"57\":1}}],[\"顾名思义就是一行一行复制\",{\"1\":{\"57\":1}}],[\"基于行的复制\",{\"1\":{\"57\":1}}],[\"基于行\",{\"1\":{\"57\":1}}],[\"基于语句消耗资源少\",{\"1\":{\"57\":1}}],[\"基于语句\",{\"1\":{\"57\":1}}],[\"基本配置\",{\"1\":{\"56\":1}}],[\"备库\",{\"1\":{\"57\":1}}],[\"二进制日志\",{\"1\":{\"57\":1}}],[\"二级索引访问需要两次查找\",{\"1\":{\"49\":1}}],[\"复制慢\",{\"1\":{\"57\":1}}],[\"复制模式\",{\"1\":{\"57\":1}}],[\"复制\",{\"0\":{\"57\":1}}],[\"慢查询衡量标准\",{\"1\":{\"56\":1}}],[\"慢查询是否开启\",{\"1\":{\"56\":1}}],[\"慢查询日志\",{\"1\":{\"43\":1}}],[\"日志文件大小\",{\"1\":{\"56\":1}}],[\"单独放在专门用来做秒杀活动的服务器集群上\",{\"1\":{\"69\":1}}],[\"单台服务器就无法满足业务需求\",{\"1\":{\"67\":1}}],[\"单点登录\",{\"0\":{\"64\":1}}],[\"单位秒\",{\"1\":{\"56\":1}}],[\"单位字节\",{\"1\":{\"55\":1}}],[\"单列\",{\"1\":{\"50\":1}}],[\"服务端实现session共享\",{\"1\":{\"66\":1}}],[\"服务器校验请求是否正确\",{\"1\":{\"65\":1}}],[\"服务器端响应\",{\"1\":{\"65\":1}}],[\"服务器端指的是session\",{\"1\":{\"65\":1}}],[\"服务器模式\",{\"1\":{\"56\":1}}],[\"服务器也只对器进行一次解析\",{\"1\":{\"55\":1}}],[\"服务的具体执行者就是我们的gin框架\",{\"1\":{\"12\":1}}],[\"节约内存和网络开销\",{\"1\":{\"55\":1}}],[\"绑定变量\",{\"0\":{\"55\":1}}],[\"之后基于行\",{\"1\":{\"57\":1}}],[\"之前的版本只有myisam支持\",{\"1\":{\"54\":1}}],[\"之间的代码段称为资源的临界区\",{\"1\":{\"32\":1}}],[\"之间没有引用关系了\",{\"1\":{\"8\":1}}],[\"全文索引\",{\"1\":{\"54\":1}}],[\"视图\",{\"0\":{\"54\":1}}],[\"选择的列最好有索引\",{\"1\":{\"53\":1}}],[\"选择合适的索引顺序至关重要\",{\"1\":{\"49\":1}}],[\"简单了解下\",{\"1\":{\"53\":1}}],[\"简单的查询可以减少锁的竞争\",{\"1\":{\"51\":1}}],[\"6113927\",{\"1\":{\"66\":1}}],[\"6版本innodb开始支持全文索引\",{\"1\":{\"54\":1}}],[\"63254901\",{\"1\":{\"54\":1}}],[\"6及以上可以放心大胆的去用子查询\",{\"1\":{\"51\":1}}],[\"6443332\",{\"1\":{\"67\":1}}],[\"64\",{\"1\":{\"12\":1}}],[\"合理使用子查询\",{\"1\":{\"51\":1}}],[\"子查询尽量少用\",{\"1\":{\"51\":1}}],[\"易缓存\",{\"1\":{\"51\":1}}],[\"分区列不能在表达式中\",{\"1\":{\"53\":1}}],[\"分区列和索引列匹配\",{\"1\":{\"53\":1}}],[\"分区的维护成本比较高\",{\"1\":{\"53\":1}}],[\"分区的时候最好不要选择默认为null的列\",{\"1\":{\"53\":1}}],[\"分区在查询的时候需要锁住所有的底层表\",{\"1\":{\"53\":1}}],[\"分区\",{\"0\":{\"53\":1},\"1\":{\"53\":1}}],[\"分解关联查询\",{\"1\":{\"51\":1}}],[\"分别是\",{\"1\":{\"65\":1,\"69\":1}}],[\"分别是未提交读\",{\"1\":{\"42\":1}}],[\"分别是add\",{\"1\":{\"27\":1}}],[\"拆分复杂的查询\",{\"1\":{\"51\":1}}],[\"减少了sql注入和攻击\",{\"1\":{\"55\":1}}],[\"减少冗余记录查询\",{\"1\":{\"51\":1}}],[\"减少查询时扫描的行数\",{\"1\":{\"51\":1}}],[\"减少不必要列的查询\",{\"1\":{\"51\":1}}],[\"建立合适的索引\",{\"1\":{\"51\":1}}],[\"建议指定确切路径和文件名\",{\"1\":{\"57\":1}}],[\"建议使用单调顺序自增类型\",{\"1\":{\"49\":1}}],[\"建议使用指针作为参数值进行传递\",{\"1\":{\"17\":1}}],[\"建议条件允许的情况下加上defer\",{\"1\":{\"2\":1}}],[\"速度慢的原因\",{\"1\":{\"50\":1}}],[\"唯一索引\",{\"1\":{\"50\":1}}],[\"唯一索引无效\",{\"1\":{\"46\":1}}],[\"聚簇索引是一种数据存储方式\",{\"1\":{\"49\":1}}],[\"计算的结果中值越接近1的就越往前\",{\"1\":{\"49\":1}}],[\"列\",{\"1\":{\"49\":1}}],[\"列不要太多\",{\"1\":{\"43\":1}}],[\"多列索引及前缀索引\",{\"1\":{\"50\":1}}],[\"多列索引\",{\"0\":{\"49\":1}}],[\"多协程操作时需要注意\",{\"1\":{\"16\":1}}],[\"字符串列名为\",{\"1\":{\"48\":1}}],[\"字面量声明\",{\"1\":{\"38\":1}}],[\"假设商品库存有10个\",{\"1\":{\"69\":1}}],[\"假设表名为testcity\",{\"1\":{\"48\":1}}],[\"假如外部struct中的字段名和内部struct的字段名相同\",{\"1\":{\"17\":1}}],[\"前缀的语句发生错误时\",{\"1\":{\"63\":1}}],[\"前缀索引更小\",{\"1\":{\"48\":1}}],[\"前缀索引主要是对字符串类型的列取公共前缀进行索引\",{\"1\":{\"48\":1}}],[\"前缀索引\",{\"0\":{\"48\":1}}],[\"前面说了\",{\"1\":{\"18\":1}}],[\"前面都是在for无限循环中读取channel中的数据\",{\"1\":{\"6\":1}}],[\"避免排序和临时表\",{\"1\":{\"47\":1}}],[\"避免使用字符串类型\",{\"1\":{\"43\":1}}],[\"右边的用不到\",{\"1\":{\"47\":1}}],[\"索引和值分离\",{\"1\":{\"50\":1}}],[\"索引可以将随机i\",{\"1\":{\"47\":1}}],[\"索引可以减少服务器扫描的数据量\",{\"1\":{\"47\":1}}],[\"索引中列的顺序不同效果也不一样\",{\"1\":{\"47\":1}}],[\"索引中的列不能被跳过\",{\"1\":{\"47\":1}}],[\"索引总是遵循最左前缀\",{\"1\":{\"47\":1}}],[\"索引相关\",{\"0\":{\"47\":1}}],[\"开发者不需要考虑sessionid的问题\",{\"1\":{\"65\":1}}],[\"开始的时候我们判断商品库存是否小于等于0\",{\"1\":{\"69\":1}}],[\"开始执行命令start\",{\"1\":{\"57\":1}}],[\"开始了新一轮的攻势\",{\"1\":{\"31\":1}}],[\"开启索引\",{\"0\":{\"46\":1}}],[\"相关参考文章\",{\"1\":{\"57\":1}}],[\"相关参数\",{\"1\":{\"55\":1,\"57\":1}}],[\"相关知识点\",{\"1\":{\"57\":1}}],[\"相关操作如下\",{\"1\":{\"44\":1}}],[\"相对安全\",{\"1\":{\"55\":1}}],[\"相当于是当前调用了\",{\"1\":{\"33\":1}}],[\"等待数据载入之后开启索引\",{\"1\":{\"44\":1}}],[\"等价于\",{\"1\":{\"18\":2}}],[\"慎用\",{\"1\":{\"44\":1}}],[\"根据当前业务场景做出相应的动作\",{\"1\":{\"63\":2}}],[\"根据错误级别记录错误日志\",{\"1\":{\"63\":2}}],[\"根据实际业务创建相关汇总表和缓存表\",{\"1\":{\"43\":1}}],[\"根据上述的结论\",{\"1\":{\"32\":1}}],[\"主索引和增量索引都要定时维护\",{\"1\":{\"57\":1}}],[\"主从复制开启步骤\",{\"1\":{\"57\":1}}],[\"主库配置二进制文件地址\",{\"1\":{\"57\":1}}],[\"主库从库配置server\",{\"1\":{\"57\":1}}],[\"主库\",{\"1\":{\"57\":1}}],[\"主键索引\",{\"1\":{\"50\":1}}],[\"主键最好使用整数类型\",{\"1\":{\"43\":1}}],[\"主要通过\",{\"1\":{\"63\":1}}],[\"主要是通过主键来实现\",{\"1\":{\"49\":1}}],[\"主要是实现\",{\"1\":{\"12\":1}}],[\"主要就是考察面试者对锁和channel的知识\",{\"1\":{\"28\":1}}],[\"尽量拦截浏览器请求\",{\"1\":{\"69\":1}}],[\"尽量优化查询\",{\"1\":{\"51\":1}}],[\"尽量使用not\",{\"1\":{\"43\":1}}],[\"尽管一个是数据对象值\",{\"1\":{\"17\":1}}],[\"状态的\",{\"1\":{\"43\":1}}],[\"记录所有的查询\",{\"1\":{\"43\":1}}],[\"记住\",{\"1\":{\"32\":1}}],[\"持久性\",{\"1\":{\"42\":1}}],[\"隔离性\",{\"1\":{\"42\":1}}],[\"支持表级锁\",{\"1\":{\"42\":1}}],[\"支持四个事务隔离级别\",{\"1\":{\"42\":1}}],[\"串行化\",{\"1\":{\"42\":1}}],[\"可把数据库中的库存数据转移到redis缓存中\",{\"1\":{\"69\":1}}],[\"可重写errorhandler方法\",{\"1\":{\"63\":1}}],[\"可重复读\",{\"1\":{\"42\":1}}],[\"可在\",{\"1\":{\"63\":1}}],[\"可忽略\",{\"1\":{\"63\":1}}],[\"可以极大可能的避免超卖\",{\"1\":{\"70\":1}}],[\"可以解决session的问题\",{\"1\":{\"67\":1}}],[\"可以自己动手实现下\",{\"1\":{\"66\":1}}],[\"可以参考这篇文章\",{\"1\":{\"66\":1,\"67\":1}}],[\"可以使用set\",{\"1\":{\"63\":1}}],[\"可以使用表连接代替\",{\"1\":{\"51\":1}}],[\"可以减少资源占用\",{\"1\":{\"51\":1}}],[\"可以通过\",{\"1\":{\"61\":1}}],[\"可以通过show\",{\"1\":{\"57\":1}}],[\"可以通过参数设置\",{\"1\":{\"57\":1}}],[\"可以通过如下语句来计算\",{\"1\":{\"48\":1}}],[\"可以通过不断比较公共前缀出现的次数和总记录的商来取前缀\",{\"1\":{\"48\":1}}],[\"可以通过伪哈希索引的手段来优化查询语句\",{\"1\":{\"47\":1}}],[\"可以通过long\",{\"1\":{\"43\":1}}],[\"可以先关闭索引\",{\"1\":{\"44\":1}}],[\"可以加载读锁\",{\"1\":{\"33\":1}}],[\"可以同时申请多个读锁\",{\"1\":{\"33\":1}}],[\"可以定义一个空接口类型的array\",{\"1\":{\"22\":1}}],[\"可以是任意类型\",{\"1\":{\"17\":1}}],[\"提交读\",{\"1\":{\"42\":1}}],[\"锁级别是行级锁\",{\"1\":{\"42\":1}}],[\"修改拷贝数据不会对原切片有影响\",{\"1\":{\"38\":1}}],[\"变量v是拷贝切片中的数据\",{\"1\":{\"38\":1}}],[\"王五\",{\"1\":{\"38\":2}}],[\"李四\",{\"1\":{\"38\":2}}],[\"张三\",{\"1\":{\"38\":2}}],[\"访问不了int1追加的元素\",{\"1\":{\"38\":1}}],[\"长度为1\",{\"1\":{\"38\":1}}],[\"长度不够时会扩展\",{\"1\":{\"38\":1}}],[\"原子性\",{\"1\":{\"42\":1}}],[\"原\",{\"1\":{\"38\":1}}],[\"原因在于\",{\"1\":{\"8\":1}}],[\"倍\",{\"1\":{\"38\":1}}],[\"大部分请求是查询请求\",{\"1\":{\"69\":1}}],[\"大多数mysql存储引擎都实现了b\",{\"1\":{\"47\":1}}],[\"大于等于老\",{\"1\":{\"38\":1}}],[\"大家可以参考下\",{\"1\":{\"28\":1}}],[\"大家可以对代码进行修改试一试\",{\"1\":{\"28\":1}}],[\"新\",{\"1\":{\"38\":3}}],[\"进行内存对齐之后\",{\"1\":{\"38\":1}}],[\"进行等值比较的数据类型\",{\"1\":{\"16\":1}}],[\"该指针指向该元素\",{\"1\":{\"38\":1}}],[\"下的cookie\",{\"1\":{\"66\":1}}],[\"下标未满足条件\",{\"1\":{\"38\":1}}],[\"下表截取创建\",{\"1\":{\"38\":1}}],[\"下面是简单样例\",{\"1\":{\"69\":1}}],[\"下面是这些算法的介绍\",{\"1\":{\"67\":1}}],[\"下面是利用\",{\"1\":{\"65\":1}}],[\"下面是对这几种错误级别的介绍\",{\"1\":{\"63\":1}}],[\"下面是多协程在channel方法下对同一个key进行操作的结果\",{\"1\":{\"28\":1}}],[\"下面添加一个前缀索引\",{\"1\":{\"48\":1}}],[\"下面的示例将会展示map的相关操作\",{\"1\":{\"16\":1}}],[\"动态数组\",{\"1\":{\"38\":1}}],[\"切片在扩容时会进行内存对齐\",{\"1\":{\"38\":1}}],[\"切片的扩容\",{\"1\":{\"38\":1}}],[\"切片的data属性是指向切片数组的指针\",{\"1\":{\"38\":1}}],[\"切片的内置结构\",{\"1\":{\"38\":1}}],[\"切片可以通过go内置append方法进行追加元素\",{\"1\":{\"38\":1}}],[\"切片可以追加元素\",{\"1\":{\"38\":1}}],[\"切片声明如下\",{\"1\":{\"38\":1}}],[\"切片描述的是一块数据\",{\"1\":{\"38\":1}}],[\"切片不是数组\",{\"1\":{\"38\":1}}],[\"切片是引用类型\",{\"1\":{\"38\":1}}],[\"切片是一种数据结构\",{\"1\":{\"38\":1}}],[\"切片是golang中特有的数据类型\",{\"1\":{\"38\":1}}],[\"切片\",{\"0\":{\"38\":1}}],[\"要根据业务场景来选择\",{\"1\":{\"67\":1}}],[\"要控制合适的分区的个数\",{\"1\":{\"53\":1}}],[\"要优化了\",{\"1\":{\"48\":1}}],[\"要是单独的列\",{\"1\":{\"47\":1}}],[\"要等待写锁完成释放后\",{\"1\":{\"33\":1}}],[\"要命的还在后头\",{\"1\":{\"8\":1}}],[\"虽然读锁不冲突\",{\"1\":{\"33\":1}}],[\"虽然不严谨\",{\"1\":{\"22\":1}}],[\"还有个map结构\",{\"1\":{\"33\":1}}],[\"还可以通过ins\",{\"1\":{\"23\":1}}],[\"还可以有一个tag属性\",{\"1\":{\"17\":1}}],[\"还可以使用new\",{\"1\":{\"17\":1}}],[\"上个例子中已经采用了原子操作\",{\"1\":{\"70\":1}}],[\"上面例子中\",{\"1\":{\"61\":1}}],[\"上面的例子中\",{\"1\":{\"63\":1}}],[\"上面的错误级别可以参考php官方文档\",{\"1\":{\"63\":1}}],[\"上面的列子很简单\",{\"1\":{\"61\":1}}],[\"上面的示例中\",{\"1\":{\"69\":1}}],[\"上面的示例\",{\"1\":{\"20\":1}}],[\"上面的horse中有两个匿名段inter和animal\",{\"1\":{\"17\":1}}],[\"上面的代码监听了8080端口来提供http服务\",{\"1\":{\"12\":1}}],[\"上面的代码表示必须f1函数执行完成才能执行f2函数\",{\"1\":{\"5\":1}}],[\"上面的代码我们看到首先声明了一个chan\",{\"1\":{\"2\":1}}],[\"上述代码中我们定义了一个结构体\",{\"1\":{\"33\":1}}],[\"撤销单次\",{\"1\":{\"33\":1}}],[\"调用\",{\"1\":{\"33\":1,\"63\":1}}],[\"调用会从获得的锁中排除新的读取器\",{\"1\":{\"33\":1}}],[\"调用servemux的servehttp方法来处理请求\",{\"1\":{\"12\":1}}],[\"已阻塞的\",{\"1\":{\"33\":1}}],[\"为了识别当前用户而创建的一种技术手段\",{\"1\":{\"65\":1}}],[\"为数组的键\",{\"1\":{\"63\":1}}],[\"为确保该锁最终可用\",{\"1\":{\"33\":1}}],[\"为各个字段做好默认的赋0初始化\",{\"1\":{\"17\":1}}],[\"申请读锁和写锁将会阻塞\",{\"1\":{\"33\":1}}],[\"看下列代码\",{\"1\":{\"66\":1}}],[\"看下这个结构的定义\",{\"1\":{\"33\":1}}],[\"看上面的案例\",{\"1\":{\"8\":1}}],[\"某游戏的内测号等等\",{\"1\":{\"68\":1}}],[\"某一时间点只有一个goroutine访问到这部分\",{\"1\":{\"32\":1}}],[\"某次评估过程中如果有满足条件的case\",{\"1\":{\"7\":1}}],[\"由于add和read操作都会使用到锁\",{\"1\":{\"32\":1}}],[\"保护的\",{\"1\":{\"32\":1}}],[\"保证send不会被阻塞\",{\"1\":{\"7\":1}}],[\"j++\",{\"1\":{\"32\":1}}],[\"j\",{\"1\":{\"32\":6}}],[\"释放锁行为可以在另一个goroutine中操作\",{\"1\":{\"34\":1}}],[\"释放锁\",{\"1\":{\"32\":1}}],[\"定义\",{\"1\":{\"32\":1}}],[\"互斥锁\",{\"1\":{\"32\":1}}],[\"互斥锁和读写锁有啥区别\",{\"1\":{\"31\":1}}],[\"排他锁\",{\"1\":{\"32\":1}}],[\"问\",{\"1\":{\"31\":1}}],[\"至于sync\",{\"1\":{\"28\":1}}],[\"至于为什么面试官不想用sync\",{\"1\":{\"28\":1}}],[\"+\",{\"1\":{\"28\":1}}],[\"说明锁起到了作用\",{\"1\":{\"27\":1}}],[\"没有选取到的用户返回秒杀失败\",{\"1\":{\"69\":1}}],[\"没有发生panic\",{\"1\":{\"27\":1}}],[\"没有定义任何接口方法\",{\"1\":{\"22\":1}}],[\"删除和查找\",{\"1\":{\"27\":1}}],[\"删除指定的key\",{\"1\":{\"16\":1}}],[\"添加\",{\"1\":{\"27\":1}}],[\"添加路由\",{\"1\":{\"12\":1}}],[\"那应该怎么办呢\",{\"1\":{\"66\":1}}],[\"那就会喧杂一个唯一的非空索引替代\",{\"1\":{\"49\":1}}],[\"那就是使用锁机制实现的线程安全的map\",{\"1\":{\"32\":1}}],[\"那就是通过channel机制来实现\",{\"1\":{\"27\":1}}],[\"那就是标准包里的sync\",{\"1\":{\"27\":1}}],[\"那这个索引就被称之为覆盖索引\",{\"1\":{\"49\":1}}],[\"那多个读锁就都会阻塞\",{\"1\":{\"33\":1}}],[\"那咋办呢\",{\"1\":{\"28\":1}}],[\"那我们还有其他的方式来实现吗\",{\"1\":{\"27\":1}}],[\"那他到底想从你这面获取什么呢\",{\"1\":{\"27\":1}}],[\"那面试官要使用原生map\",{\"1\":{\"27\":1}}],[\"那么命令模式下是不是也可以有个入口文件呢\",{\"1\":{\"61\":1}}],[\"那么索引应该这样加\",{\"1\":{\"49\":1}}],[\"那么只能用到范围查询之前的列\",{\"1\":{\"47\":1}}],[\"那么只有指针类型的实例t才算是实现了这个接口\",{\"1\":{\"21\":1}}],[\"那么这个gorutine将会被阻塞\",{\"1\":{\"32\":1}}],[\"那么值类型的实例t和指针类型的实例t都算实现了这个接口\",{\"1\":{\"21\":1}}],[\"那么选择值类型的receiver还是指针类型的receiver\",{\"1\":{\"18\":1}}],[\"那么具体是怎么执行一个http请求的呢\",{\"1\":{\"12\":1}}],[\"众所周知go中有提供线程安全的map\",{\"1\":{\"27\":1}}],[\"比如商品实际库存\",{\"1\":{\"69\":1}}],[\"比如可以采取ip限流\",{\"1\":{\"69\":1}}],[\"比如可以判断某接口如果是a类型\",{\"1\":{\"23\":1}}],[\"比如倒计时\",{\"1\":{\"69\":1}}],[\"比如双十一的商品秒杀\",{\"1\":{\"68\":1}}],[\"比如淘宝和天猫\",{\"1\":{\"66\":1}}],[\"比如用户登录\",{\"1\":{\"65\":1}}],[\"比如错误页面啊\",{\"1\":{\"63\":1}}],[\"比如在开发模式下\",{\"1\":{\"63\":2}}],[\"比如thinkphp5和yii框架都实现了这个功能\",{\"1\":{\"61\":1}}],[\"比如有存储过程的语句\",{\"1\":{\"57\":1}}],[\"比如自增id\",{\"1\":{\"49\":1}}],[\"比如下面这个语句\",{\"1\":{\"49\":1}}],[\"比如\",{\"1\":{\"49\":1,\"53\":2,\"61\":1,\"66\":1}}],[\"比如locked\",{\"1\":{\"43\":1}}],[\"比如从ch1\",{\"1\":{\"7\":1}}],[\"直接声明\",{\"1\":{\"38\":1}}],[\"直接用if\",{\"1\":{\"23\":1}}],[\"直到其被unlock\",{\"1\":{\"32\":1}}],[\"直到channel被关闭\",{\"1\":{\"6\":1}}],[\"直到channel为空\",{\"1\":{\"3\":1}}],[\"直到channel容量已满\",{\"1\":{\"3\":1}}],[\"直到sender端向channel发送了一个数据\",{\"1\":{\"3\":1}}],[\"直到receiver端将此数据receive\",{\"1\":{\"3\":1}}],[\"才能转换成什么类型\",{\"1\":{\"23\":1}}],[\"输出30\",{\"1\":{\"23\":1}}],[\"或ins\",{\"1\":{\"23\":1}}],[\"或itable\",{\"1\":{\"22\":1}}],[\"或者其它可以通过\",{\"1\":{\"16\":1}}],[\"或者能确保select不阻塞的语句块\",{\"1\":{\"7\":1}}],[\"或者结束select\",{\"1\":{\"7\":1}}],[\"或者讲无缓冲chan设置为有缓冲chan\",{\"1\":{\"4\":1}}],[\"显然\",{\"1\":{\"22\":1}}],[\"4\",{\"1\":{\"38\":3}}],[\"44\",{\"1\":{\"22\":1}}],[\"4<<10\",{\"1\":{\"12\":1}}],[\"52035072\",{\"1\":{\"57\":1}}],[\"5238682\",{\"1\":{\"54\":1}}],[\"5764978\",{\"1\":{\"57\":1}}],[\"5\",{\"1\":{\"22\":1,\"33\":1,\"38\":1,\"57\":1}}],[\"任何一个时间点都只能有一个goroutine执行这段区间的代码\",{\"1\":{\"32\":1}}],[\"任意对象都可以保存到空接口实例变量中\",{\"1\":{\"22\":1}}],[\"任务完成后对chan进行读操作\",{\"1\":{\"6\":1}}],[\"意味着go中的任意对象都可以实现空接口\",{\"1\":{\"22\":1}}],[\"空接口是一种接口\",{\"1\":{\"22\":1}}],[\"空接口是指没有定义任何接口方法的接口\",{\"1\":{\"22\":1}}],[\"空interface\",{\"0\":{\"22\":1}}],[\"空map\",{\"1\":{\"16\":1}}],[\"类型的\",{\"1\":{\"21\":2}}],[\"和在\",{\"1\":{\"63\":1}}],[\"和group\",{\"1\":{\"47\":1,\"48\":1}}],[\"和unlock\",{\"1\":{\"32\":1}}],[\"和\",{\"1\":{\"21\":1,\"63\":2,\"65\":2,\"66\":2}}],[\"和buffered\",{\"1\":{\"3\":1}}],[\"值类型的实例的method\",{\"1\":{\"21\":1}}],[\"值类型实例是一个method\",{\"1\":{\"21\":1}}],[\"值类型和指针类型\",{\"1\":{\"18\":1}}],[\"占用2个机器字长\",{\"1\":{\"20\":1}}],[\"额\",{\"1\":{\"19\":2}}],[\"被要求一定要用结构体比较怎么办\",{\"1\":{\"19\":1}}],[\"被抛弃的\",{\"1\":{\"8\":1}}],[\"结构体中有两个字段\",{\"1\":{\"27\":1}}],[\"结构体有时候并不能直接比较\",{\"1\":{\"19\":1}}],[\"结构由字段\",{\"1\":{\"17\":1}}],[\"语言中\",{\"1\":{\"19\":1}}],[\"语句里有变量的\",{\"1\":{\"57\":1}}],[\"语句\",{\"1\":{\"8\":1}}],[\"明确指定了要拷贝的对象是指针类型的实例\",{\"1\":{\"18\":1}}],[\"也是无法保证操作顺序的\",{\"1\":{\"32\":1}}],[\"也即类型检测\",{\"1\":{\"23\":1}}],[\"也在指针类型的实例t方法集中\",{\"1\":{\"21\":1}}],[\"也会拷贝\",{\"1\":{\"18\":1}}],[\"也就是把索引和列的值存在一起\",{\"1\":{\"50\":1}}],[\"也就是多版本并发控制\",{\"1\":{\"42\":1}}],[\"也就是说\",{\"1\":{\"18\":2}}],[\"也就是说两端都因为对方而使得自己当前处于阻塞状态\",{\"1\":{\"4\":1}}],[\"也就是拷贝完整的person数据结构\",{\"1\":{\"18\":1}}],[\"也就是拷贝一个副本\",{\"1\":{\"18\":1}}],[\"中主要采用反向代理的方式来实现负载均衡\",{\"1\":{\"67\":1}}],[\"中处理\",{\"1\":{\"63\":1}}],[\"中\",{\"1\":{\"18\":2}}],[\"再者\",{\"1\":{\"18\":1}}],[\"再加上\",{\"1\":{\"8\":1}}],[\"首先考虑秒杀的场景\",{\"1\":{\"69\":1}}],[\"首先我们要知道跨域\",{\"1\":{\"66\":1}}],[\"首先我们声明了一个长度为2\",{\"1\":{\"38\":1}}],[\"首先二级索引先找到主键\",{\"1\":{\"49\":1}}],[\"首先\",{\"1\":{\"18\":1}}],[\"第三方\",{\"1\":{\"67\":2}}],[\"第二个指针就是实例的指针地址\",{\"1\":{\"20\":1}}],[\"第二个规则使得同名属性不会出现歧义\",{\"1\":{\"17\":1}}],[\"第一个是指针指向实例的类型信息和方法集\",{\"1\":{\"20\":1}}],[\"第一个规则使得go\",{\"1\":{\"17\":1}}],[\"重写方法\",{\"1\":{\"17\":1}}],[\"而不是一次\",{\"1\":{\"49\":1}}],[\"而切片是对数组的抽象\",{\"1\":{\"38\":1}}],[\"而指针引用\",{\"1\":{\"19\":1}}],[\"而且它明确了要拷贝的对象是值类型的实例\",{\"1\":{\"18\":1}}],[\"而且可以重写字段\",{\"1\":{\"17\":1}}],[\"而是直接修改或访问共享数据\",{\"1\":{\"32\":1}}],[\"而是对不同的key进行操作\",{\"1\":{\"28\":1}}],[\"而是处理完被选中的case后进入下一轮select\",{\"1\":{\"7\":1}}],[\"而是等到receiver准备接收channel数据了\",{\"1\":{\"3\":1}}],[\"外部struct覆盖内部struct的同名字段\",{\"1\":{\"17\":1}}],[\"会退化为轮询策略\",{\"1\":{\"67\":1}}],[\"会话跨域和单点登录\",{\"0\":{\"66\":1}}],[\"会话安全方面php官方手册进行了说明\",{\"1\":{\"65\":1}}],[\"会话是由客户端发起请求\",{\"1\":{\"65\":1}}],[\"会话管理主要有两个部分组成\",{\"1\":{\"65\":1}}],[\"会话管理\",{\"0\":{\"64\":1,\"65\":1}}],[\"会以该函数名开头\",{\"1\":{\"63\":1}}],[\"会导致脚本终止运行\",{\"1\":{\"63\":1}}],[\"会自行创建一个隐式主键\",{\"1\":{\"49\":1}}],[\"会影响外部原始实例\",{\"1\":{\"18\":1}}],[\"会如何\",{\"1\":{\"17\":1}}],[\"会先输入数据\",{\"1\":{\"1\":1}}],[\"会先获取到数据\",{\"1\":{\"1\":1}}],[\"例如\",{\"1\":{\"17\":1}}],[\"匿名字段的名称强制和类型相同\",{\"1\":{\"17\":1}}],[\"`uri`\",{\"1\":{\"53\":1}}],[\"`ip`\",{\"1\":{\"53\":3}}],[\"`id`\",{\"1\":{\"53\":2}}],[\"`request\",{\"1\":{\"53\":4}}],[\"`\",{\"1\":{\"17\":2}}],[\"`json\",{\"1\":{\"17\":2}}],[\"除非回调函数返回了\",{\"1\":{\"63\":1}}],[\"除外的所有错误和警告信息\",{\"1\":{\"63\":1}}],[\"除了上述两个标准异常之外\",{\"1\":{\"63\":1}}],[\"除了参数name\",{\"1\":{\"18\":1}}],[\"除了实例有值类型和指针类型的区别\",{\"1\":{\"18\":1}}],[\"除了reflect包\",{\"1\":{\"17\":1}}],[\"除此之外\",{\"1\":{\"17\":1}}],[\"各个字段\",{\"1\":{\"17\":1}}],[\"注册到脚本运行结束前\",{\"1\":{\"63\":1}}],[\"注释\",{\"1\":{\"17\":1}}],[\"注意\",{\"1\":{\"3\":1,\"23\":1}}],[\"从前端来讲可以这样搞\",{\"1\":{\"69\":1}}],[\"从这个层面上说\",{\"1\":{\"67\":1}}],[\"从库启动复制\",{\"1\":{\"57\":1}}],[\"从库配置中继日志文件地址\",{\"1\":{\"57\":1}}],[\"从上面的代码我们可以看出\",{\"1\":{\"33\":1}}],[\"从上面的代码示例我们可以看到struct实例可以是一个值也可以是一个指针\",{\"1\":{\"17\":1}}],[\"从上面的案例中我们通过锁机制实现了并发安全的map\",{\"1\":{\"27\":1}}],[\"从实现接口方法的角度上看\",{\"1\":{\"21\":1}}],[\"从表象来看是一个东西\",{\"1\":{\"19\":1}}],[\"从buffered\",{\"1\":{\"3\":1}}],[\"实际上\",{\"1\":{\"17\":1}}],[\"实现一一对应的关系\",{\"1\":{\"16\":1}}],[\"实现了http\",{\"1\":{\"12\":1}}],[\"构造struct实例\",{\"1\":{\"17\":1}}],[\"构建server\",{\"1\":{\"12\":1}}],[\"构建servemux\",{\"0\":{\"12\":1}}],[\"包括了所有正在临界区里面的读者或者被写锁阻塞的等待进入临界区读者的数量\",{\"1\":{\"33\":1}}],[\"包括内置简单数据类型\",{\"1\":{\"17\":1}}],[\"包括函数\",{\"1\":{\"16\":1}}],[\"组成\",{\"1\":{\"17\":1,\"21\":1}}],[\"遍历map\",{\"1\":{\"16\":1}}],[\"遍历时是随机的\",{\"1\":{\"16\":1}}],[\"key键名为\",{\"1\":{\"69\":1}}],[\"key分区\",{\"1\":{\"53\":1}}],[\"keys\",{\"1\":{\"45\":1,\"46\":1}}],[\"key是string类型\",{\"1\":{\"27\":1}}],[\"key\",{\"1\":{\"27\":10,\"28\":11,\"33\":13,\"48\":1,\"49\":1,\"53\":2,\"69\":1,\"70\":3}}],[\"k\",{\"1\":{\"16\":1,\"28\":2}}],[\"获取最后一次错误\",{\"1\":{\"63\":1}}],[\"获取最后发生的错误\",{\"1\":{\"63\":1}}],[\"获取到参数之后\",{\"1\":{\"61\":1}}],[\"获取\",{\"1\":{\"61\":1}}],[\"获取map的长度\",{\"1\":{\"16\":1}}],[\"获取一个key值\",{\"1\":{\"16\":1}}],[\"更快\",{\"1\":{\"48\":1}}],[\"更新一个key\",{\"1\":{\"16\":1}}],[\"更通俗地说\",{\"1\":{\"4\":1}}],[\"数据存储方式不一样\",{\"1\":{\"42\":1}}],[\"数据未读就表示未send成功\",{\"1\":{\"3\":1}}],[\"数组\",{\"1\":{\"16\":1}}],[\"如下\",{\"1\":{\"19\":1}}],[\"如animal\",{\"1\":{\"17\":1}}],[\"如interface和指针可以\",{\"1\":{\"16\":1}}],[\"如int\",{\"1\":{\"16\":1}}],[\"如果订单在一定时间内不付款就把此订单状态改为失败然后redis里的\",{\"1\":{\"69\":1}}],[\"如果后端服务器down掉\",{\"1\":{\"67\":1}}],[\"如果还没有错误则返回\",{\"1\":{\"63\":1}}],[\"如果该错误由\",{\"1\":{\"63\":1}}],[\"如果非要使用的话不要设置太大的内存占用\",{\"1\":{\"55\":1}}],[\"如果表中没有定义主键\",{\"1\":{\"49\":1}}],[\"如果一个索引包含所有要查询字段的值\",{\"1\":{\"49\":1}}],[\"如果一个查询中有范围查询\",{\"1\":{\"47\":1}}],[\"如果索引类型为index\",{\"1\":{\"48\":1}}],[\"如果追加元素\",{\"1\":{\"38\":1}}],[\"如果没有符合条件的\",{\"1\":{\"49\":1}}],[\"如果没有进行写锁定\",{\"1\":{\"33\":2}}],[\"如果没有default\",{\"1\":{\"7\":1}}],[\"如果在添加写锁之前已经有其他的读锁和写锁\",{\"1\":{\"33\":1}}],[\"如果在一个地方lock\",{\"1\":{\"32\":1}}],[\"如果在select中执行send操作\",{\"1\":{\"7\":1}}],[\"如果杠精面试官说我就想要多协程对同一个key进行操作\",{\"1\":{\"28\":1}}],[\"如果我们多协程对同一个key进行操作\",{\"1\":{\"28\":1}}],[\"如果我们被迫无奈\",{\"1\":{\"19\":1}}],[\"如果是多个不同的域名呢\",{\"1\":{\"66\":1}}],[\"如果是这两个域名\",{\"1\":{\"66\":1}}],[\"如果是生产模式下就要进行优雅的错误处理\",{\"1\":{\"63\":2}}],[\"如果是b类型\",{\"1\":{\"23\":1}}],[\"如果是nil则使用默认的defaultservemux\",{\"1\":{\"12\":1}}],[\"如果ins保存的是指针类型的\",{\"1\":{\"23\":1}}],[\"如果ins保存的是值类型的type\",{\"1\":{\"23\":1}}],[\"如果某类型实现接口的方法的receiver是\",{\"1\":{\"21\":2}}],[\"如果有修改操作\",{\"1\":{\"18\":2}}],[\"如果存在default且其它case都不满足条件\",{\"1\":{\"7\":1}}],[\"如果select不在循环中或循环次数结束\",{\"1\":{\"7\":1}}],[\"如果select在循环中\",{\"1\":{\"7\":1}}],[\"如果多个case同时满足条件\",{\"1\":{\"7\":1}}],[\"如果所有的case语句块评估时都被阻塞\",{\"1\":{\"7\":1}}],[\"如果使用close\",{\"1\":{\"2\":1}}],[\"函数将错误信息托管至errorexception\",{\"1\":{\"63\":1}}],[\"函数所在文件中产生的大多数\",{\"1\":{\"63\":1}}],[\"函数来帮助开发者自定义异常处理行为\",{\"1\":{\"63\":1}}],[\"函数来注册这个方法\",{\"1\":{\"63\":1}}],[\"函数来设置错误级别\",{\"1\":{\"63\":1}}],[\"函数实现\",{\"1\":{\"63\":1}}],[\"函数的读者的数量\",{\"1\":{\"33\":1}}],[\"函数并且还没调用\",{\"1\":{\"33\":1}}],[\"函数或\",{\"1\":{\"17\":1}}],[\"函数\",{\"1\":{\"17\":1}}],[\"函数用于获取map中元素的个数\",{\"1\":{\"16\":1}}],[\"函数外的map也会被修改\",{\"1\":{\"16\":1}}],[\"若切片发生拷贝\",{\"1\":{\"38\":1}}],[\"若强行比较\",{\"1\":{\"19\":1}}],[\"若对象实例中数据比较复杂\",{\"1\":{\"17\":1}}],[\"若函数内部对map做了相关修改\",{\"1\":{\"16\":1}}],[\"若没有此操作\",{\"1\":{\"6\":1}}],[\"若没有缓冲数据\",{\"1\":{\"2\":1}}],[\"底层是数组\",{\"1\":{\"16\":1}}],[\"关于超卖问题\",{\"1\":{\"70\":1}}],[\"关于nginx轮询算法的解释可以看这篇文章\",{\"1\":{\"67\":1}}],[\"关于nginx负责均衡算法策略的选择\",{\"1\":{\"67\":1}}],[\"关于单点登录\",{\"1\":{\"66\":1}}],[\"关于session相关知识可以阅读php官方手册\",{\"1\":{\"65\":1}}],[\"关联字段\",{\"1\":{\"57\":1}}],[\"关联数组\",{\"1\":{\"16\":1}}],[\"关闭索引\",{\"0\":{\"45\":1}}],[\"关闭通道是没有意义的\",{\"1\":{\"6\":1}}],[\"关闭channel\",{\"1\":{\"2\":1}}],[\"关闭channel后\",{\"1\":{\"2\":2}}],[\"处理业务逻辑有很大的帮助\",{\"1\":{\"63\":1}}],[\"处理并相应\",{\"1\":{\"12\":1}}],[\"处理监听serve\",{\"1\":{\"12\":1}}],[\"方法让错误和异常都在这里进行处理\",{\"1\":{\"63\":1}}],[\"方法如下\",{\"1\":{\"48\":1}}],[\"方法获取锁\",{\"1\":{\"32\":1}}],[\"方法集是类型的方法集合\",{\"1\":{\"21\":1}}],[\"方法集\",{\"0\":{\"21\":1}}],[\"方法\",{\"1\":{\"20\":1}}],[\"方法内部访问的和修改的都是原始的实例数据结构\",{\"1\":{\"18\":1}}],[\"方法内部访问的和修改的都是实例的副本\",{\"1\":{\"18\":1}}],[\"方法就是函数\",{\"1\":{\"18\":1}}],[\"方法的p是一个指针类型的person实例\",{\"1\":{\"18\":1}}],[\"方法中是指针类型的receiver\",{\"1\":{\"18\":1}}],[\"方法中是值类型的receiver\",{\"1\":{\"18\":1}}],[\"方法也有值类型的方法和指针类型的区别\",{\"1\":{\"18\":1}}],[\"方法将报错\",{\"1\":{\"17\":1}}],[\"方法来执行具体的gin\",{\"1\":{\"12\":1}}],[\"方法执行完毕关闭当前连接\",{\"1\":{\"12\":1}}],[\"方法代码如下\",{\"1\":{\"12\":1}}],[\"mixed|row|statement\",{\"1\":{\"57\":1}}],[\"mixed\",{\"1\":{\"57\":1}}],[\"might\",{\"1\":{\"12\":1}}],[\"mode\",{\"1\":{\"56\":1}}],[\"moxigandashu\",{\"1\":{\"54\":1}}],[\"mliudong\",{\"1\":{\"53\":1}}],[\"message\",{\"1\":{\"63\":4}}],[\"merge则说明表的索引策略很糟糕\",{\"1\":{\"48\":1}}],[\"method\",{\"1\":{\"12\":3,\"67\":1}}],[\"mysql\",{\"1\":{\"57\":3},\"2\":{\"58\":1,\"59\":1}}],[\"mysql5\",{\"1\":{\"54\":1}}],[\"mysql高级特性\",{\"0\":{\"52\":1}}],[\"mysql版本5\",{\"1\":{\"51\":1}}],[\"mysql修改表相关\",{\"0\":{\"44\":1}}],[\"mysql优化相关\",{\"0\":{\"43\":1}}],[\"mysql的数据恢复相较于innodb较差\",{\"1\":{\"42\":1}}],[\"mysql相关知识点浅析\",{\"0\":{\"37\":1,\"41\":1}}],[\"myisam通过key\",{\"1\":{\"50\":1}}],[\"myisam却不同\",{\"1\":{\"50\":1}}],[\"myisam和innodb的索引总结\",{\"0\":{\"50\":1}}],[\"myisam和innodb的区别\",{\"0\":{\"42\":1}}],[\"myisam采用索引和列的值分离的方式存储数据\",{\"1\":{\"42\":1}}],[\"myisam崩溃的概率比innodb要大很多\",{\"1\":{\"42\":1}}],[\"myisam支持延迟更新索引键\",{\"1\":{\"42\":1}}],[\"myisam支持全文索引\",{\"1\":{\"42\":1}}],[\"myisam的锁不支持行级锁\",{\"1\":{\"42\":1}}],[\"mymap\",{\"1\":{\"27\":6,\"28\":6,\"33\":5}}],[\"mfor\",{\"1\":{\"33\":1}}],[\"mfind方法通过互斥锁去读map数据\",{\"1\":{\"33\":1}}],[\"mfind\",{\"1\":{\"33\":3}}],[\"must\",{\"1\":{\"32\":1}}],[\"mutual\",{\"1\":{\"32\":1}}],[\"mutex和rwmutex都不关联goroutine\",{\"1\":{\"34\":1}}],[\"mutex和sync\",{\"0\":{\"31\":1,\"34\":1}}],[\"mutex类型来说是允许的\",{\"1\":{\"32\":1}}],[\"mutex类型实现mutex\",{\"1\":{\"32\":1}}],[\"mutex保证了每个资源临界区的安全\",{\"1\":{\"32\":1}}],[\"mutex提供两个方法\",{\"1\":{\"32\":1}}],[\"mutex\",{\"1\":{\"32\":6,\"33\":2},\"2\":{\"36\":1}}],[\"mutex互斥锁\",{\"0\":{\"32\":1}}],[\"multiple\",{\"1\":{\"12\":1}}],[\"m定义map类型\",{\"1\":{\"28\":1}}],[\"m代表的是一个map类型\",{\"1\":{\"27\":1}}],[\"m\",{\"1\":{\"16\":10,\"27\":21,\"28\":21,\"32\":5,\"33\":19}}],[\"mark\",{\"0\":{\"74\":1}}],[\"management\",{\"1\":{\"65\":1}}],[\"manual\",{\"1\":{\"63\":9,\"65\":3}}],[\"masteruser\",{\"1\":{\"57\":1}}],[\"master\",{\"1\":{\"57\":8}}],[\"max\",{\"1\":{\"56\":1}}],[\"maxvalue\",{\"1\":{\"53\":1}}],[\"map我想大家心中已经有了答案\",{\"1\":{\"28\":1}}],[\"map类型\",{\"1\":{\"27\":1}}],[\"map同slice一样都是线程不安全的数据类型\",{\"1\":{\"16\":1}}],[\"map的相关知识大家可以读这篇文章\",{\"1\":{\"28\":1}}],[\"map的值可以是任意对象\",{\"1\":{\"16\":1}}],[\"map的key可以是任意内置的数据类型\",{\"1\":{\"16\":1}}],[\"map是一个指针\",{\"1\":{\"16\":1}}],[\"map\",{\"0\":{\"16\":1},\"1\":{\"16\":7,\"19\":1,\"22\":1,\"27\":2,\"28\":2,\"33\":2},\"2\":{\"25\":1,\"30\":1}}],[\"main函数中我们利用for语句生成了9个goruntine\",{\"1\":{\"27\":1}}],[\"main\",{\"1\":{\"3\":2,\"4\":3,\"5\":1,\"6\":2,\"7\":1,\"8\":2,\"16\":1,\"19\":1,\"27\":1,\"28\":1,\"32\":1,\"33\":2,\"38\":2}}],[\"make创建\",{\"1\":{\"38\":1}}],[\"make\",{\"1\":{\"2\":1,\"3\":4,\"4\":3,\"5\":1,\"6\":2,\"7\":2,\"8\":2,\"12\":1,\"16\":2,\"22\":1,\"27\":1,\"28\":3,\"33\":1,\"38\":2}}],[\"xianid就不是覆盖索引\",{\"1\":{\"49\":1}}],[\"xianid就是cityid的覆盖索引\",{\"1\":{\"49\":1}}],[\"xianid\",{\"1\":{\"49\":4}}],[\"x\",{\"1\":{\"12\":1,\"23\":2,\"49\":1}}],[\"即自定义异常来捕获\",{\"1\":{\"63\":1}}],[\"即基于行和基于语句一起使用\",{\"1\":{\"57\":1}}],[\"即底层数组的长度\",{\"1\":{\"38\":1}}],[\"即减少一次读锁的引用计数\",{\"1\":{\"33\":1}}],[\"即写锁权限高于读锁\",{\"1\":{\"33\":1}}],[\"即\",{\"1\":{\"21\":1}}],[\"即元素个数\",{\"1\":{\"16\":1}}],[\"即有多个少key\",{\"1\":{\"16\":1}}],[\"即交由gin来处理请求\",{\"1\":{\"12\":1}}],[\"即每次一个http请求都会建立一个连接\",{\"1\":{\"12\":1}}],[\"即先执行读取的\",{\"1\":{\"1\":1}}],[\"创建一个map\",{\"1\":{\"16\":2}}],[\"创建一个新的连接\",{\"1\":{\"12\":1}}],[\"创建一个无缓冲的chan\",{\"1\":{\"2\":1}}],[\"经过一系列相关处理\",{\"1\":{\"12\":1}}],[\"然后把用户id加入到秒杀购买成功队列\",{\"1\":{\"69\":1}}],[\"然后去消费秒杀队列\",{\"1\":{\"69\":1}}],[\"然后再通过后台进程把redis中的用户秒杀请求同步到数据库中\",{\"1\":{\"69\":1}}],[\"然后在每次请求的时候把cookie相关信息带上\",{\"1\":{\"66\":1}}],[\"然后通过http协议把这个sessionid放到cookie里返回给客户端\",{\"1\":{\"65\":1}}],[\"然后通过索引找到磁盘相应数据\",{\"1\":{\"50\":1}}],[\"然后通过主键找到具体的值\",{\"1\":{\"49\":1}}],[\"然后映射到value\",{\"1\":{\"16\":1}}],[\"然后开一个goruntine处理这个连接\",{\"1\":{\"12\":1}}],[\"然后accept阻塞直到返回下一个链接\",{\"1\":{\"12\":1}}],[\"然后阻塞\",{\"1\":{\"3\":1}}],[\"监听端口\",{\"1\":{\"12\":1}}],[\"监听http端口\",{\"1\":{\"12\":1}}],[\"代码如下\",{\"1\":{\"12\":4}}],[\"具体参考\",{\"1\":{\"63\":1}}],[\"具体可参考\",{\"1\":{\"63\":1}}],[\"具体可参考php官方手册\",{\"1\":{\"63\":1}}],[\"具体可以参考\",{\"1\":{\"53\":1,\"54\":1}}],[\"具体使用方法可以参考php官方手册\",{\"1\":{\"63\":1}}],[\"具体相关实现可以参考\",{\"1\":{\"57\":1}}],[\"具体视图相关可以参考\",{\"1\":{\"54\":1}}],[\"具体处理请求的代码是这个\",{\"1\":{\"12\":1}}],[\"具体连接的处理在conn\",{\"1\":{\"12\":1}}],[\"具体要看\",{\"1\":{\"12\":1}}],[\"具体的执行请求返回响应的方法\",{\"1\":{\"12\":1}}],[\"last\",{\"1\":{\"63\":2}}],[\"line\",{\"1\":{\"63\":3}}],[\"lib\",{\"1\":{\"57\":2}}],[\"list\",{\"1\":{\"61\":2}}],[\"list分区\",{\"1\":{\"53\":1}}],[\"listener\",{\"1\":{\"12\":1}}],[\"listen\",{\"1\":{\"12\":1}}],[\"listenandserve\",{\"1\":{\"12\":3}}],[\"l代表锁\",{\"1\":{\"27\":1}}],[\"less\",{\"1\":{\"53\":3}}],[\"left\",{\"1\":{\"48\":1}}],[\"len\",{\"1\":{\"12\":2,\"16\":2,\"38\":1}}],[\"let\",{\"1\":{\"12\":1}}],[\"lock保证了在一个时间点只有其中一个goruntine可以访问其中一个临界区\",{\"1\":{\"32\":1}}],[\"lock\",{\"1\":{\"27\":2,\"32\":4,\"33\":4}}],[\"localaddr\",{\"1\":{\"12\":1}}],[\"localaddrcontextkey\",{\"1\":{\"12\":1}}],[\"long\",{\"1\":{\"12\":1,\"56\":1}}],[\"log`\",{\"1\":{\"53\":1}}],[\"logf\",{\"1\":{\"12\":1}}],[\"log\",{\"1\":{\"6\":1,\"8\":4,\"27\":1,\"28\":3,\"32\":2,\"33\":6,\"53\":1,\"56\":2,\"57\":6}}],[\"l\",{\"1\":{\"12\":2,\"16\":1,\"27\":7}}],[\"ln\",{\"1\":{\"12\":2}}],[\"需要特别注意的是带\",{\"1\":{\"63\":1}}],[\"需要等待多少读锁释放的数量\",{\"1\":{\"33\":1}}],[\"需要重复写if结构\",{\"1\":{\"23\":1}}],[\"需要监听端口\",{\"1\":{\"12\":1}}],[\"需要注意的是要记住\",{\"1\":{\"63\":1}}],[\"需要注意的是\",{\"1\":{\"7\":1}}],[\"初始化一个实例\",{\"1\":{\"17\":1}}],[\"初始化一个map\",{\"1\":{\"16\":1}}],[\"初始化\",{\"1\":{\"16\":2}}],[\"初始化全局中间件\",{\"1\":{\"12\":1}}],[\"初始化gin\",{\"1\":{\"12\":1}}],[\"uid\",{\"1\":{\"69\":1}}],[\"uintptr\",{\"1\":{\"38\":1}}],[\"uint32\",{\"1\":{\"32\":1,\"33\":2}}],[\"uri\",{\"1\":{\"67\":1}}],[\"url\",{\"1\":{\"67\":1}}],[\"upstream\",{\"1\":{\"67\":5}}],[\"ucenter\",{\"1\":{\"66\":1}}],[\"u\",{\"1\":{\"17\":3,\"18\":4,\"20\":4}}],[\"undefined\",{\"1\":{\"63\":1}}],[\"unique\",{\"1\":{\"53\":1}}],[\"unlocked\",{\"1\":{\"32\":1}}],[\"unlock\",{\"1\":{\"27\":2,\"32\":3,\"33\":3}}],[\"unexpected\",{\"1\":{\"23\":1}}],[\"unescape\",{\"1\":{\"12\":1}}],[\"until\",{\"1\":{\"12\":1}}],[\"unbuffered\",{\"1\":{\"3\":3}}],[\"user=\",{\"1\":{\"57\":1}}],[\"users\",{\"1\":{\"38\":3}}],[\"user\",{\"1\":{\"17\":6,\"20\":2,\"38\":1,\"63\":5}}],[\"use\",{\"1\":{\"12\":1,\"32\":1}}],[\"public\",{\"1\":{\"63\":4,\"65\":8}}],[\"put\",{\"1\":{\"12\":2}}],[\"php默认会把session存储在服务器的临时目录中\",{\"1\":{\"65\":1}}],[\"phpsessid=q0fm8up72q58ne1b6khf37dlos\",{\"1\":{\"65\":1}}],[\"php官方提供了\",{\"1\":{\"63\":1}}],[\"php提供了很简单两个全局变量来操作cookie和session\",{\"1\":{\"65\":1}}],[\"php提供了\",{\"1\":{\"63\":1}}],[\"php的异常处理基类是\",{\"1\":{\"63\":1}}],[\"php的错误和异常处理\",{\"0\":{\"62\":1}}],[\"php的命令模式也就是cli模式\",{\"1\":{\"61\":1}}],[\"php的命令模式实现\",{\"0\":{\"61\":1}}],[\"php\",{\"0\":{\"75\":1},\"1\":{\"61\":4,\"63\":24,\"65\":7,\"66\":1},\"2\":{\"72\":1}}],[\"php面试总结\",{\"0\":{\"60\":1},\"2\":{\"72\":1}}],[\"port\",{\"1\":{\"65\":1}}],[\"pos设置为0表示从日志开头读起\",{\"1\":{\"57\":1}}],[\"pos=0\",{\"1\":{\"57\":1}}],[\"pool\",{\"1\":{\"12\":4,\"56\":1}}],[\"p0\",{\"1\":{\"53\":1}}],[\"pending\",{\"1\":{\"33\":1}}],[\"person实例实现了user接口\",{\"1\":{\"20\":1}}],[\"person\",{\"1\":{\"18\":6,\"20\":4}}],[\"p2\",{\"1\":{\"18\":1}}],[\"p1\",{\"1\":{\"18\":1,\"53\":1}}],[\"p\",{\"1\":{\"18\":4,\"20\":6,\"53\":1,\"54\":1,\"57\":1,\"66\":1}}],[\"pipelining\",{\"1\":{\"12\":2}}],[\"private\",{\"1\":{\"65\":2}}],[\"primary\",{\"1\":{\"53\":1}}],[\"printf\",{\"1\":{\"6\":1,\"23\":5}}],[\"println\",{\"1\":{\"3\":5,\"4\":5,\"5\":2,\"6\":1,\"7\":4,\"8\":4,\"19\":2,\"20\":1,\"22\":1,\"23\":2,\"27\":1,\"28\":3,\"32\":2,\"33\":5,\"38\":8}}],[\"protected\",{\"1\":{\"63\":2}}],[\"protoatleast\",{\"1\":{\"12\":1}}],[\"processlist\",{\"1\":{\"43\":1}}],[\"process\",{\"1\":{\"12\":1}}],[\"password\",{\"1\":{\"57\":1}}],[\"password=\",{\"1\":{\"57\":1}}],[\"paulma\",{\"1\":{\"54\":1}}],[\"pall\",{\"1\":{\"53\":1}}],[\"parse\",{\"1\":{\"63\":3}}],[\"partitions\",{\"1\":{\"53\":1}}],[\"partition\",{\"1\":{\"53\":4}}],[\"params\",{\"1\":{\"12\":3}}],[\"parallel\",{\"1\":{\"12\":1}}],[\"package\",{\"1\":{\"33\":1}}],[\"panic\",{\"1\":{\"12\":3}}],[\"path\",{\"1\":{\"12\":1}}],[\"接着我们使用go内置的append函数对ints进行追加\",{\"1\":{\"38\":1}}],[\"接着我们使用go内置的append函数对int1进行追加\",{\"1\":{\"38\":1}}],[\"接着我们通过下标截取的方式声明了一个int类型的切片\",{\"1\":{\"38\":1}}],[\"接口转回int类型的实例i\",{\"1\":{\"23\":1}}],[\"接口实例中存放的是什么类型\",{\"1\":{\"23\":1}}],[\"接口实例中可以存放各种实现了接口的类型实例\",{\"1\":{\"23\":1}}],[\"接口实例转回时\",{\"1\":{\"23\":1}}],[\"接口实例ins中保存的是int类型\",{\"1\":{\"23\":1}}],[\"接口类型的数据结构是2个指针\",{\"1\":{\"20\":1}}],[\"接口类型是指针类型\",{\"1\":{\"20\":1}}],[\"接口\",{\"1\":{\"17\":1,\"20\":1}}],[\"接口只包含一个方法\",{\"1\":{\"12\":1}}],[\"接收\",{\"1\":{\"2\":1}}],[\"html\",{\"1\":{\"53\":1,\"54\":1,\"57\":1,\"66\":1,\"67\":1}}],[\"https\",{\"1\":{\"53\":1,\"54\":2,\"57\":3,\"66\":1,\"67\":3}}],[\"httpmethod\",{\"1\":{\"12\":1}}],[\"http包中server\",{\"1\":{\"12\":1}}],[\"http包中有默认的defaultservemux\",{\"1\":{\"12\":1}}],[\"http服务的底层走的是tcp协议\",{\"1\":{\"12\":1}}],[\"http\",{\"1\":{\"12\":17,\"57\":1,\"63\":9,\"65\":3}}],[\"hostip\",{\"1\":{\"57\":1}}],[\"host=\",{\"1\":{\"57\":1}}],[\"horse称为外部struct\",{\"1\":{\"17\":1}}],[\"horse\",{\"1\":{\"17\":1}}],[\"how\",{\"1\":{\"12\":1}}],[\"hash也可以看成是轮询的升级版\",{\"1\":{\"67\":1}}],[\"hash失效时\",{\"1\":{\"67\":1}}],[\"hash\",{\"1\":{\"67\":6}}],[\"hash分区\",{\"1\":{\"53\":1}}],[\"have\",{\"1\":{\"12\":1}}],[\"handleexceptions\",{\"1\":{\"63\":2}}],[\"handles\",{\"1\":{\"12\":1}}],[\"handlehttprequest\",{\"1\":{\"12\":3}}],[\"handlershutdown\",{\"1\":{\"63\":2}}],[\"handlers\",{\"1\":{\"12\":6}}],[\"handlerfunc函数\",{\"1\":{\"12\":1}}],[\"handler\",{\"1\":{\"12\":10,\"63\":14,\"65\":1}}],[\"handler接口的实现者\",{\"1\":{\"12\":1}}],[\"handler接口\",{\"1\":{\"12\":2}}],[\"held\",{\"1\":{\"33\":1}}],[\"hello\",{\"1\":{\"22\":1}}],[\"header\",{\"1\":{\"12\":1}}],[\"here\",{\"1\":{\"12\":1}}],[\"hijacked\",{\"1\":{\"12\":2}}],[\"面试官听到这个锁的实现方法之后双眼冒光\",{\"1\":{\"31\":1}}],[\"面试总结\",{\"2\":{\"10\":1,\"14\":1,\"25\":1,\"30\":1,\"36\":1,\"40\":1,\"59\":1,\"72\":1}}],[\"面试\",{\"2\":{\"10\":1,\"14\":1,\"25\":1,\"30\":1,\"36\":1,\"40\":1,\"59\":1,\"72\":1}}],[\"源码\",{\"2\":{\"10\":1,\"14\":1,\"25\":1,\"30\":1,\"36\":1,\"40\":1}}],[\"防止了内存泄漏\",{\"1\":{\"8\":1}}],[\"防止内存泄漏\",{\"1\":{\"8\":1}}],[\"改进方法如下\",{\"1\":{\"8\":1}}],[\"清除的\",{\"1\":{\"8\":1}}],[\"了\",{\"1\":{\"8\":1}}],[\"我就是个技术混子\",{\"1\":{\"60\":1}}],[\"我就是要使用go提供的原生map\",{\"1\":{\"27\":1}}],[\"我自我感觉回答的很渣\",{\"1\":{\"60\":1}}],[\"我个人建议是使用锁进行实现\",{\"1\":{\"28\":1}}],[\"我看下这个serverhandler\",{\"1\":{\"12\":1}}],[\"我\",{\"1\":{\"8\":1,\"19\":2}}],[\"我们定义了几个key\",{\"1\":{\"69\":1}}],[\"我们使用\",{\"1\":{\"69\":1}}],[\"我们在创建秒杀活动的时候就要把商品相关信息写入到缓存中\",{\"1\":{\"69\":1}}],[\"我们一一分析下\",{\"1\":{\"69\":1}}],[\"我们自定义了一个处理类\",{\"1\":{\"63\":1}}],[\"我们可以采用redis\",{\"1\":{\"69\":1}}],[\"我们可以通过set\",{\"1\":{\"63\":1}}],[\"我们可以把它理解为线程\",{\"1\":{\"1\":1}}],[\"我们同样可以使用前缀索引中的方法来比较\",{\"1\":{\"49\":1}}],[\"我们同样是通过for循环开了9个协程来对map进行增删改查\",{\"1\":{\"28\":1}}],[\"我们对int1进行下标修改\",{\"1\":{\"38\":1}}],[\"我们来关注下面的代码\",{\"1\":{\"38\":1}}],[\"我们来思考这个问题\",{\"1\":{\"27\":1}}],[\"我们发现读数据和写数据互不冲突\",{\"1\":{\"33\":1}}],[\"我们输出的结果和我们预想的将大相径庭\",{\"1\":{\"28\":1}}],[\"我们开启了一个go协程用来读取ch中的方法并执行\",{\"1\":{\"28\":1}}],[\"我们首先想到的是使用互斥锁或读写锁\",{\"1\":{\"27\":1}}],[\"我们通过代码可以看到\",{\"1\":{\"12\":1}}],[\"我们主要看serve\",{\"1\":{\"12\":1}}],[\"我们看到在代码案例中我们对共享的变量i进行加和读操作\",{\"1\":{\"32\":1}}],[\"我们看到在这三个操作中都使用到了锁机制\",{\"1\":{\"27\":1}}],[\"我们看到代码里serverhandler中的\",{\"1\":{\"12\":1}}],[\"我们看到实例化了一个serverhandler并调用了其servehttp方法来处理\",{\"1\":{\"12\":1}}],[\"我们看到这个方法中做了哪些事\",{\"1\":{\"12\":1}}],[\"我们看到这个方法的参数是一个连接的上下文\",{\"1\":{\"12\":1}}],[\"我们看到这个方法两个步骤\",{\"1\":{\"12\":1}}],[\"我们看下gin中怎么实现的\",{\"1\":{\"12\":1}}],[\"我们这个计时器\",{\"1\":{\"8\":1}}],[\"我们本意是在3秒之后停止main\",{\"1\":{\"8\":1}}],[\"给清理掉了\",{\"1\":{\"8\":1}}],[\"global\",{\"1\":{\"43\":1}}],[\"globaloptionshandler\",{\"1\":{\"12\":1}}],[\"given\",{\"1\":{\"12\":1}}],[\"gin中主要通过context\",{\"1\":{\"12\":1}}],[\"gin\",{\"1\":{\"12\":2},\"2\":{\"14\":1}}],[\"gin框架构建servemux流程如下\",{\"1\":{\"12\":1}}],[\"gin框架也实现了这个\",{\"1\":{\"12\":1}}],[\"getname\",{\"1\":{\"20\":3}}],[\"getvalue\",{\"1\":{\"12\":1}}],[\"get\",{\"1\":{\"12\":4,\"63\":2}}],[\"gc\",{\"1\":{\"8\":2,\"65\":1}}],[\"goods\",{\"1\":{\"69\":5}}],[\"goodat\",{\"1\":{\"19\":2}}],[\"go也能像其它动态语言一样\",{\"1\":{\"22\":1}}],[\"go会自动解除引用\",{\"1\":{\"18\":1}}],[\"go中的读写锁是基于互斥锁的\",{\"1\":{\"33\":1}}],[\"go中的参数传递其本质都是以复制的方式传递的\",{\"1\":{\"17\":1}}],[\"go中标准包提供sync\",{\"1\":{\"32\":1}}],[\"go中所有需要传值的时候\",{\"1\":{\"18\":1}}],[\"go里的map用于存放key\",{\"1\":{\"16\":1}}],[\"go面试之sync\",{\"0\":{\"31\":1}}],[\"go面试之并发安全的map\",{\"0\":{\"26\":1}}],[\"go面试之map\",{\"0\":{\"15\":1}}],[\"go面试之channel的使用\",{\"0\":{\"0\":1}}],[\"going\",{\"1\":{\"12\":1}}],[\"golang提供了switch\",{\"1\":{\"23\":1}}],[\"golang将直接以panic的方式终止程序\",{\"1\":{\"23\":1}}],[\"golang通过gin框架创建http服务源码剖析\",{\"0\":{\"11\":1}}],[\"golang\",{\"0\":{\"73\":1},\"2\":{\"9\":1,\"10\":1,\"13\":1,\"24\":1,\"25\":1,\"29\":1,\"30\":1,\"35\":1,\"36\":1,\"39\":1,\"40\":1,\"71\":1}}],[\"goruntine\",{\"1\":{\"8\":2}}],[\"goroutines\",{\"1\":{\"4\":1,\"6\":1}}],[\"goroutine中进行的\",{\"1\":{\"4\":2}}],[\"goroutine\",{\"1\":{\"1\":6,\"4\":2,\"6\":1,\"12\":1}}],[\"go提供了一个select语句块\",{\"1\":{\"7\":1}}],[\"go将探测到此问题\",{\"1\":{\"4\":1}}],[\"go\",{\"1\":{\"3\":4,\"4\":1,\"5\":2,\"6\":2,\"7\":3,\"8\":2,\"12\":1,\"19\":2,\"27\":1,\"28\":2,\"32\":1,\"33\":3},\"2\":{\"10\":1,\"14\":1,\"25\":1,\"30\":1,\"36\":1,\"40\":1}}],[\"却又发现和\",{\"1\":{\"8\":1}}],[\"时\",{\"1\":{\"8\":1,\"19\":1}}],[\"因此不会有丢失流量的情况\",{\"1\":{\"67\":1}}],[\"因此很合理的也就被\",{\"1\":{\"8\":1}}],[\"因此在每次进行\",{\"1\":{\"8\":1}}],[\"因为他们不同源\",{\"1\":{\"66\":1}}],[\"因为myisam的索引和数据是分开存储存储的\",{\"1\":{\"50\":1}}],[\"因为mutex不会和goroutine进行关联\",{\"1\":{\"32\":1}}],[\"因为innodb是顺序插入的\",{\"1\":{\"49\":1}}],[\"因为ints的长度为2\",{\"1\":{\"38\":1}}],[\"因为rwmutex的多个读可以并存\",{\"1\":{\"34\":1}}],[\"因为receiver严格规定p是一个值类型的实例\",{\"1\":{\"18\":1}}],[\"因为读写锁可以多次获取读锁\",{\"1\":{\"33\":1}}],[\"因为是互斥锁\",{\"1\":{\"33\":1}}],[\"因为竞争的存在\",{\"1\":{\"32\":1}}],[\"因为任意类型都实现了空接口\",{\"1\":{\"22\":1}}],[\"因为没方法需要实现\",{\"1\":{\"22\":1}}],[\"因为没有人需要\",{\"1\":{\"8\":1}}],[\"因为这个方法既在值类型的实例t方法集中\",{\"1\":{\"21\":1}}],[\"因为这个方法不在值类型的实例t方法集中\",{\"1\":{\"21\":1}}],[\"因为\",{\"1\":{\"8\":1}}],[\"因为关闭通道是针对发送数据而言的\",{\"1\":{\"6\":1}}],[\"因为关闭通道意味着没有数据再需要发送\",{\"1\":{\"2\":1}}],[\"因为容量为1的channel\",{\"1\":{\"3\":1}}],[\"准确使用定时器\",{\"0\":{\"8\":1}}],[\"达到终止循环的效果\",{\"1\":{\"7\":1}}],[\"执行响应的逻辑\",{\"1\":{\"61\":1}}],[\"执行速度快\",{\"1\":{\"57\":1}}],[\"执行具体的handlerfunc\",{\"1\":{\"12\":1}}],[\"执行这段代码\",{\"1\":{\"7\":1}}],[\"执行default\",{\"1\":{\"7\":1}}],[\"一致性\",{\"1\":{\"42\":1,\"67\":1}}],[\"一次runlock\",{\"1\":{\"33\":1}}],[\"一旦被锁住\",{\"1\":{\"32\":1}}],[\"一个返回值的探测\",{\"1\":{\"23\":1}}],[\"一个是读写锁\",{\"1\":{\"33\":1}}],[\"一个是对象的值\",{\"1\":{\"22\":1}}],[\"一个是对象的类型\",{\"1\":{\"22\":1}}],[\"一个是指针\",{\"1\":{\"17\":1}}],[\"一般这个中间层就是我们上文提到的负载均衡\",{\"1\":{\"69\":1}}],[\"一般面试的时候问这个问题主要是考察候选人的综合能力\",{\"1\":{\"68\":1}}],[\"一般做程序开发都会遇到这种业务需求\",{\"1\":{\"68\":1}}],[\"一般选择的标准可以参考这三个指标\",{\"1\":{\"67\":1}}],[\"一般单点登录的使用场景是多系统之间\",{\"1\":{\"66\":1}}],[\"一般客户端指的是cookie\",{\"1\":{\"65\":1}}],[\"一般处理错误的时候需要进行\",{\"1\":{\"63\":1}}],[\"一般处理错误的时候需要进行以下几点\",{\"1\":{\"63\":1}}],[\"一般在框架中都会封装一套属于框架自身的错误和异常处理模块\",{\"1\":{\"63\":1}}],[\"一般在做错误处理的时候这个函数会被register\",{\"1\":{\"63\":1}}],[\"一般php常见的错误级别有这几种\",{\"1\":{\"63\":1}}],[\"一般编程语言都有自己的错误处理机制\",{\"1\":{\"63\":1}}],[\"一般的框架都会实现命令的注册\",{\"1\":{\"61\":1}}],[\"一般最简单的实现就是如下\",{\"1\":{\"61\":1}}],[\"一般最多12个表\",{\"1\":{\"43\":1}}],[\"一般是机器ip32位的后八位\",{\"1\":{\"57\":1}}],[\"一般都是在并发下\",{\"1\":{\"70\":1}}],[\"一般都是在实际应用中采用混合模式复制\",{\"1\":{\"57\":1}}],[\"一般都是通过\",{\"1\":{\"8\":1}}],[\"一般cap是切片长度的两倍\",{\"1\":{\"38\":1}}],[\"一般来说选择指针类型的receiver\",{\"1\":{\"18\":1}}],[\"一般来说\",{\"1\":{\"7\":1}}],[\"一直轮询channel的可读事件\",{\"1\":{\"7\":1}}],[\"本次select就不会出现阻塞的情况\",{\"1\":{\"7\":1}}],[\"就可以实现会话的跨域了\",{\"1\":{\"66\":1}}],[\"就可以直接从接口上调用它所保存的实例的方法\",{\"1\":{\"20\":1}}],[\"就把错误全面的展现出来\",{\"1\":{\"63\":2}}],[\"就是把php文件当做脚本执行的一种方式\",{\"1\":{\"61\":1}}],[\"就执行b类型里的特有方法\",{\"1\":{\"23\":1}}],[\"就执行a类型里的特有方法\",{\"1\":{\"23\":1}}],[\"就会导致出现例子中的直接报错的情况\",{\"1\":{\"19\":1}}],[\"就会调用都\",{\"1\":{\"8\":1}}],[\"就会出现死锁\",{\"1\":{\"4\":1}}],[\"就不难理解只有所有case都不满足条件时\",{\"1\":{\"7\":1}}],[\"其他的错误进行了忽略\",{\"1\":{\"63\":1}}],[\"其他的lock将会竞争互斥锁\",{\"1\":{\"32\":1}}],[\"其他的lock操作将无法进行\",{\"1\":{\"32\":1}}],[\"其拷贝时间都是大差不差的\",{\"1\":{\"38\":1}}],[\"其实质是对当前三个属性的拷贝\",{\"1\":{\"38\":1}}],[\"其实如果注意到select语句是在某一个goroutine中评估的\",{\"1\":{\"7\":1}}],[\"其中\",{\"1\":{\"49\":1}}],[\"其中最常用的是make创建和下标截取\",{\"1\":{\"38\":1}}],[\"其中animal称为内部struct\",{\"1\":{\"17\":1}}],[\"其虽然都是\",{\"1\":{\"19\":1}}],[\"其它自定义的struct类型\",{\"1\":{\"17\":1}}],[\"其它的case都不会被阻塞\",{\"1\":{\"7\":1}}],[\"当插入的秒杀请求数达到上限时\",{\"1\":{\"69\":1}}],[\"当部分后端机器挂掉时\",{\"1\":{\"67\":1}}],[\"当ip\",{\"1\":{\"67\":1}}],[\"当业务发展到一定程度之后\",{\"1\":{\"67\":1}}],[\"当找到索引也就找到了数据\",{\"1\":{\"50\":1}}],[\"当需要访问数据时\",{\"1\":{\"50\":1}}],[\"当使用explain分析查询语句时\",{\"1\":{\"48\":1}}],[\"当使用mfind读取数据时\",{\"1\":{\"33\":1}}],[\"当值为0时\",{\"1\":{\"43\":1}}],[\"当原\",{\"1\":{\"38\":1}}],[\"当cap不够时进行动态扩容\",{\"1\":{\"38\":1}}],[\"当channel的某一端\",{\"1\":{\"4\":1}}],[\"当只有读锁或者没有锁时\",{\"1\":{\"33\":1}}],[\"当有写锁时\",{\"1\":{\"33\":1}}],[\"当释放了释放了一个临界区\",{\"1\":{\"32\":1}}],[\"当接口实例中保存了自定义类型的实例后\",{\"1\":{\"20\":1}}],[\"当其基本类型包含\",{\"1\":{\"19\":1}}],[\"当前struct类型本身\",{\"1\":{\"17\":1}}],[\"当select中的case都在禁用状态\",{\"1\":{\"7\":1}}],[\"当select未在循环中时\",{\"1\":{\"7\":1}}],[\"则就会引起一个运行时错误\",{\"1\":{\"33\":2}}],[\"则lock就会阻塞直到该锁可用\",{\"1\":{\"33\":1}}],[\"则输出\",{\"1\":{\"23\":2}}],[\"则迟早会被send阻塞\",{\"1\":{\"7\":1}}],[\"则可能会永远被send阻塞\",{\"1\":{\"7\":1}}],[\"则所有其它case都直接结束评估\",{\"1\":{\"7\":1}}],[\"则执行default\",{\"1\":{\"7\":1}}],[\"则随机选择一个进行处理\",{\"1\":{\"7\":1}}],[\"则阻塞直到某个语句块可以被处理\",{\"1\":{\"7\":1}}],[\"bbc\",{\"1\":{\"57\":1}}],[\"bin\",{\"1\":{\"57\":3}}],[\"binlogname\",{\"1\":{\"57\":1}}],[\"binlog\",{\"1\":{\"57\":2}}],[\"blog\",{\"1\":{\"54\":1,\"57\":2,\"67\":2}}],[\"by中无法使用\",{\"1\":{\"48\":1}}],[\"by语句中也会用到索引\",{\"1\":{\"47\":1}}],[\"by\",{\"1\":{\"47\":1,\"48\":1,\"53\":1}}],[\"bytes\",{\"1\":{\"12\":1}}],[\"byte\",{\"1\":{\"12\":1}}],[\"bool\",{\"1\":{\"27\":1,\"28\":1}}],[\"body\",{\"1\":{\"12\":5}}],[\"b\",{\"1\":{\"16\":1,\"47\":1,\"66\":3}}],[\"but\",{\"1\":{\"12\":1}}],[\"buffer\",{\"1\":{\"56\":1}}],[\"buffer命中时\",{\"1\":{\"50\":1}}],[\"buffer把索引先缓存到内存中\",{\"1\":{\"50\":1}}],[\"buffered\",{\"1\":{\"3\":1}}],[\"bufw\",{\"1\":{\"12\":1}}],[\"bufr\",{\"1\":{\"12\":1}}],[\"buf\",{\"1\":{\"12\":5}}],[\"between\",{\"1\":{\"53\":1}}],[\"because\",{\"1\":{\"12\":1}}],[\"be\",{\"1\":{\"12\":1,\"32\":1}}],[\"before\",{\"1\":{\"12\":1}}],[\"backserver\",{\"1\":{\"67\":5}}],[\"background\",{\"1\":{\"12\":1}}],[\"basecontext\",{\"1\":{\"12\":3}}],[\"basectx\",{\"1\":{\"12\":4}}],[\"break\",{\"1\":{\"12\":1}}],[\"break是退出当前select\",{\"1\":{\"7\":1}}],[\"break关键字中断\",{\"1\":{\"7\":1}}],[\"但脚本仍会结束\",{\"1\":{\"63\":1}}],[\"但rwmutex显然更适用于读多写少的场景\",{\"1\":{\"34\":1}}],[\"但也因此而出现了随机性\",{\"1\":{\"32\":1}}],[\"但也可以用来向channel发送数据\",{\"1\":{\"7\":1}}],[\"但也可以使用range来迭代channel\",{\"1\":{\"6\":1}}],[\"但达不到我们预想的要求\",{\"1\":{\"28\":1}}],[\"但可以处理转换失败时的panic\",{\"1\":{\"23\":1}}],[\"但它确实保存了两个指针\",{\"1\":{\"22\":1}}],[\"但是会导致少卖\",{\"1\":{\"70\":1}}],[\"但是你在淘宝上登录之后在天猫上也可以访问自己的个人中心\",{\"1\":{\"66\":1}}],[\"但是在可以正常运行的脚本里面也可能会有类似的通知\",{\"1\":{\"63\":1}}],[\"但是在数据更改比较大的情况下\",{\"1\":{\"57\":1}}],[\"但是脚本不会终止运行\",{\"1\":{\"63\":1}}],[\"但是这个问题不是那么简单的\",{\"1\":{\"61\":1}}],[\"但是很多情况下无法正确复制数据\",{\"1\":{\"57\":1}}],[\"但是特消耗存储空间\",{\"1\":{\"49\":1}}],[\"但是追加数据会影响int1\",{\"1\":{\"38\":1}}],[\"但是追加数据不会影响ints\",{\"1\":{\"38\":1}}],[\"但是若一个写锁在占用锁\",{\"1\":{\"33\":1}}],[\"但是和上个锁的案例有个不同的地方是多个协程之间不再是对同一个key进行操作\",{\"1\":{\"28\":1}}],[\"但是它到底存放了什么东西\",{\"1\":{\"20\":1}}],[\"但是我们代码运行下来发现是一直输出数据\",{\"1\":{\"8\":1}}],[\"但其具体返回的地址是不一样的\",{\"1\":{\"19\":1}}],[\"但同时也是不可以比较的\",{\"1\":{\"19\":1}}],[\"但实例有两种类型\",{\"1\":{\"18\":1}}],[\"但重点在于计时器激活后\",{\"1\":{\"8\":1}}],[\"但允许case语句块为空块\",{\"1\":{\"7\":1}}],[\"不成立的话就把秒杀用户id加入到秒杀队列中\",{\"1\":{\"69\":1}}],[\"不成立的话就对商品库存进行\",{\"1\":{\"69\":1}}],[\"不能访问\",{\"1\":{\"66\":1}}],[\"不能动态扩容的\",{\"1\":{\"38\":1}}],[\"不错\",{\"1\":{\"60\":1}}],[\"不同的是两者实现的存储方式不一样\",{\"1\":{\"50\":1}}],[\"不同类型更不能互转\",{\"1\":{\"23\":1}}],[\"不过你仍然可以获取\",{\"1\":{\"63\":1}}],[\"不过这次我们不是比较前缀出现的次数而是整个列的记录不重复的次数\",{\"1\":{\"49\":1}}],[\"不过在order\",{\"1\":{\"48\":1}}],[\"不管当前slice具体有多少个元素\",{\"1\":{\"38\":1}}],[\"不会影响外部原始实例\",{\"1\":{\"18\":1}}],[\"不会指向任何数据结构\",{\"1\":{\"16\":1}}],[\"不允许fall\",{\"1\":{\"7\":1}}],[\"不是容量为1的buffered\",{\"1\":{\"3\":1}}],[\"所谓会话管理指的是因为http协议是无状态的一种协议\",{\"1\":{\"65\":1}}],[\"所有减库存操作都在redis中进行\",{\"1\":{\"69\":1}}],[\"所有的一切都是基于统一浏览器上\",{\"1\":{\"66\":1}}],[\"所有的错误和异常都在这里进行处理\",{\"1\":{\"63\":1}}],[\"所有的异常处理类都继承它\",{\"1\":{\"63\":1}}],[\"所有的case块都是按源代码书写顺序进行评估的\",{\"1\":{\"7\":1}}],[\"所有case都不满足条件时\",{\"1\":{\"7\":1}}],[\"所以可以读写分离\",{\"1\":{\"69\":1}}],[\"所以把页面进行静态化处理是一种很好的方法\",{\"1\":{\"69\":1}}],[\"所以适用于\",{\"1\":{\"33\":1}}],[\"所以是无序的\",{\"1\":{\"32\":1}}],[\"所以20个goruntine将会产生40个资源临界区\",{\"1\":{\"32\":1}}],[\"所以这种结构也称为type\",{\"1\":{\"23\":1}}],[\"所以上面的赋值过程是让空接口any保存各个数据对象的类型和对象的值\",{\"1\":{\"22\":1}}],[\"所以p2\",{\"1\":{\"18\":1}}],[\"所以p1\",{\"1\":{\"18\":1}}],[\"所以无论是指针类型的p1实例还是值类型的p2实例\",{\"1\":{\"18\":1}}],[\"所以方法体中的p\",{\"1\":{\"18\":1}}],[\"所以map是引用类型\",{\"1\":{\"16\":1}}],[\"所以\",{\"1\":{\"7\":1,\"18\":2}}],[\"所以default必须要可执行而不能阻塞\",{\"1\":{\"7\":1}}],[\"所以对已经关闭的chan进行send操作会引发panic\",{\"1\":{\"3\":1}}],[\"所以每发送一个数据就被阻塞\",{\"1\":{\"3\":1}}],[\"v20180824\",{\"0\":{\"60\":1}}],[\"v2\",{\"1\":{\"19\":2}}],[\"v1\",{\"1\":{\"19\":2}}],[\"v\",{\"1\":{\"7\":5,\"8\":4,\"12\":2,\"16\":1,\"23\":7,\"38\":3}}],[\"val是int类型\",{\"1\":{\"27\":1}}],[\"value插入秒杀请求\",{\"1\":{\"69\":1}}],[\"value数据结构\",{\"1\":{\"69\":1}}],[\"values\",{\"1\":{\"53\":3}}],[\"value值\",{\"1\":{\"16\":1}}],[\"value对\",{\"1\":{\"16\":1}}],[\"value\",{\"1\":{\"12\":5,\"19\":2,\"22\":2,\"23\":1,\"32\":1}}],[\"val\",{\"1\":{\"3\":2,\"27\":6,\"28\":8,\"33\":3}}],[\"variable\",{\"1\":{\"63\":1}}],[\"varchar\",{\"1\":{\"53\":1}}],[\"var\",{\"1\":{\"2\":1,\"12\":1,\"16\":2,\"17\":2,\"20\":1,\"22\":1,\"23\":2,\"32\":3,\"38\":1,\"57\":2}}],[\"用一个原子类型的变量值\",{\"1\":{\"69\":1}}],[\"用户在对订单付完款之后减商品数据库库存\",{\"1\":{\"69\":1}}],[\"用户限流\",{\"1\":{\"69\":1}}],[\"用户发起登录请求\",{\"1\":{\"65\":1}}],[\"用户级别的错误有\",{\"1\":{\"63\":1}}],[\"用来记录在获取写锁之前\",{\"1\":{\"33\":1}}],[\"用来定义行为\",{\"1\":{\"20\":1}}],[\"用来判断key是否存在\",{\"1\":{\"16\":1}}],[\"用来轮询每个case语句块的send或recv情况\",{\"1\":{\"7\":1}}],[\"用于后端服务器性能不均的情况\",{\"1\":{\"67\":1}}],[\"用于删除map中的某个key\",{\"1\":{\"16\":1}}],[\"用于端到端的数据传输\",{\"1\":{\"1\":1}}],[\"用法示例\",{\"1\":{\"7\":1}}],[\"它是一种指针类型的数据类型\",{\"1\":{\"22\":1}}],[\"它的名称和类型都是inter和animal\",{\"1\":{\"17\":1}}],[\"它的行为如下\",{\"1\":{\"7\":1}}],[\"它们的锁申请行为可以在一个goroutine中操作\",{\"1\":{\"34\":1}}],[\"它们是有区别的\",{\"1\":{\"18\":1}}],[\"它们是等价的\",{\"1\":{\"17\":1}}],[\"它们都是数据对象的实例\",{\"1\":{\"17\":1}}],[\"它们都用于将key经过hash函数处理\",{\"1\":{\"16\":1}}],[\"它会为struct分配内存\",{\"1\":{\"17\":1}}],[\"它会返回每次迭代过程中所读取的数据\",{\"1\":{\"6\":1}}],[\"它将索引和列的值存储在一起\",{\"1\":{\"49\":1}}],[\"它将不会做任何初始化\",{\"1\":{\"16\":1}}],[\"它将只对所有case评估一次\",{\"1\":{\"7\":1}}],[\"它像switch一样工作\",{\"1\":{\"7\":1}}],[\"很多时候想要同时操作多个channel\",{\"1\":{\"7\":1}}],[\"必须注意\",{\"1\":{\"6\":1}}],[\"rpush\",{\"1\":{\"69\":1}}],[\"rpath\",{\"1\":{\"12\":1}}],[\"rlock\",{\"1\":{\"27\":1,\"33\":4}}],[\"row\",{\"1\":{\"57\":1}}],[\"route\",{\"1\":{\"12\":1}}],[\"root\",{\"1\":{\"12\":4}}],[\"r\",{\"1\":{\"12\":5,\"28\":2}}],[\"running\",{\"1\":{\"43\":1}}],[\"runlock\",{\"1\":{\"27\":1,\"33\":4}}],[\"run\",{\"1\":{\"12\":1}}],[\"runtime\",{\"1\":{\"12\":1}}],[\"runhooks\",{\"1\":{\"12\":3}}],[\"rwfor\",{\"1\":{\"33\":1}}],[\"rwfind方法通过读写锁去读取数据\",{\"1\":{\"33\":1}}],[\"rwfind\",{\"1\":{\"33\":3}}],[\"rwmutex要高于mutex\",{\"1\":{\"34\":1}}],[\"rwmutex如何选择\",{\"0\":{\"34\":1}}],[\"rwmutex读写锁\",{\"0\":{\"33\":1}}],[\"rwmutex\",{\"0\":{\"31\":1},\"1\":{\"27\":1,\"33\":6}}],[\"rwc\",{\"1\":{\"12\":6}}],[\"rw\",{\"1\":{\"12\":5,\"33\":9}}],[\"range遍历切片有什么要注意的\",{\"1\":{\"38\":1}}],[\"range迭代channel就会一直被阻塞\",{\"1\":{\"6\":1}}],[\"range\",{\"1\":{\"6\":1,\"16\":1,\"22\":1,\"38\":1,\"53\":2}}],[\"redis\",{\"1\":{\"65\":2,\"70\":1}}],[\"register\",{\"1\":{\"63\":2,\"65\":1}}],[\"registeronhiteof\",{\"1\":{\"12\":1}}],[\"reporting\",{\"1\":{\"63\":5}}],[\"replies\",{\"1\":{\"12\":2}}],[\"relay\",{\"1\":{\"57\":3}}],[\"reflect\",{\"1\":{\"19\":2}}],[\"re\",{\"1\":{\"12\":2}}],[\"readcloser\",{\"1\":{\"12\":1}}],[\"readerwait\",{\"1\":{\"33\":1}}],[\"readercount\",{\"1\":{\"33\":1}}],[\"readersem\",{\"1\":{\"33\":1}}],[\"reader\",{\"1\":{\"12\":1}}],[\"read\",{\"1\":{\"12\":2,\"32\":2,\"56\":1,\"65\":1}}],[\"readrequest\",{\"1\":{\"12\":1}}],[\"remain\",{\"1\":{\"12\":1}}],[\"remoteaddr\",{\"1\":{\"12\":3}}],[\"responses\",{\"1\":{\"12\":1}}],[\"responsewriter\",{\"1\":{\"12\":4}}],[\"resp\",{\"1\":{\"12\":1}}],[\"reset\",{\"1\":{\"12\":4}}],[\"req\",{\"1\":{\"12\":20}}],[\"requesturi\",{\"1\":{\"12\":1}}],[\"requests\",{\"1\":{\"12\":2}}],[\"requestbodyremains\",{\"1\":{\"12\":1}}],[\"request\",{\"1\":{\"12\":7,\"53\":3}}],[\"returned\",{\"1\":{\"12\":2}}],[\"return是退出整个函数\",{\"1\":{\"7\":1}}],[\"return\",{\"1\":{\"3\":1,\"8\":2,\"12\":9,\"19\":1,\"20\":1,\"27\":2,\"28\":2,\"32\":2,\"33\":2,\"63\":2,\"65\":6,\"69\":2,\"70\":1}}],[\"recover\",{\"1\":{\"12\":1}}],[\"receiver部分\",{\"1\":{\"18\":2}}],[\"receiver\",{\"1\":{\"4\":2}}],[\"receiver被阻塞\",{\"1\":{\"3\":1}}],[\"receiver每次请求channel时\",{\"1\":{\"3\":1}}],[\"receiver端按照队列的方式\",{\"1\":{\"3\":1}}],[\"receiver端一直阻塞\",{\"1\":{\"3\":1}}],[\"receive\",{\"1\":{\"2\":1,\"6\":1}}],[\"receive和close\",{\"1\":{\"2\":1}}],[\"recv操作将返回对应类型的0值以及一个状态码false\",{\"1\":{\"2\":1}}],[\"recv\",{\"1\":{\"2\":1,\"4\":3}}],[\"产生死锁\",{\"1\":{\"6\":1}}],[\"open\",{\"1\":{\"65\":1}}],[\"operator\",{\"1\":{\"63\":1}}],[\"options\",{\"1\":{\"12\":2}}],[\"o\",{\"1\":{\"47\":1}}],[\"o变为顺序i\",{\"1\":{\"47\":1}}],[\"override\",{\"1\":{\"17\":1}}],[\"of\",{\"1\":{\"12\":1}}],[\"off\",{\"1\":{\"12\":1}}],[\"or\",{\"1\":{\"12\":1}}],[\"origlistener\",{\"1\":{\"12\":1}}],[\"only\",{\"1\":{\"56\":1}}],[\"one\",{\"1\":{\"12\":1}}],[\"on\",{\"1\":{\"12\":3}}],[\"out通道只用于发送数据\",{\"1\":{\"6\":1}}],[\"out\",{\"1\":{\"6\":1}}],[\"ok是一个bool值\",{\"1\":{\"16\":1}}],[\"ok\",{\"1\":{\"3\":2,\"7\":4,\"16\":1,\"23\":6,\"27\":4,\"28\":5}}],[\"表\",{\"1\":{\"49\":1}}],[\"表压缩\",{\"1\":{\"42\":1}}],[\"表明这个chan参数只能进行读取操作\",{\"1\":{\"6\":1}}],[\"表示脚本遇到可能会表现为错误的情况\",{\"1\":{\"63\":1}}],[\"表示这个slice目前最多能扩展到这么长\",{\"1\":{\"38\":1}}],[\"表示slice当前的长度\",{\"1\":{\"38\":1}}],[\"表示sender端的goroutine向channel中投放数据\",{\"1\":{\"2\":1}}],[\"表示该slice结构从底层数组的哪一个元素开始\",{\"1\":{\"38\":1}}],[\"表示当前启用的读者数量\",{\"1\":{\"33\":1}}],[\"表示无数据再需发送\",{\"1\":{\"6\":1}}],[\"表示channel\",{\"1\":{\"6\":2}}],[\"表示关闭channel\",{\"1\":{\"2\":1}}],[\"表示receiver端的goroutine从channel中读取数据\",{\"1\":{\"2\":1}}],[\"同一个key的请求\",{\"1\":{\"67\":1}}],[\"同样php有个比较好的项目叫做\",{\"1\":{\"66\":1}}],[\"同类型的值类型实例和指针类型实例不能互转\",{\"1\":{\"23\":1}}],[\"同级别的struct出现同名字段\",{\"1\":{\"17\":1}}],[\"同名方法\",{\"1\":{\"17\":1}}],[\"同时可以使用js异步请求服务端\",{\"1\":{\"69\":1}}],[\"同时也可以使用redis的乐观锁和事务实现\",{\"1\":{\"70\":1}}],[\"同时也可以指定权重\",{\"1\":{\"67\":1}}],[\"同时也支持第三方的算法\",{\"1\":{\"67\":1}}],[\"同时也支持索引间隙锁\",{\"1\":{\"42\":1}}],[\"同时还用\",{\"1\":{\"67\":1}}],[\"同时还有别的分区\",{\"1\":{\"53\":1}}],[\"同时你也可以通过自定义会话管理器来管理会话\",{\"1\":{\"65\":1}}],[\"同时php也提供了\",{\"1\":{\"63\":1}}],[\"同时用户也可以设置自身的错误级别\",{\"1\":{\"63\":1}}],[\"同时在备库上也建议指定中继日志\",{\"1\":{\"57\":1}}],[\"同时ints对应的元素值也会修改\",{\"1\":{\"38\":1}}],[\"同时达到了3秒程序结束的效果\",{\"1\":{\"8\":1}}],[\"同时我们在检测到chan关闭时\",{\"1\":{\"7\":1}}],[\"同时上面的案例中\",{\"1\":{\"6\":1}}],[\"同步模式\",{\"1\":{\"3\":1}}],[\"使每个url定向到同一个后端服务器\",{\"1\":{\"67\":1}}],[\"使之可以使用到覆盖索引\",{\"1\":{\"51\":1}}],[\"使之长度发生了改变\",{\"1\":{\"38\":2}}],[\"使数据访问更快\",{\"1\":{\"49\":1}}],[\"使用示例\",{\"1\":{\"65\":1}}],[\"使用索引\",{\"1\":{\"43\":1}}],[\"使用\",{\"1\":{\"43\":1,\"63\":1}}],[\"使用show\",{\"1\":{\"43\":1}}],[\"使用range遍历切片users\",{\"1\":{\"38\":1}}],[\"使用range读取ch将会发生panic\",{\"1\":{\"6\":1}}],[\"使用rwfind读取数据\",{\"1\":{\"33\":1}}],[\"使用了有缓冲的chan\",{\"1\":{\"6\":1}}],[\"使得recv操作无法被执行\",{\"1\":{\"4\":1}}],[\"使得sender不会阻塞\",{\"1\":{\"3\":1}}],[\"每个请求按访问ip的hash结果分配\",{\"1\":{\"67\":1}}],[\"每个请求按时间顺序逐一分配到不同的后端服务器\",{\"1\":{\"67\":1}}],[\"每个模块都有一个域名\",{\"1\":{\"66\":1}}],[\"每个框架的处理机制不一样\",{\"1\":{\"61\":1}}],[\"每个类型都分两个method\",{\"1\":{\"21\":1}}],[\"每个字段都有类型\",{\"1\":{\"17\":1}}],[\"每个字段名都必须唯一\",{\"1\":{\"17\":1}}],[\"每个field都有所属数据类型\",{\"1\":{\"17\":1}}],[\"每个连接中都会被赋予server的信息\",{\"1\":{\"12\":1}}],[\"每个channel都有3种操作\",{\"1\":{\"2\":1}}],[\"每次最多并发执行10个\",{\"1\":{\"6\":1}}],[\"nginx默认采用轮询算法\",{\"1\":{\"67\":1}}],[\"nginx\",{\"1\":{\"67\":2}}],[\"nginx或者\",{\"1\":{\"67\":1}}],[\"null\",{\"1\":{\"43\":1,\"53\":4,\"63\":3}}],[\"nolock\",{\"1\":{\"32\":1}}],[\"nolockread\",{\"1\":{\"32\":2}}],[\"no\",{\"1\":{\"19\":1}}],[\"notice\",{\"1\":{\"63\":3}}],[\"nothing\",{\"1\":{\"23\":1}}],[\"not\",{\"1\":{\"12\":2,\"32\":1,\"53\":3}}],[\"name\",{\"1\":{\"17\":3,\"18\":4,\"19\":2,\"20\":6,\"45\":1,\"46\":1}}],[\"next\",{\"1\":{\"12\":3}}],[\"never\",{\"1\":{\"12\":1}}],[\"need\",{\"1\":{\"12\":1}}],[\"new一个\",{\"1\":{\"38\":1}}],[\"newmymap\",{\"1\":{\"27\":2,\"28\":2}}],[\"newbufiowritersize\",{\"1\":{\"12\":1}}],[\"newbufioreader\",{\"1\":{\"12\":1}}],[\"newconn\",{\"1\":{\"12\":1}}],[\"new\",{\"1\":{\"12\":1,\"19\":1,\"38\":1,\"63\":3,\"65\":2}}],[\"net\",{\"1\":{\"12\":4,\"54\":1,\"57\":2,\"63\":9,\"65\":3,\"67\":2}}],[\"nil\",{\"1\":{\"7\":2,\"12\":12,\"16\":1,\"23\":2}}],[\"n\",{\"1\":{\"6\":1,\"12\":1,\"23\":4}}],[\"testcookie\",{\"1\":{\"66\":1}}],[\"testcity\",{\"1\":{\"48\":2,\"49\":5}}],[\"tempdelay\",{\"1\":{\"12\":2}}],[\"table\",{\"1\":{\"44\":1,\"45\":2,\"46\":2,\"48\":1,\"49\":1,\"53\":1,\"56\":1}}],[\"tag属性用于\",{\"1\":{\"17\":1}}],[\"taskid\",{\"1\":{\"6\":3}}],[\"task\",{\"1\":{\"6\":6}}],[\"tl\",{\"1\":{\"12\":2}}],[\"try\",{\"1\":{\"63\":1}}],[\"trigger\",{\"1\":{\"63\":2}}],[\"tree索引是有序的\",{\"1\":{\"47\":1}}],[\"tree索引\",{\"1\":{\"47\":1}}],[\"trees\",{\"1\":{\"12\":1}}],[\"tree\",{\"1\":{\"12\":2}}],[\"true\",{\"1\":{\"12\":1,\"65\":4,\"66\":1}}],[\"tcp协议监听端口\",{\"1\":{\"12\":1}}],[\"tcp\",{\"1\":{\"12\":1}}],[\"think\",{\"1\":{\"61\":2}}],[\"this\",{\"1\":{\"12\":2}}],[\"than\",{\"1\":{\"53\":3}}],[\"that\",{\"1\":{\"12\":1}}],[\"throwable\",{\"1\":{\"63\":1}}],[\"throw\",{\"1\":{\"63\":2}}],[\"throw关键字抛出异常\",{\"1\":{\"63\":1}}],[\"through行为\",{\"1\":{\"7\":1}}],[\"threads\",{\"1\":{\"43\":2}}],[\"there\",{\"1\":{\"33\":1}}],[\"their\",{\"1\":{\"12\":1}}],[\"them\",{\"1\":{\"12\":1}}],[\"the\",{\"1\":{\"12\":11,\"32\":1}}],[\"to\",{\"1\":{\"12\":6,\"23\":1,\"57\":1}}],[\"t\",{\"1\":{\"6\":3,\"12\":5,\"21\":5,\"23\":9}}],[\"types\",{\"1\":{\"63\":2}}],[\"type是否开启缓存\",{\"1\":{\"55\":1}}],[\"type\",{\"1\":{\"6\":1,\"12\":1,\"17\":6,\"18\":1,\"20\":2,\"21\":5,\"22\":1,\"23\":12,\"27\":1,\"28\":1,\"32\":1,\"33\":2,\"38\":1,\"63\":4}}],[\"time`\",{\"1\":{\"53\":3}}],[\"time参数来设置日志记录行为\",{\"1\":{\"43\":1}}],[\"timer\",{\"1\":{\"8\":3}}],[\"timeout\",{\"1\":{\"8\":2,\"65\":1}}],[\"time\",{\"1\":{\"5\":2,\"6\":2,\"8\":6,\"12\":3,\"33\":6,\"53\":2,\"56\":1,\"66\":1}}],[\"案例中我们定义了一个结构体\",{\"1\":{\"27\":1,\"28\":1}}],[\"案例中我们生成100个任务\",{\"1\":{\"6\":1}}],[\"案例\",{\"1\":{\"6\":2,\"7\":1,\"27\":1,\"28\":1,\"32\":1,\"33\":1}}],[\"两种\",{\"1\":{\"57\":1}}],[\"两者都支持\",{\"1\":{\"50\":1}}],[\"两者一直处于阻塞\",{\"1\":{\"3\":1}}],[\"两次索引查找\",{\"1\":{\"49\":1}}],[\"两个字段\",{\"1\":{\"28\":1}}],[\"两个method\",{\"1\":{\"21\":1}}],[\"两个协程之间通过ch进行通信\",{\"1\":{\"5\":1}}],[\"否则f2一直阻塞\",{\"1\":{\"5\":1}}],[\"echo\",{\"1\":{\"70\":1}}],[\"e\",{\"1\":{\"63\":35}}],[\"exec\",{\"1\":{\"70\":1}}],[\"explame\",{\"1\":{\"66\":1}}],[\"expectcontinuereader\",{\"1\":{\"12\":1}}],[\"expectscontinue\",{\"1\":{\"12\":1}}],[\"expect\",{\"1\":{\"12\":2}}],[\"examples\",{\"1\":{\"65\":1}}],[\"exceptionhandler\",{\"1\":{\"63\":3}}],[\"exceptions\",{\"1\":{\"63\":1}}],[\"exception\",{\"1\":{\"63\":11}}],[\"exclusion\",{\"1\":{\"32\":1}}],[\"empty\",{\"1\":{\"22\":1}}],[\"either\",{\"1\":{\"12\":1}}],[\"even\",{\"1\":{\"12\":1}}],[\"else\",{\"1\":{\"12\":2,\"28\":1}}],[\"erraborthandler\",{\"1\":{\"12\":1}}],[\"err\",{\"1\":{\"12\":12}}],[\"errserverclosed\",{\"1\":{\"12\":1}}],[\"error的错误可以交由set\",{\"1\":{\"63\":1}}],[\"errorhandler\",{\"1\":{\"63\":2}}],[\"errorexception\",{\"1\":{\"63\":5}}],[\"errorfunc\",{\"1\":{\"63\":1}}],[\"error\",{\"1\":{\"4\":1,\"6\":1,\"12\":2,\"63\":31}}],[\"en\",{\"1\":{\"63\":2}}],[\"enable\",{\"1\":{\"46\":1}}],[\"engine=innodb\",{\"1\":{\"53\":1}}],[\"engine\",{\"1\":{\"12\":18,\"53\":3}}],[\"end\",{\"1\":{\"5\":2}}],[\"3128\",{\"1\":{\"67\":2}}],[\"3600\",{\"1\":{\"65\":1,\"66\":1}}],[\"3625522\",{\"1\":{\"53\":1}}],[\"34\",{\"1\":{\"38\":2}}],[\"30\",{\"1\":{\"23\":1,\"53\":1}}],[\"33\",{\"1\":{\"22\":1}}],[\"3秒后才会被触发去执行某些事\",{\"1\":{\"8\":1}}],[\"3\",{\"1\":{\"5\":1,\"6\":1,\"8\":2,\"33\":2,\"38\":8,\"48\":2,\"57\":1}}],[\"distinct\",{\"1\":{\"48\":1,\"49\":2}}],[\"disable\",{\"1\":{\"45\":1}}],[\"dictionary\",{\"1\":{\"16\":1}}],[\"data\",{\"1\":{\"33\":5,\"38\":1}}],[\"dddd\",{\"1\":{\"20\":1}}],[\"duration\",{\"1\":{\"12\":1}}],[\"d\",{\"1\":{\"6\":1}}],[\"domain\",{\"1\":{\"66\":6}}],[\"domin\",{\"1\":{\"66\":1}}],[\"docs\",{\"1\":{\"57\":1}}],[\"do\",{\"1\":{\"6\":2,\"7\":2}}],[\"done\",{\"1\":{\"5\":2,\"6\":2,\"7\":2,\"27\":1,\"28\":1,\"32\":1,\"33\":3}}],[\"decr\",{\"1\":{\"69\":1}}],[\"destroy\",{\"1\":{\"65\":1}}],[\"deprecated\",{\"1\":{\"63\":3}}],[\"deployed\",{\"1\":{\"12\":1}}],[\"details\",{\"1\":{\"54\":1,\"57\":2,\"67\":2}}],[\"deepequal\",{\"1\":{\"19\":2}}],[\"delete\",{\"1\":{\"16\":2,\"27\":4,\"28\":3}}],[\"delegates\",{\"1\":{\"12\":1}}],[\"defalut语句是可选的\",{\"1\":{\"7\":1}}],[\"default404body\",{\"1\":{\"12\":1}}],[\"defaultservemux\",{\"1\":{\"12\":2}}],[\"default\",{\"1\":{\"7\":1,\"23\":1,\"53\":2}}],[\"defer\",{\"1\":{\"5\":3,\"6\":1,\"7\":2,\"12\":2,\"27\":4,\"28\":1,\"32\":3,\"33\":6}}],[\"deadlock\",{\"0\":{\"4\":1},\"1\":{\"4\":1,\"6\":1}}],[\"27093465\",{\"1\":{\"67\":1}}],[\"21\",{\"1\":{\"38\":2}}],[\"25倍\",{\"1\":{\"38\":2}}],[\"2倍或者1\",{\"1\":{\"38\":1}}],[\"22\",{\"1\":{\"22\":1}}],[\"2\",{\"1\":{\"5\":1,\"7\":1,\"12\":1,\"22\":1,\"38\":12,\"57\":1,\"63\":3}}],[\"20\",{\"1\":{\"3\":1,\"38\":2}}],[\"wpjamer\",{\"1\":{\"67\":1}}],[\"www\",{\"1\":{\"53\":1,\"54\":1,\"57\":1,\"63\":1,\"66\":1,\"67\":1}}],[\"where条件要包含分区列\",{\"1\":{\"53\":1}}],[\"where\",{\"1\":{\"49\":2,\"53\":1}}],[\"world\",{\"1\":{\"22\":1}}],[\"warning\",{\"1\":{\"63\":5}}],[\"was\",{\"1\":{\"12\":1}}],[\"wait\",{\"1\":{\"5\":1,\"6\":1,\"7\":1,\"27\":1,\"28\":1,\"32\":1,\"33\":1}}],[\"waitgroup\",{\"1\":{\"5\":1,\"6\":1,\"7\":1,\"27\":1,\"28\":1,\"32\":1,\"33\":1}}],[\"write\",{\"1\":{\"65\":2}}],[\"writersem\",{\"1\":{\"33\":1}}],[\"writers\",{\"1\":{\"33\":1}}],[\"writermem\",{\"1\":{\"12\":3}}],[\"writeheadernow\",{\"1\":{\"12\":1}}],[\"wrap\",{\"1\":{\"12\":1}}],[\"wild\",{\"1\":{\"12\":1}}],[\"wire\",{\"1\":{\"12\":1}}],[\"with\",{\"1\":{\"12\":1}}],[\"withcancel\",{\"1\":{\"12\":1}}],[\"withvalue\",{\"1\":{\"12\":2}}],[\"weight=10\",{\"1\":{\"67\":2}}],[\"weight和访问比率成正比\",{\"1\":{\"67\":1}}],[\"web开发中主要使用\",{\"1\":{\"67\":1}}],[\"well\",{\"1\":{\"12\":1}}],[\"we\",{\"1\":{\"12\":5}}],[\"w\",{\"1\":{\"12\":18,\"33\":1}}],[\"wg\",{\"1\":{\"5\":5,\"6\":4,\"7\":5,\"27\":4,\"28\":4,\"32\":4,\"33\":6}}],[\"sale\",{\"1\":{\"69\":2}}],[\"save\",{\"1\":{\"65\":1}}],[\"syssession\",{\"1\":{\"65\":2}}],[\"sync\",{\"0\":{\"32\":1,\"33\":1,\"34\":1},\"1\":{\"5\":1,\"6\":1,\"7\":1,\"27\":2,\"28\":1,\"32\":3,\"33\":4}}],[\"spl\",{\"1\":{\"63\":1}}],[\"spl提供了一系列标准异常\",{\"1\":{\"63\":1}}],[\"sphinxsearch\",{\"1\":{\"57\":1}}],[\"sphinx全文索引\",{\"1\":{\"57\":1}}],[\"squid2\",{\"1\":{\"67\":1}}],[\"squid1\",{\"1\":{\"67\":1}}],[\"square\",{\"1\":{\"23\":2}}],[\"sql\",{\"1\":{\"56\":1}}],[\"sql语句查看当前连接线程是否有废线程\",{\"1\":{\"43\":1}}],[\"sql语句查看当前连接数\",{\"1\":{\"43\":1}}],[\"switch\",{\"0\":{\"23\":1},\"1\":{\"23\":2}}],[\"slave\",{\"1\":{\"57\":1}}],[\"slow\",{\"1\":{\"56\":1}}],[\"sliceheader\",{\"1\":{\"38\":1}}],[\"slice\",{\"1\":{\"16\":1,\"19\":1,\"22\":1,\"38\":6},\"2\":{\"40\":1}}],[\"sleep\",{\"1\":{\"5\":1,\"6\":1,\"12\":1,\"33\":3}}],[\"shutdown\",{\"1\":{\"63\":3,\"65\":1}}],[\"shuttingdown\",{\"1\":{\"12\":1}}],[\"show\",{\"1\":{\"43\":1}}],[\"sh\",{\"1\":{\"12\":2}}],[\"soar\",{\"1\":{\"57\":1}}],[\"sound\",{\"1\":{\"17\":1}}],[\"so\",{\"1\":{\"12\":1}}],[\"simultaneous\",{\"1\":{\"12\":1}}],[\"size缓冲池大小\",{\"1\":{\"56\":1}}],[\"size查询缓存的总内存空间\",{\"1\":{\"55\":1}}],[\"size\",{\"1\":{\"12\":2,\"56\":2}}],[\"support\",{\"1\":{\"12\":1}}],[\"success\",{\"1\":{\"6\":1}}],[\"s\",{\"1\":{\"12\":2}}],[\"srv即为server\",{\"1\":{\"12\":1}}],[\"srv\",{\"1\":{\"12\":14}}],[\"stuct等等\",{\"1\":{\"16\":1}}],[\"store进行\",{\"1\":{\"69\":1}}],[\"store\",{\"1\":{\"12\":1,\"69\":4}}],[\"start\",{\"1\":{\"65\":1}}],[\"startbackgroundread\",{\"1\":{\"12\":2}}],[\"stack\",{\"1\":{\"12\":1}}],[\"statement\",{\"1\":{\"57\":1}}],[\"state\",{\"1\":{\"32\":1}}],[\"stateactive\",{\"1\":{\"12\":1}}],[\"stateclosed\",{\"1\":{\"12\":1}}],[\"statenew\",{\"1\":{\"12\":1}}],[\"statusnotfound\",{\"1\":{\"12\":1}}],[\"status\",{\"1\":{\"6\":2,\"43\":1,\"57\":1}}],[\"strpos\",{\"1\":{\"63\":1}}],[\"strconv\",{\"1\":{\"28\":1}}],[\"strict\",{\"1\":{\"63\":5}}],[\"strictly\",{\"1\":{\"12\":1}}],[\"string需要拷贝\",{\"1\":{\"18\":1}}],[\"string\",{\"1\":{\"6\":1,\"12\":1,\"16\":5,\"17\":4,\"18\":2,\"19\":3,\"20\":5,\"27\":5,\"28\":5,\"33\":5}}],[\"struct等\",{\"1\":{\"22\":1}}],[\"struct是可以比较\",{\"1\":{\"19\":1}}],[\"struct的比较\",{\"0\":{\"19\":1}}],[\"struct的方法\",{\"0\":{\"18\":1}}],[\"struct可以嵌套自身的特性使之在实现树和链表上更加方便\",{\"1\":{\"17\":1}}],[\"struct能够实现面向对象中的重写\",{\"1\":{\"17\":1}}],[\"struct中的字段可以不用给名称\",{\"1\":{\"17\":1}}],[\"struct定义结构\",{\"1\":{\"17\":1}}],[\"struct类型都不能作为key\",{\"1\":{\"16\":1}}],[\"struct\",{\"0\":{\"15\":1,\"17\":1},\"1\":{\"6\":1,\"12\":1,\"17\":4,\"18\":1,\"20\":1,\"27\":1,\"28\":1,\"32\":1,\"33\":2,\"38\":1},\"2\":{\"25\":1}}],[\"sessionhandlerinterface\",{\"1\":{\"65\":1}}],[\"session\",{\"1\":{\"65\":8}}],[\"session和cookie的关系\",{\"1\":{\"65\":1}}],[\"sel的值越接近1越好\",{\"1\":{\"48\":1}}],[\"sel\",{\"1\":{\"48\":1}}],[\"select的方式进行使用\",{\"1\":{\"8\":1}}],[\"select的行为模式主要是对channel是否可读进行轮询\",{\"1\":{\"7\":1}}],[\"select将会结束\",{\"1\":{\"7\":1}}],[\"select确实是随机选择case进行执行\",{\"1\":{\"7\":1}}],[\"select会放在一个无限循环语句中\",{\"1\":{\"7\":1}}],[\"select会被return\",{\"1\":{\"7\":1}}],[\"select所在goroutine才会被阻塞\",{\"1\":{\"7\":1}}],[\"select\",{\"1\":{\"7\":2,\"8\":5,\"48\":1,\"49\":3,\"53\":1}}],[\"select多路监听\",{\"0\":{\"7\":1}}],[\"security\",{\"1\":{\"65\":2}}],[\"section\",{\"1\":{\"32\":1}}],[\"second\",{\"1\":{\"5\":1,\"6\":1,\"8\":2,\"33\":3}}],[\"sema\",{\"1\":{\"32\":1}}],[\"serialized\",{\"1\":{\"12\":1}}],[\"serving\",{\"1\":{\"12\":1}}],[\"serveerror\",{\"1\":{\"12\":1}}],[\"serve中\",{\"1\":{\"12\":1}}],[\"serve\",{\"1\":{\"12\":5}}],[\"server2\",{\"1\":{\"67\":1}}],[\"server1\",{\"1\":{\"67\":1}}],[\"serverhandler\",{\"1\":{\"12\":5}}],[\"servercontextkey\",{\"1\":{\"12\":1}}],[\"server\",{\"1\":{\"12\":10,\"67\":10}}],[\"servehttp\",{\"1\":{\"12\":8}}],[\"setcookie\",{\"1\":{\"66\":1}}],[\"setexprie\",{\"1\":{\"65\":1}}],[\"set由值类型和指针类型的receiver共同组成\",{\"1\":{\"21\":1}}],[\"set由不同receiver类型的方法组成\",{\"1\":{\"21\":1}}],[\"set只由值类型的receiver\",{\"1\":{\"21\":1}}],[\"set\",{\"1\":{\"21\":3,\"63\":8,\"65\":1}}],[\"setage\",{\"1\":{\"18\":6}}],[\"setname\",{\"1\":{\"18\":5,\"20\":3}}],[\"setreaddeadline\",{\"1\":{\"12\":1}}],[\"settrue\",{\"1\":{\"12\":1}}],[\"setstate\",{\"1\":{\"12\":3}}],[\"sendexpectationfailed\",{\"1\":{\"12\":1}}],[\"sender\",{\"1\":{\"4\":2}}],[\"sender每发送一个数据\",{\"1\":{\"3\":1}}],[\"sender发送一个数据\",{\"1\":{\"3\":1}}],[\"sender端可以向channel中send多个数据\",{\"1\":{\"3\":1}}],[\"sender端向channel中send一个数据\",{\"1\":{\"3\":1}}],[\"send的时候会直接阻塞main\",{\"1\":{\"4\":1}}],[\"send和recv是一个整体行为\",{\"1\":{\"3\":1}}],[\"send操作将导致painc\",{\"1\":{\"2\":1}}],[\"send\",{\"1\":{\"2\":2,\"3\":2,\"4\":3}}],[\"解决方法\",{\"1\":{\"4\":1}}],[\"atomicinteger\",{\"1\":{\"69\":1}}],[\"apache\",{\"1\":{\"67\":1}}],[\"append\",{\"1\":{\"38\":2}}],[\"ajax模式下错误响应\",{\"1\":{\"63\":1}}],[\"adparking\",{\"1\":{\"57\":1}}],[\"add方法中使用了互斥锁\",{\"1\":{\"32\":1}}],[\"addr\",{\"1\":{\"12\":6}}],[\"add\",{\"1\":{\"5\":1,\"6\":1,\"7\":1,\"27\":3,\"28\":4,\"32\":3,\"33\":4,\"48\":1,\"49\":1}}],[\"away\",{\"1\":{\"57\":1}}],[\"auto\",{\"1\":{\"53\":1}}],[\"argv\",{\"1\":{\"61\":1}}],[\"articles\",{\"1\":{\"67\":1}}],[\"article\",{\"1\":{\"54\":1,\"57\":2,\"67\":2}}],[\"array\",{\"1\":{\"63\":4}}],[\"arr\",{\"1\":{\"38\":1}}],[\"are\",{\"1\":{\"4\":1,\"6\":1,\"33\":1}}],[\"age实际上等价于\",{\"1\":{\"18\":1}}],[\"age\",{\"1\":{\"17\":4,\"18\":5,\"38\":2}}],[\"alter\",{\"1\":{\"44\":1,\"45\":1,\"46\":1,\"48\":1,\"49\":1}}],[\"also\",{\"1\":{\"12\":1}}],[\"allnoroute\",{\"1\":{\"12\":1}}],[\"all\",{\"1\":{\"4\":1,\"6\":1,\"12\":1,\"63\":3}}],[\"as\",{\"1\":{\"12\":1,\"48\":1,\"49\":2}}],[\"asleep\",{\"1\":{\"4\":1,\"6\":1}}],[\"an\",{\"1\":{\"32\":1}}],[\"animal\",{\"1\":{\"17\":2}}],[\"answer\",{\"1\":{\"12\":1}}],[\"and\",{\"1\":{\"12\":2,\"53\":1}}],[\"another\",{\"1\":{\"12\":1}}],[\"any\",{\"1\":{\"12\":1,\"22\":5}}],[\"acid指\",{\"1\":{\"42\":1}}],[\"active\",{\"1\":{\"12\":2}}],[\"accept\",{\"1\":{\"12\":2}}],[\"a\",{\"1\":{\"12\":1,\"16\":2,\"27\":1,\"28\":1,\"32\":4,\"33\":1,\"63\":1,\"66\":2}}],[\"after进行初始化\",{\"1\":{\"8\":1}}],[\"after\",{\"1\":{\"8\":4,\"32\":1}}],[\"此channel中recv的操作<\",{\"1\":{\"4\":1}}],[\"此时ch是一个nil\",{\"1\":{\"2\":2}}],[\"向unbuffered\",{\"1\":{\"4\":1}}],[\"另一端正好在期待本端的操作时\",{\"1\":{\"4\":1}}],[\"操作并判断是否小于0\",{\"1\":{\"69\":1}}],[\"操作在大多数情况下都会锁表\",{\"1\":{\"44\":1}}],[\"操作只是对读锁数量减1\",{\"1\":{\"33\":1}}],[\"操作\",{\"1\":{\"4\":1,\"69\":1}}],[\"期待另一端的\",{\"1\":{\"4\":1}}],[\"死锁\",{\"0\":{\"4\":1}}],[\"于是sender被阻塞\",{\"1\":{\"3\":1}}],[\"都属于\",{\"1\":{\"66\":1}}],[\"都会拷贝整个实例对象\",{\"1\":{\"18\":1}}],[\"都会重新初始化一个全新的计时器\",{\"1\":{\"8\":1}}],[\"都是拷贝指针\",{\"1\":{\"18\":2}}],[\"都是拷贝整个底层数据结构的\",{\"1\":{\"18\":1}}],[\"都是按值传递的\",{\"1\":{\"18\":1}}],[\"都是在向channel发送请求\",{\"1\":{\"3\":1}}],[\"都返回数据对象的指针给变量\",{\"1\":{\"17\":1}}],[\"都将会阻塞\",{\"1\":{\"2\":1}}],[\"无法加载读锁\",{\"1\":{\"33\":1}}],[\"无论是指针类型的实例p1还是值类型的p2\",{\"1\":{\"18\":1}}],[\"无论是使用值类型的实例还是指针类型的实例\",{\"1\":{\"18\":2}}],[\"无论是send还是recv操作\",{\"1\":{\"3\":1}}],[\"无视它们的类型\",{\"1\":{\"18\":1}}],[\"无缓冲同步通信示例\",{\"0\":{\"5\":1}}],[\"无缓冲\",{\"1\":{\"3\":3}}],[\"并在每次运行时进行gc操作\",{\"1\":{\"65\":1}}],[\"并做适当处理\",{\"1\":{\"63\":1}}],[\"并通过goruntine来处理这个连接\",{\"1\":{\"12\":1}}],[\"并发安全的map\",{\"0\":{\"27\":1}}],[\"并发安全\",{\"2\":{\"10\":1,\"30\":1,\"36\":1}}],[\"并发送第二个数据的时候才被阻塞\",{\"1\":{\"3\":1}}],[\"并退出此次select\",{\"1\":{\"7\":1}}],[\"并报错\",{\"1\":{\"4\":1}}],[\"并且重建整表\",{\"1\":{\"44\":1}}],[\"并且是非线程安全的\",{\"1\":{\"27\":1}}],[\"并且不会推出main\",{\"1\":{\"8\":1}}],[\"并且遵循了\",{\"1\":{\"1\":1}}],[\"并且在用户态上实现了属于自己的调度模型\",{\"1\":{\"1\":1}}],[\"0\",{\"1\":{\"3\":1,\"6\":1,\"7\":1,\"8\":2,\"12\":3,\"22\":1,\"32\":1,\"33\":1,\"38\":9,\"63\":6,\"67\":6,\"70\":1}}],[\"先进先出\",{\"1\":{\"3\":1}}],[\"先发送数据的\",{\"1\":{\"1\":1}}],[\"<0\",{\"1\":{\"69\":1}}],[\"<<\",{\"1\":{\"12\":1}}],[\"<\",{\"1\":{\"3\":4,\"4\":7,\"5\":2,\"6\":7,\"7\":7,\"8\":6,\"12\":2,\"27\":1,\"28\":7,\"32\":1,\"33\":1,\"63\":2,\"66\":1,\"70\":1}}],[\"ip绑定\",{\"1\":{\"67\":1}}],[\"ip\",{\"1\":{\"65\":1,\"67\":4}}],[\"ivictor\",{\"1\":{\"57\":1}}],[\"id选项\",{\"1\":{\"57\":1}}],[\"id\",{\"1\":{\"49\":1}}],[\"idx\",{\"1\":{\"49\":1}}],[\"import\",{\"1\":{\"33\":1}}],[\"implements\",{\"1\":{\"65\":1}}],[\"implement\",{\"1\":{\"12\":1}}],[\"isfatal\",{\"1\":{\"63\":1}}],[\"is\",{\"1\":{\"12\":1,\"32\":2,\"63\":1}}],[\"itkingone\",{\"1\":{\"67\":1}}],[\"itoa\",{\"1\":{\"28\":1}}],[\"it\",{\"1\":{\"12\":2}}],[\"incr\",{\"1\":{\"69\":1}}],[\"increment\",{\"1\":{\"53\":1}}],[\"ini\",{\"1\":{\"65\":1}}],[\"init\",{\"1\":{\"63\":1}}],[\"initialreadlimitsize\",{\"1\":{\"12\":1}}],[\"innodb\",{\"1\":{\"53\":3,\"56\":2}}],[\"innodb的数据和索引放在一起\",{\"1\":{\"50\":1}}],[\"innodb的索引策略是聚簇索引\",{\"1\":{\"42\":1}}],[\"innodb中使用聚簇索引的方式存储数据\",{\"1\":{\"50\":1}}],[\"innodb存储引擎支持\",{\"1\":{\"49\":1}}],[\"innodb采用聚簇索引的方式存储数据\",{\"1\":{\"42\":1}}],[\"innodb支持热备份\",{\"1\":{\"42\":1}}],[\"innodb支持事务\",{\"1\":{\"42\":1}}],[\"innodb使用mvcc实现并发控制\",{\"1\":{\"42\":1}}],[\"ins\",{\"1\":{\"23\":9}}],[\"index\",{\"1\":{\"12\":2,\"61\":1,\"63\":1}}],[\"index++\",{\"1\":{\"12\":2}}],[\"in通道只用于接收数据\",{\"1\":{\"6\":1}}],[\"in\",{\"1\":{\"6\":1,\"12\":4,\"63\":1}}],[\"int1切片的data属性的指针地址和ints的指针地址是一样的\",{\"1\":{\"38\":1}}],[\"int1\",{\"1\":{\"38\":13}}],[\"ints\",{\"1\":{\"38\":14}}],[\"int32\",{\"1\":{\"32\":1,\"33\":2}}],[\"inter\",{\"1\":{\"17\":1}}],[\"interface类型断言和type\",{\"0\":{\"23\":1}}],[\"interface\",{\"0\":{\"15\":1,\"20\":1},\"1\":{\"12\":1,\"20\":2,\"22\":3,\"23\":1},\"2\":{\"25\":1}}],[\"int8\",{\"1\":{\"12\":1}}],[\"int64\",{\"1\":{\"6\":2}}],[\"int\",{\"1\":{\"2\":2,\"3\":4,\"4\":3,\"5\":1,\"6\":6,\"7\":4,\"8\":2,\"16\":5,\"17\":3,\"18\":2,\"22\":2,\"23\":2,\"27\":5,\"28\":6,\"32\":4,\"33\":8,\"38\":7,\"53\":3,\"63\":1}}],[\"if\",{\"1\":{\"3\":1,\"7\":2,\"12\":23,\"19\":1,\"23\":2,\"28\":1,\"33\":1,\"38\":1,\"63\":2,\"69\":2,\"70\":1}}],[\"i++\",{\"1\":{\"3\":1,\"6\":2,\"7\":1,\"8\":2,\"12\":1,\"27\":1,\"28\":1,\"32\":1,\"33\":1}}],[\"i\",{\"1\":{\"3\":7,\"6\":12,\"7\":8,\"8\":4,\"12\":4,\"16\":1,\"22\":1,\"23\":2,\"27\":5,\"28\":7,\"32\":3,\"33\":11}}],[\"15\",{\"1\":{\"67\":3}}],[\"1500000000\",{\"1\":{\"53\":2}}],[\"14\",{\"1\":{\"67\":3}}],[\"1400000000\",{\"1\":{\"53\":2}}],[\"168\",{\"1\":{\"67\":6}}],[\"192\",{\"1\":{\"67\":6}}],[\"18\",{\"1\":{\"38\":2}}],[\"11\",{\"1\":{\"22\":2,\"53\":3}}],[\"1是在main\",{\"1\":{\"4\":1}}],[\"1\",{\"1\":{\"3\":1,\"4\":5,\"5\":1,\"6\":3,\"12\":3,\"16\":1,\"22\":1,\"27\":2,\"28\":2,\"32\":1,\"38\":7,\"57\":1,\"63\":2,\"69\":2}}],[\"1024\",{\"1\":{\"38\":2}}],[\"100\",{\"1\":{\"6\":2,\"12\":1}}],[\"10\",{\"1\":{\"3\":2,\"6\":2,\"7\":2,\"8\":2,\"12\":1,\"27\":1,\"28\":1,\"32\":1,\"49\":2}}],[\"features\",{\"1\":{\"65\":1}}],[\"free\",{\"1\":{\"43\":1}}],[\"from\",{\"1\":{\"12\":1,\"48\":1,\"49\":3,\"53\":1}}],[\"fullpath\",{\"1\":{\"12\":2}}],[\"function\",{\"1\":{\"12\":1,\"19\":1,\"63\":13,\"65\":9}}],[\"func\",{\"1\":{\"3\":4,\"4\":4,\"5\":3,\"6\":5,\"7\":4,\"8\":4,\"12\":9,\"16\":1,\"18\":2,\"19\":1,\"20\":2,\"27\":6,\"28\":12,\"32\":5,\"33\":11,\"38\":2}}],[\"file=\",{\"1\":{\"57\":1}}],[\"file\",{\"1\":{\"56\":1,\"61\":1,\"63\":3}}],[\"first\",{\"1\":{\"32\":1}}],[\"field除了名称和数据类型\",{\"1\":{\"17\":1}}],[\"field\",{\"1\":{\"17\":1}}],[\"find\",{\"1\":{\"12\":2,\"27\":3,\"28\":3}}],[\"finishrequest\",{\"1\":{\"12\":1}}],[\"fifo\",{\"1\":{\"1\":1,\"3\":1}}],[\"fair\",{\"1\":{\"67\":2}}],[\"failure\",{\"1\":{\"12\":1}}],[\"false\",{\"1\":{\"12\":1,\"63\":1,\"66\":1,\"69\":2,\"70\":1}}],[\"fatalexceptionfromerror\",{\"1\":{\"63\":1}}],[\"fatal\",{\"1\":{\"4\":1,\"6\":1}}],[\"f2\",{\"1\":{\"5\":3}}],[\"f1\",{\"1\":{\"5\":3}}],[\"format\",{\"1\":{\"57\":1}}],[\"for在循环时\",{\"1\":{\"8\":1}}],[\"for+select\",{\"1\":{\"8\":1}}],[\"for\",{\"1\":{\"3\":2,\"6\":3,\"7\":2,\"8\":5,\"12\":5,\"16\":1,\"22\":1,\"27\":1,\"28\":2,\"32\":2,\"33\":1,\"38\":1}}],[\"fmt\",{\"1\":{\"3\":5,\"4\":5,\"5\":2,\"6\":1,\"7\":4,\"19\":2,\"20\":1,\"22\":1,\"23\":6,\"38\":8}}],[\"阻塞和不阻塞是由channel控制的\",{\"1\":{\"3\":1}}],[\"阻塞\",{\"1\":{\"3\":1}}],[\"有的时候我们一个网站有很多服务模块\",{\"1\":{\"66\":1}}],[\"有的时候php本身对错误的处理难以满足我们的业务需求\",{\"1\":{\"63\":1}}],[\"有利于后期排查\",{\"1\":{\"63\":2}}],[\"有写锁时优先进行写锁定\",{\"1\":{\"33\":1}}],[\"有写锁时\",{\"1\":{\"33\":1}}],[\"有以下两个名称冲突的规则\",{\"1\":{\"17\":1}}],[\"有缓冲chan一般在进行并发限制的时候用的较多\",{\"1\":{\"6\":1}}],[\"有缓冲chan\",{\"0\":{\"6\":1}}],[\"有缓冲\",{\"1\":{\"3\":3}}],[\"有属于自己的栈空间\",{\"1\":{\"1\":1}}],[\"只能保证map是线程安全的\",{\"1\":{\"32\":1}}],[\"只有在unlock后才会解除阻塞\",{\"1\":{\"32\":1}}],[\"只用于接收数据的通道<\",{\"1\":{\"6\":1}}],[\"只需将send操作放在另一个goroutine中执行即可\",{\"1\":{\"4\":1}}],[\"只要receiver是指针类型的\",{\"1\":{\"18\":1}}],[\"只要receiver是值类型的\",{\"1\":{\"18\":1}}],[\"只要有一个case满足条件\",{\"1\":{\"7\":1}}],[\"只要所有goroutine都被阻塞\",{\"1\":{\"4\":1}}],[\"只要channel未关闭\",{\"1\":{\"6\":1}}],[\"只要channel非空\",{\"1\":{\"3\":1}}],[\"只要channel容量未满\",{\"1\":{\"3\":2}}],[\"只在sender端上显式使用close\",{\"1\":{\"2\":1}}],[\"只不过\",{\"1\":{\"1\":2}}],[\"在服务端控制层需要针对同一个访问uid\",{\"1\":{\"69\":1}}],[\"在前端和后端服务之间增加一个中间层\",{\"1\":{\"69\":1}}],[\"在某一时间段内只允许用户提交一次请求\",{\"1\":{\"69\":1}}],[\"在某些时候可以自动被关闭\",{\"1\":{\"2\":1}}],[\"在时间范围内\",{\"1\":{\"69\":1}}],[\"在web开发中\",{\"1\":{\"65\":1}}],[\"在php\",{\"1\":{\"67\":1}}],[\"在php中通过上述代码就可以让a\",{\"1\":{\"66\":1}}],[\"在php中采用\",{\"1\":{\"63\":1}}],[\"在php7以上\",{\"1\":{\"63\":1}}],[\"在主服务器上创建一个复制账号\",{\"1\":{\"57\":1}}],[\"在高并发的情况下建议关闭查询缓存\",{\"1\":{\"55\":1}}],[\"在进行分区查询的时候\",{\"1\":{\"53\":1}}],[\"在内存中直接搜索索引\",{\"1\":{\"50\":1}}],[\"在设计innodb主键的时候\",{\"1\":{\"49\":1}}],[\"在实际业务中可以通过使用相同的列不同的顺序来创建更多的索引\",{\"1\":{\"47\":1}}],[\"在order\",{\"1\":{\"47\":1}}],[\"在并发高的情况下进行读写操作的时候性能很差\",{\"1\":{\"42\":1}}],[\"在底层数组上int1是ints的子集\",{\"1\":{\"38\":1}}],[\"在编译器会固定大小\",{\"1\":{\"38\":1}}],[\"在另一个地方不lock\",{\"1\":{\"32\":1}}],[\"在这一区间内的代码是严格被lock\",{\"1\":{\"32\":1}}],[\"在lock\",{\"1\":{\"32\":1}}],[\"在对实例初始化的时候\",{\"1\":{\"28\":1}}],[\"在上个总结的线程安全的map一文中是有一处错误的\",{\"1\":{\"32\":1}}],[\"在上一个总结中我们在实现线程安全的map的时候用到了锁的概念\",{\"1\":{\"31\":1}}],[\"在上一个总结中我们知道map是引用类型的\",{\"1\":{\"27\":1}}],[\"在上面horse中嵌套了其它的struct\",{\"1\":{\"17\":1}}],[\"在上面的示例中\",{\"1\":{\"4\":1}}],[\"在不能转换时\",{\"1\":{\"23\":1}}],[\"在有需要的时候\",{\"1\":{\"23\":1}}],[\"在数据结构中存储任意类型的数据\",{\"1\":{\"22\":1}}],[\"在\",{\"1\":{\"19\":1,\"67\":1}}],[\"在需要的时候\",{\"1\":{\"18\":1}}],[\"在struct中\",{\"1\":{\"17\":1}}],[\"在select查询中加上limit关键字\",{\"1\":{\"51\":1}}],[\"在serverhandler的servehttp方法中判断server的handler是否为nil\",{\"1\":{\"12\":1}}],[\"在sender和receiver接收到ok消息之前\",{\"1\":{\"3\":1}}],[\"在函数中我们传递一个对象的实例可以是对象的值也可以是对象的指针\",{\"1\":{\"17\":1}}],[\"在函数中map作为参数传递时\",{\"1\":{\"16\":1}}],[\"在一个struct中\",{\"1\":{\"17\":1}}],[\"在其它地方常称为hash\",{\"1\":{\"16\":1}}],[\"在定时任务未到期之前\",{\"1\":{\"8\":1}}],[\"在使用的时候要正确使用\",{\"1\":{\"8\":1}}],[\"在使用send的时候\",{\"1\":{\"7\":1}}],[\"在go语言中数组是固定长度的\",{\"1\":{\"38\":1}}],[\"在goruntine中已有的锁在没有被释放前去获取锁\",{\"1\":{\"32\":1}}],[\"在go中允许这样\",{\"1\":{\"32\":1}}],[\"在go中map的元素是无序的\",{\"1\":{\"16\":1}}],[\"在go中提供了定时器功能\",{\"1\":{\"8\":1}}],[\"在go的内部行为中\",{\"1\":{\"3\":1}}],[\"在task的do方法中我们使用指向的chan\",{\"1\":{\"6\":1}}],[\"在任务执行之前对chan进行写操作\",{\"1\":{\"6\":1}}],[\"在多并发操作里是属于协程安全的\",{\"1\":{\"1\":1}}],[\"cdn加速\",{\"1\":{\"69\":1}}],[\"class\",{\"1\":{\"63\":5,\"65\":1}}],[\"close并非强制需要使用close\",{\"1\":{\"2\":1}}],[\"close\",{\"1\":{\"2\":1,\"3\":3,\"5\":1,\"6\":1,\"7\":4,\"12\":1,\"28\":1,\"65\":2}}],[\"csdn\",{\"1\":{\"54\":1,\"57\":2,\"67\":2}}],[\"cnblogs\",{\"1\":{\"53\":1,\"54\":1,\"57\":1,\"66\":1,\"67\":1}}],[\"crc32\",{\"1\":{\"67\":1}}],[\"create\",{\"1\":{\"53\":1}}],[\"critical\",{\"1\":{\"32\":1}}],[\"c>x\",{\"1\":{\"49\":1}}],[\"cityid\",{\"1\":{\"49\":9}}],[\"city\",{\"1\":{\"48\":3}}],[\"circle\",{\"1\":{\"23\":2}}],[\"cookie\",{\"1\":{\"65\":2}}],[\"core\",{\"1\":{\"63\":3}}],[\"com进行cookie之间的相互传递\",{\"1\":{\"66\":1}}],[\"compile\",{\"1\":{\"63\":4}}],[\"com\",{\"1\":{\"53\":1,\"54\":1,\"57\":2,\"66\":8,\"67\":1}}],[\"count\",{\"1\":{\"48\":2,\"49\":4}}],[\"could\",{\"1\":{\"12\":1}}],[\"copied\",{\"1\":{\"32\":1}}],[\"control\",{\"1\":{\"63\":1}}],[\"contentlength\",{\"1\":{\"12\":1}}],[\"context\",{\"1\":{\"12\":12}}],[\"continue\",{\"1\":{\"12\":2}}],[\"construct\",{\"1\":{\"65\":1}}],[\"constants\",{\"1\":{\"63\":1}}],[\"const\",{\"1\":{\"12\":1}}],[\"connected\",{\"1\":{\"43\":1}}],[\"connections\",{\"1\":{\"56\":1}}],[\"connection\",{\"1\":{\"12\":1}}],[\"connreader\",{\"1\":{\"12\":1}}],[\"conn\",{\"1\":{\"12\":4}}],[\"conncontext\",{\"1\":{\"12\":2}}],[\"connctx\",{\"1\":{\"12\":5}}],[\"conforms\",{\"1\":{\"12\":1}}],[\"curreq\",{\"1\":{\"12\":1}}],[\"catch\",{\"1\":{\"63\":1}}],[\"callable\",{\"1\":{\"63\":1}}],[\"cache\",{\"1\":{\"55\":2,\"56\":1}}],[\"cap为4的int类型切片\",{\"1\":{\"38\":1}}],[\"cap\",{\"1\":{\"38\":5}}],[\"cannot\",{\"1\":{\"12\":1}}],[\"canwritecontinue\",{\"1\":{\"12\":1}}],[\"cancelctx\",{\"1\":{\"12\":5}}],[\"can\",{\"1\":{\"12\":2}}],[\"case结构用于做多种类型的探测\",{\"1\":{\"23\":1}}],[\"case\",{\"1\":{\"7\":4,\"8\":4,\"23\":3}}],[\"cc\",{\"1\":{\"12\":3}}],[\"ctx\",{\"1\":{\"12\":9}}],[\"c\",{\"1\":{\"12\":60,\"49\":1,\"63\":1}}],[\"charset=utf8\",{\"1\":{\"53\":1}}],[\"change\",{\"1\":{\"57\":1}}],[\"chan不可被关闭\",{\"1\":{\"6\":1}}],[\"chan<\",{\"1\":{\"6\":1}}],[\"chan进行send\",{\"1\":{\"2\":1}}],[\"chan\",{\"1\":{\"2\":4,\"3\":4,\"4\":4,\"5\":1,\"6\":5,\"7\":2,\"8\":2,\"28\":3}}],[\"channel的实现只能保证这个map在并发读写的时候不会panic\",{\"1\":{\"28\":1}}],[\"channel的两种分类\",{\"0\":{\"3\":1}}],[\"channel实现并发安全的map\",{\"0\":{\"28\":1}}],[\"channel等等\",{\"1\":{\"17\":1}}],[\"channel中send数据的操作ch\",{\"1\":{\"4\":1}}],[\"channel中按序receive其中数据\",{\"1\":{\"3\":1}}],[\"channel不会返回ok消息\",{\"1\":{\"3\":1}}],[\"channel不会向sender返回ok\",{\"1\":{\"3\":1}}],[\"channel都会向其返回ok消息\",{\"1\":{\"3\":1}}],[\"channel都会向sender的请求直接返回一个ok消息\",{\"1\":{\"3\":1}}],[\"channel才会向sender和receiver双方发送ok消息\",{\"1\":{\"3\":1}}],[\"channel暂时不会向sender的请求返回ok消息\",{\"1\":{\"3\":1}}],[\"channel可以认为是容量为0的buffered\",{\"1\":{\"3\":1}}],[\"channel分为两种\",{\"1\":{\"3\":1}}],[\"channel是golang在语言层面提供的goroutine间的通信方式\",{\"1\":{\"1\":1}}],[\"channel\",{\"0\":{\"1\":1},\"1\":{\"1\":3,\"3\":8},\"2\":{\"10\":1}}],[\"ch代表chan\",{\"1\":{\"28\":1}}],[\"check\",{\"1\":{\"23\":1}}],[\"checkconnerrorwriter\",{\"1\":{\"12\":1}}],[\"ch也是在main\",{\"1\":{\"4\":1}}],[\"ch<\",{\"1\":{\"3\":1}}],[\"ch2读数据\",{\"1\":{\"7\":1}}],[\"ch2\",{\"1\":{\"3\":1,\"7\":8}}],[\"ch1\",{\"1\":{\"3\":1,\"7\":8}}],[\"ch\",{\"1\":{\"2\":3,\"3\":10,\"4\":9,\"5\":4,\"6\":9,\"8\":8,\"28\":10}}],[\"读和读却是冲突的\",{\"1\":{\"33\":1}}],[\"读多写少\",{\"1\":{\"33\":1}}],[\"读锁又被称为共享锁\",{\"1\":{\"42\":1}}],[\"读锁才会继续执行\",{\"1\":{\"33\":1}}],[\"读锁解锁\",{\"1\":{\"33\":1}}],[\"读锁可以加载多个\",{\"1\":{\"33\":1}}],[\"读锁\",{\"1\":{\"33\":1}}],[\"读锁需要等待写锁释放的信号量\",{\"1\":{\"33\":1}}],[\"读写锁常被用于读多写少的场景\",{\"1\":{\"33\":1}}],[\"读写锁允许有多个读锁和一个写锁\",{\"1\":{\"33\":1}}],[\"读取请求内容\",{\"1\":{\"12\":1}}],[\"读\",{\"1\":{\"2\":1}}],[\"发送\",{\"1\":{\"2\":1}}],[\"写锁被称为排它锁\",{\"1\":{\"42\":1}}],[\"写锁解锁\",{\"1\":{\"33\":1}}],[\"写锁\",{\"1\":{\"33\":1}}],[\"写锁需要等待读锁释放的信号量\",{\"1\":{\"33\":1}}],[\"写\",{\"1\":{\"2\":1}}],[\"对库存的判断出现了问题\",{\"1\":{\"70\":1}}],[\"对代码的修改建议\",{\"1\":{\"63\":1}}],[\"对优化mysql查询至关重要\",{\"1\":{\"43\":1}}],[\"对应的是一个匿名函数\",{\"1\":{\"28\":1}}],[\"对同一个map下的key进行并发读写\",{\"1\":{\"27\":1}}],[\"对\",{\"1\":{\"19\":2}}],[\"对chan进行了nil赋值\",{\"1\":{\"7\":1}}],[\"对于每个用户的秒杀\",{\"1\":{\"69\":1}}],[\"对于读多写少业务\",{\"1\":{\"69\":1}}],[\"对于innodb来说最重要的两个配置为\",{\"1\":{\"56\":1}}],[\"对于引擎是myisam的数据表在迁移或转入大量数据的时候\",{\"1\":{\"44\":1}}],[\"对于这个结构体我们添加了三个方法\",{\"1\":{\"27\":1}}],[\"对于这一次的选择\",{\"1\":{\"7\":1}}],[\"对于非接口类型\",{\"1\":{\"21\":1}}],[\"对于指针类型的实例p1\",{\"1\":{\"18\":1}}],[\"对于recv来说\",{\"1\":{\"6\":1}}],[\"对于receiver也一样\",{\"1\":{\"3\":1}}],[\"对于buffered\",{\"1\":{\"3\":1}}],[\"对于unbuffered\",{\"1\":{\"3\":1}}],[\"对nil\",{\"1\":{\"2\":1}}],[\"对象\",{\"1\":{\"1\":1}}],[\"=>\",{\"1\":{\"63\":4}}],[\"==\",{\"1\":{\"12\":6,\"16\":1}}],[\"=\",{\"1\":{\"2\":1,\"3\":7,\"4\":3,\"5\":4,\"6\":8,\"7\":9,\"8\":7,\"12\":55,\"16\":7,\"17\":1,\"18\":2,\"19\":2,\"20\":3,\"22\":5,\"23\":9,\"27\":7,\"28\":10,\"32\":1,\"33\":5,\"38\":14,\"49\":2,\"53\":3,\"57\":3,\"63\":7,\"65\":4,\"69\":1}}],[\"声明如下\",{\"1\":{\"17\":1}}],[\"声明一个空接口实例\",{\"1\":{\"22\":1}}],[\"声明一个map类型的变量\",{\"1\":{\"16\":2}}],[\"声明一个chan\",{\"1\":{\"2\":1}}],[\"声明和创建\",{\"0\":{\"2\":1}}],[\"特性\",{\"1\":{\"1\":1}}],[\"的存储的例子\",{\"1\":{\"65\":1}}],[\"的当前值\",{\"1\":{\"63\":1}}],[\"的路径和文件名\",{\"1\":{\"57\":1}}],[\"的时候\",{\"1\":{\"38\":1}}],[\"的容量是要\",{\"1\":{\"38\":1}}],[\"的场景\",{\"1\":{\"33\":1}}],[\"的方式做类型探测在探测类型数量多时不是很方便\",{\"1\":{\"23\":1}}],[\"的方式将接口实例ins直接转回type类型的实例\",{\"1\":{\"23\":1}}],[\"的方式来构造struct实例\",{\"1\":{\"17\":1}}],[\"的\",{\"1\":{\"19\":2}}],[\"的底层会调用new\",{\"1\":{\"17\":1}}],[\"的实现\",{\"1\":{\"12\":1}}],[\"的定时任务还是在时间堆中等待触发\",{\"1\":{\"8\":1}}],[\"的组合会导致内存泄露\",{\"1\":{\"8\":1}}],[\"的性能开销很小\",{\"1\":{\"1\":1}}],[\"的发送方和接受方是\",{\"1\":{\"1\":1}}],[\"是否能够正常工作\",{\"1\":{\"67\":1}}],[\"是否能够将请求均匀的发送给后端\",{\"1\":{\"67\":1}}],[\"是否能落到同一台机器\",{\"1\":{\"67\":1}}],[\"是否只读\",{\"1\":{\"56\":1}}],[\"是的\",{\"1\":{\"60\":1}}],[\"是线程安全的\",{\"1\":{\"32\":1}}],[\"是一种灵活地\",{\"1\":{\"38\":1}}],[\"是一种类型\",{\"1\":{\"20\":1}}],[\"是一个合格的servemux了\",{\"1\":{\"12\":1}}],[\"是一个通道\",{\"1\":{\"1\":1}}],[\"是不能比较的\",{\"1\":{\"19\":1}}],[\"是不会被\",{\"1\":{\"8\":1}}],[\"是在换个文件的参数\",{\"1\":{\"61\":1}}],[\"是在\",{\"1\":{\"8\":1}}],[\"是在channel中已有一个数据\",{\"1\":{\"3\":1}}],[\"是引用类型\",{\"1\":{\"1\":1}}],[\"是轻量级的协程\",{\"1\":{\"1\":1}}],[\"概念\",{\"1\":{\"1\":1}}],[\"这两个是同源域名\",{\"1\":{\"66\":1}}],[\"这两者有什么区别呢\",{\"1\":{\"28\":1}}],[\"这会带来很多的开销\",{\"1\":{\"53\":1}}],[\"这也就是为什么索引不在key\",{\"1\":{\"50\":1}}],[\"这是个零切片\",{\"1\":{\"38\":1}}],[\"这是比较方便的语法\",{\"1\":{\"23\":1}}],[\"这对于sync\",{\"1\":{\"32\":1}}],[\"这40个临界区是随机被访问的\",{\"1\":{\"32\":1}}],[\"这时需要类型断言\",{\"1\":{\"23\":1}}],[\"这时候可以使用反射方法\",{\"1\":{\"19\":1}}],[\"这时称为匿名字段\",{\"1\":{\"17\":1}}],[\"这时将会出现死锁问题\",{\"1\":{\"4\":1}}],[\"这几种称呼都是对同一种数据结构的不同称呼\",{\"1\":{\"16\":1}}],[\"这里我们选择的是读写锁\",{\"1\":{\"27\":1}}],[\"这里我们的handler是由gin框架实现的一个servemux\",{\"1\":{\"12\":1}}],[\"这里涉及到了\",{\"1\":{\"1\":1}}],[\"这样每个访客固定访问一个后端服务器\",{\"1\":{\"67\":1}}],[\"这样每次循环的时候就不会对time\",{\"1\":{\"8\":1}}],[\"这样就可以实现共享session了\",{\"1\":{\"65\":1}}],[\"这样就限制了goruntine的个数\",{\"1\":{\"6\":1}}],[\"这样可以在查询的时候减少分区的扫描\",{\"1\":{\"53\":1}}],[\"这样才能用到索引\",{\"1\":{\"47\":1}}],[\"这样它们就可以用来存放任意类型的对象\",{\"1\":{\"22\":1}}],[\"这就会导致严重的内存泄漏\",{\"1\":{\"8\":1}}],[\"这个产品很好的实现了单点登录\",{\"1\":{\"66\":1}}],[\"这个解决方案是解决了主域名和子域名下的会话管理问题\",{\"1\":{\"66\":1}}],[\"这个类只对致命性错误和语法错误进行防范处理\",{\"1\":{\"63\":1}}],[\"这个值会是\",{\"1\":{\"63\":1}}],[\"这个机制对调试应用程序\",{\"1\":{\"63\":1}}],[\"这个可以通过阅读框架的源码看下\",{\"1\":{\"61\":1}}],[\"这个就是命令模式下的入口文件\",{\"1\":{\"61\":1}}],[\"这个就是go高并发的原理\",{\"1\":{\"12\":1}}],[\"这个入口文件叫\",{\"1\":{\"61\":1}}],[\"这个方法对主键\",{\"1\":{\"46\":1}}],[\"这个特性会导致\",{\"1\":{\"42\":1}}],[\"这个时候就要考虑到使用集群方案\",{\"1\":{\"67\":1}}],[\"这个时候我们就要考虑到单点登录了\",{\"1\":{\"66\":1}}],[\"这个时候我们想实现多个域名之间的会话管理\",{\"1\":{\"66\":1}}],[\"这个时候我们可以自定义一个错误处理方法来接管php本身的错误处理方式\",{\"1\":{\"63\":1}}],[\"这个时候idx\",{\"1\":{\"49\":1}}],[\"这个时候ints的长度小于容量\",{\"1\":{\"38\":1}}],[\"这个时候int1的长度小于容量\",{\"1\":{\"38\":1}}],[\"这个时候\",{\"1\":{\"38\":1}}],[\"这个时候杠精面试官问\",{\"1\":{\"27\":1}}],[\"这个和内存分配策略相关\",{\"1\":{\"38\":1}}],[\"这个概念很重要\",{\"1\":{\"38\":1}}],[\"这个叫做锁竞争\",{\"1\":{\"32\":1}}],[\"这个要看struct的场景\",{\"1\":{\"19\":1}}],[\"这个操作可以让当前case禁用\",{\"1\":{\"7\":1}}],[\"这个是go中特有的\",{\"1\":{\"6\":1}}],[\"这次结束后就结束select\",{\"1\":{\"7\":1}}],[\"这有点像我们平常使用的消息队列\",{\"1\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
