const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":515,\"nextId\":515,\"documentIds\":{\"0\":\"v-55325e94\",\"1\":\"v-55325e94#channel\",\"2\":\"v-55325e94#声明和创建\",\"3\":\"v-55325e94#channel的两种分类\",\"4\":\"v-55325e94#死锁-deadlock\",\"5\":\"v-55325e94#无缓冲同步通信示例\",\"6\":\"v-55325e94#有缓冲chan\",\"7\":\"v-55325e94#select多路监听\",\"8\":\"v-55325e94#准确使用定时器\",\"9\":\"v-55325e94@0\",\"10\":\"v-55325e94@1\",\"11\":\"v-197289d8\",\"12\":\"v-197289d8#构建servemux\",\"13\":\"v-197289d8@0\",\"14\":\"v-197289d8@1\",\"15\":\"v-3b39a20c\",\"16\":\"v-3b39a20c#并发模型\",\"17\":\"v-3b39a20c#csp篇\",\"18\":\"v-3b39a20c#gpm调度模型\",\"19\":\"v-3b39a20c#goroutine\",\"20\":\"v-3b39a20c#processor\",\"21\":\"v-3b39a20c#三者的关系\",\"22\":\"v-3b39a20c#系统调用\",\"23\":\"v-3b39a20c#sysmon\",\"24\":\"v-3b39a20c@0\",\"25\":\"v-3b39a20c@1\",\"26\":\"v-1b42369e\",\"27\":\"v-1b42369e#goroutine简介\",\"28\":\"v-1b42369e#线程模型与调度器\",\"29\":\"v-1b42369e#调度器数据结构概述\",\"30\":\"v-1b42369e#重要的结构体\",\"31\":\"v-1b42369e#stack结构体\",\"32\":\"v-1b42369e#gobuf结构体\",\"33\":\"v-1b42369e#g结构体\",\"34\":\"v-1b42369e#m结构体\",\"35\":\"v-1b42369e#p结构体\",\"36\":\"v-1b42369e#schedt结构体\",\"37\":\"v-1b42369e#重要的全局变量\",\"38\":\"v-1b42369e@0\",\"39\":\"v-1b42369e@1\",\"40\":\"v-d0b736b8\",\"41\":\"v-d0b736b8#map\",\"42\":\"v-d0b736b8#struct\",\"43\":\"v-d0b736b8#struct的方法\",\"44\":\"v-d0b736b8#struct的比较\",\"45\":\"v-d0b736b8#interface\",\"46\":\"v-d0b736b8#方法集\",\"47\":\"v-d0b736b8#空interface\",\"48\":\"v-d0b736b8#interface类型断言和type-switch\",\"49\":\"v-d0b736b8@0\",\"50\":\"v-d0b736b8@1\",\"51\":\"v-cd4d857a\",\"52\":\"v-cd4d857a#并发安全的map\",\"53\":\"v-cd4d857a#channel实现并发安全的map\",\"54\":\"v-cd4d857a@0\",\"55\":\"v-cd4d857a@1\",\"56\":\"v-5c6dc018\",\"57\":\"v-5c6dc018#sync-mutex互斥锁\",\"58\":\"v-5c6dc018#sync-rwmutex读写锁\",\"59\":\"v-5c6dc018#sync-mutex和sync-rwmutex如何选择\",\"60\":\"v-5c6dc018@0\",\"61\":\"v-5c6dc018@1\",\"62\":\"v-747d3c5a\",\"63\":\"v-747d3c5a#切片\",\"64\":\"v-747d3c5a@0\",\"65\":\"v-747d3c5a@1\",\"66\":\"v-4ee05028\",\"67\":\"v-4ee05028#二叉查找树\",\"68\":\"v-4ee05028#平衡二叉树\",\"69\":\"v-4ee05028#b树\",\"70\":\"v-4ee05028#b-树\",\"71\":\"v-4ee05028#聚集索引-vs-非聚集索引\",\"72\":\"v-4ee05028#利用聚集索引和非聚集索引查找数据\",\"73\":\"v-4ee05028#总结\",\"74\":\"v-4ee05028@0\",\"75\":\"v-4ee05028@1\",\"76\":\"v-5a15b589\",\"77\":\"v-5a15b589#_1-mysql-索引使用有哪些注意事项呢\",\"78\":\"v-5a15b589#索引哪些情况会失效\",\"79\":\"v-5a15b589#索引不适合哪些场景\",\"80\":\"v-5a15b589#索引的一些潜规则\",\"81\":\"v-5a15b589#_2-mysql-遇到过死锁问题吗-你是如何解决的\",\"82\":\"v-5a15b589#_3-日常工作中你是怎么优化sql的\",\"83\":\"v-5a15b589#_4-说说分库与分表的设计\",\"84\":\"v-5a15b589#分库分表方案\",\"85\":\"v-5a15b589#常用的分库分表中间件\",\"86\":\"v-5a15b589#分库分表可能遇到的问题\",\"87\":\"v-5a15b589#_5-innodb与myisam的区别\",\"88\":\"v-5a15b589#_6-数据库索引的原理-为什么要用-b-树-为什么不用二叉树\",\"89\":\"v-5a15b589#为什么不是一般二叉树\",\"90\":\"v-5a15b589#为什么不是平衡二叉树呢\",\"91\":\"v-5a15b589#那为什么不是b树而是b-树呢\",\"92\":\"v-5a15b589#_7-聚集索引与非聚集索引的区别\",\"93\":\"v-5a15b589#_8-limit-1000000-加载很慢的话-你是怎么解决的呢\",\"94\":\"v-5a15b589#_9-如何选择合适的分布式主键方案呢\",\"95\":\"v-5a15b589#_10-事务的隔离级别有哪些-mysql的默认隔离级别是什么\",\"96\":\"v-5a15b589#_11-什么是幻读-脏读-不可重复读呢\",\"97\":\"v-5a15b589#_12-在高并发情况下-如何做到安全的修改同一行数据\",\"98\":\"v-5a15b589#使用悲观锁\",\"99\":\"v-5a15b589#使用乐观锁\",\"100\":\"v-5a15b589#_13-数据库的乐观锁和悲观锁。\",\"101\":\"v-5a15b589#悲观锁\",\"102\":\"v-5a15b589#乐观锁\",\"103\":\"v-5a15b589#_14-sql优化的一般步骤是什么-怎么看执行计划-explain-如何理解其中各个字段的含义。\",\"104\":\"v-5a15b589#_15-select-for-update有什么含义-会锁表还是锁行还是其他。\",\"105\":\"v-5a15b589#select-for-update-含义\",\"106\":\"v-5a15b589#_16-mysql事务得四大特性以及实现原理\",\"107\":\"v-5a15b589#事务acid特性的实现思想\",\"108\":\"v-5a15b589#_17-如果某个表有近千万数据-crud比较慢-如何优化。\",\"109\":\"v-5a15b589#分库分表\",\"110\":\"v-5a15b589#索引优化\",\"111\":\"v-5a15b589#_18-如何写sql能够有效的使用到复合索引。\",\"112\":\"v-5a15b589#_19-mysql中in-和exists的区别。\",\"113\":\"v-5a15b589#_20-数据库自增主键可能遇到什么问题。\",\"114\":\"v-5a15b589#_21-mvcc熟悉吗-它的底层原理\",\"115\":\"v-5a15b589#mvcc需要关注这几个知识点\",\"116\":\"v-5a15b589#_22-数据库中间件了解过吗-sharding-jdbc-mycat\",\"117\":\"v-5a15b589#_23-mysql的主从延迟-你怎么解决\",\"118\":\"v-5a15b589#主从同步延迟的原因\",\"119\":\"v-5a15b589#主从同步延迟的解决办法\",\"120\":\"v-5a15b589#_24-说一下大表查询的优化方案\",\"121\":\"v-5a15b589#_25-什么是数据库连接池-为什么需要数据库连接池呢\",\"122\":\"v-5a15b589#连接池基本原理\",\"123\":\"v-5a15b589#应用程序和数据库建立连接的过程\",\"124\":\"v-5a15b589#数据库连接池好处\",\"125\":\"v-5a15b589#_26-一条sql语句在mysql中如何执行的\",\"126\":\"v-5a15b589#查询语句\",\"127\":\"v-5a15b589#_27-innodb引擎中的索引策略-了解过吗\",\"128\":\"v-5a15b589#_28-数据库存储日期格式时-如何考虑时区转换问题\",\"129\":\"v-5a15b589#_29-一条sql执行过长的时间-你如何优化-从哪些方面入手\",\"130\":\"v-5a15b589#_30-mysql数据库服务器性能分析的方法命令有哪些\",\"131\":\"v-5a15b589#_31-blob和text有什么区别\",\"132\":\"v-5a15b589#_32-mysql里记录货币用什么字段类型比较好\",\"133\":\"v-5a15b589#_33-mysql中有哪几种锁-列举一下\",\"134\":\"v-5a15b589#_34-hash索引和b-树区别是什么-你在设计索引是怎么抉择的\",\"135\":\"v-5a15b589#_35-mysql-的内连接、左连接、右连接有什么区别\",\"136\":\"v-5a15b589#_36-说说mysql-的基础架构图\",\"137\":\"v-5a15b589#_37-什么是内连接、外连接、交叉连接、笛卡尔积呢\",\"138\":\"v-5a15b589#_38-说一下数据库的三大范式\",\"139\":\"v-5a15b589#_39-mysql有关权限的表有哪几个呢\",\"140\":\"v-5a15b589#_40-mysql的binlog有几种录入格式-分别有什么区别\",\"141\":\"v-5a15b589#_41-innodb引擎的4大特性-了解过吗\",\"142\":\"v-5a15b589#_42-索引有哪些优缺点\",\"143\":\"v-5a15b589#_43-索引有哪几种类型\",\"144\":\"v-5a15b589#_44-创建索引有什么原则呢\",\"145\":\"v-5a15b589#_45-创建索引的三种方式\",\"146\":\"v-5a15b589#_46-百万级别或以上的数据-你是如何删除的\",\"147\":\"v-5a15b589#_47-什么是最左前缀原则-什么是最左匹配原则\",\"148\":\"v-5a15b589#_48-b树和b-树的区别-数据库为什么使用b-树而不是b树\",\"149\":\"v-5a15b589#_49-覆盖索引、回表等这些-了解过吗\",\"150\":\"v-5a15b589#_50-b-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据\",\"151\":\"v-5a15b589#_51-何时使用聚簇索引与非聚簇索引\",\"152\":\"v-5a15b589#_52-非聚簇索引一定会回表查询吗\",\"153\":\"v-5a15b589#_53-组合索引是什么-为什么需要注意组合索引中的顺序\",\"154\":\"v-5a15b589#_54-什么是数据库事务\",\"155\":\"v-5a15b589#_55-隔离级别与锁的关系\",\"156\":\"v-5a15b589#_56-按照锁的粒度分-数据库锁有哪些呢-锁机制与innodb锁算法\",\"157\":\"v-5a15b589#_57-从锁的类别角度讲-mysql都有哪些锁呢\",\"158\":\"v-5a15b589#_58-mysql中innodb引擎的行锁是怎么实现的\",\"159\":\"v-5a15b589#_59-什么是死锁-怎么解决\",\"160\":\"v-5a15b589#_60-为什么要使用视图-什么是视图\",\"161\":\"v-5a15b589#为什么要使用视图\",\"162\":\"v-5a15b589#什么是视图\",\"163\":\"v-5a15b589#_61-视图有哪些特点-哪些使用场景\",\"164\":\"v-5a15b589#视图特点\",\"165\":\"v-5a15b589#视图的常见使用场景\",\"166\":\"v-5a15b589#_62-视图的优点-缺点-讲一下\",\"167\":\"v-5a15b589#_63-count-1-、count-与-count-列名-的区别\",\"168\":\"v-5a15b589#_64-什么是游标\",\"169\":\"v-5a15b589#_65-什么是存储过程-有哪些优缺点\",\"170\":\"v-5a15b589#_66-什么是触发器-触发器的使用场景有哪些\",\"171\":\"v-5a15b589#_67-mysql中都有哪些触发器\",\"172\":\"v-5a15b589#_68-超键、候选键、主键、外键分别是什么\",\"173\":\"v-5a15b589#_69-sql-约束有哪几种呢\",\"174\":\"v-5a15b589#_70-谈谈六种关联查询-使用场景。\",\"175\":\"v-5a15b589#_71-varchar-50-中50的涵义\",\"176\":\"v-5a15b589#_72-mysql中int-20-和char-20-以及varchar-20-的区别\",\"177\":\"v-5a15b589#_73-drop、delete与truncate的区别\",\"178\":\"v-5a15b589#_74-union与union-all的区别\",\"179\":\"v-5a15b589#_75-sql的生命周期\",\"180\":\"v-5a15b589#_76-一条sql的执行顺序\",\"181\":\"v-5a15b589#_77-列值为null时-查询是否会用到索引\",\"182\":\"v-5a15b589#_78-关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过\",\"183\":\"v-5a15b589#_79-主键使用自增id还是uuid-为什么\",\"184\":\"v-5a15b589#_80-mysql自增主键用完了怎么办\",\"185\":\"v-5a15b589#_81-字段为什么要求定义为not-null\",\"186\":\"v-5a15b589#_82-如果要存储用户的密码散列-应该使用什么字段进行存储\",\"187\":\"v-5a15b589#_83-mysql驱动程序是什么\",\"188\":\"v-5a15b589#_84-如何优化长难的查询语句-有实战过吗\",\"189\":\"v-5a15b589#_85-优化特定类型的查询语句\",\"190\":\"v-5a15b589#_86-mysql数据库cpu飙升的话-要怎么处理呢\",\"191\":\"v-5a15b589#_87-读写分离常见方案\",\"192\":\"v-5a15b589#_88-mysql的复制原理以及流程\",\"193\":\"v-5a15b589#_89-mysql中datetime和timestamp的区别\",\"194\":\"v-5a15b589#_90-innodb的事务实现原理\",\"195\":\"v-5a15b589#_91-谈谈mysql的explain\",\"196\":\"v-5a15b589#_92-innodb的事务与日志的实现方式\",\"197\":\"v-5a15b589#有多少种日志\",\"198\":\"v-5a15b589#日志的存放形式\",\"199\":\"v-5a15b589#事务是如何通过日志来实现的\",\"200\":\"v-5a15b589#_93-mysql中text数据类型的最大长度\",\"201\":\"v-5a15b589#_94-500台db-在最快时间之内重启。\",\"202\":\"v-5a15b589#_95-你是如何监控你们的数据库的-你们的慢日志都是怎么查询的\",\"203\":\"v-5a15b589#_96-你是否做过主从一致性校验-如果有-怎么做的-如果没有-你打算怎么做\",\"204\":\"v-5a15b589#_97-你们数据库是否支持emoji表情存储-如果不支持-如何操作\",\"205\":\"v-5a15b589#_98-mysql如何获取当前日期\",\"206\":\"v-5a15b589#_99-一个6亿的表a-一个3亿的表b-通过外间tid关联-你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。\",\"207\":\"v-5a15b589#_100-mysql一条sql加锁分析\",\"208\":\"v-5a15b589@0\",\"209\":\"v-5a15b589@1\",\"210\":\"v-a5c72302\",\"211\":\"v-a5c72302#mvcc-是什么\",\"212\":\"v-a5c72302#数据库并发控制——锁\",\"213\":\"v-a5c72302#数据库并发控制——mvcc\",\"214\":\"v-a5c72302#mvcc-的两种读形式\",\"215\":\"v-a5c72302#mvcc-的实现原理\",\"216\":\"v-a5c72302#实践\",\"217\":\"v-a5c72302#准备数据\",\"218\":\"v-a5c72302#示例一\",\"219\":\"v-a5c72302#示例二\",\"220\":\"v-a5c72302@0\",\"221\":\"v-a5c72302@1\",\"222\":\"v-bbe522b8\",\"223\":\"v-bbe522b8#myisam和innodb的区别\",\"224\":\"v-bbe522b8#mysql优化相关\",\"225\":\"v-bbe522b8#mysql修改表相关\",\"226\":\"v-bbe522b8#关闭索引\",\"227\":\"v-bbe522b8#开启索引\",\"228\":\"v-bbe522b8#索引相关\",\"229\":\"v-bbe522b8#前缀索引\",\"230\":\"v-bbe522b8#多列索引\",\"231\":\"v-bbe522b8#myisam和innodb的索引总结。\",\"232\":\"v-bbe522b8#查询优化相关\",\"233\":\"v-bbe522b8#mysql高级特性\",\"234\":\"v-bbe522b8#分区\",\"235\":\"v-bbe522b8#视图\",\"236\":\"v-bbe522b8#绑定变量\",\"237\":\"v-bbe522b8#配置优化\",\"238\":\"v-bbe522b8#复制\",\"239\":\"v-bbe522b8@0\",\"240\":\"v-bbe522b8@1\",\"241\":\"v-b87b717a\",\"242\":\"v-b87b717a#mysql架构\",\"243\":\"v-b87b717a#sql查询语句的执行\",\"244\":\"v-b87b717a#sql更新语句的执行\",\"245\":\"v-b87b717a#事务\",\"246\":\"v-b87b717a#索引\",\"247\":\"v-b87b717a@0\",\"248\":\"v-b87b717a@1\",\"249\":\"v-b511c03c\",\"250\":\"v-b511c03c#唯一索引和普通索引的选择\",\"251\":\"v-b511c03c#change-buffer-和-redo-log\",\"252\":\"v-b511c03c#mysql为何有的时候选择的索引不是理想中的-如何避免\",\"253\":\"v-b511c03c#字符串类型的字段如何加索引\",\"254\":\"v-b511c03c#mysql在fsync操作时执行查询或更新语句很慢\",\"255\":\"v-b511c03c#数据删除问题\",\"256\":\"v-b511c03c#count\",\"257\":\"v-b511c03c@0\",\"258\":\"v-b511c03c@1\",\"259\":\"v-4b4371d9\",\"260\":\"v-4b4371d9#php的命令模式实现\",\"261\":\"v-4b4371d9#php的错误和异常处理\",\"262\":\"v-4b4371d9#错误处理\",\"263\":\"v-4b4371d9#会话管理-跨域-单点登录\",\"264\":\"v-4b4371d9#会话管理\",\"265\":\"v-4b4371d9#会话跨域和单点登录\",\"266\":\"v-4b4371d9#负载均衡\",\"267\":\"v-4b4371d9#秒杀活动和超卖\",\"268\":\"v-4b4371d9#秒杀设计\",\"269\":\"v-4b4371d9#超卖问题\",\"270\":\"v-4b4371d9@0\",\"271\":\"v-4b4371d9@1\",\"272\":\"v-4db0594a\",\"273\":\"v-4db0594a#redis常见的数据结构\",\"274\":\"v-4db0594a#_1-string-字符串类型\",\"275\":\"v-4db0594a#_2-hash-哈希\",\"276\":\"v-4db0594a#_3-链表\",\"277\":\"v-4db0594a#_4-set-集合\",\"278\":\"v-4db0594a#_5-zset-有序集合\",\"279\":\"v-4db0594a@0\",\"280\":\"v-4db0594a@1\",\"281\":\"v-100b1fac\",\"282\":\"v-100b1fac#缓存应用的典型场景\",\"283\":\"v-100b1fac#缓存雪崩\",\"284\":\"v-100b1fac#缓存同时失效\",\"285\":\"v-100b1fac#缓存系统故障\",\"286\":\"v-100b1fac#缓存穿透\",\"287\":\"v-100b1fac#缓存更新与数据一致性\",\"288\":\"v-100b1fac#几种更新缓存的策略\",\"289\":\"v-100b1fac@0\",\"290\":\"v-100b1fac@1\",\"291\":\"v-1fa3a2ca\",\"292\":\"v-1fa3a2ca#_1-底层数据结构-与redis-value-type之间的关系\",\"293\":\"v-1fa3a2ca#_2-底层数据结构\",\"294\":\"v-1fa3a2ca#_2-1-sds-simple-dynamic-string\",\"295\":\"v-1fa3a2ca#_2-2-list\",\"296\":\"v-1fa3a2ca#_2-3-dict\",\"297\":\"v-1fa3a2ca#_2-4-zskiplist\",\"298\":\"v-1fa3a2ca#_2-5-intset\",\"299\":\"v-1fa3a2ca#_2-6-ziplist\",\"300\":\"v-1fa3a2ca#_2-7-quicklist\",\"301\":\"v-1fa3a2ca#_2-8-zipmap\",\"302\":\"v-1fa3a2ca@0\",\"303\":\"v-1fa3a2ca@1\",\"304\":\"v-114cb4ee\",\"305\":\"v-114cb4ee#一、什么是redis主从复制\",\"306\":\"v-114cb4ee#二、为什么需要redis主从复制\",\"307\":\"v-114cb4ee#三、redis主从复制的作用\",\"308\":\"v-114cb4ee#四、配置redis主从复制\",\"309\":\"v-114cb4ee#_1-使用客户端命令行启动\",\"310\":\"v-114cb4ee#_2-使用配置文件启用\",\"311\":\"v-114cb4ee#_3-启动redis服务器时启动\",\"312\":\"v-114cb4ee#_4-主从复制启动后的日志信息查看\",\"313\":\"v-114cb4ee#五、主从复制工作原理\",\"314\":\"v-114cb4ee#_1-主从复制的三个阶段\",\"315\":\"v-114cb4ee#_2-第一阶段-建立连接过程\",\"316\":\"v-114cb4ee#_3-第二阶段-数据同步阶段过程\",\"317\":\"v-114cb4ee#_4-第三阶段-命令传播阶段\",\"318\":\"v-114cb4ee#六-详细介绍主从复制原理-全量复制-部分复制\",\"319\":\"v-114cb4ee#七-心跳机制\",\"320\":\"v-114cb4ee#八、部分复制的三个核心要素\",\"321\":\"v-114cb4ee#_1-服务器的运行id-run-id\",\"322\":\"v-114cb4ee#_2-复制积压缓冲区\",\"323\":\"v-114cb4ee#_3-复制偏移量-offset\",\"324\":\"v-114cb4ee#九-主从复制常见的问题\",\"325\":\"v-114cb4ee#_1-主节点重启问题-内部优化\",\"326\":\"v-114cb4ee#_2-从节点网络中断偏移量越界导致全量复制\",\"327\":\"v-114cb4ee#_3-频繁的网路中断\",\"328\":\"v-114cb4ee#_4-数据不一致问题\",\"329\":\"v-114cb4ee#十-总结\",\"330\":\"v-114cb4ee@0\",\"331\":\"v-114cb4ee@1\",\"332\":\"v-8a3c387a\",\"333\":\"v-8a3c387a#背景\",\"334\":\"v-8a3c387a#创建备份\",\"335\":\"v-8a3c387a#生成内存快照\",\"336\":\"v-8a3c387a#redis-rdb-tools-安装\",\"337\":\"v-8a3c387a#使用-pypi-安装\",\"338\":\"v-8a3c387a#从源码安装\",\"339\":\"v-8a3c387a#使用-redis-rdb-tools-生成内存快照\",\"340\":\"v-8a3c387a#分析内存快照\",\"341\":\"v-8a3c387a#导入方法\",\"342\":\"v-8a3c387a#总结\",\"343\":\"v-8a3c387a@0\",\"344\":\"v-8a3c387a@1\",\"345\":\"v-57c686e8\",\"346\":\"v-57c686e8#redis-3-0中近似lru算法\",\"347\":\"v-57c686e8#redis-4-0中新的lfu算法\",\"348\":\"v-57c686e8@0\",\"349\":\"v-57c686e8@1\",\"350\":\"v-7a9c3a08\",\"351\":\"v-7a9c3a08#持久化的配置\",\"352\":\"v-7a9c3a08#rdb的持久化配置\",\"353\":\"v-7a9c3a08#aof的配置\",\"354\":\"v-7a9c3a08#工作原理\",\"355\":\"v-7a9c3a08#rdb的原理\",\"356\":\"v-7a9c3a08#aof的原理\",\"357\":\"v-7a9c3a08#从持久化中恢复数据\",\"358\":\"v-7a9c3a08#性能与实践\",\"359\":\"v-7a9c3a08@0\",\"360\":\"v-7a9c3a08@1\",\"361\":\"v-3362fc64\",\"362\":\"v-3362fc64#golang-常见面试题目解析\",\"363\":\"v-3362fc64@0\",\"364\":\"v-3362fc64@1\",\"365\":\"v-147ae2ab\",\"366\":\"v-147ae2ab#交替打印数字和字母\",\"367\":\"v-147ae2ab@0\",\"368\":\"v-147ae2ab@1\",\"369\":\"v-162fbb4a\",\"370\":\"v-162fbb4a#判断字符串中字符是否全都不同\",\"371\":\"v-162fbb4a@0\",\"372\":\"v-162fbb4a@1\",\"373\":\"v-17e493e9\",\"374\":\"v-17e493e9#翻转字符串\",\"375\":\"v-17e493e9@0\",\"376\":\"v-17e493e9@1\",\"377\":\"v-19996c88\",\"378\":\"v-19996c88#判断两个给定的字符串排序后是否一致\",\"379\":\"v-19996c88@0\",\"380\":\"v-19996c88@1\",\"381\":\"v-1b4e4527\",\"382\":\"v-1b4e4527#字符串替换问题\",\"383\":\"v-1b4e4527@0\",\"384\":\"v-1b4e4527@1\",\"385\":\"v-1d031dc6\",\"386\":\"v-1d031dc6#机器人坐标问题\",\"387\":\"v-1d031dc6@0\",\"388\":\"v-1d031dc6@1\",\"389\":\"v-1eb7f665\",\"390\":\"v-1eb7f665#常见语法题目-一\",\"391\":\"v-1eb7f665#_1、下面代码能运行吗-为什么。\",\"392\":\"v-1eb7f665#_2、请说出下面代码存在什么问题。\",\"393\":\"v-1eb7f665#_3、写出打印的结果。\",\"394\":\"v-1eb7f665#_4、下面的代码是有问题的-请说明原因。\",\"395\":\"v-1eb7f665#_5、请找出下面代码的问题所在。\",\"396\":\"v-1eb7f665#_6、请说明下面代码书写是否正确。\",\"397\":\"v-1eb7f665#_7、下面的程序运行后为什么会爆异常。\",\"398\":\"v-1eb7f665#_8、请说出下面代码哪里写错了\",\"399\":\"v-1eb7f665#_9、请说出下面代码-执行时为什么会报错\",\"400\":\"v-1eb7f665#_10、请说出下面的代码存在什么问题\",\"401\":\"v-1eb7f665#_11、下面这段代码为什么会卡死\",\"402\":\"v-1eb7f665@0\",\"403\":\"v-1eb7f665@1\",\"404\":\"v-206ccf04\",\"405\":\"v-206ccf04#_1、写出下面代码输出内容。\",\"406\":\"v-206ccf04#_2、-以下代码有什么问题-说明原因\",\"407\":\"v-206ccf04#_3、下面的代码会输出什么-并说明原因\",\"408\":\"v-206ccf04#_4、下面代码会输出什么\",\"409\":\"v-206ccf04#_5、下面代码会触发异常吗-请详细说明\",\"410\":\"v-206ccf04#_6、下面代码输出什么\",\"411\":\"v-206ccf04#_7、请写出以下输入内容\",\"412\":\"v-206ccf04#_8、下面的代码有什么问题\",\"413\":\"v-206ccf04#_9、下面的迭代会有什么问题\",\"414\":\"v-206ccf04#_10、以下代码能编译过去吗-为什么\",\"415\":\"v-206ccf04#_11、以下代码打印出来什么内容-说出为什么。。。\",\"416\":\"v-206ccf04@0\",\"417\":\"v-206ccf04@1\",\"418\":\"v-2221a7a3\",\"419\":\"v-2221a7a3@0\",\"420\":\"v-2221a7a3@1\",\"421\":\"v-47ac454d\",\"422\":\"v-47ac454d@0\",\"423\":\"v-47ac454d@1\",\"424\":\"v-49611dec\",\"425\":\"v-49611dec@0\",\"426\":\"v-49611dec@1\",\"427\":\"v-4b15f68b\",\"428\":\"v-4b15f68b#_1-写出以下逻辑-要求每秒钟调用一次proc并保证程序不退出\",\"429\":\"v-4b15f68b@0\",\"430\":\"v-4b15f68b@1\",\"431\":\"v-4ccacf2a\",\"432\":\"v-4ccacf2a@0\",\"433\":\"v-4ccacf2a@1\",\"434\":\"v-4e7fa7c9\",\"435\":\"v-4e7fa7c9#写出以下代码出现的问题\",\"436\":\"v-4e7fa7c9#写出以下打印内容\",\"437\":\"v-4e7fa7c9#找出下面代码的问题\",\"438\":\"v-4e7fa7c9#写出以下打印结果-并解释下为什么这么打印的。\",\"439\":\"v-4e7fa7c9#写出以下打印结果\",\"440\":\"v-4e7fa7c9#写出以下代码的问题\",\"441\":\"v-4e7fa7c9#下面代码写法有什么问题\",\"442\":\"v-4e7fa7c9@0\",\"443\":\"v-4e7fa7c9@1\",\"444\":\"v-50348068\",\"445\":\"v-50348068#_1-mutex\",\"446\":\"v-50348068#_2-rwmutex\",\"447\":\"v-50348068#_3-waitgroup\",\"448\":\"v-50348068#_4-双检查实现单例\",\"449\":\"v-50348068#_5-mutex\",\"450\":\"v-50348068#_6-pool\",\"451\":\"v-50348068#_7-channel\",\"452\":\"v-50348068#_8-channel\",\"453\":\"v-50348068#_9-map\",\"454\":\"v-50348068#_10-happens-before\",\"455\":\"v-50348068#答案\",\"456\":\"v-50348068#_1-d\",\"457\":\"v-50348068#_2-d\",\"458\":\"v-50348068#_3-d\",\"459\":\"v-50348068#_4-c\",\"460\":\"v-50348068#_5-d\",\"461\":\"v-50348068#_6-c\",\"462\":\"v-50348068#_7-c\",\"463\":\"v-50348068#_8-d\",\"464\":\"v-50348068#_9-a\",\"465\":\"v-50348068#_10-b\",\"466\":\"v-50348068@0\",\"467\":\"v-50348068@1\",\"468\":\"v-51e95907\",\"469\":\"v-51e95907#题目\",\"470\":\"v-51e95907@0\",\"471\":\"v-51e95907@1\",\"472\":\"v-539e31a6\",\"473\":\"v-539e31a6#题目\",\"474\":\"v-539e31a6@0\",\"475\":\"v-539e31a6@1\",\"476\":\"v-55530a45\",\"477\":\"v-55530a45#题目\",\"478\":\"v-55530a45#回答\",\"479\":\"v-55530a45#示例\",\"480\":\"v-55530a45#_1-写已经关闭的-chan\",\"481\":\"v-55530a45#_2-读已经关闭的-chan\",\"482\":\"v-55530a45#多问一句\",\"483\":\"v-55530a45#_1-为什么写已经关闭的-chan-就会-panic-呢\",\"484\":\"v-55530a45#_2-为什么读已关闭的-chan-会一直能读到值\",\"485\":\"v-55530a45@0\",\"486\":\"v-55530a45@1\",\"487\":\"v-5707e2e4\",\"488\":\"v-5707e2e4#问题\",\"489\":\"v-5707e2e4#回答\",\"490\":\"v-5707e2e4#举例\",\"491\":\"v-5707e2e4@0\",\"492\":\"v-5707e2e4@1\",\"493\":\"v-7c92808e\",\"494\":\"v-7c92808e#问题\",\"495\":\"v-7c92808e#回答\",\"496\":\"v-7c92808e#解释\",\"497\":\"v-7c92808e@0\",\"498\":\"v-7c92808e@1\",\"499\":\"v-7e47592d\",\"500\":\"v-7e47592d#问题\",\"501\":\"v-7e47592d#怎么答\",\"502\":\"v-7e47592d#解释\",\"503\":\"v-7e47592d#总结\",\"504\":\"v-7e47592d@0\",\"505\":\"v-7e47592d@1\",\"506\":\"v-7ffc31cc\",\"507\":\"v-7ffc31cc#问题\",\"508\":\"v-7ffc31cc#解析\",\"509\":\"v-7ffc31cc@0\",\"510\":\"v-7ffc31cc@1\",\"511\":\"v-7630e300\",\"512\":\"v-eb072ff4\",\"513\":\"v-744b4c30\",\"514\":\"v-dc384366\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,27],\"2\":[1,38],\"3\":[1,86],\"4\":[3,48],\"5\":[1,32],\"6\":[1,91],\"7\":[1,102],\"8\":[1,74],\"9\":[null,null,1],\"10\":[null,null,7],\"11\":[1],\"12\":[1,333],\"13\":[null,null,1],\"14\":[null,null,5],\"15\":[2,9],\"16\":[1,23],\"17\":[1,16],\"18\":[1,12],\"19\":[1,102],\"20\":[1,28],\"21\":[1,38],\"22\":[1,13],\"23\":[1,22],\"24\":[null,null,1],\"25\":[null,null,5],\"26\":[1],\"27\":[1,44],\"28\":[1,60],\"29\":[1,151],\"30\":[1,14],\"31\":[1,33],\"32\":[1,101],\"33\":[1,82],\"34\":[1,82],\"35\":[1,110],\"36\":[1,110],\"37\":[1,53],\"38\":[null,null,1],\"39\":[null,null,5],\"40\":[3],\"41\":[1,76],\"42\":[1,89],\"43\":[1,71],\"44\":[1,46],\"45\":[1,34],\"46\":[1,25],\"47\":[1,49],\"48\":[2,66],\"49\":[null,null,1],\"50\":[null,null,8],\"51\":[1],\"52\":[1,79],\"53\":[1,77],\"54\":[null,null,1],\"55\":[null,null,7],\"56\":[3,6],\"57\":[2,112],\"58\":[2,128],\"59\":[3,8],\"60\":[null,null,1],\"61\":[null,null,7],\"62\":[1],\"63\":[1,126],\"64\":[null,null,1],\"65\":[null,null,6],\"66\":[2,29],\"67\":[1,37],\"68\":[1,26],\"69\":[1,68],\"70\":[1,48],\"71\":[3,32],\"72\":[1,122],\"73\":[1,9],\"74\":[null,null,1],\"75\":[null,null,3],\"76\":[1],\"77\":[4,4],\"78\":[1,29],\"79\":[1,5],\"80\":[1,6],\"81\":[5,10],\"82\":[3,7],\"83\":[2,3],\"84\":[2,18],\"85\":[2,14],\"86\":[1,20],\"87\":[2,48],\"88\":[6,10],\"89\":[2,6],\"90\":[2,13],\"91\":[2,22],\"92\":[2,15],\"93\":[6,39],\"94\":[3,6],\"95\":[4,11],\"96\":[5,18],\"97\":[4,3],\"98\":[1,19],\"99\":[1,10],\"100\":[3],\"101\":[2,9],\"102\":[2,9],\"103\":[6,14],\"104\":[6],\"105\":[4,13],\"106\":[2,21],\"107\":[1,25],\"108\":[5],\"109\":[1,21],\"110\":[1,3],\"111\":[3,26],\"112\":[4,81],\"113\":[3,8],\"114\":[4,6],\"115\":[2,6],\"116\":[6,22],\"117\":[4,33],\"118\":[1,10],\"119\":[1,24],\"120\":[2,10],\"121\":[4],\"122\":[2,5],\"123\":[2,8],\"124\":[2,6],\"125\":[3,1],\"126\":[2,23],\"127\":[4,13],\"128\":[4,8],\"129\":[5,17],\"130\":[3,19],\"131\":[3,11],\"132\":[3,20],\"133\":[4,20],\"134\":[4,15],\"135\":[6,12],\"136\":[3,7],\"137\":[6,16],\"138\":[2,13],\"139\":[3,23],\"140\":[4,26],\"141\":[3,12],\"142\":[3,14],\"143\":[3,21],\"144\":[3,18],\"145\":[2,40],\"146\":[4,4],\"147\":[4,15],\"148\":[4,27],\"149\":[5,11],\"150\":[3,15],\"151\":[2,14],\"152\":[3,18],\"153\":[4,6],\"154\":[3,9],\"155\":[2,5],\"156\":[4,7],\"157\":[4,16],\"158\":[3,16],\"159\":[4,27],\"160\":[4],\"161\":[2,3],\"162\":[2,4],\"163\":[4],\"164\":[2,18],\"165\":[2,7],\"166\":[5,7],\"167\":[7,17],\"168\":[3,4],\"169\":[4,24],\"170\":[4,11],\"171\":[3,7],\"172\":[6,15],\"173\":[4,19],\"174\":[4,5],\"175\":[4,11],\"176\":[6,9],\"177\":[3,21],\"178\":[4,10],\"179\":[3,10],\"180\":[3],\"181\":[4,7],\"182\":[5,14],\"183\":[4,18],\"184\":[3,7],\"185\":[4,3],\"186\":[4,6],\"187\":[3,14],\"188\":[4,6],\"189\":[2,11],\"190\":[4,37],\"191\":[3,11],\"192\":[2,45],\"193\":[2,25],\"194\":[3,25],\"195\":[2,32],\"196\":[2],\"197\":[1,2],\"198\":[1,28],\"199\":[1,29],\"200\":[2,19],\"201\":[4,13],\"202\":[4,4],\"203\":[7,6],\"204\":[5,2],\"205\":[3,4],\"206\":[6,24],\"207\":[2,33],\"208\":[null,null,1],\"209\":[null,null,3],\"210\":[4],\"211\":[3],\"212\":[2,53],\"213\":[2,13],\"214\":[2,37],\"215\":[2,140],\"216\":[1],\"217\":[1,27],\"218\":[1,118],\"219\":[1,158],\"220\":[null,null,1],\"221\":[null,null,4],\"222\":[1],\"223\":[1,31],\"224\":[1,35],\"225\":[1,9],\"226\":[1,6],\"227\":[1,7],\"228\":[1,24],\"229\":[1,32],\"230\":[1,55],\"231\":[2,23],\"232\":[1,18],\"233\":[1],\"234\":[1,76],\"235\":[1,21],\"236\":[1,14],\"237\":[2,28],\"238\":[1,105],\"239\":[null,null,1],\"240\":[null,null,3],\"241\":[1],\"242\":[1,10],\"243\":[1,12],\"244\":[1,55],\"245\":[1,45],\"246\":[1,123],\"247\":[null,null,1],\"248\":[null,null,3],\"249\":[1],\"250\":[1,43],\"251\":[5,27],\"252\":[2,28],\"253\":[1,16],\"254\":[1],\"255\":[1,32],\"256\":[2,6],\"257\":[null,null,1],\"258\":[null,null,3],\"259\":[2,7],\"260\":[1,29],\"261\":[1],\"262\":[1,216],\"263\":[3],\"264\":[1,100],\"265\":[1,59],\"266\":[1,101],\"267\":[1,6],\"268\":[1,108],\"269\":[1,24],\"270\":[null,null,1],\"271\":[null,null,4],\"272\":[2],\"273\":[2,6],\"274\":[3,27],\"275\":[4,17],\"276\":[2,27],\"277\":[3,22],\"278\":[3,21],\"279\":[null,null,1],\"280\":[null,null,3],\"281\":[3,7],\"282\":[1,44],\"283\":[1,7],\"284\":[1,23],\"285\":[1,33],\"286\":[1,21],\"287\":[1,24],\"288\":[2,110],\"289\":[null,null,1],\"290\":[null,null,5],\"291\":[1,2],\"292\":[5,77],\"293\":[2],\"294\":[6,214],\"295\":[2,55],\"296\":[3,479],\"297\":[3,160],\"298\":[3,78],\"299\":[3,412],\"300\":[3,270],\"301\":[3,70],\"302\":[null,null,1],\"303\":[null,null,3],\"304\":[1,7],\"305\":[3,15],\"306\":[3,25],\"307\":[2,29],\"308\":[2,36],\"309\":[2,24],\"310\":[2,25],\"311\":[2,10],\"312\":[2,5],\"313\":[2],\"314\":[2,9],\"315\":[3,13],\"316\":[3,13],\"317\":[3,26],\"318\":[4,57],\"319\":[2,47],\"320\":[2],\"321\":[5,20],\"322\":[2,35],\"323\":[4,7],\"324\":[2],\"325\":[4,26],\"326\":[2,21],\"327\":[2,23],\"328\":[2,25],\"329\":[2,19],\"330\":[null,null,1],\"331\":[null,null,3],\"332\":[1],\"333\":[1,21],\"334\":[1,12],\"335\":[1,19],\"336\":[4,6],\"337\":[3,4],\"338\":[1,16],\"339\":[5,62],\"340\":[1,15],\"341\":[1,47],\"342\":[1,54],\"343\":[null,null,1],\"344\":[null,null,4],\"345\":[1,50],\"346\":[3,200],\"347\":[3,59],\"348\":[null,null,1],\"349\":[null,null,3],\"350\":[1,15],\"351\":[1,3],\"352\":[1,61],\"353\":[1,49],\"354\":[1,25],\"355\":[1,41],\"356\":[1,49],\"357\":[1,15],\"358\":[1,49],\"359\":[null,null,1],\"360\":[null,null,3],\"361\":[2],\"362\":[2,8],\"363\":[null,null,1],\"364\":[null,null,8],\"365\":[1],\"366\":[1,58],\"367\":[null,null,1],\"368\":[null,null,8],\"369\":[1],\"370\":[1,92],\"371\":[null,null,1],\"372\":[null,null,8],\"373\":[1],\"374\":[1,46],\"375\":[null,null,1],\"376\":[null,null,8],\"377\":[1],\"378\":[1,44],\"379\":[null,null,1],\"380\":[null,null,8],\"381\":[1],\"382\":[1,45],\"383\":[null,null,1],\"384\":[null,null,8],\"385\":[1],\"386\":[1,84],\"387\":[null,null,1],\"388\":[null,null,8],\"389\":[1],\"390\":[2],\"391\":[4,24],\"392\":[3,37],\"393\":[3,38],\"394\":[4,33],\"395\":[3,44],\"396\":[3,17],\"397\":[3,48],\"398\":[2,28],\"399\":[3,22],\"400\":[3,37],\"401\":[3,89],\"402\":[null,null,1],\"403\":[null,null,8],\"404\":[2],\"405\":[3,38],\"406\":[3,32],\"407\":[3,77],\"408\":[3,28],\"409\":[3,24],\"410\":[3,29],\"411\":[2,20],\"412\":[3,47],\"413\":[3,26],\"414\":[4,46],\"415\":[4,34],\"416\":[null,null,1],\"417\":[null,null,8],\"418\":[3,52],\"419\":[null,null,1],\"420\":[null,null,8],\"421\":[1,61],\"422\":[null,null,1],\"423\":[null,null,8],\"424\":[1,101],\"425\":[null,null,1],\"426\":[null,null,8],\"427\":[1],\"428\":[4,47],\"429\":[null,null,1],\"430\":[null,null,8],\"431\":[7,63],\"432\":[null,null,1],\"433\":[null,null,8],\"434\":[1],\"435\":[1,20],\"436\":[1,16],\"437\":[1,42],\"438\":[3,42],\"439\":[1,17],\"440\":[1,12],\"441\":[2,26],\"442\":[null,null,1],\"443\":[null,null,8],\"444\":[2,4],\"445\":[2,25],\"446\":[2,33],\"447\":[2,25],\"448\":[2,34],\"449\":[2,29],\"450\":[2,63],\"451\":[2,35],\"452\":[2,24],\"453\":[2,23],\"454\":[3,23],\"455\":[1],\"456\":[2,4],\"457\":[2,12],\"458\":[2,7],\"459\":[2,3],\"460\":[2,6],\"461\":[2,5],\"462\":[2,8],\"463\":[2,4],\"464\":[2,6],\"465\":[2,7],\"466\":[null,null,1],\"467\":[null,null,8],\"468\":[1],\"469\":[1,37],\"470\":[null,null,1],\"471\":[null,null,8],\"472\":[1],\"473\":[1,37],\"474\":[null,null,1],\"475\":[null,null,8],\"476\":[4],\"477\":[1,6],\"478\":[1,28],\"479\":[1],\"480\":[3,22],\"481\":[3,58],\"482\":[1],\"483\":[7,34],\"484\":[5,54],\"485\":[null,null,1],\"486\":[null,null,8],\"487\":[2],\"488\":[1,3],\"489\":[1,58],\"490\":[1,105],\"491\":[null,null,1],\"492\":[null,null,8],\"493\":[3],\"494\":[1,3],\"495\":[1,8],\"496\":[1,38],\"497\":[null,null,1],\"498\":[null,null,8],\"499\":[1],\"500\":[1,38],\"501\":[1,15],\"502\":[1,274],\"503\":[1,45],\"504\":[null,null,1],\"505\":[null,null,8],\"506\":[3],\"507\":[1,28],\"508\":[1,26],\"509\":[null,null,1],\"510\":[null,null,8],\"511\":[1],\"512\":[1],\"513\":[1],\"514\":[1]},\"averageFieldLength\":[2.2038322096447205,38.911909111020485,1.9776618842289058],\"storedFields\":{\"0\":{\"h\":\"Go面试之Channel的使用\"},\"1\":{\"h\":\"channel\",\"t\":[\"channel是Golang在语言层面提供的goroutine间的通信方式。channel 是一个通道，用于端到端的数据传输，这有点像我们平常使用的消息队列，只不过 channel 的发送方和接受方是 goroutine 对象，属于内存级别的通信。\",\"这里涉及到了 goroutine 概念，goroutine 是轻量级的协程，有属于自己的栈空间。 我们可以把它理解为线程，只不过 goroutine 的性能开销很小，并且在用户态上实现了属于自己的调度模型。\",\"channel 是引用类型，在多并发操作里是属于协程安全的，并且遵循了 FIFO 特性。即先执行读取的 goroutine 会先获取到数据，先发送数据的 goroutine 会先输入数据。\"]},\"2\":{\"h\":\"声明和创建\",\"t\":[\"var ch chan int // 声明一个chan，此时ch是一个nil chan ch := make(chan int) // 创建一个无缓冲的chan \",\"上面的代码我们看到首先声明了一个chan，此时ch是一个nil chan，对nil chan进行send(写、发送)，recv(读、接收)都将会阻塞。\",\"每个channel都有3种操作：send、receive和close\",\"send：表示sender端的goroutine向channel中投放数据\",\"receive：表示receiver端的goroutine从channel中读取数据\",\"close：表示关闭channel \",\"关闭channel后，send操作将导致painc\",\"关闭channel后，若没有缓冲数据，recv操作将返回对应类型的0值以及一个状态码false\",\"close并非强制需要使用close(ch)来关闭channel，在某些时候可以自动被关闭\",\"只在sender端上显式使用close()关闭channel。因为关闭通道意味着没有数据再需要发送\",\"如果使用close()，建议条件允许的情况下加上defer\"]},\"3\":{\"h\":\"channel的两种分类\",\"t\":[\"channel分为两种：unbuffered channel(无缓冲)和buffered channel（有缓冲）\",\"ch1 := make(chan int) // 无缓冲 ch2 := make(chan int, 10) // 有缓冲 \",\"unbuffered channel(无缓冲)：阻塞，同步模式\",\"sender端向channel中send一个数据，然后阻塞，直到receiver端将此数据receive\",\"receiver端一直阻塞，直到sender端向channel发送了一个数据\",\"func main(){ ch := make(chan int) go func(){ fmt.Println(\\\"go send\\\") ch<-1 close(ch) }() i := <-ch fmt.Println(\\\"ch val: \\\", i) } \",\"buffered channel（有缓冲）：非阻塞，异步模式\",\"sender端可以向channel中send多个数据(只要channel容量未满)，容量满之前不会阻塞\",\"receiver端按照队列的方式(FIFO,先进先出)从buffered channel中按序receive其中数据\",\"func main() { ch := make(chan int, 10) go func() { fmt.Println(\\\"go send\\\") for i := 0; i < 20; i++ { ch <- i } close(ch) }() for { i, ok := <-ch if !ok { fmt.Println(\\\"ch close\\\") return } fmt.Println(\\\"ch val: \\\", i) } } \",\"unbuffered channel可以认为是容量为0的buffered channel，所以每发送一个数据就被阻塞。注意，不是容量为1的buffered channel，因为容量为1的channel，是在channel中已有一个数据，并发送第二个数据的时候才被阻塞。\",\"阻塞和不阻塞是由channel控制的，无论是send还是recv操作，都是在向channel发送请求：\",\"对于unbuffered channel，sender发送一个数据，channel暂时不会向sender的请求返回ok消息，而是等到receiver准备接收channel数据了，channel才会向sender和receiver双方发送ok消息。在sender和receiver接收到ok消息之前，两者一直处于阻塞。\",\"对于buffered channel，sender每发送一个数据，只要channel容量未满，channel都会向sender的请求直接返回一个ok消息，使得sender不会阻塞，直到channel容量已满，channel不会向sender返回ok，于是sender被阻塞。对于receiver也一样，只要channel非空，receiver每次请求channel时，channel都会向其返回ok消息，直到channel为空，channel不会返回ok消息，receiver被阻塞。\",\"在Go的内部行为中，send和recv是一个整体行为，数据未读就表示未send成功。所以对已经关闭的chan进行send操作会引发panic\"]},\"4\":{\"h\":\"死锁(deadlock)\",\"t\":[\"当channel的某一端(sender/receiver)期待另一端的(receiver/sender)操作，另一端正好在期待本端的操作时，也就是说两端都因为对方而使得自己当前处于阻塞状态，这时将会出现死锁问题。更通俗地说，只要所有goroutine都被阻塞，就会出现死锁。\",\"func main() { ch := make(chan int) ch <- 1 fmt.Println(\\\"recv\\\") <-ch } \",\"在上面的示例中，向unbuffered channel中send数据的操作ch <- 1是在main goroutine中进行的，此channel中recv的操作<-ch也是在main goroutine中进行的。send的时候会直接阻塞main goroutine，使得recv操作无法被执行，go将探测到此问题，并报错：\",\"fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: \",\"解决方法，只需将send操作放在另一个goroutine中执行即可：\",\"func main() { ch := make(chan int) go func() { fmt.Println(\\\"send\\\") ch <- 1 }() fmt.Println(\\\"recv\\\") <-ch } \",\"或者讲无缓冲chan设置为有缓冲chan：\",\"func main() { ch := make(chan int, 1) fmt.Println(\\\"send\\\") ch <- 1 fmt.Println(\\\"recv\\\") <-ch } \"]},\"5\":{\"h\":\"无缓冲同步通信示例\",\"t\":[\"func main() { ch := make(chan int) defer close(ch) wg := sync.WaitGroup{} wg.Add(2) f1 := func() { defer wg.Done() time.Sleep(3 * time.Second) fmt.Println(\\\"f1 end.\\\") ch <- 1 } f2 := func() { defer wg.Done() <-ch fmt.Println(\\\"f2 end\\\") } go f1() go f2() wg.Wait() } \",\"上面的代码表示必须f1函数执行完成才能执行f2函数，否则f2一直阻塞，两个协程之间通过ch进行通信。\"]},\"6\":{\"h\":\"有缓冲chan\",\"t\":[\"有缓冲chan一般在进行并发限制的时候用的较多，案例：\",\"type Task struct { TaskId int64 Status string } func (t *Task) Do(ch <-chan int) { time.Sleep(time.Second * 3) t.Status = \\\"Success\\\" log.Printf(\\\"task %d done.\\\\n\\\", t.TaskId) <-ch } func main() { ch := make(chan int, 10) wg := sync.WaitGroup{} for i := 1; i < 100; i++ { wg.Add(1) ch <- i go func(i int) { defer wg.Done() task := &Task{TaskId: int64(i)} task.Do(ch) }(i) } wg.Wait() } \",\"案例中我们生成100个任务，每次最多并发执行10个，使用了有缓冲的chan，在任务执行之前对chan进行写操作，任务完成后对chan进行读操作，这样就限制了goruntine的个数。 同时上面的案例中，在task的Do方法中我们使用指向的chan，这个是Go中特有的，表明这个chan参数只能进行读取操作。\",\"in <-chan int：表示channel in通道只用于接收数据\",\"out chan<- int：表示channel out通道只用于发送数据\",\"只用于接收数据的通道<-chan不可被关闭，因为关闭通道是针对发送数据而言的，表示无数据再需发送。对于recv来说，关闭通道是没有意义的。\",\"案例：\",\"func main() { ch := make(chan int, 10) go func() { for i := 0; i < 100; i++ { ch <- i } close(ch) // 若没有此操作，使用range读取ch将会发生panic，产生死锁 }() for i := range ch { fmt.Println(\\\"i: \\\", i) } } \",\"前面都是在for无限循环中读取channel中的数据，但也可以使用range来迭代channel，它会返回每次迭代过程中所读取的数据，直到channel被关闭。必须注意，只要channel未关闭，range迭代channel就会一直被阻塞。\",\"fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: \"]},\"7\":{\"h\":\"select多路监听\",\"t\":[\"很多时候想要同时操作多个channel，比如从ch1、ch2读数据。Go提供了一个select语句块，它像switch一样工作，里面放一些case语句块，用来轮询每个case语句块的send或recv情况。\",\"用法示例：\",\"select{ case <-ch1: // do case v := <-ch2: // do default: // 所有case都不满足条件时，执行default } \",\"defalut语句是可选的，不允许fall through行为，但允许case语句块为空块。select会被return、break关键字中断：return是退出整个函数，break是退出当前select。\",\"select的行为模式主要是对channel是否可读进行轮询，但也可以用来向channel发送数据。它的行为如下：\",\"如果所有的case语句块评估时都被阻塞，则阻塞直到某个语句块可以被处理\",\"如果多个case同时满足条件，则随机选择一个进行处理，对于这一次的选择，其它的case都不会被阻塞，而是处理完被选中的case后进入下一轮select(如果select在循环中)或者结束select(如果select不在循环中或循环次数结束)\",\"如果存在default且其它case都不满足条件，则执行default。所以default必须要可执行而不能阻塞\",\"所有的case块都是按源代码书写顺序进行评估的。当select未在循环中时，它将只对所有case评估一次，这次结束后就结束select。某次评估过程中如果有满足条件的case，则所有其它case都直接结束评估，并退出此次select。\",\"其实如果注意到select语句是在某一个goroutine中评估的，就不难理解只有所有case都不满足条件时，select所在goroutine才会被阻塞，只要有一个case满足条件，本次select就不会出现阻塞的情况。\",\"需要注意的是，如果在select中执行send操作，则可能会永远被send阻塞。所以，在使用send的时候，应该也使用defalut语句块，保证send不会被阻塞。如果没有default，或者能确保select不阻塞的语句块，则迟早会被send阻塞。\",\"一般来说，select会放在一个无限循环语句中，一直轮询channel的可读事件。\",\"案例：\",\"func main() { ch1 := make(chan int) ch2 := make(chan int, 10) wg := sync.WaitGroup{} go func() { for { select { case v, ok := <-ch1: if !ok { fmt.Println(\\\"ch1 close\\\") ch1 = nil } fmt.Println(\\\"ch1: \\\", v) case v, ok := <-ch2: if !ok { fmt.Println(\\\"ch2 close\\\") ch2 = nil } fmt.Println(\\\"ch2: \\\", v) } } }() for i := 0; i < 10; i++ { wg.Add(2) go func(i int) { defer wg.Done() ch2 <- i }(i) go func(i int) { defer wg.Done() ch1 <- i }(i) } wg.Wait() close(ch1) close(ch2) } \",\"执行这段代码，select确实是随机选择case进行执行，同时我们在检测到chan关闭时，对chan进行了nil赋值，这个操作可以让当前case禁用，当select中的case都在禁用状态，select将会结束，达到终止循环的效果\"]},\"8\":{\"h\":\"准确使用定时器\",\"t\":[\"在Go中提供了定时器功能，一般都是通过 for-select的方式进行使用，在使用的时候要正确使用，防止内存泄漏\",\"func main() { ch := make(chan int, 10) go func() { i := 0 for { ch <- i i++ } }() for { select { case <-time.After(3 * time.Second): log.Println(\\\"timeout.\\\") return case v := <-ch: log.Println(\\\"ch: \\\", v) } } } \",\"看上面的案例，我们本意是在3秒之后停止main goruntine，但是我们代码运行下来发现是一直输出数据，并且不会推出main goruntine。原因在于 for+select，再加上 time.After 的组合会导致内存泄露。因为 for在循环时，就会调用都 select 语句，因此在每次进行 select 时，都会重新初始化一个全新的计时器（Timer）。我们这个计时器，是在 3秒后才会被触发去执行某些事，但重点在于计时器激活后，却又发现和 select 之间没有引用关系了，因此很合理的也就被 GC 给清理掉了，因为没有人需要 “我” 了。\",\"要命的还在后头，被抛弃的 time.After 的定时任务还是在时间堆中等待触发，在定时任务未到期之前，是不会被 GC 清除的。这就会导致严重的内存泄漏。改进方法如下：\",\"func main() { ch := make(chan int, 10) go func() { i := 0 for { ch <- i i++ } }() timer := time.After(3 * time.Second) for { select { case <-timer: log.Println(\\\"timeout.\\\") return case v := <-ch: log.Println(\\\"ch: \\\", v) } } } \",\"将延时器放到for循环之外定义，这样每次循环的时候就不会对time.After进行初始化，防止了内存泄漏，同时达到了3秒程序结束的效果.\"]},\"9\":{\"c\":[\"golang\"]},\"10\":{\"c\":[\"go\",\"golang\",\"channel\",\"并发安全\",\"源码\",\"面试\",\"面试总结\"]},\"11\":{\"h\":\"Golang通过Gin框架创建http服务源码剖析\"},\"12\":{\"h\":\"构建ServeMux\",\"t\":[\"net/http包中有默认的DefaultServeMux，gin框架也实现了这个，主要是实现 http.Handler接口，接口只包含一个方法 ServeHTTP(ResponseWriter, *Request)\",\"我们看下gin中怎么实现的\",\" // ServeHTTP conforms to the http.Handler interface. func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) // 具体的执行请求返回响应的方法 engine.pool.Put(c) } \",\"gin框架构建ServeMux流程如下：\",\" engine := gin.New() // 初始化gin，实现了http.Handler接口，是一个合格的ServeMux了 engine.Use() // 初始化全局中间件 engine.Get(\\\"/path\\\", function(ctx *gin.Context){}) // 添加路由 构建Server http服务的底层走的是tcp协议，需要监听端口 srv := http.Server{ Handler: engine, // http.Handler接口的实现者 Addr: \\\":8080\\\", // 监听http端口 } srv.ListenAndServe() \",\"上面的代码监听了8080端口来提供http服务，服务的具体执行者就是我们的gin框架，那么具体是怎么执行一个http请求的呢，具体要看 net/http包中Server.ListenAndServe()的实现，代码如下：\",\"func (srv *Server) ListenAndServe() error { if srv.shuttingDown() { return ErrServerClosed } addr := srv.Addr if addr == \\\"\\\" { addr = \\\":http\\\" } ln, err := net.Listen(\\\"tcp\\\", addr) if err != nil { return err } return srv.Serve(ln) } \",\"我们看到这个方法两个步骤，tcp协议监听端口，处理监听serve，我们主要看serve，代码如下：\",\"func (srv *Server) Serve(l net.Listener) error { ····· ..... baseCtx := context.Background() if srv.BaseContext != nil { baseCtx = srv.BaseContext(origListener) if baseCtx == nil { panic(\\\"BaseContext returned a nil context\\\") } } var tempDelay time.Duration // how long to sleep on accept failure ctx := context.WithValue(baseCtx, ServerContextKey, srv) for { rw, err := l.Accept() if err != nil { ····· ····· return err } connCtx := ctx if cc := srv.ConnContext; cc != nil { connCtx = cc(connCtx, rw) if connCtx == nil { panic(\\\"ConnContext returned nil\\\") } } tempDelay = 0 c := srv.newConn(rw) c.setState(c.rwc, StateNew, runHooks) // before Serve can return go c.serve(connCtx) } } \",\"我们通过代码可以看到，监听端口，然后accept阻塞直到返回下一个链接，经过一系列相关处理，创建一个新的连接，然后开一个goruntine处理这个连接，即每次一个http请求都会建立一个连接，每个连接中都会被赋予Server的信息，并通过goruntine来处理这个连接，这个就是go高并发的原理，具体连接的处理在conn.serve中，我们看到这个方法的参数是一个连接的上下文，方法代码如下：\",\" func (c *conn) serve(ctx context.Context) { c.remoteAddr = c.rwc.RemoteAddr().String() ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr()) defer func() { if err := recover(); err != nil && err != ErrAbortHandler { const size = 64 << 10 buf := make([]byte, size) buf = buf[:runtime.Stack(buf, false)] c.server.logf(\\\"http: panic serving %v: %v\\\\n%s\\\", c.remoteAddr, err, buf) } if !c.hijacked() { c.close() c.setState(c.rwc, StateClosed, runHooks) } }() ........ ........ // HTTP/1.x from here on. ctx, cancelCtx := context.WithCancel(ctx) c.cancelCtx = cancelCtx defer cancelCtx() c.r = &connReader{conn: c} c.bufr = newBufioReader(c.r) c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4<<10) for { w, err := c.readRequest(ctx) if c.r.remain != c.server.initialReadLimitSize() { // If we read any bytes off the wire, we're active. c.setState(c.rwc, StateActive, runHooks) } if err != nil { ....... ....... return } // Expect 100 Continue support req := w.req if req.expectsContinue() { if req.ProtoAtLeast(1, 1) && req.ContentLength != 0 { // Wrap the Body reader with one that replies on the connection req.Body = &expectContinueReader{readCloser: req.Body, resp: w} w.canWriteContinue.setTrue() } } else if req.Header.get(\\\"Expect\\\") != \\\"\\\" { w.sendExpectationFailed() return } c.curReq.Store(w) if requestBodyRemains(req.Body) { registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead) } else { w.conn.r.startBackgroundRead() } // HTTP cannot have multiple simultaneous active requests.[*] // Until the server replies to this request, it can't read another, // so we might as well run the handler in this goroutine. // [*] Not strictly true: HTTP pipelining. We could let them all process // in parallel even if their responses need to be serialized. // But we're not going to implement HTTP pipelining because it // was never deployed in the wild and the answer is HTTP/2. serverHandler{c.server}.ServeHTTP(w, w.req) w.cancelCtx() if c.hijacked() { return } w.finishRequest() .......... .......... c.rwc.SetReadDeadline(time.Time{}) } } \",\"我们看到这个方法中做了哪些事，方法执行完毕关闭当前连接，读取请求内容，处理并相应。具体处理请求的代码是这个 serverHandler{c.server}.ServeHTTP(w, w.req)我们看到实例化了一个serverHandler并调用了其ServeHTTP方法来处理，我看下这个serverHandler，代码如下：\",\" // serverHandler delegates to either the server's Handler or // DefaultServeMux and also handles \\\"OPTIONS *\\\" requests. type serverHandler struct { srv *Server } func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { handler := sh.srv.Handler if handler == nil { handler = DefaultServeMux } if req.RequestURI == \\\"*\\\" && req.Method == \\\"OPTIONS\\\" { handler = globalOptionsHandler{} } handler.ServeHTTP(rw, req) } \",\"我们看到代码里serverHandler中的 srv即为Server，在serverHandler的ServeHTTP方法中判断Server的Handler是否为nil，如果是nil则使用默认的DefaultServeMux，这里我们的Handler是由gin框架实现的一个ServeMux，调用ServeMux的ServeHTTP方法来处理请求，即交由gin来处理请求。gin中主要通过context.Next()方法来执行具体的gin.HandlerFunc函数，代码如下\",\" func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) engine.pool.Put(c) } func (engine *Engine) handleHTTPRequest(c *Context) { ........ ........ // Find root of the tree for the given HTTP method t := engine.trees for i, tl := 0, len(t); i < tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // Find route in tree value := root.getValue(rPath, c.Params, unescape) if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() c.writermem.WriteHeaderNow() return } ...... ...... break } ...... ...... c.handlers = engine.allNoRoute serveError(c, http.StatusNotFound, default404Body) } func (c *Context) Next() { c.index++ for c.index < int8(len(c.handlers)) { c.handlers[c.index](c) // 执行具体的HandlerFunc c.index++ } } \"]},\"13\":{\"c\":[\"golang\"]},\"14\":{\"c\":[\"go\",\"gin\",\"源码\",\"面试\",\"面试总结\"]},\"15\":{\"h\":\"Go语言的GPM调度器是什么？\",\"t\":[\"相信很多人都听说过Go语言天然支持高并发，原因是内部有协程（goroutine）加持，可以在一个进程中启动成千上万个协程。那么，它凭什么做到如此高的并发呢？那就需要先了解什么是并发模型。\"]},\"16\":{\"h\":\"并发模型\",\"t\":[\"著名的C++专家Herb Sutter曾经说过“免费的午餐已经终结”。为了让代码运行的更快，单纯依靠更快的硬件已经无法得到满足，我们需要利用多核来挖掘并行的价值，而并发模型的目的就是来告诉你不同执行实体之间是如何协作的。\",\"当然，不同的并发模型的协作方式也不尽相同，常见的并发模型有七种：\",\"线程与锁\",\"函数式编程\",\"Clojure之道\",\"actor\",\"通讯顺序进程（CSP）\",\"数据级并行\",\"Lambda架构\",\"而今天，我们只讲与Go语言相关的并发模型CSP，感兴趣的同学可以自行查阅书籍《七周七并发模型》。\"]},\"17\":{\"h\":\"CSP篇\",\"t\":[\"CSP，全称Communicating Sequential Processes，意为通讯顺序进程，它是七大并发模型中的一种，它的核心观念是将两个并发执行的实体通过通道channel连接起来，所有的消息都通过channel传输。其实CSP概念早在1978年就被东尼·霍尔提出，由于近来Go语言的兴起，CSP又火了起来。 那么CSP与Go语言有什么关系呢？接下来我们来看Go语言对CSP并发模型的实现——GPM调度模型。\"]},\"18\":{\"h\":\"GPM调度模型\",\"t\":[\"GPM代表了三个角色，分别是Goroutine、Processor、Machine。\",\"Goroutine：就是咱们常用的用go关键字创建的执行体，它对应一个结构体g，结构体里保存了goroutine的堆栈信息\",\"Machine：表示操作系统的线程\",\"Processor：表示处理器，有了它才能建立G、M的联系\"]},\"19\":{\"h\":\"Goroutine\",\"t\":[\"Goroutine就是代码中使用go关键词创建的执行单元，也是大家熟知的有“轻量级线程”之称的协程，协程是不为操作系统所知的，它由编程语言层面实现，上下文切换不需要经过内核态，再加上协程占用的内存空间极小，所以有着非常大的发展潜力。\",\"go func() {}() \",\"复制代码在Go语言中，Goroutine由一个名为runtime.go的结构体表示，该结构体非常复杂，有40多个成员变量，主要存储执行栈、状态、当前占用的线程、调度相关的数据。还有玩大家很想获取的goroutine标识，但是很抱歉，官方考虑到Go语言的发展，设置成私有了，不给你调用😏。\",\"type g struct { stack struct { lo uintptr hi uintptr } // 栈内存：[stack.lo, stack.hi) stackguard0 uintptr stackguard1 uintptr _panic *_panic _defer *_defer m *m // 当前的 m sched gobuf stktopsp uintptr // 期望 sp 位于栈顶，用于回溯检查 param unsafe.Pointer // wakeup 唤醒时候传递的参数 atomicstatus uint32 goid int64 preempt bool // 抢占信号，stackguard0 = stackpreempt 的副本 timer *timer // 为 time.Sleep 缓存的计时器 ... } \",\"Goroutine调度相关的数据存储在sched，在协程切换、恢复上下文的时候用到。\",\"type gobuf struct { sp uintptr pc uintptr g guintptr ret sys.Uintreg ... } \",\"M就是对应操作系统的线程，最多会有GOMAXPROCS个活跃线程能够正常运行，默认情况下GOMAXPROCS被设置为内核数，假如有四个内核，那么默认就创建四个线程，每一个线程对应一个runtime.m结构体。线程数等于CPU个数的原因是，每个线程分配到一个CPU上就不至于出现线程的上下文切换，可以保证系统开销降到最低。\",\"type m struct { g0 *g curg *g ... } \",\"M里面存了两个比较重要的东西，一个是g0，一个是curg。\",\"g0：会深度参与运行时的调度过程，比如goroutine的创建、内存分配等\",\"curg：代表当前正在线程上执行的goroutine。\",\"刚才说P是负责M与G的关联，所以M里面还要存储与P相关的数据。\",\"type m struct { ... p puintptr nextp puintptr oldp puintptr } \",\"p：正在运行代码的处理器\",\"nextp：暂存的处理器\",\"oldp：系统调用之前的线程的处理器\"]},\"20\":{\"h\":\"Processor\",\"t\":[\"Proccessor负责Machine与Goroutine的连接，它能提供线程需要的上下文环境，也能分配G到它应该去的线程上执行，有了它，每个G都能得到合理的调用，每个线程都不再浑水摸鱼，真是居家必备之良品。\",\"同样的，处理器的数量也是默认按照GOMAXPROCS来设置的，与线程的数量一一对应。\",\"type p struct { m muintptr runqhead uint32 runqtail uint32 runq [256]guintptr runnext guintptr ... } \",\"结构体P中存储了性能追踪、垃圾回收、计时器等相关的字段外，还存储了处理器的待运行队列，队列中存储的是待执行的Goroutine列表。\"]},\"21\":{\"h\":\"三者的关系\",\"t\":[\"首先，默认启动四个线程四个处理器，然后互相绑定。\",\"这个时候，一个Goroutine结构体被创建，在进行函数体地址、参数起始地址、参数长度等信息以及调度相关属性更新之后，它就要进到一个处理器的队列等待发车。\",\"啥，又创建了一个G？那就轮流往其他P里面放呗，相信你排队取号的时候看到其他窗口没人排队也会过去的。\",\"假如有很多G，都塞满了怎么办呢？那就不把G塞到处理器的私有队列里了，而是把它塞到全局队列里（候车大厅）。\",\"除了往里塞之外，M这边还要疯狂往外取，首先去处理器的私有队列里取G执行，如果取完的话就去全局队列取，如果全局队列里也没有的话，就去其他处理器队列里偷，哇，这么饥渴，简直是恶魔啊！\",\"如果哪里都没找到要执行的G呢？那M就会因为太失望和P断开关系，然后去睡觉（idle）了。\",\"那如果两个Goroutine正在通过channel做一些恩恩爱爱的事阻塞住了怎么办，难道M要等他们完事了再继续执行？显然不会，M并不稀罕这对Go男女，而会转身去找别的G执行。\"]},\"22\":{\"h\":\"系统调用\",\"t\":[\"如果G进行了系统调用syscall，M也会跟着进入系统调用状态，那么这个P留在这里就浪费了，怎么办呢？这点精妙之处在于，P不会傻傻的等待G和M系统调用完成，而会去找其他比较闲的M执行其他的G。\",\"当G完成了系统调用，因为要继续往下执行，所以必须要再找一个空闲的处理器发车。\",\"如果没有空闲的处理器了，那就只能把G放回全局队列当中等待分配。\"]},\"23\":{\"h\":\"sysmon\",\"t\":[\"sysmon是我们的保洁阿姨，它是一个M，又叫监控线程，不需要P就可以独立运行，每20us~10ms会被唤醒一次出来打扫卫生，主要工作就是回收垃圾、回收长时间系统调度阻塞的P、向长时间运行的G发出抢占调度等等。\",\"作者：平也\\n链接：https://juejin.im/post/5e999ead518825739b2d44d7\\n来源：掘金\\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\"]},\"24\":{\"c\":[\"golang\"]},\"25\":{\"c\":[\"go\",\"goroutine\",\"源码\",\"面试\",\"面试总结\"]},\"26\":{\"h\":\"goroutine调度器概述\"},\"27\":{\"h\":\"goroutine简介\",\"t\":[\"goroutine是Go语言实现的用户态线程，主要用来解决操作系统线程太“重”的问题，所谓的太重，主要表现在以下两个方面：\",\"创建和切换太重：操作系统线程的创建和切换都需要进入内核，而进入内核所消耗的性能代价比较高，开销较大；\",\"内存使用太重：一方面，为了尽量避免极端情况下操作系统线程栈的溢出，内核在创建操作系统线程时默认会为其分配一个较大的栈内存（虚拟地址空间，内核并不会一开始就分配这么多的物理内存），然而在绝大多数情况下，系统线程远远用不了这么多内存，这导致了浪费；另一方面，栈内存空间一旦创建和初始化完成之后其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有溢出的风险。\",\"而相对的，用户态的goroutine则轻量得多：\",\"goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换；\",\"goroutine启动时默认栈大小只有2k，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大，同时，如果栈太大了过于浪费它还能自动收缩，这样既没有栈溢出的风险，也不会造成栈内存空间的大量浪费。\",\"正是因为Go语言中实现了如此轻量级的线程，才使得我们在Go程序中，可以轻易的创建成千上万甚至上百万的goroutine出来并发的执行任务而不用太担心性能和内存等问题。\",\"注意： 为了避免混淆，从现在开始，后面出现的所有的线程一词均是指操作系统线程，而goroutine我们不再称之为什么什么线程而是直接使用goroutine这个词。\"]},\"28\":{\"h\":\"线程模型与调度器\",\"t\":[\"第一章讨论操作系统线程调度的时候我们曾经提到过，goroutine建立在操作系统线程基础之上，它与操作系统线程之间实现了一个多对多(M:N)的两级线程模型。\",\"这里的 M:N 是指M个goroutine运行在N个操作系统线程之上，内核负责对这N个操作系统线程进行调度，而这N个系统线程又负责对这M个goroutine进行调度和运行。\",\"所谓的对goroutine的调度，是指程序代码按照一定的算法在适当的时候挑选出合适的goroutine并放到CPU上去运行的过程，这些负责对goroutine进行调度的程序代码我们称之为goroutine调度器。用极度简化了的伪代码来描述goroutine调度器的工作流程大概是下面这个样子：\",\"// 程序启动时的初始化代码 ...... for i := 0; i < N; i++ { // 创建N个操作系统线程执行schedule函数 create_os_thread(schedule) // 创建一个操作系统线程执行schedule函数 } //schedule函数实现调度逻辑 func schedule() { for { //调度循环 // 根据某种算法从M个goroutine中找出一个需要运行的goroutine g := find_a_runnable_goroutine_from_M_goroutines() run_g(g) // CPU运行该goroutine，直到需要调度其它goroutine才返回 save_status_of_g(g) // 保存goroutine的状态，主要是寄存器的值 } } \",\"这段伪代码表达的意思是，程序运行起来之后创建了N个由内核调度的操作系统线程（为了方便描述，我们称这些系统线程为工作线程）去执行shedule函数，而schedule函数在一个调度循环中反复从M个goroutine中挑选出一个需要运行的goroutine并跳转到该goroutine去运行，直到需要调度其它goroutine时才返回到schedule函数中通过save_status_of_g保存刚刚正在运行的goroutine的状态然后再次去寻找下一个goroutine。\",\"需要强调的是，这段伪代码对goroutine的调度代码做了高度的抽象、修改和简化处理，放在这里只是为了帮助我们从宏观上了解goroutine的两级调度模型，具体的实现原理和细节将从本章开始进行全面介绍。\"]},\"29\":{\"h\":\"调度器数据结构概述\",\"t\":[\"第一章我们讨论操作系统线程及其调度时还说过，可以把内核对系统线程的调度简单的归纳为：在执行操作系统代码时，内核调度器按照一定的算法挑选出一个线程并把该线程保存在内存之中的寄存器的值放入CPU对应的寄存器从而恢复该线程的运行。\",\"万变不离其宗，系统线程对goroutine的调度与内核对系统线程的调度原理是一样的，实质都是通过保存和修改CPU寄存器的值来达到切换线程/goroutine的目的。\",\"因此，为了实现对goroutine的调度，需要引入一个数据结构来保存CPU寄存器的值以及goroutine的其它一些状态信息，在Go语言调度器源代码中，这个数据结构是一个名叫g的结构体，它保存了goroutine的所有信息，该结构体的每一个实例对象都代表了一个goroutine，调度器代码可以通过g对象来对goroutine进行调度，当goroutine被调离CPU时，调度器代码负责把CPU寄存器的值保存在g对象的成员变量之中，当goroutine被调度起来运行时，调度器代码又负责把g对象的成员变量所保存的寄存器的值恢复到CPU的寄存器。\",\"要实现对goroutine的调度，仅仅有g结构体对象是不够的，至少还需要一个存放所有（可运行）goroutine的容器，便于工作线程寻找需要被调度起来运行的goroutine，于是Go调度器又引入了schedt结构体，一方面用来保存调度器自身的状态信息，另一方面它还拥有一个用来保存goroutine的运行队列。因为每个Go程序只有一个调度器，所以在每个Go程序中schedt结构体只有一个实例对象，该实例对象在源代码中被定义成了一个共享的全局变量，这样每个工作线程都可以访问它以及它所拥有的goroutine运行队列，我们称这个运行队列为全局运行队列。\",\"既然说到全局运行队列，读者可能猜想到应该还有一个局部运行队列。确实如此，因为全局运行队列是每个工作线程都可以读写的，因此访问它需要加锁，然而在一个繁忙的系统中，加锁会导致严重的性能问题。于是，调度器又为每个工作线程引入了一个私有的局部goroutine运行队列，工作线程优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列，这大大减少了锁冲突，提高了工作线程的并发性。在Go调度器源代码中，局部运行队列被包含在p结构体的实例对象之中，每一个运行着go代码的工作线程都会与一个p结构体的实例对象关联在一起。\",\"除了上面介绍的g、schedt和p结构体，Go调度器源代码中还有一个用来代表工作线程的m结构体，每个工作线程都有唯一的一个m结构体的实例对象与之对应，m结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的goroutine以及是否空闲等等状态信息之外，还通过指针维持着与p结构体的实例对象之间的绑定关系。于是，通过m既可以找到与之对应的工作线程正在运行的goroutine，又可以找到工作线程的局部运行队列等资源。下面是g、p、m和schedt之间的关系图：\",\"上图中圆形图案代表g结构体的实例对象，三角形代表m结构体的实例对象，正方形代表p结构体的实例对象，其中红色的g表示m对应的工作线程正在运行的goroutine，而灰色的g表示处于运行队列之中正在等待被调度起来运行的goroutine。\",\"从上图可以看出，每个m都绑定了一个p，每个p都有一个私有的本地goroutine队列，m对应的线程从本地和全局goroutine队列中获取goroutine并运行之。\",\"前面我们说每个工作线程都有一个m结构体对象与之对应，但并未详细说明它们之间是如何对应起来的，工作线程执行的代码是如何找到属于自己的那个m结构体实例对象的呢？\",\"如果只有一个工作线程，那么就只会有一个m结构体对象，问题就很简单，定义一个全局的m结构体变量就行了。可是我们有多个工作线程和多个m需要一一对应，怎么办呢？还记得第一章我们讨论过的线程本地存储吗？当时我们说过，线程本地存储其实就是线程私有的全局变量，这不正是我们所需要的吗？！只要每个工作线程拥有了各自私有的m结构体全局变量，我们就能在不同的工作线程中使用相同的全局变量名来访问不同的m结构体对象，这完美的解决我们的问题。\",\"具体到goroutine调度器代码，每个工作线程在刚刚被创建出来进入调度循环之前就利用线程本地存储机制为该工作线程实现了一个指向m结构体实例对象的私有全局变量，这样在之后的代码中就使用该全局变量来访问自己的m结构体对象以及与m相关联的p和g对象。\",\"有了上述数据结构以及工作线程与数据结构之间的映射机制，我们可以把前面的调度伪代码写得更丰满一点：\",\"// 程序启动时的初始化代码 ...... for i := 0; i < N; i++ { // 创建N个操作系统线程执行schedule函数 create_os_thread(schedule) // 创建一个操作系统线程执行schedule函数 } // 定义一个线程私有全局变量，注意它是一个指向m结构体对象的指针 // ThreadLocal用来定义线程私有全局变量 ThreadLocal self *m //schedule函数实现调度逻辑 func schedule() { // 创建和初始化m结构体对象，并赋值给私有全局变量self self = initm() for { //调度循环 if (self.p.runqueue is empty) { // 根据某种算法从全局运行队列中找出一个需要运行的goroutine g := find_a_runnable_goroutine_from_global_runqueue() } else { // 根据某种算法从私有的局部运行队列中找出一个需要运行的goroutine g := find_a_runnable_goroutine_from_local_runqueue() } run_g(g) // CPU运行该goroutine，直到需要调度其它goroutine才返回 save_status_of_g(g) // 保存goroutine的状态，主要是寄存器的值 } } \",\"仅仅从上面这个伪代码来看，我们完全不需要线程私有全局变量，只需在schedule函数中定义一个局部变量就行了。但真实的调度代码错综复杂，不光是这个schedule函数会需要访问m，其它很多地方还需要访问它，所以需要使用全局变量来方便其它地方对m的以及与m相关的g和p的访问。\",\"在简单的介绍了Go语言调度器以及它所需要的数据结构之后，下面我们来看一下Go的调度代码中对上述的几个结构体的定义。\"]},\"30\":{\"h\":\"重要的结构体\",\"t\":[\"下面介绍的这些结构体中的字段非常多，牵涉到的细节也很庞杂，光是看这些结构体的定义我们没有必要也无法真正理解它们的用途，所以在这里我们只需要大概了解一下就行了，看不懂记不住都没有关系，随着后面对代码逐步深入的分析，我们也必将会对这些结构体有越来越清晰的认识。为了节省篇幅，下面各结构体的定义略去了跟调度器无关的成员。另外，这些结构体的定义全部位于Go语言的源代码路径下的runtime/runtime2.go文件之中。\"]},\"31\":{\"h\":\"stack结构体\",\"t\":[\"stack结构体主要用来记录goroutine所使用的栈的信息，包括栈顶和栈底位置：\",\"// Stack describes a Go execution stack. // The bounds of the stack are exactly [lo, hi), // with no implicit data structures on either side. //用于记录goroutine使用的栈的起始和结束位置 type stack struct { lo uintptr // 栈顶，指向内存低地址 hi uintptr // 栈底，指向内存高地址 } \"]},\"32\":{\"h\":\"gobuf结构体\",\"t\":[\"gobuf结构体用于保存goroutine的调度信息，主要包括CPU的几个寄存器的值：\",\"type gobuf struct { // The offsets of sp, pc, and g are known to (hard-coded in) libmach. // // ctxt is unusual with respect to GC: it may be a // heap-allocated funcval, so GC needs to track it, but it // needs to be set and cleared from assembly, where it's // difficult to have write barriers. However, ctxt is really a // saved, live register, and we only ever exchange it between // the real register and the gobuf. Hence, we treat it as a // root during stack scanning, which means assembly that saves // and restores it doesn't need write barriers. It's still // typed as a pointer so that any other writes from Go get // write barriers. sp uintptr // 保存CPU的rsp寄存器的值 pc uintptr // 保存CPU的rip寄存器的值 g guintptr // 记录当前这个gobuf对象属于哪个goroutine ctxt unsafe.Pointer // 保存系统调用的返回值，因为从系统调用返回之后如果p被其它工作线程抢占， // 则这个goroutine会被放入全局运行队列被其它工作线程调度，其它线程需要知道系统调用的返回值。 ret sys.Uintreg lr uintptr // 保存CPU的rip寄存器的值 bp uintptr // for GOEXPERIMENT=framepointer } \"]},\"33\":{\"h\":\"g结构体\",\"t\":[\"g结构体用于代表一个goroutine，该结构体保存了goroutine的所有信息，包括栈，gobuf结构体和其它的一些状态信息：\",\"// 前文所说的g结构体，它代表了一个goroutine type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the C stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash). // 记录该goroutine使用的栈 stack stack // offset known to runtime/cgo // 下面两个成员用于栈溢出检查，实现栈的自动伸缩，抢占调度也会用到stackguard0 stackguard0 uintptr // offset known to liblink stackguard1 uintptr // offset known to liblink ...... // 此goroutine正在被哪个工作线程执行 m *m // current m; offset known to arm liblink // 保存调度信息，主要是几个寄存器的值 sched gobuf ...... // schedlink字段指向全局运行队列中的下一个g， //所有位于全局运行队列中的g形成一个链表 schedlink guintptr ...... // 抢占调度标志，如果需要抢占调度，设置preempt为true preempt bool // preemption signal, duplicates stackguard0 = stackpreempt ...... } \"]},\"34\":{\"h\":\"m结构体\",\"t\":[\"m结构体用来代表工作线程，它保存了m自身使用的栈信息，当前正在运行的goroutine以及与m绑定的p等信息，详见下面定义中的注释：\",\"type m struct { // g0主要用来记录工作线程使用的栈信息，在执行调度代码时需要使用这个栈 // 执行用户goroutine代码时，使用用户goroutine自己的栈，调度时会发生栈的切换 g0 *g // goroutine with scheduling stack // 通过TLS实现m结构体对象与工作线程之间的绑定 tls [6]uintptr // thread-local storage (for x86 extern register) mstartfn func() // 指向工作线程正在运行的goroutine的g结构体对象 curg *g // current running goroutine // 记录与当前工作线程绑定的p结构体对象 p puintptr // attached p for executing go code (nil if not executing go code) nextp puintptr oldp puintptr // the p that was attached before executing a syscall // spinning状态：表示当前工作线程正在试图从其它工作线程的本地运行队列偷取goroutine spinning bool // m is out of work and is actively looking for work blocked bool // m is blocked on a note // 没有goroutine需要运行时，工作线程睡眠在这个park成员上， // 其它线程通过这个park唤醒该工作线程 park note // 记录所有工作线程的一个链表 alllink *m // on allm schedlink muintptr // Linux平台thread的值就是操作系统线程ID thread uintptr // thread handle freelink *m // on sched.freem ...... } \"]},\"35\":{\"h\":\"p结构体\",\"t\":[\"p结构体用于保存工作线程执行go代码时所必需的资源，比如goroutine的运行队列，内存分配用到的缓存等等。\",\"type p struct { lock mutex status uint32 // one of pidle/prunning/... link puintptr schedtick uint32 // incremented on every scheduler call syscalltick uint32 // incremented on every system call sysmontick sysmontick // last tick observed by sysmon m muintptr // back-link to associated m (nil if idle) ...... // Queue of runnable goroutines. Accessed without lock. //本地goroutine运行队列 runqhead uint32 // 队列头 runqtail uint32 // 队列尾 runq [256]guintptr //使用数组实现的循环队列 // runnext, if non-nil, is a runnable G that was ready'd by // the current G and should be run next instead of what's in // runq if there's time remaining in the running G's time // slice. It will inherit the time left in the current time // slice. If a set of goroutines is locked in a // communicate-and-wait pattern, this schedules that set as a // unit and eliminates the (potentially large) scheduling // latency that otherwise arises from adding the ready'd // goroutines to the end of the run queue. runnext guintptr // Available G's (status == Gdead) gFree struct { gList n int32 } ...... } \"]},\"36\":{\"h\":\"schedt结构体\",\"t\":[\"schedt结构体用来保存调度器的状态信息和goroutine的全局运行队列：\",\"type schedt struct { // accessed atomically. keep at top to ensure alignment on 32-bit systems. goidgen uint64 lastpoll uint64 lock mutex // When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be // sure to call checkdead(). // 由空闲的工作线程组成链表 midle muintptr // idle m's waiting for work // 空闲的工作线程的数量 nmidle int32 // number of idle m's waiting for work nmidlelocked int32 // number of locked m's waiting for work mnext int64 // number of m's that have been created and next M ID // 最多只能创建maxmcount个工作线程 maxmcount int32 // maximum number of m's allowed (or die) nmsys int32 // number of system m's not counted for deadlock nmfreed int64 // cumulative number of freed m's ngsys uint32 // number of system goroutines; updated atomically // 由空闲的p结构体对象组成的链表 pidle puintptr // idle p's // 空闲的p结构体对象的数量 npidle uint32 nmspinning uint32 // See \\\"Worker thread parking/unparking\\\" comment in proc.go. // Global runnable queue. // goroutine全局运行队列 runq gQueue runqsize int32 ...... // Global cache of dead G's. // gFree是所有已经退出的goroutine对应的g结构体对象组成的链表 // 用于缓存g结构体对象，避免每次创建goroutine时都重新分配内存 gFree struct { lock mutex stack gList // Gs with stacks noStack gList // Gs without stacks n int32 } ...... } \"]},\"37\":{\"h\":\"重要的全局变量\",\"t\":[\"allgs []*g // 保存所有的g allm *m // 所有的m构成的一个链表，包括下面的m0 allp []*p // 保存所有的p，len(allp) == gomaxprocs ncpu int32 // 系统中cpu核的数量，程序启动时由runtime代码初始化 gomaxprocs int32 // p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改 sched schedt // 调度器结构体对象，记录了调度器的工作状态 m0 m // 代表进程的主线程 g0 g // m0的g0，也就是m0.g0 = &g0 \",\"在程序初始化时，这些全变量都会被初始化为0值，指针会被初始化为nil指针，切片初始化为nil切片，int被初始化为数字0，结构体的所有成员变量按其本类型初始化为其类型的0值。所以程序刚启动时allgs，allm和allp都不包含任何g,m和p。\",\"原文： https://mp.weixin.qq.com/s?__biz=MzU1OTg5NDkzOA==&mid=2247483761&idx=1&sn=15949fbeb48985c6c3781583df6956e6&scene=19#wechat_redirect\"]},\"38\":{\"c\":[\"golang\"]},\"39\":{\"c\":[\"go\",\"goroutine\",\"源码\",\"面试\",\"面试总结\"]},\"40\":{\"h\":\"Go面试之map、struct、interface\"},\"41\":{\"h\":\"map\",\"t\":[\"Go里的map用于存放key/value对，在其它地方常称为hash、dictionary、关联数组，这几种称呼都是对同一种数据结构的不同称呼，它们都用于将key经过hash函数处理，然后映射到value，实现一一对应的关系。\",\"在Go中map的元素是无序的，遍历时是随机的。map是一个指针，底层是数组，所以map是引用类型。在函数中map作为参数传递时，若函数内部对map做了相关修改，函数外的map也会被修改。\",\"通过下面的示例对map进行声明和创建\",\"var m map[string]int // 声明一个map类型的变量,nil map，它将不会做任何初始化，不会指向任何数据结构 m := make(map[string]int) // 初始化，创建一个map m := map[string]int{} // 空map， 初始化，创建一个map \",\"len()函数用于获取map中元素的个数，即有多个少key。delete()用于删除map中的某个key。\",\"map的key可以是任意内置的数据类型(如int)，或者其它可以通过\\\"==\\\" 进行等值比较的数据类型，如interface和指针可以。slice、数组、map、struct类型都不能作为key。map的值可以是任意对象，包括函数、指针、stuct等等。下面的示例将会展示map的相关操作\",\"func main() { var m map[string]int // 声明一个map类型的变量 m = make(map[string]int) // 初始化一个map m[\\\"a\\\"] = 1 // 更新一个key/value值 i, ok := m[\\\"b\\\"] // 获取一个key值，ok是一个bool值，用来判断key是否存在 l := len(m) // 获取map的长度，即元素个数 delete(m, \\\"a\\\") // 删除指定的key for k, v := range m{ } // 遍历map } \",\"map同slice一样都是线程不安全的数据类型，多协程操作时需要注意。\"]},\"42\":{\"h\":\"struct\",\"t\":[\"struct定义结构，结构由字段(field)组成，每个field都有所属数据类型，在一个struct中，每个字段名都必须唯一。每个字段都有类型，可以是任意类型，包括内置简单数据类型、其它自定义的struct类型、当前struct类型本身、接口、函数、channel等等。声明如下：\",\"type User struct{ Name string Age int } 构造struct实例 var u User // 初始化一个实例 // 除此之外，还可以使用new()函数或&TYPE{}的方式来构造struct实例，它会为struct分配内存，为各个字段做好默认的赋0初始化。它们是等价的，都返回数据对象的指针给变量， // 实际上&TYPE{}的底层会调用new()。 var u *User u = &User{} \",\"从上面的代码示例我们可以看到struct实例可以是一个值也可以是一个指针。尽管一个是数据对象值，一个是指针，它们都是数据对象的实例。\",\"在函数中我们传递一个对象的实例可以是对象的值也可以是对象的指针，Go中的参数传递其本质都是以复制的方式传递的。若对象实例中数据比较复杂，建议使用指针作为参数值进行传递。\",\"在struct中，field除了名称和数据类型，还可以有一个tag属性。tag属性用于\\\"注释\\\"各个字段，除了reflect包，正常的程序中都无法使用这个tag属性。\",\"type User struct{ Name string `json:\\\"user\\\"` Age int `json:\\\"age\\\"` } \",\"struct中的字段可以不用给名称，这时称为匿名字段。匿名字段的名称强制和类型相同。例如：\",\"type animal struct { name string age int } type Horse struct{ inter animal sound string } \",\"上面的Horse中有两个匿名段inter和animal，它的名称和类型都是inter和animal。 在上面Horse中嵌套了其它的struct(如animal)。其中animal称为内部struct，Horse称为外部struct。\",\"假如外部struct中的字段名和内部struct的字段名相同，会如何？\",\"有以下两个名称冲突的规则：\",\"外部struct覆盖内部struct的同名字段、同名方法\",\"同级别的struct出现同名字段、方法将报错 第一个规则使得Go struct能够实现面向对象中的重写(override)，而且可以重写字段、重写方法。 第二个规则使得同名属性不会出现歧义。 struct可以嵌套自身的特性使之在实现树和链表上更加方便。\"]},\"43\":{\"h\":\"struct的方法\",\"t\":[\"type Person struct{ Name string Age int } func (u Person)SetName(name string){ u.Name = name } func (u *Person)SetAge(age int){ u.Age = age } \",\"除了实例有值类型和指针类型的区别，方法也有值类型的方法和指针类型的区别 setname()方法中是值类型的receiver，setage()方法中是指针类型的receiver。它们是有区别的。\",\"首先，setage()方法的p是一个指针类型的person实例，所以方法体中的p.age实际上等价于(*p).age。\",\"再者，方法就是函数，Go中所有需要传值的时候，都是按值传递的，也就是拷贝一个副本。\",\"setname()中，除了参数name string需要拷贝，receiver部分(p person)也会拷贝，而且它明确了要拷贝的对象是值类型的实例，也就是拷贝完整的person数据结构。但实例有两种类型：值类型和指针类型。(p person) 无视它们的类型，因为receiver严格规定p是一个值类型的实例。所以无论是指针类型的p1实例还是值类型的p2实例，都会拷贝整个实例对象。对于指针类型的实例p1，前面说了，在需要的时候，Go会自动解除引用，所以p1.setname() 等价于(*p1).setname()。\",\"也就是说，只要receiver是值类型的，无论是使用值类型的实例还是指针类型的实例，都是拷贝整个底层数据结构的，方法内部访问的和修改的都是实例的副本。所以，如果有修改操作，不会影响外部原始实例。\",\"setage()中，receiver部分(p *person)明确指定了要拷贝的对象是指针类型的实例，无论是指针类型的实例p1还是值类型的p2，都是拷贝指针。所以p2.setage()等价于(&p2).setage()。\",\"也就是说，只要receiver是指针类型的，无论是使用值类型的实例还是指针类型的实例，都是拷贝指针，方法内部访问的和修改的都是原始的实例数据结构。所以，如果有修改操作，会影响外部原始实例。\",\"那么选择值类型的receiver还是指针类型的receiver？一般来说选择指针类型的receiver。\"]},\"44\":{\"h\":\"struct的比较\",\"t\":[\"struct是可以比较，但同时也是不可以比较的，这个要看struct的场景。在 Go 语言中，Go 结构体有时候并不能直接比较，当其基本类型包含：slice、map、function 时，是不能比较的。若强行比较，就会导致出现例子中的直接报错的情况。而指针引用，其虽然都是 new(string)，从表象来看是一个东西，但其具体返回的地址是不一样的。\",\"如果我们被迫无奈，被要求一定要用结构体比较怎么办？这时候可以使用反射方法 reflect.DeepEqual，如下：\",\"func main() { v1 := Value{Name: \\\"对\\\", GoodAt: []string{\\\"的\\\", \\\"额\\\", \\\"我\\\"}} v2 := Value{Name: \\\"对\\\", GoodAt: []string{\\\"的\\\", \\\"额\\\", \\\"我\\\"}} if reflect.DeepEqual(v1, v2) { fmt.Println(\\\"yes\\\") return } fmt.Println(\\\"no\\\") } \"]},\"45\":{\"h\":\"interface\",\"t\":[\"接口(interface)是一种类型，用来定义行为(方法)。\",\" type User interface{ GetName() string SetName(name string) } type Person struct{ Name string } func (p *Person) GetName()string { return p.Name } func (p *Person) SetName(name string){ p.Name = name } var u User p := &Person{} u = p // 当接口实例中保存了自定义类型的实例后，就可以直接从接口上调用它所保存的实例的方法 u.SetName(\\\"dddd\\\") fmt.Println(u.GetName()) \",\"上面的示例，Person实例实现了User接口。\",\"接口类型是指针类型，但是它到底存放了什么东西？接口类型的数据结构是2个指针，占用2个机器字长。第一个是指针指向实例的类型信息和方法集，第二个指针就是实例的指针地址。\"]},\"46\":{\"h\":\"方法集\",\"t\":[\"方法集是类型的方法集合，对于非接口类型，每个类型都分两个Method Set：值类型实例是一个Method Set，指针类型的实例是另一个Method Set。两个Method Set由不同receiver类型的方法组成。\",\"值类型的实例的Method Set只由值类型的receiver(T Type)组成\",\"指针类型的实例的Method Set由值类型和指针类型的receiver共同组成，即(T Type)和(T *Type)\",\"从实现接口方法的角度上看：\",\"如果某类型实现接口的方法的receiver是(T Type)类型的，那么只有指针类型的实例T才算是实现了这个接口，因为这个方法不在值类型的实例T方法集中\",\"如果某类型实现接口的方法的receiver是(T Type)类型的，那么值类型的实例T和指针类型的实例T都算实现了这个接口，因为这个方法既在值类型的实例T方法集中，也在指针类型的实例T方法集中\"]},\"47\":{\"h\":\"空interface\",\"t\":[\"空接口是指没有定义任何接口方法的接口。没有定义任何接口方法，意味着Go中的任意对象都可以实现空接口(因为没方法需要实现)，任意对象都可以保存到空接口实例变量中。\",\"type empty_int interface{} // 声明一个空接口实例 var i interface{} \",\"可以定义一个空接口类型的array、slice、map、struct等，这样它们就可以用来存放任意类型的对象，因为任意类型都实现了空接口。\",\"any := make([]interface{}, 5) any[0] = 11 any[1] = \\\"hello world\\\" any[2] = []int{11, 22, 33, 44} for _, value := range any { fmt.Println(value) } \",\"显然，通过空接口类型，Go也能像其它动态语言一样，在数据结构中存储任意类型的数据。\",\"空接口是一种接口，它是一种指针类型的数据类型，虽然不严谨，但它确实保存了两个指针，一个是对象的类型(或iTable)，一个是对象的值。所以上面的赋值过程是让空接口any保存各个数据对象的类型和对象的值。\"]},\"48\":{\"h\":\"interface类型断言和type-switch\",\"t\":[\"接口实例中可以存放各种实现了接口的类型实例，在有需要的时候，还可以通过ins.(Type)或ins.(*Type)的方式将接口实例ins直接转回Type类型的实例。\",\"var i int = 30 var ins interface{} \",\"// 接口实例ins中保存的是int类型\",\"ins = i x := ins.(int) // 接口转回int类型的实例i println(x) //输出30 \",\"注意，接口实例转回时，接口实例中存放的是什么类型，才能转换成什么类型。同类型的值类型实例和指针类型实例不能互转，不同类型更不能互转。\",\"在不能转换时，Golang将直接以Panic的方式终止程序。但可以处理转换失败时的panic，这时需要类型断言，也即类型检测。\",\"// 如果ins保存的是值类型的Type，则输出 if t, ok := ins.(Type); ok { fmt.Printf(\\\"%T\\\\n\\\", v) } // 如果ins保存的是指针类型的*Type，则输出 if t, ok := ins.(*Type); ok { fmt.Printf(\\\"%T\\\\n\\\", v) } // 一个返回值的探测 t := ins.(Type) t := ins.(*Type) \",\"直接用if v,ok := ins.(Type);ok {}的方式做类型探测在探测类型数量多时不是很方便，需要重复写if结构。\",\"Golang提供了switch...case结构用于做多种类型的探测，所以这种结构也称为type-switch。这是比较方便的语法，比如可以判断某接口如果是A类型，就执行A类型里的特有方法，如果是B类型，就执行B类型里的特有方法。\",\"switch v := ins.(type) { case *Square: fmt.Printf(\\\"Type Square %T\\\\n\\\", v) case *Circle: fmt.Printf(\\\"Type Circle %T\\\\n\\\", v) case nil: fmt.Println(\\\"nil value: nothing to check?\\\") default: fmt.Printf(\\\"Unexpected type %T\\\", v) } \"]},\"49\":{\"c\":[\"golang\"]},\"50\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"51\":{\"h\":\"Go面试之并发安全的map\"},\"52\":{\"h\":\"并发安全的map\",\"t\":[\"在上一个总结中我们知道map是引用类型的，并且是非线程安全的。这个时候杠精面试官问，我就是要使用Go提供的原生map，你怎么来保证这个map是线程安全的呢？\",\"众所周知Go中有提供线程安全的map，那就是标准包里的sync.Map类型。那面试官要使用原生map，那他到底想从你这面获取什么呢？我们来思考这个问题。\",\"怎么保证线程安全的原生map，我们首先想到的是使用互斥锁或读写锁。案例：\",\"type myMap struct { l sync.RWMutex m map[string]int } func NewMyMap() *myMap { return &myMap{ m: make(map[string]int), } } func (m *myMap) Add(key string, val int) { m.l.Lock() defer m.l.Unlock() m.m[key] = val } func (m *myMap) Delete(key string) { m.l.Lock() defer m.l.Unlock() delete(m.m, key) } func (m *myMap) Find(key string) (int, bool) { m.l.RLock() defer m.l.RUnlock() val, ok := m.m[key] return val, ok } func main() { wg := sync.WaitGroup{} m := NewMyMap() for i := 1; i < 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() key := \\\"a\\\" m.Add(key, i) val, ok := m.Find(key) m.Delete(key) log.Println(val, ok) }(i) } wg.Wait() } \",\"案例中我们定义了一个结构体，结构体中有两个字段，l代表锁，这里我们选择的是读写锁，m代表的是一个map类型，key是string类型，val是int类型。对于这个结构体我们添加了三个方法，分别是Add，Delete，Find，添加、删除和查找。我们看到在这三个操作中都使用到了锁机制。main函数中我们利用for语句生成了9个goruntine，对同一个map下的key进行并发读写，运行程序正常输出，没有发生panic。说明锁起到了作用。\",\"从上面的案例中我们通过锁机制实现了并发安全的map，那我们还有其他的方式来实现吗？答案是有的，那就是通过channel机制来实现。\"]},\"53\":{\"h\":\"channel实现并发安全的map\",\"t\":[\"案例:\",\"type myMap struct { m map[string]int ch chan func() } func NewMyMap() *myMap { m := &myMap{ m: make(map[string]int), ch: make(chan func()), } go func() { for { (<-m.ch)() } }() return m } func (m *myMap) Add(key string, val int) { m.ch <- func() { log.Println(\\\"add\\\", key, val) m.m[key] = val } } func (m *myMap) Delete(key string) { m.ch <- func() { delete(m.m, key) } } func (m *myMap) Find(key string) (int, bool) { ch := make(chan int) m.ch <- func() { val, ok := m.m[key] log.Println(\\\"find\\\", val, ok) if !ok { close(ch) } else { ch <- val } } r, k := <-ch return r, k } func main() { wg := sync.WaitGroup{} m := NewMyMap() for i := 1; i < 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() key := \\\"a\\\" + strconv.Itoa(i) m.Add(key, i) val, ok := m.Find(key) m.Delete(key) log.Println(i, val, ok) }(i) } wg.Wait() } \",\"案例中我们定义了一个结构体，两个字段，ch代表chan，对应的是一个匿名函数，m定义map类型，在对实例初始化的时候，我们开启了一个go协程用来读取ch中的方法并执行。我们同样是通过for循环开了9个协程来对map进行增删改查，但是和上个锁的案例有个不同的地方是多个协程之间不再是对同一个key进行操作，而是对不同的key进行操作。这两者有什么区别呢？如果我们多协程对同一个key进行操作，我们输出的结果和我们预想的将大相径庭。大家可以对代码进行修改试一试。\",\"如果杠精面试官说我就想要多协程对同一个key进行操作，那咋办呢？我个人建议是使用锁进行实现，channel的实现只能保证这个map在并发读写的时候不会panic，但达不到我们预想的要求。\",\"下面是多协程在channel方法下对同一个key进行操作的结果，大家可以参考下。\",\"至于为什么面试官不想用sync.map我想大家心中已经有了答案，主要就是考察面试者对锁和channel的知识，至于sync.map的相关知识大家可以读这篇文章：\"]},\"54\":{\"c\":[\"golang\"]},\"55\":{\"c\":[\"go\",\"golang\",\"map\",\"并发安全\",\"源码\",\"面试\",\"面试总结\"]},\"56\":{\"h\":\"Go面试之sync.Mutex和sync.RWMutex\",\"t\":[\"在上一个总结中我们在实现线程安全的map的时候用到了锁的概念，面试官听到这个锁的实现方法之后双眼冒光，开始了新一轮的攻势。问：互斥锁和读写锁有啥区别？\"]},\"57\":{\"h\":\"sync.Mutex互斥锁\",\"t\":[\"Go中标准包提供sync.Mutex类型实现mutex(排他锁、互斥锁)。定义：\",\"// A Mutex is a mutual exclusion lock. // The zero value for a Mutex is an unlocked mutex. // // A Mutex must not be copied after first use. type Mutex struct { state int32 sema uint32 } \",\"sync.Mutex提供两个方法，Lock()方法获取锁，UnLock()释放锁。一旦被锁住，其他的Lock操作将无法进行，直到其被UnLock。在goruntine中已有的锁在没有被释放前去获取锁，那么这个gorutine将会被阻塞，只有在UnLock后才会解除阻塞。案例：\",\"var i int var m sync.Mutex func add() { m.Lock() defer m.Unlock() i++ } func read() int { m.Lock() defer m.Unlock() return i } func noLockRead() int { return i } func main() { var wg sync.WaitGroup for j := 0; j < 10; j++ { wg.Add(1) go func(j int) { defer wg.Done() add() log.Println(\\\"nolock\\\", j, noLockRead()) log.Println(j, read()) }(j) } wg.Wait() } \",\"我们看到在代码案例中我们对共享的变量i进行加和读操作，add方法中使用了互斥锁，记住：**在Lock()和Unlock()之间的代码段称为资源的临界区(critical section)，在这一区间内的代码是严格被Lock()保护的，是线程安全的，任何一个时间点都只能有一个goroutine执行这段区间的代码。**由于add和read操作都会使用到锁，所以20个goruntine将会产生40个资源临界区，Lock保证了在一个时间点只有其中一个goruntine可以访问其中一个临界区，当释放了释放了一个临界区，其他的Lock将会竞争互斥锁，这个叫做锁竞争。因为竞争的存在，这40个临界区是随机被访问的，所以是无序的，总结下来就是：Mutex保证了每个资源临界区的安全，某一时间点只有一个goroutine访问到这部分，但也因此而出现了随机性。\",\"在Go中允许这样：如果在一个地方Lock()，在另一个地方不Lock()而是直接修改或访问共享数据，这对于sync.Mutex类型来说是允许的，因为mutex不会和goroutine进行关联。\",\"根据上述的结论，在上个总结的线程安全的map一文中是有一处错误的，那就是使用锁机制实现的线程安全的map，也是无法保证操作顺序的，只能保证map是线程安全的。\"]},\"58\":{\"h\":\"sync.RWMutex读写锁\",\"t\":[\"看下这个结构的定义：\",\"type RWMutex struct { w Mutex // held if there are pending writers writerSem uint32 // 写锁需要等待读锁释放的信号量 readerSem uint32 // 读锁需要等待写锁释放的信号量 readerCount int32 // 表示当前启用的读者数量，包括了所有正在临界区里面的读者或者被写锁阻塞的等待进入临界区读者的数量。相当于是当前调用了 RLock 函数并且还没调用 RUnLock 函数的读者的数量。 readerWait int32 // 用来记录在获取写锁之前，需要等待多少读锁释放的数量。 } \",\"从上面的代码我们可以看出：\",\"Go中的读写锁是基于互斥锁的\",\"读写锁允许有多个读锁和一个写锁 \",\"可以同时申请多个读锁\",\"有写锁时，申请读锁和写锁将会阻塞\",\"读写锁常被用于读多写少的场景\",\"func (rw *RWMutex) Lock() 写锁，如果在添加写锁之前已经有其他的读锁和写锁，则lock就会阻塞直到该锁可用，为确保该锁最终可用，已阻塞的 Lock 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定。\",\"func (rw *RWMutex) Unlock() 写锁解锁，如果没有进行写锁定，则就会引起一个运行时错误\",\"func (rw *RWMutex) RLock() 读锁，当有写锁时，无法加载读锁，当只有读锁或者没有锁时，可以加载读锁，读锁可以加载多个，所以适用于＂读多写少＂的场景\",\"func (rw *RWMutex)RUnlock() 读锁解锁，RUnlock 撤销单次 RLock 调用，一次RUnlock()操作只是对读锁数量减1，即减少一次读锁的引用计数，如果没有进行写锁定，则就会引起一个运行时错误\",\"案例：\",\"package main import ( \\\"log\\\" \\\"sync\\\" ) type myMap struct { rw sync.RWMutex m sync.Mutex data map[string]int } func (m *myMap) add(key string, val int) { m.rw.Lock() log.Println(\\\"add\\\", key, val) //time.Sleep(time.Second * 3) defer m.rw.Unlock() m.data[key] = val } func (m *myMap) mFind(key string) int { m.m.Lock() log.Println(\\\"mfind\\\", key) //time.Sleep(time.Second) defer m.m.Unlock() return m.data[key] } func (m *myMap) rwFind(key string) int { m.rw.RLock() log.Println(\\\"rwfind\\\", key) //time.Sleep(time.Second) defer m.rw.RUnlock() return m.data[key] } func main() { wg := sync.WaitGroup{} m := &myMap{data: make(map[string]int)} key := \\\"a\\\" for i := 0; i < 5; i++ { wg.Add(3) go func(i int) { defer wg.Done() m.add(key, i) }(i) go func(i int) { defer wg.Done() log.Println(\\\"mfor\\\", i, m.mFind(key)) }(i) go func(i int) { defer wg.Done() log.Println(\\\"rwfor\\\", i, m.rwFind(key)) }(i) } wg.Wait() } \",\"上述代码中我们定义了一个结构体，里面的属性一个是互斥锁，一个是读写锁，还有个map结构。mFind方法通过互斥锁去读map数据，rwFind方法通过读写锁去读取数据。当使用mFind读取数据时，我们发现读数据和写数据互不冲突，读和读却是冲突的，因为是互斥锁。使用rwFind读取数据，虽然读锁不冲突，因为读写锁可以多次获取读锁，但是若一个写锁在占用锁，那多个读锁就都会阻塞，要等待写锁完成释放后，读锁才会继续执行。\"]},\"59\":{\"h\":\"sync.Mutex和sync.RWMutex如何选择\",\"t\":[\"Mutex和RWMutex都不关联goroutine，它们的锁申请行为可以在一个goroutine中操作，释放锁行为可以在另一个goroutine中操作。但RWMutex显然更适用于读多写少的场景。仅针对读的性能来说，RWMutex要高于Mutex，因为rwmutex的多个读可以并存。\"]},\"60\":{\"c\":[\"golang\"]},\"61\":{\"c\":[\"go\",\"golang\",\"mutex\",\"并发安全\",\"源码\",\"面试\",\"面试总结\"]},\"62\":{\"h\":\"Go面试之Slice\"},\"63\":{\"h\":\"切片\",\"t\":[\"切片是Golang中特有的数据类型。在Go语言中数组是固定长度的，不能动态扩容的，在编译器会固定大小。而切片是对数组的抽象，是一种灵活地\\\"动态数组\\\"，切片可以追加元素。切片是一种数据结构，切片不是数组，切片描述的是一块数据。切片声明如下：\",\"var ints []int // 直接声明 ints := []int{1, 2, 3, 4} // 字面量声明 ints := make([]int{}, 2, 4) // make创建 ints := arr[1:5] // 下表截取创建 ints := *new([]int) // new一个 \",\"其中最常用的是make创建和下标截取。切片可以通过Go内置append方法进行追加元素，当cap不够时进行动态扩容。一般cap是切片长度的两倍。切片是引用类型。\",\"切片的内置结构：\",\"type SliceHeader struct { Data uintptr // 表示该slice结构从底层数组的哪一个元素开始，该指针指向该元素 Len int // 表示slice当前的长度，如果追加元素，长度不够时会扩展，最大扩展到Capacity的长度 Cap int // 即底层数组的长度，表示这个slice目前最多能扩展到这么长 } \",\"切片的Data属性是指向切片数组的指针，这个概念很重要。若切片发生拷贝，其实质是对当前三个属性的拷贝，不管当前slice具体有多少个元素，其拷贝时间都是大差不差的。\",\"切片的扩容 切片在扩容时会进行内存对齐，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于老 slice 容量的 2倍或者1.25倍，当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。\",\"我们来关注下面的代码：\",\"func main() { ints := make([]int, 2, 4) fmt.Println(ints) // [0 0] int1 := ints[1:] fmt.Println(int1, cap(int1)) // [0] 3 int1[0] = 1 fmt.Println(ints) // [0 1] int1 = append(int1, 2) fmt.Println(int1, cap(int1)) // [1 2] 3 fmt.Println(ints) // [0 1] int1[0] = 2 fmt.Println(ints, int1, cap(int1)) // [0 2] [2 2] 3 ints = append(ints, 3) fmt.Println(ints, int1, cap(int1)) // [0 2 3] [2 3] 3 } \",\"首先我们声明了一个长度为2，cap为4的int类型切片，这是个零切片。接着我们通过下标截取的方式声明了一个int类型的切片， 这个时候 int1切片的data属性的指针地址和ints的指针地址是一样的，长度为1，容量为3。我们对int1进行下标修改，同时ints对应的元素值也会修改。\",\"接着我们使用Go内置的append函数对int1进行追加，使之长度发生了改变，这个时候int1的长度小于容量，指针不会被重新分配，但是追加数据不会影响ints，因为ints的长度为2，下标未满足条件，访问不了int1追加的元素。\",\"接着我们使用Go内置的append函数对ints进行追加，使之长度发生了改变，这个时候ints的长度小于容量，指针不会被重新分配，但是追加数据会影响int1，在底层数组上int1是ints的子集。\",\"range遍历切片有什么要注意的？\",\"func main() { users := []User{ {\\\"张三\\\", 18}, {\\\"李四\\\", 34}, {\\\"王五\\\", 21}, } for _, v := range users{ if v.Age != 20{ v.Age = 20 } } fmt.Println(users) // [{张三 18} {李四 34} {王五 21}] } \",\"使用range遍历切片users，变量v是拷贝切片中的数据，修改拷贝数据不会对原切片有影响。\"]},\"64\":{\"c\":[\"golang\"]},\"65\":{\"c\":[\"go\",\"golang\",\"slice\",\"面试\",\"面试总结\",\"源码\"]},\"66\":{\"h\":\"为什么MySQL使用B+树做索引？\",\"t\":[\"索引这个词，相信大多数人已经相当熟悉了，很多人都知道MySQL的索引主要以B+树为主，但是要问到为什么用B+树，恐怕很少有人能把前因后果讲述的很完整。本文就来从头到尾介绍下数据库的索引。\",\"索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。 索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在[1,2,3,4]中找到4这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。索引在mysql数据库中分三类：\",\"B+树索引、Hash索引、全文索引\",\"我们今天要介绍的是工作开发中最常接触到innodb存储引擎中的的B+树索引。\",\"要介绍B+树索引，就不得不提二叉查找树，平衡二叉树和B树这三种数据结构。B+树就是从他们仨演化来的。\"]},\"67\":{\"h\":\"二叉查找树\",\"t\":[\"首先，让我们先看一张图\",\"从图中可以看到，我们为user表（用户信息表）建立了一个二叉查找树的索引。图中的圆为二叉查找树的节点，节点中存储了键(key)和数据(data)。\",\"键对应user表中的id，数据对应user表中的行数据。二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。 顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。\",\"如果我们需要查找id=12的用户信息，利用我们创建的二叉查找树索引，查找流程如下：\",\"将根节点作为当前节点，把12与当前节点的键值10比较，12大于10，接下来我们把当前节点>的右子节点作为当前节点。\",\"继续把12和当前节点的键值13比较，发现12小于13，把当前节点的左子节点作为当前节点。\",\"把12和当前节点的键值12对比，12等于12，满足条件，我们从当前节点中取出data，即id=12,name=xm。\",\"利用二叉查找树我们只需要3次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要6次才能找到。\"]},\"68\":{\"h\":\"平衡二叉树\",\"t\":[\"上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造：\",\"这个时候可以看到我们的二叉查找树变成了一个链表。\",\"如果我们需要查找id=17的用户信息，我们需要查找7次，也就相当于全表扫描了。\",\"导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。\",\"为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。\",\"平衡二叉树又称AVL树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过1。\",\"下面是平衡二叉树和非平衡二叉树的对比：\",\"由平衡二叉树的构造我们可以发现第一张图中的二叉树其实就是一棵平衡二叉树。\",\"平衡二叉树保证了树的构造是平衡的，当我们插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式这里就不介绍了。\",\"平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。\"]},\"69\":{\"h\":\"B树\",\"t\":[\"因为内存的易失性。一般情况下，我们都会选择将user表中的数据和索引存储在磁盘这种外围设备中。\",\"但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。 另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。\",\"如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。\",\"如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。\",\"那说明什么？\",\"说明每个磁盘块仅仅存储一个键值和数据！\",\"那如果我们要存储海量的数据呢？\",\"可以想象到二叉树的节点将会非常多，高度也会及其高，我们查找数据时也会进行很多次磁盘IO，我们查找数据的效率将会极低！\",\"为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的B树。\",\"B树（Balance Tree）即为平衡树的意思，下图即是一颗B树。\",\"图中的p节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。- 图中的每个节点称为页，页就是我们上面说的磁盘块，在mysql中数据读取的基本单位都是页，所以我们这里叫做页更符合mysql中索引的底层数据结构。\",\"从上图可以看出，B树相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的B树为3阶B树，高度也会很低。 基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。\",\"假如我们要查找id=28的用户信息，那么我们在上图B树中查找的流程如下：\",\"先找到根节点也就是页1，判断28在键值17和35之间，我们那么我们根据页1中的指针p2找到页3。\",\"将28和页3中的键值相比较，28在26和30之间，我们根据页3中的指针p2找到页8。\",\"将28和页8中的键值相比较，发现有匹配的键值28，键值28对应的用户信息为(28,bv)。\"]},\"70\":{\"h\":\"B+树\",\"t\":[\"B+树是对B树的进一步优化。让我们先来看下B+树的结构图：\",\"根据上图我们来看下B+树和B树有什么不同。\",\"B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。另外，B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。\",\"因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。\",\"有心的读者可能还发现上图B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。 其实上面的B树我们也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在mysql的innodb存储引擎中，索引就是这样存储的。也就是说上图中的B+树索引就是innodb中B+树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。 通过上图可以看到，在innodb中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。 MyISAM中的B+树索引实现与innodb中的略有不同。在MyISAM中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。\"]},\"71\":{\"h\":\"聚集索引 VS 非聚集索引\",\"t\":[\"在上节介绍B+树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。那什么是聚集索引呢？ 在MySQL中，B+树索引按照存储方式的不同分为聚集索引和非聚集索引。 这里我们着重介绍innodb中的聚集索引和非聚集索引。\",\"聚集索引（聚簇索引）：以innodb作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这是因为innodb是把数据存放在B+树中的，而B+树的键值就是主键，在B+树的叶子节点中，存储了表中所有的数据。这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。\",\"非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。\",\"明白了聚集索引和非聚集索引的定义，我们应该明白这样一句话：数据即索引，索引即数据。\"]},\"72\":{\"h\":\"利用聚集索引和非聚集索引查找数据\",\"t\":[\"前面我们讲解B+树索引的时候并没有去说怎么在B+树中进行数据的查找，主要就是因为还没有引出聚集索引和非聚集索引的概念。下面我们通过讲解如何通过聚集索引以及非聚集索引查找数据表中数据的方式介绍一下B+树索引查找数据方法。 利用聚集索引查找数据\",\"还是这张B+树索引图，现在我们应该知道这就是聚集索引，表中的数据存储在其中。现在假设我们要查找id>=18并且id<40的用户数据。对应的sql语句为select * from user where id>=18 and id <40，其中id为主键。具体的查找过程如下：\",\"一般根节点都是常驻内存的，也就是说页1已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。 从内存中读取到页1，要查找这个id>=18 and id <40或者范围值，我们首先需要找到id=18的键值。 从页1中我们可以找到键值18，此时我们需要根据指针p2，定位到页3。\",\"要从页3中查找数据，我们就需要拿着p2指针去磁盘中进行读取页3。 从磁盘中读取页3后将页3放入内存中，然后进行查找，我们可以找到键值18，然后再拿到页3中的指针p1，定位到页8。\",\"同样的页8页不在内存中，我们需要再去磁盘中将页8读取到内存中。 将页8读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值18。 此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值18对应的数据。 因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页8中的键值依次进行遍历查找并匹配满足条件的数据。 我们可以一直找到键值为22的数据，然后页8中就没有数据了，此时我们需要拿着页8中的p指针去读取页9中的数据。\",\"因为页9不在内存中，就又会加载页9到内存中，并通过和页8中一样的方式进行数据的查找，直到将页12加载到内存中，发现41大于40，此时不满足条件。那么查找到此终止。 最终我们找到满足条件的所有数据为：(18,kl),(19,kl),(22,hj),(24,io),(25,vg),(29,jk),(31,jk),(33,rt),(34,ty),(35,yu),(37,rt),(39,rt) 总共12条记录。\",\"下面看下具体的查找流程图：\",\"利用非聚集索引查找数据\",\"读者看到这张图的时候可能会蒙，这是啥东西啊？怎么都是数字。 如果有这种感觉，请仔细看下图中红字的解释。什么？还看不懂？那我再来解释下吧。首先，这个非聚集索引表示的是用户幸运数字的索引（为什么是幸运数字？一时兴起想起来的:-)），此时表结构是这样的。\",\"id\",\"name\",\"luckyNum\",\"1\",\"zs\",\"23\",\"2\",\"ls\",\"7\",\"在叶子节点中，不在存储所有的数据了，存储的是键值和主键。\",\"对于叶子节点中的x-y，比如1-1。左边的1表示的是索引的键值，右边的1表示的是主键值。如果我们要找到幸运数字为33的用户信息，对应的sql语句为select * from user where luckNum=33。\",\"查找的流程跟聚集索引一样，这里就不详细介绍了。我们最终会找到主键值47，找到主键后我们需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。\",\"下面看下具体的查找流程图：\",\"在MyISAM中，聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。\"]},\"73\":{\"h\":\"总结\",\"t\":[\"本篇文从二叉查找树，详细说明了为什么mysql用B+树作为数据的索引，以及在innodb中数据库如何通过B+树索引来存储数据以及查找数据。我们一定要记住这句话：数据即索引，索引即数据。\",\"原文： 再有人问你为什么MySQL用B+树做索引，就把这篇文章发给她\"]},\"74\":{\"c\":[\"mysql\"]},\"75\":{\"c\":[\"mysql\",\"面试\",\"面试总结\"]},\"76\":{\"h\":\"MySQL数据库经典面试题解析\"},\"77\":{\"h\":\"1. MySQL 索引使用有哪些注意事项呢？\",\"t\":[\"可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则\"]},\"78\":{\"h\":\"索引哪些情况会失效\",\"t\":[\"查询条件包含or，可能导致索引失效\",\"如何字段类型是字符串，where时一定用引号括起来，否则索引失效\",\"like通配符可能导致索引失效。\",\"联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。\",\"在索引列上使用mysql的内置函数，索引失效。\",\"对索引列运算（如，+、-、*、/），索引失效。\",\"索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。\",\"索引字段上使用is null， is not null，可能导致索引失效。\",\"左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。\",\"mysql估计使用全表扫描要比使用索引快,则不使用索引。\"]},\"79\":{\"h\":\"索引不适合哪些场景\",\"t\":[\"数据量少的不适合加索引\",\"更新比较频繁的也不适合加索引\",\"区分度低的字段不适合加索引（如性别）\"]},\"80\":{\"h\":\"索引的一些潜规则\",\"t\":[\"覆盖索引\",\"回表\",\"索引数据结构（B+树）\",\"最左前缀原则\",\"索引下推\"]},\"81\":{\"h\":\"2. MySQL 遇到过死锁问题吗，你是如何解决的？\",\"t\":[\"我排查死锁的一般步骤是酱紫的：\",\"查看死锁日志show engine innodb status;\",\"找出死锁Sql\",\"分析sql加锁情况\",\"模拟死锁案发\",\"分析死锁日志\",\"分析死锁结果\"]},\"82\":{\"h\":\"3. 日常工作中你是怎么优化SQL的？\",\"t\":[\"可以从这几个维度回答这个问题：\",\"加索引\",\"避免返回不必要的数据\",\"适当分批量进行\",\"优化sql结构\",\"分库分表\",\"读写分离\"]},\"83\":{\"h\":\"4. 说说分库与分表的设计\",\"t\":[\"分库分表方案，分库分表中间件，分库分表可能遇到的问题\"]},\"84\":{\"h\":\"分库分表方案:\",\"t\":[\"水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。\",\"水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。\",\"垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。\",\"垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。\"]},\"85\":{\"h\":\"常用的分库分表中间件：\",\"t\":[\"sharding-jdbc（当当）\",\"Mycat\",\"TDDL（淘宝）\",\"Oceanus(58同城数据库中间件)\",\"vitess（谷歌开发的数据库中间件）\",\"Atlas(Qihoo 360)\"]},\"86\":{\"h\":\"分库分表可能遇到的问题\",\"t\":[\"事务问题：需要用分布式事务啦\",\"跨节点Join的问题：解决这一问题可以分两次查询实现\",\"跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。\",\"数据迁移，容量规划，扩容等问题\",\"ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID\",\"跨分片的排序分页问题（后台加大pagesize处理？）\"]},\"87\":{\"h\":\"5. InnoDB与MyISAM的区别\",\"t\":[\"InnoDB支持事务，MyISAM不支持事务\",\"InnoDB支持外键，MyISAM不支持外键\",\"InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持\",\"select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。\",\"Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）\",\"InnoDB支持表、行级锁，而MyISAM支持表级锁。\",\"InnoDB表必须有主键，而MyISAM可以没有主键\",\"Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。\",\"Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。\",\"InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引\",\"InnoDB 属于索引组织表，使用共享表空间和多表空间储存数据。MyISAM用.frm、.MYD、.MTI来储存表定义，数据和索引。\"]},\"88\":{\"h\":\"6. 数据库索引的原理，为什么要用 B+树，为什么不用二叉树？\",\"t\":[\"可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？\"]},\"89\":{\"h\":\"为什么不是一般二叉树？\",\"t\":[\"如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。\"]},\"90\":{\"h\":\"为什么不是平衡二叉树呢？\",\"t\":[\"我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。\"]},\"91\":{\"h\":\"那为什么不是B树而是B+树呢？\",\"t\":[\"1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。\",\"2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。\"]},\"92\":{\"h\":\"7. 聚集索引与非聚集索引的区别\",\"t\":[\"一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。\",\"聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。\",\"索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\",\"聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；\",\"何时使用聚集索引或非聚集索引？\"]},\"93\":{\"h\":\"8. limit 1000000 加载很慢的话，你是怎么解决的呢？\",\"t\":[\"方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit\",\"select id，name from employee where id>1000000 limit 10. \",\"方案二：在业务允许的情况下限制页数：\",\"建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。\",\"方案三：order by + 索引（id为索引）\",\"select id，name from employee order by id limit 1000000，10 \",\"SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id \",\"方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）\"]},\"94\":{\"h\":\"9. 如何选择合适的分布式主键方案呢？\",\"t\":[\"数据库自增长序列或字段。\",\"UUID。\",\"Redis生成ID\",\"Twitter的snowflake算法\",\"利用zookeeper生成唯一ID\",\"MongoDB的ObjectId\"]},\"95\":{\"h\":\"10. 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？\",\"t\":[\"读未提交（Read Uncommitted）\",\"读已提交（Read Committed）\",\"可重复读（Repeatable Read）\",\"串行化（Serializable）\",\"Mysql默认的事务隔离级别是可重复读(Repeatable Read)\"]},\"96\":{\"h\":\"11. 什么是幻读，脏读，不可重复读呢？\",\"t\":[\"事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是脏读\",\"在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。\",\"事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。\"]},\"97\":{\"h\":\"12. 在高并发情况下，如何做到安全的修改同一行数据？\",\"t\":[\"要安全的修改同一行数据，就要保证一个线程在修改时其它线程无法更新这行记录。一般有悲观锁和乐观锁两种方案~\"]},\"98\":{\"h\":\"使用悲观锁\",\"t\":[\"悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~ 比如，可以使用select…for update ~\",\"select * from User where name=‘jay’ for update \",\"以上这条sql语句会锁定了User表中所有符合检索条件（name=‘jay’）的记录。本次事务提交之前，别的线程都无法修改这些记录。\"]},\"99\":{\"h\":\"使用乐观锁\",\"t\":[\"乐观锁思想就是，有线程过来，先放过去修改，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就修改失败或者重试。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。\"]},\"100\":{\"h\":\"13. 数据库的乐观锁和悲观锁。\"},\"101\":{\"h\":\"悲观锁：\",\"t\":[\"悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。\"]},\"102\":{\"h\":\"乐观锁：\",\"t\":[\"乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。\"]},\"103\":{\"h\":\"14. SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。\",\"t\":[\"show status 命令了解各种 sql 的执行频率\",\"通过慢查询日志定位那些执行效率较低的 sql 语句\",\"explain 分析低效 sql 的执行计划（这点非常重要，日常开发中用它分析Sql，会大大降低Sql导致的线上事故）\"]},\"104\":{\"h\":\"15. select for update有什么含义，会锁表还是锁行还是其他。\"},\"105\":{\"h\":\"select for update 含义\",\"t\":[\"select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁哦。至于加了是行锁还是表锁，这就要看是不是用了索引/主键啦。 没用索引/主键的话就是表锁，否则就是是行锁。\"]},\"106\":{\"h\":\"16. MySQL事务得四大特性以及实现原理\",\"t\":[\"原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\",\"一致性： 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。\",\"隔离性： 多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。\",\"持久性： 表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。\"]},\"107\":{\"h\":\"事务ACID特性的实现思想\",\"t\":[\"原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。\",\"持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。\",\"隔离性：通过锁以及MVCC,使事务相互隔离开。\",\"一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。\"]},\"108\":{\"h\":\"17. 如果某个表有近千万数据，CRUD比较慢，如何优化。\"},\"109\":{\"h\":\"分库分表\",\"t\":[\"某个表有近千万数据，可以考虑优化表结构，分表（水平分表，垂直分表），当然，你这样回答，需要准备好面试官问你的分库分表相关问题呀，如\",\"分表方案（水平分表，垂直分表，切分规则hash等）\",\"分库分表中间件（Mycat，sharding-jdbc等）\",\"分库分表一些问题（事务问题？跨节点Join的问题）\",\"解决方案（分布式事务等）\"]},\"110\":{\"h\":\"索引优化\",\"t\":[\"除了分库分表，优化表结构，当然还有所以索引优化等方案~\"]},\"111\":{\"h\":\"18. 如何写sql能够有效的使用到复合索引。\",\"t\":[\"复合索引，也叫组合索引，用户可以在多个列上建立索引,这种索引叫做复合索引。\",\"当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。\",\"select * from table where k1=A AND k2=B AND k3=D \",\"有关于复合索引，我们需要关注查询Sql条件的顺序，确保最左匹配原则有效，同时可以删除不必要的冗余索引。\"]},\"112\":{\"h\":\"19. mysql中in 和exists的区别。\",\"t\":[\"这个，跟一下demo来看更刺激吧，啊哈哈\",\"假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下SQL:\",\"select * from A where deptId in (select deptId from B); \",\"这样写等价于：\",\"先查询部门表B select deptId from B 再由部门deptId，查询A的员工 select * from A where A.deptId = B.deptId\",\"可以抽象成这样的一个循环：\",\" List<> resultSet ; for(int i=0;i<B.length;i++) { for(int j=0;j<A.length;j++) { if(A[i].id==B[j].id) { resultSet.add(A[i]); break; } } } \",\"显然，除了使用in，我们也可以用exists实现一样的查询功能，如下：\",\"select * from A where exists (select 1 from B where A.deptId = B.deptId); \",\"因为exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。\",\"那么，这样写就等价于：\",\"select * from A,先从A表做循环 select * from B where A.deptId = B.deptId,再从B表做循环.\",\"同理，可以抽象成这样一个循环：\",\" List<> resultSet ; for(int i=0;i<A.length;i++) { for(int j=0;j<B.length;j++) { if(A[i].deptId==B[j].deptId) { resultSet.add(A[i]); break; } } } \",\"数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。 因此，我们要选择最外层循环小的，也就是，如果B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exists，这就是in和exists的区别。\"]},\"113\":{\"h\":\"20. 数据库自增主键可能遇到什么问题。\",\"t\":[\"使用自增主键对数据库做分库分表，可能出现诸如主键重复等的问题。解决方案的话，简单点的话可以考虑使用UUID哈 自增主键会产生表锁，从而引发问题 自增主键可能用完问题。\"]},\"114\":{\"h\":\"21. MVCC熟悉吗，它的底层原理？\",\"t\":[\"MVCC,多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。\"]},\"115\":{\"h\":\"MVCC需要关注这几个知识点：\",\"t\":[\"事务版本号\",\"表的隐藏列\",\"undo log\",\"read view\"]},\"116\":{\"h\":\"22. 数据库中间件了解过吗，sharding jdbc，mycat？\",\"t\":[\"sharding-jdbc目前是基于jdbc驱动，无需额外的proxy，因此也无需关注proxy本身的高可用。 Mycat 是基于 Proxy，它复写了 MySQL 协议，将 Mycat Server 伪装成一个 MySQL 数据库，而 Sharding-JDBC 是基于 JDBC 接口的扩展，是以 jar 包的形式提供轻量级服务的。\"]},\"117\":{\"h\":\"23. MYSQL的主从延迟，你怎么解决？\",\"t\":[\"嘻嘻，先复习一下主从复制原理吧，如图：\",\"主从复制分了五个步骤进行：\",\"步骤一：主库的更新事件(update、insert、delete)被写到binlog\",\"步骤二：从库发起连接，连接到主库。\",\"步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。\",\"步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log\",\"步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db\"]},\"118\":{\"h\":\"主从同步延迟的原因\",\"t\":[\"一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。\"]},\"119\":{\"h\":\"主从同步延迟的解决办法\",\"t\":[\"主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置等。\",\"选择更好的硬件设备作为slave。\",\"把一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的SQL效率自然就高了。\",\"增加从服务器喽，这个目的还是分散读的压力，从而降低服务器负载。\"]},\"120\":{\"h\":\"24. 说一下大表查询的优化方案\",\"t\":[\"优化shema、sql语句+索引；\",\"可以考虑加缓存，memcached, redis，或者JVM本地缓存；\",\"主从复制，读写分离；\",\"分库分表；\"]},\"121\":{\"h\":\"25. 什么是数据库连接池?为什么需要数据库连接池呢?\"},\"122\":{\"h\":\"连接池基本原理：\",\"t\":[\"数据库连接池原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法。\"]},\"123\":{\"h\":\"应用程序和数据库建立连接的过程：\",\"t\":[\"通过TCP协议的三次握手和数据库服务器建立连接\",\"发送数据库用户账号密码，等待数据库验证用户身份\",\"完成身份验证后，系统可以提交SQL语句到数据库执行\",\"把连接关闭，TCP四次挥手告别。\"]},\"124\":{\"h\":\"数据库连接池好处：\",\"t\":[\"资源重用 (连接复用)\",\"更快的系统响应速度\",\"新的资源分配手段 统一的连接管理，避免数据库连接泄漏\"]},\"125\":{\"h\":\"26. 一条SQL语句在MySQL中如何执行的？\",\"t\":[\"先看一下Mysql的逻辑架构图吧~\"]},\"126\":{\"h\":\"查询语句：\",\"t\":[\"先检查该语句是否有权限\",\"如果没有权限，直接返回错误信息\",\"如果有权限，在 MySQL8.0 版本以前，会先查询缓存。\",\"如果没有缓存，分析器进行词法分析，提取 sql 语句select等的关键元素。然后判断sql 语句是否有语法错误，比如关键词是否正确等等。\",\"优化器进行确定执行方案\",\"进行权限校验，如果没有权限就直接返回错误信息，如果有权限就会调用数据库引擎接口，返回执行结果。\"]},\"127\":{\"h\":\"27. InnoDB引擎中的索引策略，了解过吗？\",\"t\":[\"覆盖索引\",\"最左前缀原则\",\"索引下推\",\"索引下推优化是 MySQL 5.6 引入的， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\"]},\"128\":{\"h\":\"28. 数据库存储日期格式时，如何考虑时区转换问题？\",\"t\":[\"datetime类型适合用来记录数据的原始的创建时间，修改记录中其他字段的值，datetime字段的值不会改变，除非手动修改它。\",\"timestamp类型适合用来记录数据的最后修改时间，只要修改了记录中其他字段的值，timestamp字段的值都会被自动更新。\"]},\"129\":{\"h\":\"29. 一条sql执行过长的时间，你如何优化，从哪些方面入手？\",\"t\":[\"查看是否涉及多表和子查询，优化Sql结构，如去除冗余字段，是否可拆表等\",\"优化索引结构，看是否可以适当添加索引\",\"数量大的表，可以考虑进行分离/分表（如交易流水表）\",\"数据库主从分离，读写分离\",\"explain分析sql语句，查看执行计划，优化sql\",\"查看mysql执行日志，分析是否有其他方面的问题\"]},\"130\":{\"h\":\"30. MYSQL数据库服务器性能分析的方法命令有哪些?\",\"t\":[\"Show status, 一些值得监控的变量值：\",\"Bytes_received和Bytes_sent 和服务器之间来往的流量。 Com_*服务器正在执行的命令。 Created_*在查询执行期限间创建的临时表和文件。 Handler_*存储引擎操作。 Select_*不同类型的联接执行计划。 Sort_*几种排序信息。\",\"Show profiles 是MySql用来分析当前会话SQL语句执行的资源消耗情况\"]},\"131\":{\"h\":\"31. Blob和text有什么区别？\",\"t\":[\"Blob用于存储二进制数据，而Text用于存储大字符串。\",\"Blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。\",\"text值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较。\"]},\"132\":{\"h\":\"32. mysql里记录货币用什么字段类型比较好？\",\"t\":[\"货币在数据库中MySQL常用Decimal和Numric类型表示，这两种类型被MySQL实现为同样的类型。他们被用于保存与金钱有关的数据。\",\"salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。存储在salary列中的值的范围是从-9999999.99到9999999.99。\",\"DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。\"]},\"133\":{\"h\":\"33. Mysql中有哪几种锁，列举一下？\",\"t\":[\"如果按锁粒度划分，有以下3种：\",\"表锁： 开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。\",\"行锁： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。\",\"页锁： 开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般\"]},\"134\":{\"h\":\"34. Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？\",\"t\":[\"B+树可以进行范围查询，Hash索引不能。\",\"B+树支持联合索引的最左侧原则，Hash索引不支持。\",\"B+树支持order by排序，Hash索引不支持。\",\"Hash索引在等值查询上比B+树效率更高。\",\"B+树使用like 进行模糊查询的时候，like后面（比如%开头）的话可以起到优化的作用，Hash索引根本无法进行模糊查询。\"]},\"135\":{\"h\":\"35. mysql 的内连接、左连接、右连接有什么区别？\",\"t\":[\"Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集\",\"left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。\",\"right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。\"]},\"136\":{\"h\":\"36. 说说MySQL 的基础架构图\",\"t\":[\"Mysql逻辑架构图主要分三层：\",\"第一层负责连接处理，授权认证，安全等等\",\"第二层负责编译并优化SQL\",\"第三层是存储引擎。\"]},\"137\":{\"h\":\"37. 什么是内连接、外连接、交叉连接、笛卡尔积呢？\",\"t\":[\"内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。\",\"外连接（outer join）：取得两张表中满足存在连接匹配关系的记录，以及某张表（或两张表）中不满足匹配关系的记录。\",\"交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，也被称为：笛卡尔积。\"]},\"138\":{\"h\":\"38. 说一下数据库的三大范式\",\"t\":[\"第一范式：数据表中的每一列（每个字段）都不可以再拆分。\",\"第二范式：在第一范式的基础上，分主键列完全依赖于主键，而不能是依赖于主键的一部分。\",\"第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。\"]},\"139\":{\"h\":\"39. mysql有关权限的表有哪几个呢？\",\"t\":[\"MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。\",\"user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。\",\"db权限表：记录各个帐号在各个数据库上的操作权限。\",\"table_priv权限表：记录数据表级的操作权限。\",\"columns_priv权限表：记录数据列级的操作权限。\",\"host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。\"]},\"140\":{\"h\":\"40. Mysql的binlog有几种录入格式？分别有什么区别？\",\"t\":[\"有三种格式哈，statement，row和mixed。\",\"statement，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。\",\"row，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。\",\"mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。\"]},\"141\":{\"h\":\"41. InnoDB引擎的4大特性，了解过吗\",\"t\":[\"插入缓冲（insert buffer)\",\"二次写(double write)\",\"自适应哈希索引(ahi)\",\"预读(read ahead)\"]},\"142\":{\"h\":\"42. 索引有哪些优缺点？\",\"t\":[\"优点：\",\"唯一索引可以保证数据库表中每一行的数据的唯一性\",\"索引可以加快数据查询速度，减少查询时间\",\"缺点：\",\"创建索引和维护索引要耗费时间\",\"索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间\",\"以表中的数据进行增、删、改的时候，索引也要动态的维护。\"]},\"143\":{\"h\":\"43. 索引有哪几种类型？\",\"t\":[\"主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。\",\"唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。\",\"普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。\",\"全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。\",\"覆盖索引：查询列要被所建的索引覆盖，不必读取数据行\",\"组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并\"]},\"144\":{\"h\":\"44. 创建索引有什么原则呢？\",\"t\":[\"最左前缀匹配原则\",\"频繁作为查询条件的字段才去创建索引\",\"频繁更新的字段不适合创建索引\",\"索引列不能参与计算，不能有函数操作\",\"优先考虑扩展索引，而不是新建索引，避免不必要的索引\",\"在order by或者group by子句中，创建索引需要注意顺序\",\"区分度低的数据列不适合做索引列(如性别）\",\"定义有外键的数据列一定要建立索引。\",\"对于定义为text、image数据类型的列不要建立索引。\",\"删除不再使用或者很少使用的索引\"]},\"145\":{\"h\":\"45. 创建索引的三种方式\",\"t\":[\"在执行CREATE TABLE时创建索引\",\"CREATE TABLE `employee` ( `id` int(11) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` int(11) DEFAULT NULL, `date` datetime DEFAULT NULL, `sex` int(1) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_name` (`name`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8; \",\"使用ALTER TABLE命令添加索引\",\"ALTER TABLE table_name ADD INDEX index_name (column); \",\"使用CREATE INDEX命令创建\",\"CREATE INDEX index_name ON table_name (column); \"]},\"146\":{\"h\":\"46. 百万级别或以上的数据，你是如何删除的？\",\"t\":[\"我们想要删除百万数据的时候可以先删除索引\",\"然后批量删除其中无用数据\",\"删除完成后重新创建索引。\"]},\"147\":{\"h\":\"47. 什么是最左前缀原则？什么是最左匹配原则？\",\"t\":[\"最左前缀原则，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。\",\"当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。。\"]},\"148\":{\"h\":\"48. B树和B+树的区别，数据库为什么使用B+树而不是B树？\",\"t\":[\"在B树中，键和值即存放在内部节点又存放在叶子节点；在B+树中，内部节点只存键，叶子节点则同时存放键和值。\",\"B+树的叶子节点有一条链相连，而B树的叶子节点各自独立的。\",\"B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。.\",\"B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快.\"]},\"149\":{\"h\":\"49. 覆盖索引、回表等这些，了解过吗？\",\"t\":[\"覆盖索引： 查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。\",\"回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。\"]},\"150\":{\"h\":\"50. B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？\",\"t\":[\"在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。\",\"当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。\"]},\"151\":{\"h\":\"51. 何时使用聚簇索引与非聚簇索引\",\"t\":[\"动作描述\",\"使用聚集索引\",\"使用非聚集索引\",\"列经常被分组排序\",\"应\",\"应\",\"返回某范围内的数据\",\"应\",\"不应\",\"一个或极少不同值\",\"不应\",\"不应\",\"小数目的不同值\",\"应\",\"不应\",\"大数目的不同值\",\"不应\",\"应\",\"频繁更新的列\",\"不应\",\"应\",\"外键列\",\"应\",\"应\",\"主键列\",\"应\",\"应\",\"频繁修改索引列\",\"不应\",\"应\"]},\"152\":{\"h\":\"52. 非聚簇索引一定会回表查询吗？\",\"t\":[\"不一定，如果查询语句的字段全部命中了索引，那么就不必再进行回表查询（哈哈，覆盖索引就是这么回事）。\",\"举个简单的例子，假设我们在学生表的上建立了索引，那么当进行select age from student where age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。\"]},\"153\":{\"h\":\"53. 组合索引是什么？为什么需要注意组合索引中的顺序？\",\"t\":[\"组合索引，用户可以在多个列上建立索引,这种索引叫做组合索引。 因为InnoDB引擎中的索引策略的最左原则，所以需要注意组合索引中的顺序。\"]},\"154\":{\"h\":\"54. 什么是数据库事务？\",\"t\":[\"数据库事务（简称：事务），是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。\"]},\"155\":{\"h\":\"55. 隔离级别与锁的关系\",\"t\":[\"回答这个问题，可以先阐述四种隔离级别，再阐述它们的实现原理。隔离级别就是依赖锁和MVCC实现的。\"]},\"156\":{\"h\":\"56. 按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法\",\"t\":[\"按锁粒度分有：表锁，页锁，行锁\",\"按锁机制分有：乐观锁，悲观锁\"]},\"157\":{\"h\":\"57. 从锁的类别角度讲，MySQL都有哪些锁呢？\",\"t\":[\"从锁的类别上来讲，有共享锁和排他锁。\",\"共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。\",\"排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。\",\"锁兼容性如下：\"]},\"158\":{\"h\":\"58. MySQL中InnoDB引擎的行锁是怎么实现的？\",\"t\":[\"基于索引来完成行锁的。\",\"select * from t where id = 666 for update; \",\"for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将实行表锁。\"]},\"159\":{\"h\":\"59. 什么是死锁？怎么解决？\",\"t\":[\"死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。看图形象一点，如下：\",\"死锁有四个必要条件：互斥条件，请求和保持条件，环路等待条件，不剥夺条件。 解决死锁思路，一般就是切断环路，尽量避免并发形成环路。\",\"如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。\",\"在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；\",\"对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；\",\"如果业务处理不好可以用分布式事务锁或者使用乐观锁\",\"死锁与索引密不可分，解决索引问题，需要合理优化你的索引，\"]},\"160\":{\"h\":\"60. 为什么要使用视图？什么是视图？\"},\"161\":{\"h\":\"为什么要使用视图？\",\"t\":[\"为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。\"]},\"162\":{\"h\":\"什么是视图？\",\"t\":[\"视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。\"]},\"163\":{\"h\":\"61. 视图有哪些特点？哪些使用场景？\"},\"164\":{\"h\":\"视图特点：\",\"t\":[\"视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。\",\"视图是由基本表(实表)产生的表(虚表)。\",\"视图的建立和删除不影响基本表。\",\"对视图内容的更新(添加，删除和修改)直接影响基本表。\",\"当视图来自多个基本表时，不允许添加和删除数据。\",\"视图用途： 简化sql查询，提高开发效率，兼容老的表结构。\"]},\"165\":{\"h\":\"视图的常见使用场景：\",\"t\":[\"重用SQL语句；\",\"简化复杂的SQL操作。\",\"使用表的组成部分而不是整个表；\",\"保护数据\",\"更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。\"]},\"166\":{\"h\":\"62. 视图的优点，缺点，讲一下？\",\"t\":[\"查询简单化。视图能简化用户的操作\",\"数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护\",\"逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性\"]},\"167\":{\"h\":\"63. count(1)、count(*) 与 count(列名) 的区别？\",\"t\":[\"count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL\",\"count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL\",\"count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。\"]},\"168\":{\"h\":\"64. 什么是游标？\",\"t\":[\"游标提供了一种对从表中检索出的数据进行操作的灵活手段，就本质而言，游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制。\"]},\"169\":{\"h\":\"65. 什么是存储过程？有哪些优缺点？\",\"t\":[\"存储过程，就是一些编译好了的SQL语句，这些SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。\",\"优点：\",\"存储过程是一个预编译的代码块，执行效率比较高\",\"存储过程在服务器端运行，减少客户端的压力\",\"允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用 -一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率\",\"可以一定程度上确保数据安全\",\"缺点：\",\"调试麻烦\",\"可移植性不灵活\",\"重新编译问题\"]},\"170\":{\"h\":\"66. 什么是触发器？触发器的使用场景有哪些？\",\"t\":[\"触发器，指一段代码，当触发某个事件时，自动执行这些代码。\",\"使用场景：\",\"可以通过数据库中的相关表实现级联更改。\",\"实时监控某张表中的某个字段的更改而需要做出相应的处理。\",\"例如可以生成某些业务的编号。\",\"注意不要滥用，否则会造成数据库及应用程序的维护困难。\"]},\"171\":{\"h\":\"67. MySQL中都有哪些触发器？\",\"t\":[\"MySQL 数据库中有六种触发器：\",\"Before Insert\",\"After Insert\",\"Before Update\",\"After Update\",\"Before Delete\",\"After Delete\"]},\"172\":{\"h\":\"68. 超键、候选键、主键、外键分别是什么？\",\"t\":[\"超键：在关系模式中，能唯一知标识元组的属性集称为超键。\",\"候选键：是最小超键，即没有冗余元素的超键。\",\"主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。\",\"外键：在一个表中存在的另一个表的主键称此表的外键。。\"]},\"173\":{\"h\":\"69. SQL 约束有哪几种呢？\",\"t\":[\"NOT NULL: 约束字段的内容一定不能为NULL。\",\"UNIQUE: 约束字段唯一性，一个表允许有多个 Unique 约束。\",\"PRIMARY KEY: 约束字段唯一，不可重复，一个表只允许存在一个。\",\"FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键。\",\"CHECK: 用于控制字段的值范围。\"]},\"174\":{\"h\":\"70. 谈谈六种关联查询，使用场景。\",\"t\":[\"交叉连接\",\"内连接\",\"外连接\",\"联合查询\",\"全连接\",\"交叉连接\"]},\"175\":{\"h\":\"71. varchar(50)中50的涵义\",\"t\":[\"字段最多存放 50 个字符 如 varchar(50) 和 varchar(200) 存储 \\\"jay\\\" 字符串所占空间是一样的，后者在排序时会消耗更多内存\"]},\"176\":{\"h\":\"72. mysql中int(20)和char(20)以及varchar(20)的区别\",\"t\":[\"int(20) 表示字段是int类型，显示长度是 20\",\"char(20)表示字段是固定长度字符串，长度为 20\",\"varchar(20) 表示字段是可变长度字符串，长度为 20\"]},\"177\":{\"h\":\"73. drop、delete与truncate的区别\",\"t\":[\"delete\",\"truncate\",\"drop\",\"类型\",\"DML\",\"DDL\",\"DDL\",\"回滚\",\"可回滚\",\"不可回滚\",\"不可回滚\",\"删除内容\",\"表结构还在，删除表的全部或者一部分数据行\",\"表结构还在，删除表中的所有数据\",\"从数据库中删除表，所有的数据行，索引和权限也会被删除\",\"删除速度\",\"删除速度慢，逐行删除\",\"删除速度快\",\"删除速度最快\"]},\"178\":{\"h\":\"74. UNION与UNION ALL的区别？\",\"t\":[\"Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；\",\"Union All：对两个结果集进行并集操作，包括重复行，不进行排序；\",\"UNION的效率高于 UNION ALL\"]},\"179\":{\"h\":\"75. SQL的生命周期？\",\"t\":[\"服务器与数据库建立连接\",\"数据库进程拿到请求sql\",\"解析并生成执行计划，执行\",\"读取数据到内存，并进行逻辑处理\",\"通过步骤一的连接，发送结果到客户端\",\"关掉连接，释放资源\"]},\"180\":{\"h\":\"76. 一条Sql的执行顺序？\"},\"181\":{\"h\":\"77. 列值为NULL时，查询是否会用到索引？\",\"t\":[\"列值为NULL也是可以走索引的 计划对列进行索引，应尽量避免把它设置为可空，因为这会让 MySQL 难以优化引用了可空列的查询，同时增加了引擎的复杂度\"]},\"182\":{\"h\":\"78. 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\",\"t\":[\"我们平时写Sql时，都要养成用explain分析的习惯。\",\"慢查询的统计，运维会定期统计给我们\",\"优化慢查询：\",\"分析语句，是否加载了不必要的字段/数据。\",\"分析SQl执行句话，是否命中索引等。\",\"如果SQL很复杂，优化SQL结构\",\"如果表数据量太大，考虑分表\"]},\"183\":{\"h\":\"79. 主键使用自增ID还是UUID，为什么？\",\"t\":[\"如果是单机的话，选择自增ID；如果是分布式系统，优先考虑UUID吧，但还是最好自己公司有一套分布式唯一ID生产方案吧。\",\"自增ID：数据存储空间小，查询效率高。但是如果数据量过大,会超出自增长的值范围，多库合并，也有可能有问题。\",\"uuid：适合大量数据的插入和更新操作，但是它无序的，插入数据效率慢，占用空间大。\"]},\"184\":{\"h\":\"80. mysql自增主键用完了怎么办？\",\"t\":[\"自增主键一般用int类型，一般达不到最大值，可以考虑提前分库分表的。\",\"自增ID用完后 一直都是最大值 如果标识了主键 则主键冲突\"]},\"185\":{\"h\":\"81. 字段为什么要求定义为not null？\",\"t\":[\"null值会占用更多的字节，并且null有很多坑的。\"]},\"186\":{\"h\":\"82. 如果要存储用户的密码散列，应该使用什么字段进行存储？\",\"t\":[\"密码散列，盐，用户身份证号等固定长度的字符串，应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。\"]},\"187\":{\"h\":\"83. Mysql驱动程序是什么？\",\"t\":[\"这个jar包： mysql-connector-java-5.1.18.jar Mysql驱动程序主要帮助编程语言与 MySQL服务端进行通信，如连接、传输数据、关闭等。\"]},\"188\":{\"h\":\"84. 如何优化长难的查询语句？有实战过吗？\",\"t\":[\"将一个大的查询分为多个小的相同的查询\",\"减少冗余记录的查询。\",\"一个复杂查询可以考虑拆成多个简单查询\",\"分解关联查询，让缓存的效率更高。\"]},\"189\":{\"h\":\"85. 优化特定类型的查询语句\",\"t\":[\"平时积累吧：\",\"比如使用select 具体字段代替 select *\",\"使用count(*) 而不是count(列名)\",\"在不影响业务的情况，使用缓存\",\"explain 分析你的SQL\"]},\"190\":{\"h\":\"86. MySQL数据库cpu飙升的话，要怎么处理呢？\",\"t\":[\"排查过程：\",\"使用top 命令观察，确定是mysqld导致还是其他原因。\",\"如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。\",\"找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。\",\"处理：\",\"kill 掉这些线程(同时观察 cpu 使用率是否下降)，\",\"进行相应的调整(比如说加索引、改 sql、改内存参数)\",\"重新跑这些 SQL。\",\"其他情况：\",\"也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等\"]},\"191\":{\"h\":\"87. 读写分离常见方案？\",\"t\":[\"应用程序根据业务逻辑来判断，增删改等写操作命令发给主库，查询命令发给备库。\",\"利用中间件来做代理，负责对数据库的请求识别出读还是写，并分发到不同的数据库中。（如：amoeba，mysql-proxy）\"]},\"192\":{\"h\":\"88. MySQL的复制原理以及流程\",\"t\":[\"主从复制原理，简言之，就三步曲，如下：\",\"主数据库有个bin-log二进制文件，纪录了所有增删改Sql语句。（binlog线程）\",\"从数据库把主数据库的bin-log文件的sql语句复制过来。（io线程）\",\"从数据库的relay-log重做日志文件中再执行一次这些sql语句。（Sql执行线程）\",\"如下图所示：\",\"上图主从复制分了五个步骤进行：\",\"步骤一：主库的更新事件(update、insert、delete)被写到binlog\",\"步骤二：从库发起连接，连接到主库。\",\"步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。\",\"步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log\",\"步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db\"]},\"193\":{\"h\":\"89. MySQL中DATETIME和TIMESTAMP的区别\",\"t\":[\"存储精度都为秒\",\"区别：\",\"DATETIME 的日期范围是 1001——9999 年；TIMESTAMP 的时间范围是 1970——2038 年\",\"DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区\",\"DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节\",\"DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)\"]},\"194\":{\"h\":\"90. Innodb的事务实现原理？\",\"t\":[\"原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。\",\"持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。\",\"隔离性：通过锁以及MVCC,使事务相互隔离开。\",\"一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。\"]},\"195\":{\"h\":\"91. 谈谈MySQL的Explain\",\"t\":[\"Explain 执行计划包含字段信息如下：分别是 id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、filtered、Extra 等12个字段。 我们重点关注的是type，它的属性排序如下：\",\"system > const > eq_ref > ref > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL \"]},\"196\":{\"h\":\"92. Innodb的事务与日志的实现方式\"},\"197\":{\"h\":\"有多少种日志\",\"t\":[\"innodb两种日志redo和undo。\"]},\"198\":{\"h\":\"日志的存放形式\",\"t\":[\"redo：在页修改的时候，先写到 redo log buffer 里面， 然后写到 redo log 的文件系统缓存里面(fwrite)，然后再同步到磁盘文件（ fsync）。\",\"Undo：在 MySQL5.5 之前， undo 只能存放在 ibdata文件里面， 5.6 之后，可以通过设置 innodb_undo_tablespaces 参数把 undo log 存放在 ibdata之外。\"]},\"199\":{\"h\":\"事务是如何通过日志来实现的\",\"t\":[\"因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 Redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。\",\"当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的 状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。\",\"如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。\"]},\"200\":{\"h\":\"93. MySQL中TEXT数据类型的最大长度\",\"t\":[\"TINYTEXT：256 bytes\",\"TEXT：65,535 bytes(64kb)\",\"MEDIUMTEXT：16,777,215 bytes(16MB)\",\"LONGTEXT：4,294,967,295 bytes(4GB)\"]},\"201\":{\"h\":\"94. 500台db，在最快时间之内重启。\",\"t\":[\"可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。\",\"也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务\"]},\"202\":{\"h\":\"95. 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？\",\"t\":[\"监控的工具有很多，例如zabbix，lepus，我这里用的是lepus\"]},\"203\":{\"h\":\"96. 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？\",\"t\":[\"主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等\"]},\"204\":{\"h\":\"97. 你们数据库是否支持emoji表情存储，如果不支持，如何操作？\",\"t\":[\"更换字符集utf8-->utf8mb4\"]},\"205\":{\"h\":\"98. MySQL如何获取当前日期？\",\"t\":[\"SELECT CURRENT_DATE();\"]},\"206\":{\"h\":\"99. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。\",\"t\":[\"1、如果A表TID是自增长,并且是连续的,B表的ID为索引\",\"select * from a,b where a.tid = b.id and a.tid>500000 limit 200; \",\"2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。\",\"select * from b , (select tid from a limit 50000,200) a where b.id = a .tid; \"]},\"207\":{\"h\":\"100. Mysql一条SQL加锁分析\",\"t\":[\"一条SQL加锁，可以分9种情况进行：\",\"组合一：id列是主键，RC隔离级别\",\"组合二：id列是二级唯一索引，RC隔离级别\",\"组合三：id列是二级非唯一索引，RC隔离级别\",\"组合四：id列上没有索引，RC隔离级别\",\"组合五：id列是主键，RR隔离级别\",\"组合六：id列是二级唯一索引，RR隔离级别\",\"组合七：id列是二级非唯一索引，RR隔离级别\",\"组合八：id列上没有索引，RR隔离级别\",\"组合九：Serializable隔离级别\",\"作者：Jay_huaxiao\\n链接：https://juejin.im/post/5ec15ab9f265da7bc60e1910\\n来源：掘金\\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\"]},\"208\":{\"c\":[\"mysql\"]},\"209\":{\"c\":[\"mysql\",\"面试\",\"面试总结\"]},\"210\":{\"h\":\"MySQL InnoDB MVCC 机制的原理及实现\"},\"211\":{\"h\":\"MVCC 是什么？\"},\"212\":{\"h\":\"数据库并发控制——锁\",\"t\":[\"Multiversion (version) concurrency control (MCC or MVCC) 多版本并发控制 ，它是数据库管理系统一种常见的并发控制。 我们知道并发控制常用的是锁，当线程要对一个共享资源进行操作的时候，加锁是一种非常简单粗暴的方法(事务开始时给 DQL 加读锁，给 DML 加写锁)，这种锁是一种 悲观 的实现方式，也就是说这会给其他事务造成堵塞，从而影响数据库性能。 我来解释一下 乐观锁 和 悲观锁 的概念。我觉得它俩主要是概念的理解。\",\"悲观锁： 当一个线程需要对共享资源进行操作的时候，首先对共享资源进行加锁，当该线程持有该资源的锁的时候，其他线程对该资源进行操作的时候会被 阻塞。比如 Java 中的 Synchronized 关键字。\",\"乐观锁：当一个线程需要对一个共享资源进行操作的时候，不对它进行加锁，而是在操作完成之后进行判断。(比如乐观锁会通过一个版本号控制，如果操作完成后通过版本号进行判断在该线程操作过程中是否有其他线程已经对该共享资源进行操作了，如果有则通知操作失败，如果没有则操作成功)，当然除了 版本号 还有 CAS，如果不了解的可以去学习一下，这里不做过多涉及。\"]},\"213\":{\"h\":\"数据库并发控制——MVCC\",\"t\":[\"很多人认为 MVCC 就是一种 乐观锁 的实现形式，而我认为 MVCC 只是一种 乐观 的实现形式，它是通过 一种 可见性算法 来实现数据库并发控制。\"]},\"214\":{\"h\":\"MVCC 的两种读形式\",\"t\":[\"在讲 MVCC 的实现原理之前，我觉很有必要先去了解一下 MVCC 的两种读形式。\",\"快照读：读取的只是当前事务的可见版本，不用加锁。而你只要记住 简单的 select 操作就是快照读(select * from table where id = xxx)。\",\"当前读：读取的是当前版本，比如 特殊的读操作，更新/插入/删除操作\",\"比如：\",\" select * from table where xxx lock in share mode， select * from table where xxx for update， update table set.... insert into table (xxx,xxx) values (xxx,xxx) delete from table where id = xxx \"]},\"215\":{\"h\":\"MVCC 的实现原理\",\"t\":[\"MVCC 使用了“三个隐藏字段”来实现版本并发控制，我查了很多资料，看到有很多博客上写的是通过 一个创建事务id字段和一个删除事务id字段 来控制实现的。但后来发现并不是很正确，我们先来看一看 MySQL 在建表的时候 innoDB 创建的真正的三个隐藏列吧。\",\"RowID\",\"DB_TRX_ID\",\"DB_ROLL_PTR\",\"id\",\"name\",\"password\",\"自动创建的id\",\"事务id\",\"回滚指针\",\"id\",\"name\",\"password\",\"RowID：隐藏的自增ID，当建表没有指定主键，InnoDB会使用该RowID创建一个聚簇索引。\",\"DB_TRX_ID：最近修改（更新/删除/插入）该记录的事务ID。\",\"DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本。\",\"其实还有一个删除的flag字段，用来判断该行记录是否已经被删除。\",\"而 MVCC 使用的是其中的 事务字段，回滚指针字段，是否删除字段。我们来看一下现在的表格(isDelete是我自己取的，按照官方说法是在一行开头的content里面，这里其实位置无所谓，你只要知道有就行了)。\",\"isDelete\",\"DB_TRX_ID\",\"DB_ROLL_PTR\",\"id\",\"name\",\"password\",\"true/false\",\"事务id\",\"回滚指针\",\"id\",\"name\",\"password\",\"那么如何通过这三个字段来实现 MVCC 的 可见性算法 呢？ 还差点东西！ undoLog(回滚日志) 和 read-view(读视图)。\",\"undoLog: 事务的回滚日志，是 可见性算法 的非常重要的部分，分为两类。 \",\"insert undo log：事务在插入新记录产生的undo log，当事务提交之后可以直接丢弃\",\"update undo log：事务在进行 update 或者 delete 的时候产生的 undo log，在快照读的时候还是需要的，所以不能直接删除，只有当系统没有比这个log更早的read-view了的时候才能删除。ps：所以长事务会产生很多老的视图导致undo log无法删除 大量占用存储空间。\",\"read-view: 读视图，是MySQL秒级创建视图的必要条件，比如一个事务在进行 select 操作(快照读)的时候会创建一个 read-view ，这个read-view 其实只是三个字段。 \",\"alive_trx_list(我自己取的)：read-view生成时刻系统中正在活跃的事务id。\",\"up_limit_id：记录上面的 alive_trx_list 中的最小事务id。\",\"low_limit_id：read-view生成时刻，目前已出现的事务ID的最大值 + 1。\",\"这时候，万事俱备，只欠东风了。下面我来介绍一下，最重要的 可见性算法。 其实主要思路就是：当生成read-view的时候如何去拿获取的 DB_TRX_ID 去和 read-view 中的三个属性(上面讲了)去作比较。我来说一下三个步骤，如果不是很理解可以参考着我后面的实践结合着去理解。\",\"首先比较这条记录的 DB_TRX_ID 是否是 小于 up_limit_id 或者 等于当前事务id。如果满足，那么说明当前事务能看到这条记录。如果大于则进入下一轮判断\",\"然后判断这条记录的 DB_TRX_ID 是否 大于等于 low-limit-id。如果大于等于则说明此事务无法看见该条记录，不然就进入下一轮判断。\",\"判断该条记录的 DB_TRX_ID 是否在活跃事务的数组中，如果在则说明这条记录还未提交对于当前操作的事务是不可见的，如果不在则说明已经提交，那么就是可见的。\",\"如果此条记录对于该事务不可见且 ROLL_PTR 不为空那么就会指向回滚指针的地址，通过undolog来查找可见的记录版本。\",\"下面我画了一个可见性的算法的流程图\"]},\"216\":{\"h\":\"实践\"},\"217\":{\"h\":\"准备数据\",\"t\":[\"首先我创建了一个非常简单的表，只有id和name的学生表。\",\"id\",\"name\",\"学生id\",\"学生姓名\",\"这个时候我们将我们需要的隐藏列也标识出来，就变成了这样\",\"isDelete\",\"id\",\"name\",\"DB_TRX_ID\",\"DB_ROLL_PTR\",\"是否被删除\",\"学生id\",\"学生姓名\",\"创建删除更新该记录的事务id\",\"回滚指针\",\"这个时候插入三行数据，将表的数据变成下面这个样子。\",\"isDelete\",\"id\",\"name\",\"DB_TRX_ID\",\"DB_ROLL_PTR\",\"false\",\"1\",\"小明\",\"1\",\"null\",\"false\",\"2\",\"小方\",\"1\",\"null\",\"false\",\"3\",\"小张\",\"1\",\"null\"]},\"218\":{\"h\":\"示例一\",\"t\":[\"使用过 MySQL 的都知道，因为隔离性，事务 B 此时获取到的数据肯定是这样的。\",\"id\",\"name\",\"1\",\"小明\",\"2\",\"小方\",\"3\",\"小张\",\"为什么事务A未提交的修改对于事务B是不可见的，MVCC 是如何做到的？我们用刚刚的可见性算法来实验一下。 首先事务A开启了事务(当然这不算开启，在RR模式下 真正获取read-view的是在进行第一次进行快照读的时候)。我们假设事务A的事务id为2，事务B的id为3。 然后事务A进行了更新操作，如图所示，更新操作创建了一个新的版本并且新版本的回滚指针指向了旧的版本(注意 undo log其实存放的是逻辑日志，这里为了方便我直接写成物理日志)。\",\"最后 事务B 进行了快照读，注意，这是我们分析的重点。\",\"首先，在进行快照读的时候我们会创建一个 read-view (忘记回去看一下那三个字段) 这个时候我们的 read-view 是:\",\" up-limit-id = 2 alive-trx-list = [2,3] low-limit-id = 4 \",\"然后我们获取那两个没有被修改的记录(没有顺序，这里为了一起解释方便), 我们获取到(2,小方)和(3,小张)这两条记录，发现他们两的 DB_TRX_ID = 1, 我们先判断 DB_TRX_ID 是否小于 up-limit-id 或者等于当前事务id , 发现 1<2 小于 up-limit-id ，则可见 直接返回视图。\",\"然后我们获取更改了的数据行:\",\"其实你也发现了这是一个链表，此时链表头的 DB_TRX_ID 为 2,我们进行判断 2 < 2 不符合，进入下一步判断, 判断 DB_TRX_ID >= low_limit_id 发现此时是 2 >= 4 不符合 故再进入下一步,此时判断 Db_TRX_ID 是否在 alive_trx_list 活跃事务列表中，发现这个 DB_TRX_ID 在活跃列表中，所以只能说明该行记录还未提交，不可见。最终判断不可见之后通过回滚指针查看旧版本，发现此时 DB_TRX_ID 为1,故再次进行判断 DB_TRX_ID < up-limit-id ,此时 1 < 2 符合 ，所以可见并返回, 所以最终返回的是\",\"id\",\"name\",\"1\",\"小明\",\"2\",\"小方\",\"3\",\"小张\",\"我们再来验证一下，这个时候我们将事务A提交，重新创建一个事务C并select。\",\"我们预期的结果应该是这样的\",\"id\",\"name\",\"1\",\"小强\",\"2\",\"小方\",\"3\",\"小张\",\"这个操作的流程图如下\",\"这个时候我们再来分析一下 事务c产生的 read-view。\",\"这个时候事务A已经提交，所以事务A不在活跃事务数组中，此时 read-view 的三个属性应该是\",\" up-limit-id = 3 alive-trx-list = [3,4] low-limit-id = 5 \",\"跟上面一样，我们首先获取(2,小方)和(3,小张)这两条记录，发现他们两的 DB_TRX_ID = 1，此时 1 < up-limit-id = 3，故符合可见性，则返回。\",\"然后我们获取刚刚被修改的id为1的记录行，发现链表头部的 DB_TRX_ID 为 2, 此时 2 < up-limit-id = 3 故也符合可见性，则返回。\",\"所以最终返回的就是\",\"id\",\"name\",\"1\",\"小强\",\"2\",\"小方\",\"3\",\"小张\"]},\"219\":{\"h\":\"示例二\",\"t\":[\"为了加深理解，我们再使用一个相对来说比较复杂的示例来验证 可见性算法 。\",\"首先我们在事务A中删除一条记录，这个时候就变成了下面的样子。\",\"然后事务B进行了插入，这样就变成了下面这样。\",\"然后事务B进行了 select 操作，我们可以发现 这个时候整张表其实会变成这样让这个 select 操作进行选取。\",\"此时的 read-view 为\",\" up-limit-id = 2 alive-trx-list = [2,3,4] low-limit-id = 5 \",\"这个时候我们进行 快照读，首先对于前面两条小明和小方的记录是一样的，此时 DB_TX_ID 为 1，我们可以判断此时 DB_TX_ID = 1 < up-limit-id = 2 成立故返回。然后判断小张这条记录，首先也是 DB_TX_ID = 2 < up-limit-id = 2 不成立故进入下一轮，DB_TX_ID = 2 >= low-limit-id 不成立再进入最后一轮判断是否在活跃事务列表中，发现 DB_TX_ID = 2 在 alive-trx-list = [2,3,4] 中故不可见(如果可见则会知道前面的删除标志是已经删除，则返回的是空)，则根据回滚指针找到上一个版本记录，此时 DB_TX_ID = 1 和上面一样可见则返回该行。 最后一个判断小亮这条记录，因为 DB_TX_ID = current_tx_id(当前事务id) 所以可见并返回。 这个时候返回的表则是这样的\",\"id\",\"name\",\"1\",\"小明\",\"2\",\"小方\",\"3\",\"小张\",\"4\",\"小亮\",\"然后是事务A进行了select的操作，我们可以得知现在的 read-view 为\",\" up-limit-id = 2 alive-trx-list = [2,3,4] low-limit-id = 5 \",\"然后此时所见和上面也是一样的\",\"这个时候我们进行 快照读，首先对于前面两条小明和小方的记录是一样的，此时 DB_TX_ID 为 1，我们可以判断此时 DB_TX_ID = 1 < up-limit-id = 2 成立故返回。然后判断小张这条记录，首先 DB_TX_ID = 2 = current_tx_id = 2 成立故返回发现前面的 isDelete 标志为true 则说明已被删除则返回空，对于第四条小亮的也是一样判断 DB_TX_ID = 4 < up-limit-id = 2 不成立进入下一步判断 DB_TX_ID = 4 >= low-limit-id = 5 不成立进入最后一步发现在活跃事务数组中故不可见且此条记录回滚指针为null所以返回空。 那么此时返回的列表应该就是这样了\",\"id\",\"name\",\"1\",\"小明\",\"2\",\"小方\",\"虽然要分析很多，但多多益善嘛，多熟悉熟悉就能更深刻理解这个算法了。\",\"之后是事务C进行 快照读 操作。首先此时视图还是这个样子\",\"然后对于事务C的 read-view 为\",\" up-limit-id = 2 alive-trx-list = [2,3,4] low-limit-id = 5 \",\"小明和小方的两条记录和上面一样是可见的这里我就不重复分析了，然后对于小张这条记录 DB_TX_ID = 2 < up-limit-id = 2 || DB_TX_ID == curent_tx_id = 4 不成立故进入下一轮发现 DB_TX_ID >= low-limit-id = 5 更不成立故进入最后一轮发现 DB_TX_ID = 2 在活跃事务数组中故不可见，然后通过回滚指针判断 DB_TX_ID = 1 的小张记录发现可见并返回。最后的小亮也是如此 最后会发现 DB_TX_ID = 3 也在活跃事务数组中故不可见。 所以事务C select 的结果为\",\"id\",\"name\",\"1\",\"小明\",\"2\",\"小方\",\"3\",\"小张\",\"后面事务A和事务B都进行了提交的动作，并且有一个事务D进行了快照读，此时视图还是如此\",\"但此时的 read-view发生了变化\",\" up-limit-id = 4 alive-trx-list = [4,5] low-limit-id = 6 \",\"我们首先判断小明和小方的记录——可见(不解释了)，小张的记录 DB_TX_ID = 2 < up-limit-id = 4 成立故可见，因为前面 isDelete 为 true 则说明删除了返回空，然后小亮的记录 DB_TX_ID = 3 < up-limit-id = 4 成立故可见则返回。所以这次的 select 结果应该是这样的\",\"id\",\"name\",\"1\",\"小明\",\"2\",\"小方\",\"4\",\"小亮\",\"最后(真的最后了，不容易吧！)，事务C有一次进行了 select 操作。因为在 RR 模式下 read-view 是在第一次快照读的时候确定的，所以此时 read-view是不会更改的，然后前面视图也没有进行更改，所以此时即使前面事务A 事务B已经进行了提交，对于这个时候的事务C的select结果是没有影响的。故结果应该为\",\"id\",\"name\",\"1\",\"小明\",\"2\",\"小方\",\"3\",\"小张\",\"总结 我们来总结一下吧。\",\"其实 MVCC 是通过 \\\"三个\\\" 隐藏字段 (事务id,回滚指针,删除标志) 加上undo log和可见性算法来实现的版本并发控制。\",\"为了你再次深入理解这个算法，我再把这张图挂上来\",\"作者：FrancisQ\\n链接：https://juejin.im/post/5da8493ae51d4524b25add55\\n来源：掘金\\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\"]},\"220\":{\"c\":[\"mysql\"]},\"221\":{\"c\":[\"mysql\",\"InnoDB\",\"面试\",\"面试总结\"]},\"222\":{\"h\":\"MySQL相关知识点浅析\"},\"223\":{\"h\":\"Myisam和Innodb的区别\",\"t\":[\"innodb支持事务，锁级别是行级锁，支持四个事务隔离级别，分别是未提交读、提交读、可重复读、串行化\",\"innodb的索引策略是聚簇索引\",\"innodb使用MVCC实现并发控制、也就是多版本并发控制，同时也支持索引间隙锁\",\"innodb支持热备份\",\"myisam支持全文索引、表压缩\",\"myisam的锁不支持行级锁，支持表级锁，这个特性会导致，在并发高的情况下进行读写操作的时候性能很差。\",\"myisam支持延迟更新索引键\",\"myisam崩溃的概率比innodb要大很多，MySQL的数据恢复相较于innodb较差\",\"数据存储方式不一样，innodb采用聚簇索引的方式存储数据，myisam采用索引和列的值分离的方式存储数据。\",\"读锁又被称为共享锁，写锁被称为排它锁。\",\"ACID指：原子性、一致性、隔离性、持久性\"]},\"224\":{\"h\":\"mysql优化相关\",\"t\":[\"慢查询日志，对优化MySQL查询至关重要。可以通过long_query_time参数来设置日志记录行为，当值为0时，记录所有的查询\",\"使用show global status SQL语句查看当前连接数(threads_connected)、查询线程数(threads_running)、查询数(queries)\",\"使用 show processlist SQL语句查看当前连接线程是否有废线程，比如locked、free 状态的\",\"设计表的时候选择合适的数据类型，尽量使用NOT NULL，列不要太多\",\"主键最好使用整数类型，避免使用字符串类型\",\"查询SQL数据表关联不要过多，一般最多12个表\",\"根据实际业务创建相关汇总表和缓存表\",\"使用索引。\"]},\"225\":{\"h\":\"mysql修改表相关\",\"t\":[\"alter table 操作在大多数情况下都会锁表，并且重建整表，慎用\",\"对于引擎是myisam的数据表在迁移或转入大量数据的时候，可以先关闭索引，等待数据载入之后开启索引，相关操作如下\"]},\"226\":{\"h\":\"关闭索引\",\"t\":[\"alter table table_name disable keys; \"]},\"227\":{\"h\":\"开启索引\",\"t\":[\"alter table table_name enable keys; \",\"这个方法对主键、唯一索引无效\"]},\"228\":{\"h\":\"索引相关\",\"t\":[\"大多数MySQL存储引擎都实现了b-tree索引，b-tree索引是有序的，在order by 和group by语句中也会用到索引\",\"索引总是遵循最左前缀\",\"索引中的列不能被跳过，如果一个查询中有范围查询，那么只能用到范围查询之前的列，右边的用不到。\",\"可以通过伪哈希索引的手段来优化查询语句\",\"查询中的条件的列不能是一个表达式或函数的参数，要是单独的列，这样才能用到索引\",\"索引中列的顺序不同效果也不一样，在实际业务中可以通过使用相同的列不同的顺序来创建更多的索引\",\"索引可以减少服务器扫描的数据量，避免排序和临时表，索引可以将随机I/O变为顺序I/O\"]},\"229\":{\"h\":\"前缀索引\",\"t\":[\"前缀索引主要是对字符串类型的列取公共前缀进行索引。可以通过不断比较公共前缀出现的次数和总记录的商来取前缀，方法如下：\",\"假设表名为testcity，字符串列名为'city',可以通过如下语句来计算\",\"select count(distinct left(city,3)) /count(*) as sel from testcity;\",\"sel的值越接近1越好。\",\"下面添加一个前缀索引\",\"alter table testcity add key(city(3));\",\"前缀索引更小，更快，不过在order by 和group by中无法使用。\",\"当使用explain分析查询语句时，如果索引类型为index_merge则说明表的索引策略很糟糕，要优化了\"]},\"230\":{\"h\":\"多列索引\",\"t\":[\"选择合适的索引顺序至关重要。我们同样可以使用前缀索引中的方法来比较，不过这次我们不是比较前缀出现的次数而是整个列的记录不重复的次数：\",\"表：testcity 列：cityid, xianid。\",\"select count(distinct cityid) /count(*) as c, count(distinct xianid) /count(*) as x from testcity;\",\"计算的结果中值越接近1的就越往前，比如 c>x,那么索引应该这样加\",\"alter table testcity add key(cityid, xianid);\",\"如果一个索引包含所有要查询字段的值，那这个索引就被称之为覆盖索引。比如下面这个语句：\",\"select cityid from testcity where cityid = 10;\",\"其中 idx_cityid_xianid就是cityid的覆盖索引\",\"select cityid,id, xianid from testcity where cityid = 10;这个时候idx_cityid_xianid就不是覆盖索引\",\"聚簇索引是一种数据存储方式，innodb存储引擎支持，主要是通过主键来实现，如果表中没有定义主键，那就会喧杂一个唯一的非空索引替代，如果没有符合条件的，会自行创建一个隐式主键。它将索引和列的值存储在一起。使数据访问更快，但是特消耗存储空间，二级索引访问需要两次查找，而不是一次（首先二级索引先找到主键，然后通过主键找到具体的值，两次索引查找）\",\"在设计innodb主键的时候，建议使用单调顺序自增类型，比如自增ID，因为innodb是顺序插入的。\"]},\"231\":{\"h\":\"myisam和innodb的索引总结。\",\"t\":[\"两者都支持，主键索引、唯一索引、单列、多列索引及前缀索引，不同的是两者实现的存储方式不一样，innodb中使用聚簇索引的方式存储数据，也就是把索引和列的值存在一起，myisam却不同，索引和值分离；：因为myisam的索引和数据是分开存储存储的，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因 ；innodb的数据和索引放在一起，当找到索引也就找到了数据。\"]},\"232\":{\"h\":\"查询优化相关\",\"t\":[\"减少不必要列的查询\",\"尽量优化查询，使之可以使用到覆盖索引\",\"建立合适的索引，减少查询时扫描的行数\",\"拆分复杂的查询，分解关联查询，简单的查询可以减少锁的竞争，易缓存，减少冗余记录查询\",\"在select查询中加上limit关键字，可以减少资源占用\",\"子查询尽量少用，合理使用子查询，可以使用表连接代替（MySQL版本5.6及以上可以放心大胆的去用子查询）\"]},\"233\":{\"h\":\"MySQL高级特性\"},\"234\":{\"h\":\"分区\",\"t\":[\"range 分区\",\"CREATE TABLE `request_log` ( `id` int(11) NOT NULL AUTO_INCREMENT, `ip` int(11) NOT NULL, `uri` varchar(30) DEFAULT NULL, `request_time` int(11) NOT NULL, PRIMARY KEY (`id`,`request_time`), UNIQUE KEY `ip` (`ip`,`request_time`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 partition BY RANGE (request_time) (partition p0 VALUES LESS THAN (1400000000) ENGINE = InnoDB, partition p1 VALUES LESS THAN (1500000000) ENGINE = InnoDB, PARTITION pall VALUES LESS THAN MAXVALUE ENGINE = InnoDB); \",\"同时还有别的分区，比如，list分区，hash分区，key分区。具体可以参考：https://www.cnblogs.com/mliudong/p/3625522.html 简单了解下\",\"分区的时候最好不要选择默认为NULL的列，选择的列最好有索引（分区列和索引列匹配），分区在查询的时候需要锁住所有的底层表，这会带来很多的开销，要控制合适的分区的个数。分区的维护成本比较高\",\"在进行分区查询的时候，where条件要包含分区列，分区列不能在表达式中，这样可以在查询的时候减少分区的扫描。\",\"比如：partitions select * from request_log where request_time between 1400000000 and 1500000000;\"]},\"235\":{\"h\":\"视图\",\"t\":[\"具体视图相关可以参考：https://blog.csdn.net/moxigandashu/article/details/63254901\",\"全文索引\",\"MySQL5.6版本innodb开始支持全文索引，之前的版本只有myisam支持，具体可以参考：https://www.cnblogs.com/PaulMa/p/5238682.html\"]},\"236\":{\"h\":\"绑定变量\",\"t\":[\"以二进制的方式向服务端发送参数和句柄，节约内存和网络开销。服务器也只对器进行一次解析。\",\"相对安全，减少了SQL注入和攻击\",\"在高并发的情况下建议关闭查询缓存，如果非要使用的话不要设置太大的内存占用，相关参数：query_cache_type是否开启缓存；query_cache_size查询缓存的总内存空间，单位字节。\"]},\"237\":{\"h\":\"配置优化：\",\"t\":[\"对于innodb来说最重要的两个配置为：\",\"innodb_buffer_pool_size缓冲池大小\",\"innodb_log_file_size 日志文件大小\",\"基本配置\",\"slow_query_log 慢查询是否开启\",\"long_query_time 慢查询衡量标准，单位秒\",\"max-connections 最大连接数\",\"read-only 是否只读\",\"table_cache_size\",\"sql_mode 服务器模式\"]},\"238\":{\"h\":\"复制\",\"t\":[\"二进制日志（binlog）建议指定确切路径和文件名，同时在备库上也建议指定中继日志（relay_log）的路径和文件名\",\"相关参数：\",\"主库：\",\"log_bin = /var/lib/mysql/mysql-bin\",\"备库：\",\"relay_log = /var/lib/mysql/relay-bin\",\"复制模式，两种，基于语句(statement)，基于行(row)。\",\"基于语句消耗资源少，执行速度快，但是很多情况下无法正确复制数据。比如有存储过程的语句，语句里有变量的\",\"基于行的复制，顾名思义就是一行一行复制，但是在数据更改比较大的情况下，消耗资源多，复制慢。\",\"一般都是在实际应用中采用混合模式复制(mixed)，即基于行和基于语句一起使用，5.7.7之前默认是基于语句，之后基于行，可以通过参数设置：\",\"binlog_format = mixed|row|statement\",\"参考文章：https://www.cnblogs.com/ivictor/p/5764978.html\",\"主从复制开启步骤\",\"1、在主服务器上创建一个复制账号\",\"2、主库从库配置server_id选项，一般是机器IP32位的后八位，主库配置二进制文件地址，从库配置中继日志文件地址，可以通过show master status 查看binlog日志的名字\",\"3、从库启动复制：\",\"命令： change master to master_host='hostip',master_user='masteruser',master_password='password',master_log_file='binlogname',master_log_pos=0;\",\"master_log_pos设置为0表示从日志开头读起，配置好之后，开始执行命令start slave;\",\"sphinx全文索引\",\"主索引和增量索引都要定时维护。具体相关实现可以参考：bbc，相关知识点，搞清楚文档、属性、关联字段。\",\"相关参考文章：https://blog.csdn.net/soar_away/article/details/52035072\",\"https://blog.csdn.net/adparking/article/details/7080278\",\"手册地址：http://sphinxsearch.com/docs/\"]},\"239\":{\"c\":[\"mysql\"]},\"240\":{\"c\":[\"mysql\",\"面试\",\"面试总结\"]},\"241\":{\"h\":\"MySQL笔记之基础篇\"},\"242\":{\"h\":\"MySQL架构\",\"t\":[\"server层：连接器、分析器、优化器、执行器\",\"存储引擎层，比较有名引擎包括：innodb、myisam、memory\"]},\"243\":{\"h\":\"SQL查询语句的执行\",\"t\":[\"连接器->查询缓存（8.0版本已废弃）->分析器->优化器->执行器 \",\"rows_examined 的字段，表示这个语句执行过程中扫描了多少行\",\"查询缓存在每次表数据更新的时候就会清除缓存\"]},\"244\":{\"h\":\"SQL更新语句的执行\",\"t\":[\"连接器->分析器->优化器->执行器->存储引擎->执行器->存储引擎 \",\"执行器操作存储引擎获取要执行的记录\",\"拿到记录后执行器对指定字段的结果进行更改\",\"执行器调用存储引擎进行数据更改，存储引擎将数据写到内存，并且记录redolog，日志记录的状态为prepare\",\"执行器生成操作的binlog日志，\",\"执行器调用事务提交接口，引擎将刚刚写入的redolog改成commit状态\",\"执行器SQL更改流程\",\"redo log 的写入拆成了两个步骤：prepare 和 commit，这就是\\\"两阶段提交\\\"。\",\"redolog和binlog的区别 \",\"redolog是引擎层的日志，innodb独有的\",\"binlog是server层的日志，所有引擎都可以使用\",\"redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。\",\"redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\",\"Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。\"]},\"245\":{\"h\":\"事务\",\"t\":[\"事务的特性\",\"原子性\",\"隔离性\",\"一致性\",\"持久性\",\"事务的隔离级别\",\"读未提交，在一个事务里可以读取其他事务未提交的数据变更\",\"读提交，在一个事务里只能读取已提交事务的变更数据\",\"可重复性读，在一个事务里可以多次读取到当前事务第一次读取的数据\",\"串行化，一个事务结束，另一个事务才能继续操作\",\"隔离级别越高，并发性越低，安全性越高\",\"幻读：第一次查询不存在，然后insert失败，这个时候出现了幻读，串行化没幻读，其余都有\",\"事务隔离的实现\",\"每条记录在更新的时候都会记录一条回滚操作，回滚日志(undolog)在没有比这个版本更老的视图的时候进行删除\",\"同一个记录在系统中存在多个版本，也就是多版本并发控制（MVCC）\",\"尽量避免使用长事务，长事务会占用较大的磁盘空间，长事务占用大量的锁资源，会拖垮整个库。长事务是指执行时间长的SQL变更\",\"避免长事务，设置SQL语句操作超时时间、开启自动提交、避免只读事务\",\"事务默认都是开启的，可以通过set autocommit=0配置进行关闭\",\"可以通过显示的命令开启事务\"]},\"246\":{\"h\":\"索引\",\"t\":[\"索引的出现其实就是为了提高数据查询的效率，就像书的目录一样\",\"常见的索引数据结构\",\"哈希，适用于精确查询，范围查询效率贼低\",\"哈希冲突时使用链表把相同hash的值搞在一块\",\"有序数组，在等值查询和范围查询场景中的性能就都非常优，但是在更新数据时效率太低\",\"树，每一个索引在 InnoDB 里面对应一棵 B+ 树。\",\"二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子\",\"InnoDB的索引\",\"主键索引\",\"非主键索引\",\"在使用非主键索引查询时，首先要先找到主键索引，然后根据主键索引查到行记录，这个过程称为回表\",\"主键索引的B+树的叶子节点存储的是page （页），一个页里面可以存多个行\",\"非主键索引的叶子节点存储的是主键\",\"基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。\",\"覆盖索引，比如使用普通索引去查询主键字段或普通索引上的字段，则会命中覆盖索引，无需回表，减少了一次扫描索引树。\",\"覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。\",\"索引遵循最左前缀原则，最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符\",\"自增主键可以避免页分裂，从性能和存储空间方面考量，自增主键往往是更合理的选择\",\"主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。\",\"联合索引创建\",\"第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。\",\"比如字段 a,b在使用时，都会被频繁查询，a的评率更高，一般建议搞一个 (a,b) 和一个(b)\",\"索引下推\",\"在使用联合索引时，当命中了最左原则，在MySQL5.6版本以上会根据后续条件的值判断索引值是否符合，减少回表次数\",\"索引重建过程\",\"主键索引重建，使用 alter table T engine=InnoDB 语句\",\"drop主键索引会导致其他索引失效，但drop普通索引不会。\",\"索引总结\",\"覆盖索引：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据\",\"最左前缀：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符\",\"联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。\",\"索引下推：like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度\"]},\"247\":{\"c\":[\"mysql\"]},\"248\":{\"c\":[\"mysql\",\"面试\",\"面试总结\"]},\"249\":{\"h\":\"MySQL笔记之实践篇\"},\"250\":{\"h\":\"唯一索引和普通索引的选择\",\"t\":[\"主要从更新性能考虑\",\"同一个字段，唯一索引和普通索引的查询消耗的性能对MySQL来说是相差不大的，普通索引比唯一索引多一次操作\",\"数据插入时针对于这两个索引，Innodb存储引擎处理的逻辑是不一样的\",\"唯一索引：判断有没有冲突，插入值，语句更新结束，如果插入的记录所在页不在内存中，还要多一步：将数据页读到内存。\",\"唯一索引，由于索引唯一性，查到第一个满足条件的记录后，停止检索\",\"普通索引：数据页在内存中直接插入值，数据页不在内存中，直接将数据写入change buffer中，结束\",\"普通索引，查到满足条件的第一个记录后，继续查找下一个记录，知道第一个不满足条件的记录\",\"change buffer是可以持久化的数据。在内存中有拷贝，也会被写入到磁盘上\",\"change buffer类似于缓冲，先将数据写入缓冲池，然后在下次查询的时候把数据读入内存，执行数据页中相关的操作，减少了读磁盘的次数\",\"只有普通索引会用到change buffer\",\"在更新之后需要立马查询的表中，change buffer反而会增加维护成本，一般适用于更新频繁但查询比较少的表，比如日志表，账单流水表\",\"索引选择是要根据业务来做的，业务正确性优先\"]},\"251\":{\"h\":\"change buffer 和 redo log\",\"t\":[\"先操作change buffer，然后将这个语句写到redolog里\",\"redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。\",\"changebuffer跟普通数据页一样也是存在磁盘里，区别在于changebuffer是在共享表空间ibdata1里\",\"redolog有两种，一种记录普通数据页的改动，一种记录changebuffer的改动\",\"只要内存里脏页（innodb buffer pool）里的数据发生了变化，就一定会记录2中前一种redolog （对数据的修改记录在changebuffer里的时候，内存里是没有这个物理页的，不存在脏页）\",\"真正对磁盘数据页的修改是通过将内存里脏页的数据刷回磁盘来完成的，而不是根据redolog\"]},\"252\":{\"h\":\"MySQL为何有的时候选择的索引不是理想中的，如何避免\",\"t\":[\"针对于大数据表，并且有删除过数据的表，往往使用索引时都不尽任意，一般是由优化器在对SQL语句进行分析时造成的，优化器是根据索引的”区分度“来做的\",\"一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。\",\"MySQL里是采用采样统计的方式来拼比基数的，当数据更新导致的统计出错的时候可以使用 analyze table t命令对数据进行重新统计\",\"可以采用 force index的方式强制使用指定的索引\",\"修改查询语句，引导MySQL使用我们期望的索引\",\"创建更加合理的索引，删除无用索引\"]},\"253\":{\"h\":\"字符串类型的字段如何加索引\",\"t\":[\"全字段加入索引，这样可能比较占用空间；\",\"字段值的前几个创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；\",\"对于特殊的字符可以采用倒序的方法创建索引，也就是把字段值倒序过来存储，取前几个创建前缀索引\",\"新增一个针对于当前字段的hash值列，在每次存储字段值的时候计算hash值并把hash存储hash列，对当前列做索引\",\"倒序和哈希两种方法都不支持范围查询，针对于精确查询hash更加稳定\",\"还是那句话脱离具体业务的技术选型，都是耍流氓\"]},\"254\":{\"h\":\"MySQL在fsync操作时执行查询或更新语句很慢\"},\"255\":{\"h\":\"数据删除问题\",\"t\":[\"delete语句执行后数据文件大小并没有改变，这是因为delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也可以认为是一种逻辑删除，所以物理空间没有实际释放，只是标记为可复用，\",\"表数据信息可能较小也可能巨大无比，她可以存储在共享表空间里，也可以单独存储在一个以.ibd为后缀的文件里，由参数innodb_file_per_table来控制，建议总是作为一个单独的文件来存储，这样非常容易管理，并且在不需要的时候，使用drop table命令也能直接把对应的文件删除，如果存储在共享空间之中即使表删除了空间也不会释放。\",\"执行过delete语句之后建议执行重建表语句，对数据表进行相关重建，比如：\",\"alter table xxx engine=innodb; optimize table xxx;\"]},\"256\":{\"h\":\"count(*)\",\"t\":[\"尽量使用count(*)，在innodb里引擎对他做了相关优化\",\"innodb里是全表扫描，一行一行进行累加，未指定条件下\",\"myisam里如果未指定条件就会取自身维护的总数\"]},\"257\":{\"c\":[\"mysql\"]},\"258\":{\"c\":[\"mysql\",\"面试\",\"面试总结\"]},\"259\":{\"h\":\"PHP面试总结 v20180824\",\"t\":[\"今天面试主要和面试官讨论这些问题，我自我感觉回答的很渣。不错，我就是个技术混子，嗯，是的。\"]},\"260\":{\"h\":\"PHP的命令模式实现\",\"t\":[\"PHP的命令模式也就是cli模式，就是把PHP文件当做脚本执行的一种方式。一般最简单的实现就是如下：\",\"php file.php \",\"上面的列子很简单，但是这个问题不是那么简单的。通常我们在web模式下都会有个入口文件，这个入口文件叫 index.php，那么命令模式下是不是也可以有个入口文件呢？答案是可以的，比如ThinkPHP5和yii框架都实现了这个功能。比如：\",\"php think list \",\"上面例子中，think 这个就是命令模式下的入口文件，list 是在换个文件的参数，可以通过 $SERVER['argv'] 获取，获取到参数之后，执行响应的逻辑。一般的框架都会实现命令的注册，每个框架的处理机制不一样，这个可以通过阅读框架的源码看下。\"]},\"261\":{\"h\":\"PHP的错误和异常处理\"},\"262\":{\"h\":\"错误处理\",\"t\":[\"一般编程语言都有自己的错误处理机制，这个机制对调试应用程序，处理业务逻辑有很大的帮助。 PHP提供了 error_reporting() 函数来设置错误级别。一般PHP常见的错误级别有这几种：E_ALL, E_ERROR, E_WARNING, E_NOTICE, E_STRICT, E_DEPRECATED。下面是对这几种错误级别的介绍。\",\"E_ERROR：致命错误，会导致脚本终止运行\",\"E_WARNING：运行时警告 (非致命错误)。仅给出提示信息，但是脚本不会终止运行\",\"E_NOTICE：运行时通知。表示脚本遇到可能会表现为错误的情况，但是在可以正常运行的脚本里面也可能会有类似的通知。\",\"E_STRICT：启用 PHP 对代码的修改建议，以确保代码具有最佳的互操作性和向前兼容性。\",\"E_DEPRECATED：运行时通知。启用后将会对在未来版本中可能无法正常工作的代码给出警告。（可忽略）\",\"E_ALL：E_STRICT 除外的所有错误和警告信息。\",\"同时用户也可以设置自身的错误级别，主要通过 trigger_error() 函数实现。用户级别的错误有：E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE, E_USER_DEPRECATED。\",\"上面的错误级别可以参考PHP官方文档：http://php.net/manual/zh/errorfunc.constants.php\",\"有的时候PHP本身对错误的处理难以满足我们的业务需求，这个时候我们可以自定义一个错误处理方法来接管PHP本身的错误处理方式。我们可以通过set_error_handler(callable $error_handler [, int $error_types = E_ALL | E_STRICT ]) 函数来注册这个方法。需要注意的是要记住 error_types 里指定的错误类型都会绕过 PHP 标准错误处理程序， 除非回调函数返回了 FALSE。 error_reporting() 设置将不会起到作用而你的错误处理函数继续会被调用 —— 不过你仍然可以获取 error_reporting 的当前值，并做适当处理。 需要特别注意的是带 @ error-control operator 前缀的语句发生错误时，这个值会是 0。 以下级别的错误不能由用户定义的函数来处理： E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，和在 调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT。可在 register_shutdown_function() 中处理( 但脚本仍会结束 )\",\"error_get_last()获取最后发生的错误，返回了一个关联数组，描述了最后错误的信息，以该错误的 “type”、 “message”、”file” 和 “line” 为数组的键。 如果该错误由 PHP 内置函数导致的，”message”会以该函数名开头。 如果还没有错误则返回 NULL。\",\"Array ( [type] => 8 [message] => Undefined variable: a [file] => C:\\\\WWW\\\\index.php [line] => 2 ) \",\"一般在做错误处理的时候这个函数会被register_shutdown_function()注册到脚本运行结束前。\",\"具体使用方法可以参考PHP官方手册：http://php.net/manual/zh/function.set-error-handler.php\",\"异常处理 在PHP中采用 try...catch 模式来处理异常，使用 throw关键字抛出异常。PHP的异常处理基类是 Exception，所有的异常处理类都继承它。官方手册地址：http://php.net/manual/zh/class.exception.php\",\"同时PHP也提供了 ErrorException 错误异常处理类，可以使用set_error_handler()函数将错误信息托管至ErrorException：\",\"<?php function exception_error_handler($errno, $errstr, $errfile, $errline ) { throw new ErrorException($errstr, 0, $errno, $errfile, $errline); } set_error_handler(\\\"exception_error_handler\\\"); /* Trigger exception */ strpos(); ?> \",\"具体可参考PHP官方手册：http://php.net/manual/zh/class.errorexception.php\",\"除了上述两个标准异常之外，SPL提供了一系列标准异常。具体可参考：http://php.net/manual/zh/spl.exceptions.php\",\"PHP官方提供了 set_exception_handler() 函数来帮助开发者自定义异常处理行为。手册地址：http://php.net/manual/zh/function.set-exception-handler.php\",\"错误和异常统一处理 一般在框架中都会封装一套属于框架自身的错误和异常处理模块，通常错误会被转化为异常进行统一处理。以下是简单的实现思路\",\"<?php class handleExceptions { public function init() { // 致命错误和语法错误 error_reporting(E_ERROR | E_USER_ERROR | E_PARSE | E_COMPILE_ERROR); set_error_handler([$this, 'errorHandler']); set_exception_handler([$this, 'exceptionHandler']); // 获取最后一次错误 register_shutdown_function([$this, 'handlerShutdown']); } public function errorHandler($level, $message, $file = '', $line = 0, $context = array()) { // 判断错误级别是否是设置的 if (error_reporting() & $level) { throw new \\\\ErrorException($message, 0, $level, $file, $line); } } public function exceptionHandler(Exception $e) { // 所有的错误和异常都在这里进行处理,一般处理错误的时候需要进行以下几点 // 1、根据错误级别记录错误日志，有利于后期排查 // 2、根据当前业务场景做出相应的动作，比如在开发模式下，就把错误全面的展现出来，如果是生产模式下就要进行优雅的错误处理。 } public function handlerShutdown() { $error = error_get_last(); if ( ! is_null($error) && $this->isFatal($error['type'])) { $this->exceptionHandler($this->fatalExceptionFromError($error, 0)); } } protected function fatalExceptionFromError(array $error, $traceOffset = null) { return new \\\\ErrorException( $error['message'], 0, $error['type'], $error['file'], $error['line'] ); } protected function isFatal($type) { $a = in_array($type, [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE]); return $a; } } \",\"上面的例子中，我们自定义了一个处理类，这个类只对致命性错误和语法错误进行防范处理，其他的错误进行了忽略。（可重写errorHandler方法，让其对其他级别的错误进行处理）handleExceptions::exceptionHandler()方法让错误和异常都在这里进行处理。 一般处理错误的时候需要进行：\",\"1、根据错误级别记录错误日志，有利于后期排查\",\"2、根据当前业务场景做出相应的动作，比如在开发模式下，就把错误全面的展现出来，如果是生产模式下就要进行优雅的错误处理。（比如错误页面啊，Ajax模式下错误响应，错误恢复脚本继续执行等等）\",\"在PHP7以上，E_ERROR的错误可以交由set_exception_handler，即自定义异常来捕获。具体参考：http://php.net/manual/en/class.error.php 和 http://php.net/manual/en/class.throwable.php 及 http://php.net/manual/zh/function.set-exception-handler.php\"]},\"263\":{\"h\":\"会话管理，跨域，单点登录\"},\"264\":{\"h\":\"会话管理\",\"t\":[\"在web开发中，总是会用到会话管理。所谓会话管理指的是因为HTTP协议是无状态的一种协议，为了识别当前用户而创建的一种技术手段。会话管理主要有两个部分组成，客户端和服务器端。一般客户端指的是COOKIE，服务器端指的是SESSION。\",\"Session和cookie的关系。会话是由客户端发起请求，服务器端响应。比如用户登录，用户发起登录请求，服务器校验请求是否正确，正确的话就在服务器端生成一个唯一sessionID，然后通过HTTP协议把这个sessionID放到cookie里返回给客户端，客户端收到cookie后会在每次请求的时候带上cookie。格式如下：\",\"Cookie: PHPSESSID=q0fm8up72q58ne1b6khf37dlos\",\"PHP提供了很简单两个全局变量来操作cookie和session，分别是 $_COOKIE 和 $_SESSION，开发者不需要考虑sessionID的问题。PHP默认会把session存储在服务器的临时目录中，并在每次运行时进行GC操作。你可以通过配置 php.ini 文件改变它。同时你也可以通过自定义会话管理器来管理会话。自定义会话管理可以实现共享session。下面是利用 Redis 来实现 session 的存储的例子。\",\" class sysSession implements SessionHandlerInterface { private $client; private $exprie; public function __construct($client) { $this->client = $client; } public function setExprie($exprie) { $this->exprie = $exprie; } public function open($savePath, $sessionName) { return true; } public function close() { return true; } public function read($id) { return $this->client->get($id); } public function write($id, $data) { return $this->client->setsetEx($id, $this->exprie, $data); } public function destroy($id) { return $this->client->delete($id); } public function gc($lifetime) { return true; } } \",\"使用示例：\",\" $redis = new Redis; $redis->open(\\\"ip\\\", \\\"port\\\", \\\"timeout\\\"); $handler = new sysSession($redis); $handler->setExprie(3600); session_set_save_handler($handler, true); register_shutdown_function('session_write_close'); session_start(); \",\"你可以把session存储到一个公共的服务器或集群中，这样就可以实现共享session了\",\"关于session相关知识可以阅读PHP官方手册：http://php.net/manual/zh/session.examples.php 会话安全方面PHP官方手册进行了说明，地址：http://php.net/manual/zh/session.security.php 和 http://php.net/manual/zh/features.session.security.management.php\"]},\"265\":{\"h\":\"会话跨域和单点登录\",\"t\":[\"有的时候我们一个网站有很多服务模块，每个模块都有一个域名，这个时候我们想实现多个域名之间的会话管理，那应该怎么办呢？首先我们要知道跨域，浏览器有一种同源策略。比如： a.domin.com 不能访问 b.explame.com 下的cookie，因为他们不同源，如果是这两个域名 a.domain.com 和 b.domain.com 呢？这两个是同源域名，都属于 domain.com，看下列代码：\",\"<?php setcookie(\\\"TestCookie\\\", \\\"\\\", time() - 3600, \\\"/\\\", \\\"domain.com\\\", false, true); \",\"在PHP中通过上述代码就可以让a.domain.com 和 b.domain.com进行cookie之间的相互传递，然后在每次请求的时候把cookie相关信息带上，服务端实现session共享，就可以实现会话的跨域了。这个解决方案是解决了主域名和子域名下的会话管理问题，如果是多个不同的域名呢，应该怎么办？这个时候我们就要考虑到单点登录了\",\"关于单点登录，可以参考这篇文章：https://www.cnblogs.com/ywlaker/p/6113927.html 一般单点登录的使用场景是多系统之间。比如淘宝和天猫。淘宝和天猫是两种不同的系统，域名也不一样，但是你在淘宝上登录之后在天猫上也可以访问自己的个人中心。（所有的一切都是基于统一浏览器上）\",\"同样PHP有个比较好的项目叫做 UCenter，这个产品很好的实现了单点登录，可以自己动手实现下。\"]},\"266\":{\"h\":\"负载均衡\",\"t\":[\"当业务发展到一定程度之后，单台服务器就无法满足业务需求，这个时候就要考虑到使用集群方案。负载均衡是集群方案中的一种策略。负载均衡的主要作用就是根据不同的算法分发请求至服务集群中的某个节点。在PHP web开发中主要使用 Nginx或者 Apache 来做负载均衡执行者。在 Nginx 中主要采用反向代理的方式来实现负载均衡。Nginx默认采用轮询算法。同时还用 IP_hash 算法。Nginx 默认提供这两种算法，同时也支持第三方的算法。下面是这些算法的介绍。\",\"轮询算法(默认)\",\"每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\",\"upstream backserver { server 192.168.0.14; server 192.168.0.15; } \",\"同时也可以指定权重，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\",\"upstream backserver { server 192.168.0.14 weight=10; server 192.168.0.15 weight=10; } \",\"IP绑定 ip_hash\",\"每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\",\"upstream backserver { ip_hash; server 192.168.0.14:88; server 192.168.0.15:80; } \",\"当ip hash失效时，会退化为轮询策略，因此不会有丢失流量的情况。从这个层面上说，ip hash也可以看成是轮询的升级版。\",\"fair（第三方）\",\"按后端服务器的响应时间来分配请求，响应时间短的优先分配。\",\"upstream backserver { server server1; server server2; fair; } \",\"url_hash（第三方）\",\"按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\",\"upstream backserver { server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32; } \",\"关于Nginx负责均衡算法策略的选择，要根据业务场景来选择,一般选择的标准可以参考这三个指标：\",\"均衡性：是否能够将请求均匀的发送给后端\",\"一致性：同一个key的请求，是否能落到同一台机器\",\"容灾性：当部分后端机器挂掉时，是否能够正常工作 可以参考这篇文章：https://www.cnblogs.com/wpjamer/articles/6443332.html\",\"负载均衡相关知识可参考：https://blog.csdn.net/qq_27093465/article/details/78273656 关于Nginx轮询算法的解释可以看这篇文章：https://blog.csdn.net/itkingone/article/details/80365212\"]},\"267\":{\"h\":\"秒杀活动和超卖\",\"t\":[\"一般做程序开发都会遇到这种业务需求：秒杀活动。比如双十一的商品秒杀，某游戏的内测号等等。一般面试的时候问这个问题主要是考察候选人的综合能力。\"]},\"268\":{\"h\":\"秒杀设计\",\"t\":[\"首先考虑秒杀的场景，秒杀是指在指定时间范围内有限库存限制下的售卖行为。在时间范围内，随着请求的增加怎么保持服务的快速响应，怎么限制用户的下单行为，商品库存的增减等等都是要考虑的。我们一一分析下。\",\"高并发下的秒杀活动页面快速响应\",\"从前端来讲可以这样搞：\",\"页面静态化：像秒杀活动页面一般都是访问比较高的，商品信息和库存都是固定的。所以把页面进行静态化处理是一种很好的方法，同时可以使用JS异步请求服务端，做一些简单的逻辑处理。比如倒计时、购买按钮禁止，库存修改、禁止重复提交和无限刷新等。\",\"CDN加速：静态资源可以使用CDN加速。\",\"用户限流：在某一时间段内只允许用户提交一次请求，比如可以采取IP限流\",\"后端的角度可以这样搞：\",\"-在前端和后端服务之间增加一个中间层。一般这个中间层就是我们上文提到的负载均衡，通过负载均衡把请求分发到不同的节点。\",\"-限制同一UserID访问频率：尽量拦截浏览器请求，在服务端控制层需要针对同一个访问uid，限制访问频率。\",\"-业务分离:将秒杀业务系统和其他业务分离，单独放在专门用来做秒杀活动的服务器集群上。\",\"-采用消息队列缓存请求：将大流量请求写到消息队列缓存，利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求\",\"-利用缓存应对读请求：对于读多写少业务，大部分请求是查询请求，所以可以读写分离，利用缓存分担数据库压力\",\"-利用缓存应对写请求：缓存也是可以应对写请求的，可把数据库中的库存数据转移到Redis缓存中，所有减库存操作都在Redis中进行，然后再通过后台进程把Redis中的用户秒杀请求同步到数据库中。\",\"-随机选取用户执行秒杀逻辑，没有选取到的用户返回秒杀失败\",\"我们在创建秒杀活动的时候就要把商品相关信息写入到缓存中，比如商品实际库存、秒杀限制库存，商品相关信息等。\",\"我们可以采用Redis 最简单的key-value数据结构，用一个原子类型的变量值(AtomicInteger)作为key，把用户id作为value，库存数量便是原子变量的最大值。对于每个用户的秒杀，我们使用 RPUSH key value插入秒杀请求， 当插入的秒杀请求数达到上限时，停止所有后续插入。下面是简单样例：\",\"// 假设商品库存有10个,key键名为 goods.store $nums = $redis->get('goods.store'); if($nums<=0){ return false; } if ($redis->decr('goods.store')<0){ return false; } $redis->rpush('sale:1', 'uid') \",\"上面的示例中，我们定义了几个key，分别是：goods.store(商品库存)、sale:1(秒杀队列的key)，开始的时候我们判断商品库存是否小于等于0，成立的话就说明秒杀失败，不成立的话就对商品库存进行 decr 操作并判断是否小于0，成立说明秒杀失败，不成立的话就把秒杀用户ID加入到秒杀队列中，然后去消费秒杀队列，用户在对订单付完款之后减商品数据库库存，然后把用户ID加入到秒杀购买成功队列,如果订单在一定时间内不付款就把此订单状态改为失败然后redis里的 goods.store进行 incr 操作。\"]},\"269\":{\"h\":\"超卖问题\",\"t\":[\"关于超卖问题，一般都是在并发下，对库存的判断出现了问题，上个例子中已经采用了原子操作，可以极大可能的避免超卖，但是会导致少卖，同时也可以使用redis的乐观锁和事务实现：\",\"$redis->watch(key) if(redis->get(key) < 0){ echo '抢购失败';return false; } $redis->multi(); $redis->decr(key); $redis->rpush(); $redis-exec(); \"]},\"270\":{\"c\":[\"golang\"]},\"271\":{\"c\":[\"php\",\"面试\",\"面试总结\",\"php面试总结\"]},\"272\":{\"h\":\"Redis 基础\"},\"273\":{\"h\":\"Redis常见的数据结构？\",\"t\":[\"String、Hash、List、Set、SortedSet。\"]},\"274\":{\"h\":\"1.String 字符串类型\",\"t\":[\"是redis中最基本的数据类型，一个key对应一个value。\",\"String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。\",\"实战场景：\",\"缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。\",\"计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。\",\"session：常见方案spring session + redis实现session共享\"]},\"275\":{\"h\":\"2.Hash （哈希）\",\"t\":[\"是一个Mapmap，指值本身又是一种键值对结构，如 value={{field1,value1},......fieldN,valueN}}\",\"实战场景：\",\"1.缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。\"]},\"276\":{\"h\":\"3.链表\",\"t\":[\"List 说白了就是链表（redis 使用双端链表实现的 List），是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。\",\"使用列表的技巧\",\"lpush+lpop=Stack(栈)\",\"lpush+rpop=Queue（队列）\",\"lpush+ltrim=Capped Collection（有限集合）\",\"lpush+brpop=Message Queue（消息队列）\",\"实战场景：\",\"1.timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。\"]},\"277\":{\"h\":\"4.Set 集合\",\"t\":[\"集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 1. 不允许有重复的元素，2.集合中的元素是无序的，不能通过索引下标获取元素，3.支持集合间的操作，可以取多个集合取交集、并集、差集。\",\"实战场景;\",\"标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。\",\"点赞，或点踩，收藏等，可以放到set中实现\"]},\"278\":{\"h\":\"5.zset 有序集合\",\"t\":[\"有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。\",\"（有序集合中的元素不可以重复，但是score 分数 可以重复，就和一个班里的同学学号不能重复，但考试成绩可以相同）。\",\"实战场景：\",\"排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。\"]},\"279\":{\"c\":[\"redis\"]},\"280\":{\"c\":[\"redis\",\"面试\",\"面试总结\"]},\"281\":{\"h\":\"缓存系统中面临的雪崩/穿透/一致性问题\",\"t\":[\"缓存系统一定程度上极大提升系统并发能力，但同样也增加额外技术考虑因素，下面针对缓存系统设计与使用中面临的常见问题展开。\",\"缓存应用的典型场景\",\"缓存雪崩\",\"缓存穿透\",\"缓存更新与数据一致性\"]},\"282\":{\"h\":\"缓存应用的典型场景\",\"t\":[\" 请求->缓存->命中缓存则返回数据->无缓存则读取原始数据源\",\"缓存定位：前置数据加载，避免数据回源，提供高性能、高并发的数据读取能力；只有未命中缓存时才进行数据回源，极大减轻原始数据读取的压力\",\"缓存分类：按缓存系统所处位置不同，分为本地缓存、分布式缓存\",\"本地缓存：内存级缓存、文件级缓存，内存级缓存优势在于本地内存I/O、高性能(单次内存寻址100ns)，缺点在于空间有限，无法多端数据同步，此类方案有PHP的Opcache/Yac, Java中Encache/GuavaCache/SpringCache等；文件级缓存依赖磁盘I/O实现缓存作用，受机械磁盘寻道性能限制(单次磁盘读取时间10ms左右)，或考虑固态硬盘/Raid优化方案，较少使用\",\"分布式缓存：Memcached、Redis等，分布式系统解决缓存容量问题，具备持续扩容能力，但不可避免一次网络I/O请求 本文主要讨论分布式缓存系统设计与使用中面临的问题。\"]},\"283\":{\"h\":\"缓存雪崩\",\"t\":[\"定义：缓存雪崩是指缓存系统失效，导致大量请求同时进行数据回源，导致数据源压力骤增而崩溃。两种情况会导致此问题：\",\"多个缓存数据同时失效；\",\"缓存系统崩溃\"]},\"284\":{\"h\":\"缓存同时失效\",\"t\":[\"在大量缓存同时失效的情况下，请求回源，导致数据源请求暴增而崩溃，系统全局不可用\",\"缓存时间设置原则：根据缓存数据访问规律和缓存数据不一致的敏感性要求来选择缓存时间\",\"缓存数据访问规律：如不同缓存数据访问无规律或相对离散，则不会存在这些缓存数据同时失效的情况；如缓存数据为批量写入(定时任务预热)，应考虑将缓存时间离散化，避免同时失效的情况下大量回源请求\",\"缓存数据不一致的敏感性：不同应用场景下对缓存数据的一致性要求不同，缓存时间的设置视情况而定\",\"这里也涉及到缓存更新策略问题，错误的更新策略可能会先删除缓存，再设置缓存，此时间差范围内的请求会进行回源，会导致此问题\",\"如何避免应考虑：缓存失效时间离散化\"]},\"285\":{\"h\":\"缓存系统故障\",\"t\":[\"缓存系统整体故障，则整个缓存系统不可用，大量回源请求，且由于缓存系统故障无法回写缓存，导致无法快速恢复。\",\"一句老话：为解决一个问题，引入新的解决方案，同时也必然引入新的问题。\",\"这也是缓存系统的引入，在解决高性能、高并发的同时，引入了新的故障点。\",\"考虑此问题，应从事前、事故中、事后不同阶段考虑：\",\"事前：增加缓存系统高可用方案设计，避免出现系统性故障\",\"事故中：\",\"增加多级缓存，在单一缓存故障时，仍有其他缓存系统可用，如之前项目中使用的三级缓存方案：内存级缓存->Memcached->Redis这样的方案；\",\"启用熔断限流机制，只允许可承受流量，避免全部流量压垮系统\",\"事后：缓存数据持久化，在故障后快速恢复缓存系统\"]},\"286\":{\"h\":\"缓存穿透\",\"t\":[\"定义：缓存穿透是指访问不存在数据，从而绕过缓存，直取数据源（大量数据源读取操作）\",\"解决缓存穿透的思路：\",\"不存在资源访问时，在缓存系统设置空值来拦截\",\"优点：实现简单\",\"问题：大量非法请求时，缓存系统被填充大量非法值\",\"根据资源设置拦截机制（布隆过滤器bloomfilter或压缩filter过滤有效资源，如有效用户id等；也可以全局保存有效资源摘要，专用过滤、防穿透）\",\"优点：缓存系统空间利用较好\",\"问题：过滤器实现机制和数据一致性要求\"]},\"287\":{\"h\":\"缓存更新与数据一致性\",\"t\":[\"缓存系统数据的更新策略是需要专门开题来说的，建议阅读左耳朵耗子：缓存更新的套路系统了解，这里只根据实际经验给出在不同一致性要求下的建议。\",\"一种常见缓存更新策略（此方案有问题）：\",\"读操作：命中缓存则返回，无缓存则取回源数据，写缓存\",\"写操作：先删除缓存，再更新数据源\",\"问题场景：读写并发的场景下先删缓存操作可能导致脏数据入缓存\",\"写操作：删除缓存\",\"读操作：无缓存则取回源数据（旧数据），回写缓存（此时缓存中为旧数据）\",\"写操作：更新数据源\",\"此时缓存数据不一致：缓存中为旧数据，数据源为新数据，出现缓存旧数据问题\"]},\"288\":{\"h\":\"几种更新缓存的策略：\",\"t\":[\"Cache Aside Pattern：缓存失效时回源取数据，更新缓存；命中缓存时，返回缓存数据；先数据源更新后，再失效缓存（由等待下次读取来回写缓存）\",\"优势：无缓存旧数据问题、缓存系统维护简单、Facebook推荐方案\",\"问题：无法绝对杜绝并发读写问题\",\"缓存过期的背景下，读操作回源取数据（此时为旧数据）\",\"写操作：更新数据源，失效缓存\",\"读操作：将回源数据（旧数据）写缓存，出现缓存数据不一致问题\",\"这种问题出现概率极低，几点要求：缓存已过期、并发读写、读数据比写数据快、但读操作更新缓存比写操作失效缓存慢（也就是说写操作的行为需完全发生在读操作两步之间），一般而言读操作（读库+更新缓存）时长要小于写操作（更新数据源+失效缓存），所以认为这种并发问题概率较低\",\"是否可进一步解决此问题：增加锁机制，解决并发问题\",\"Read Through Pattern：更新数据源由缓存系统操作\",\"读取数据时，如缓存失效，则缓存服务取回源数据更新缓存\",\"而Cache Aside中是由应用服务（调用方）更新缓存\",\"这套对调用方是透明的，只有一套存储系统，而无视缓存、数据源的差异\",\"Write Through Pattern：更新数据源由缓存系统操作\",\"写数据时，如缓存失效，则直接更新数据源（不做任何缓存操作）；如命中缓存，则更新缓存（由缓存系统更新数据源）\",\"在缓存失效下写操作的处理后，何时更新缓存呢？下一次读操作，按Read Through中缓存失效策略来更新缓存\",\"Write Behind Caching Pattern：又称Write Back\",\"一句话总结：更新数据时，只更新缓存，不更新数据源（缓存异步批量更新数据源）\",\"优势：\",\"更新缓存为内存操作，读写I/O非常高\",\"异步批量更新数据源，合并多个操作\",\"问题：\",\"缓存不满足强一致性要求\",\"强一致性和高性能的冲突、高可用和高性能的冲突终究会使Trade-Off\",\"实现复杂，需跟踪哪些Cache更新，成本较高 总体来说，不同方案在不同场景下是有各自优劣的，技术选型、架构设计应根据实际场景取舍，并对选择方案的利弊有足够且深入理解。\",\"一般而言，推荐Cache Aside Pattern方案，容忍较小概率的不一致（同时也可以增加锁机制解决此低概率并发问题），简化缓存系统复杂度。\",\"原文链接：http://fivezh.github.io/2019/02/11/cache-things/\"]},\"289\":{\"c\":[\"redis\"]},\"290\":{\"c\":[\"redis\",\"cache\",\"缓存\",\"面试\",\"面试总结\"]},\"291\":{\"h\":\"Redis中的数据结构\",\"t\":[\"原文地址 Redis中的数据结构\"]},\"292\":{\"h\":\"1. 底层数据结构, 与Redis Value Type之间的关系\",\"t\":[\"对于Redis的使用者来说, Redis作为Key-Value型的内存数据库, 其Value有多种类型.\",\"String\",\"Hash\",\"List\",\"Set\",\"ZSet\",\"这些Value的类型, 只是\\\"Redis的用户认为的, Value存储数据的方式\\\". 而在具体实现上, 各个Type的Value到底如何存储, 这对于Redis的使用者来说是不公开的.\",\"举个粟子: 使用下面的命令创建一个Key-Value\",\"SET \\\"Hello\\\" \\\"World\\\" \",\"对于Redis的使用者来说, Hello这个Key, 对应的Value是String类型, 其值为五个ASCII字符组成的二进制数据. 但具体在底层实现上, 这五个字节是如何存储的, 是不对用户公开的. 即, Value的Type, 只是表象, 具体数据在内存中以何种数据结构存放, 这对于用户来说是不必要了解的.\",\"Redis对使用者暴露了五种Value Type, 其底层实现的数据结构有8种, 分别是:\",\"SDS - simple synamic string - 支持自动动态扩容的字节数组\",\"list - 平平无奇的链表\",\"dict - 使用双哈希表实现的, 支持平滑扩容的字典\",\"zskiplist - 附加了后向指针的跳跃表\",\"intset - 用于存储整数数值集合的自有结构\",\"ziplist - 一种实现上类似于TLV, 但比TLV复杂的, 用于存储任意数据的有序序列的数据结构\",\"quicklist - 一种以ziplist作为结点的双链表结构, 实现的非常苟\",\"zipmap - 一种用于在小规模场合使用的轻量级字典结构\",\"而衔接\\\"底层数据结构\\\"与\\\"Value Type\\\"的桥梁的, 则是Redis实现的另外一种数据结构: redisObject. Redis中的Key与Value在表层都是一个redisObject实例, 故该结构有所谓的\\\"类型\\\", 即是ValueType. 对于每一种Value Type类型的redisObject, 其底层至少支持两种不同的底层数据结构来实现. 以应对在不同的应用场景中, Redis的运行效率, 或内存占用.\"]},\"293\":{\"h\":\"2. 底层数据结构\"},\"294\":{\"h\":\"2.1 SDS - simple dynamic string\",\"t\":[\"这是一种用于存储二进制数据的一种结构, 具有动态扩容的特点. 其实现位于src/sds.h与src/sds.c中, 其关键定义如下:\",\"typedef char *sds; /* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; \",\"SDS的总体概览如下图:\",\"其中sdshdr是头部, buf是真实存储用户数据的地方. 另外注意, 从命名上能看出来, 这个数据结构除了能存储二进制数据, 显然是用于设计作为字符串使用的, 所以在buf中, 用户数据后总跟着一个\\\\0. 即图中 \\\"数据\\\" + \\\"\\\\0\\\" 是为所谓的buf\",\"SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的头部, 分别如下:\",\"len分别以uint8, uint16, uint32, uint64表示用户数据的长度(不包括末尾的\\\\0)\",\"alloc分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\\\\0, 剩余的字节数.\",\"flag始终为一字节, 以低三位标示着头部的类型, 高5位未使用.\",\"当在程序中持有一个SDS实例时, 直接持有的是数据区的头指针, 这样做的用意是: 通过这个指针, 向前偏一个字节, 就能取到flag, 通过判断flag低三位的值, 能迅速判断: 头部的类型, 已用字节数, 总字节数, 剩余字节数. 这也是为什么sds类型即是char *指针类型别名的原因.\",\"创建一个SDS实例有三个接口, 分别是:\",\"// 创建一个不含数据的sds: // 头部 3字节 sdshdr8 // 数据区 0字节 // 末尾 \\\\0 占一字节 sds sdsempty(void); // 带数据创建一个sds: // 头部 按initlen的值, 选择最小的头部类型 // 数据区 从入参指针init处开始, 拷贝initlen个字节 // 末尾 \\\\0 占一字节 sds sdsnewlen(const void *init, size_t initlen); // 带数据创建一个sds: // 头部 按strlen(init)的值, 选择最小的头部类型 // 数据区 入参指向的字符串中的所有字符, 不包括末尾 \\\\0 // 末尾 \\\\0 占一字节 sds sdsnew(const char *init); \",\"所有创建sds实例的接口, 都不会额外分配预留内存空间\",\"sdsnewlen用于带二进制数据创建sds实例, sdsnew用于带字符串创建sds实例. 接口返回的sds可以直接传入libc中的字符串输出函数中进行操作, 由于无论其中存储的是用户的二进制数据, 还是字符串, 其末尾都带一个\\\\0, 所以至少调用libc中的字符串输出函数是安全的.\",\"在对SDS中的数据进行修改时, 若剩余空间不足, 会调用sdsMakeRoomFor函数用于扩容空间, 这是一个很低级的API, 通常情况下不应当由SDS的使用者直接调用. 其实现中核心的几行如下:\",\"sds sdsMakeRoomFor(sds s, size_t addlen) { ... /* Return ASAP if there is enough space left. */ if (avail >= addlen) return s; len = sdslen(s); sh = (char*)s-sdsHdrSize(oldtype); newlen = (len+addlen); if (newlen < SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; ... } \",\"可以看到, 在扩充空间时\",\"先保证至少有addlen可用\",\"然后再进一步扩充, 在总体占用空间不超过阈值SDS_MAC_PREALLOC时, 申请空间再翻一倍. 若总体空间已经超过了阈值, 则步进增长SDS_MAC_PREALLOC. 这个阈值的默认值为 1024 * 1024\",\"SDS也提供了接口用于移除所有未使用的内存空间. sdsRemoveFreeSpace, 该接口没有间接的被任何SDS其它接口调用, 即默认情况下, SDS不会自动回收预留空间. 在SDS的使用者需要节省内存时, 由使用者自行调用:\",\"sds sdsRemoveFreeSpace(sds s); \",\"总结:\",\"SDS除了是某些Value Type的底层实现, 也被大量使用在Redis内部, 用于替代C-Style字符串. 所以默认的创建SDS实例接口, 不分配额外的预留空间. 因为多数字符串在程序运行期间是不变的. 而对于变更数据区的API, 其内部则是调用了 sdsMakeRoomFor, 每一次扩充空间, 都会预留大量的空间. 这样做的考量是: 如果一个SDS实例中的数据被变更了, 那么很有可能会在后续发生多次变更.\",\"SDS的API内部不负责清除未使用的闲置内存空间, 因为内部API无法判断这样做的合适时机. 即便是在操作数据区的时候导致数据区占用内存减少时, 内部API也不会清除闲置内在空间. 清除闲置内存空间责任应当由SDS的使用者自行担当.\",\"用SDS替代C-Style字符串时, 由于其头部额外存储了数据区的长度信息, 所以字符串的求长操作时间复杂度为O(1)\"]},\"295\":{\"h\":\"2.2 list\",\"t\":[\"这是普通的链表实现, 链表结点不直接持有数据, 而是通过void *指针来间接的指向数据. 其实现位于 src/adlist.h与src/adlist.c中, 关键定义如下:\",\"typedef struct listNode { struct listNode *prev; struct listNode *next; void *value; } listNode; typedef struct listIter { listNode *next; int direction; } listIter; typedef struct list { listNode *head; listNode *tail; void *(*dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr, void *key); unsigned long len; } list; \",\"其内存布局如下图所示:\",\"这是一个平平无奇的链表的实现. list在Redis除了作为一些Value Type的底层实现外, 还广泛用于Redis的其它功能实现中, 作为一种数据结构工具使用. 在list的实现中, 除了基本的链表定义外, 还额外增加了:\",\"迭代器listIter的定义, 与相关接口的实现.\",\"由于list中的链表结点本身并不直接持有数据, 而是通过value字段, 以void *指针的形式间接持有, 所以数据的生命周期并不完全与链表及其结点一致. 这给了list的使用者相当大的灵活性. 比如可以多个结点持有同一份数据的地址. 但与此同时, 在对链表进行销毁, 结点复制以及查找匹配时, 就需要list的使用者将相关的函数指针赋值于list.dup, list.free, list.match字段.\"]},\"296\":{\"h\":\"2.3 dict\",\"t\":[\"dict是Redis底层数据结构中实现最为复杂的一个数据结构, 其功能类似于C++标准库中的std::unordered_map, 其实现位于 src/dict.h 与 src/dict.c中, 其关键定义如下:\",\"typedef struct dictEntry { void *key; union { void *val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next; } dictEntry; typedef struct dictType { uint64_t (*hashFunction)(const void *key); void *(*keyDup)(void *privdata, const void *key); void *(*valDup)(void *privdata, const void *obj); int (*keyCompare)(void *privdata, const void *key1, const void *key2); void (*keyDestructor)(void *privdata, void *key); void (*valDestructor)(void *privdata, void *obj); } dictType; /* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */ typedef struct dictht { dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used; } dictht; typedef struct dict { dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */ } dict; /* If safe is set to 1 this is a safe iterator, that means, you can call * dictAdd, dictFind, and other functions against the dictionary even while * iterating. Otherwise it is a non safe iterator, and only dictNext() * should be called while iterating. */ typedef struct dictIterator { dict *d; long index; int table, safe; dictEntry *entry, *nextEntry; /* unsafe iterator fingerprint for misuse detection. */ long long fingerprint; } dictIterator; \",\"其内存布局如下所示:\",\"dict中存储的键值对, 是通过dictEntry这个结构间接持有的, k通过指针间接持有键, v通过指针间接持有值. 注意, 若值是整数值的话, 是直接存储在v字段中的, 而不是间接持有. 同时next指针用于指向, 在bucket索引值冲突时, 以链式方式解决冲突, 指向同索引的下一个dictEntry结构.\",\"传统的哈希表实现, 是一块连续空间的顺序表, 表中元素即是结点. 在dictht.table中, 结点本身是散布在内存中的, 顺序表中存储的是dictEntry的指针\",\"哈希表即是dictht结构, 其通过table字段间接的持有顺序表形式的bucket, bucket的容量存储在size字段中, 为了加速将散列值转化为bucket中的数组索引, 引入了sizemask字段, 计算指定键在哈希表中的索引时, 执行的操作类似于dict->type->hashFunction(键) & dict->ht[x].sizemask. 从这里也可以看出来, bucket的容量适宜于为2的幂次, 这样计算出的索引值能覆盖到所有bucket索引位.\",\"dict即为字典. 其中type字段中存储的是本字典使用到的各种函数指针, 包括散列函数, 键与值的复制函数, 释放函数, 以及键的比较函数. privdata是用于存储用户自定义数据. 这样, 字典的使用者可以最大化的自定义字典的实现, 通过自定义各种函数实现, 以及可以附带私有数据, 保证了字典有很大的调优空间.\",\"字典为了支持平滑扩容, 定义了ht[2]这个数组字段. 其用意是这样的:\",\"一般情况下, 字典dict仅持有一个哈希表dictht的实例, 即整个字典由一个bucket实现.\",\"随着插入操作, bucket中出现冲突的概率会越来越大, 当字典中存储的结点数目, 与bucket数组长度的比值达到一个阈值(1:1)时, 字典为了缓解性能下降, 就需要扩容\",\"扩容的操作是平滑的, 即在扩容时, 字典会持有两个dictht的实例, ht[0]指向旧哈希表, ht[1]指向扩容后的新哈希表. 平滑扩容的重点在于两个策略:\",\"后续每一次的插入, 替换, 查找操作, 都插入到ht[1]指向的哈希表中\",\"每一次插入, 替换, 查找操作执行时, 会将旧表ht[0]中的一个bucket索引位持有的结点链表, 迁移到ht[1]中去. 迁移的进度保存在rehashidx这个字段中.在旧表中由于冲突而被链接在同一索引位上的结点, 迁移到新表后, 可能会散布在多个新表索引中去.\",\"当迁移完成后, ht[0]指向的旧表会被释放, 之后会将新表的持有权转交给ht[0], 再重置ht[1]指向NULL\",\"这种平滑扩容的优点有两个:\",\"平滑扩容过程中, 所有结点的实际数据, 即dict->ht[0]->table[rehashindex]->k与dict->ht[0]->table[rehashindex]->v分别指向的实际数据, 内存地址都不会变化. 没有发生键数据与值数据的拷贝或移动, 扩容整个过程仅是各种指针的操作. 速度非常快\",\"扩容操作是步进式的, 这保证任何一次插入操作都是顺畅的, dict的使用者是无感知的. 若扩容是一次性的, 当新旧bucket容量特别大时, 迁移所有结点必然会导致耗时陡增.\",\"除了字典本身的实现外, 其中还顺带实现了一个迭代器, 这个迭代器中有字段safe以标示该迭代器是\\\"安全迭代器\\\"还是\\\"非安全迭代器\\\", 所谓的安全与否, 指是的这种场景: 设想在运行迭代器的过程中, 字典正处于平滑扩容的过程中. 在平滑扩容的过程中时, 旧表一个索引位上的, 由冲突而链起来的多个结点, 迁移到新表后, 可能会散布到新表的多个索引位上. 且新的索引位的值可能比旧的索引位要低.\",\"遍历操作的重点是, 保证在迭代器遍历操作开始时, 字典中持有的所有结点, 都会被遍历到. 而若在遍历过程中, 一个未遍历的结点, 从旧表迁移到新表后, 索引值减小了, 那么就可能会导致这个结点在遍历过程中被遗漏.\",\"所以, 所谓的\\\"安全\\\"迭代器, 其在内部实现时: 在迭代过程中, 若字典正处于平滑扩容过程, 则暂停结点迁移, 直至迭代器运行结束. 这样虽然不能保证在迭代过程中插入的结点会被遍历到, 但至少保证在迭代起始时, 字典中持有的所有结点都会被遍历到.\",\"这也是为什么dict结构中有一个iterators字段的原因: 该字段记录了运行于该字典上的安全迭代器的数目. 若该数目不为0, 字典是不会继续进行结点迁移平滑扩容的.\",\"下面是字典的扩容操作中的核心代码, 我们以插入操作引起的扩容为例:\",\"先是插入操作的外部逻辑:\",\"如果插入时, 字典正处于平滑扩容过程中, 那么无论本次插入是否成功, 先迁移一个bucket索引中的结点至新表\",\"在计算新插入结点键的bucket索引值时, 内部会探测哈希表是否需要扩容(若当前不在平滑扩容过程中)\",\"int dictAdd(dict *d, void *key, void *val) { dictEntry *entry = dictAddRaw(d,key,NULL); // 调用dictAddRaw if (!entry) return DICT_ERR; dictSetVal(d, entry, val); return DICT_OK; } dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing) { long index; dictEntry *entry; dictht *ht; if (dictIsRehashing(d)) _dictRehashStep(d); // 若在平滑扩容过程中, 先步进迁移一个bucket索引 /* Get the index of the new element, or -1 if * the element already exists. */ // 在计算键在bucket中的索引值时, 内部会检查是否需要扩容 if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1) return NULL; /* Allocate the memory and store the new entry. * Insert the element in top, with the assumption that in a database * system it is more likely that recently added entries are accessed * more frequently. */ ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0]; entry = zmalloc(sizeof(*entry)); entry->next = ht->table[index]; ht->table[index] = entry; ht->used++; /* Set the hash entry fields. */ dictSetKey(d, entry, key); return entry; } \",\"下面是计算bucket索引值的函数, 内部会探测该哈希表是否需要扩容, 如果需要扩容(结点数目与bucket数组长度比例达到1:1), 就使字典进入平滑扩容过程:\",\"static long _dictKeyIndex(dict *d, const void *key, uint64_t hash, dictEntry **existing) { unsigned long idx, table; dictEntry *he; if (existing) *existing = NULL; /* Expand the hash table if needed */ if (_dictExpandIfNeeded(d) == DICT_ERR) // 探测是否需要扩容, 如果需要, 则开始扩容 return -1; for (table = 0; table <= 1; table++) { idx = hash & d->ht[table].sizemask; /* Search if this slot does not already contain the given key */ he = d->ht[table].table[idx]; while(he) { if (key==he->key || dictCompareKeys(d, key, he->key)) { if (existing) *existing = he; return -1; } he = he->next; } if (!dictIsRehashing(d)) break; } return idx; } /* Expand the hash table if needed */ static int _dictExpandIfNeeded(dict *d) { /* Incremental rehashing already in progress. Return. */ if (dictIsRehashing(d)) return DICT_OK; // 如果正在扩容过程中, 则什么也不做 /* If the hash table is empty expand it to the initial size. */ // 若字典中本无元素, 则初始化字典, 初始化时的bucket数组长度为4 if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE); /* If we reached the 1:1 ratio, and we are allowed to resize the hash * table (global setting) or we should avoid it but the ratio between * elements/buckets is over the \\\"safe\\\" threshold, we resize doubling * the number of buckets. */ // 若字典中元素的个数与bucket数组长度比值大于1:1时, 则调用dictExpand进入平滑扩容状态 if (d->ht[0].used >= d->ht[0].size && (dict_can_resize || d->ht[0].used/d->ht[0].size > dict_force_resize_ratio)) { return dictExpand(d, d->ht[0].used*2); } return DICT_OK; } int dictExpand(dict *d, unsigned long size) { dictht n; /* the new hash table */ // 新建一个dictht结构 unsigned long realsize = _dictNextPower(size); /* the size is invalid if it is smaller than the number of * elements already inside the hash table */ if (dictIsRehashing(d) || d->ht[0].used > size) return DICT_ERR; /* Rehashing to the same table size is not useful. */ if (realsize == d->ht[0].size) return DICT_ERR; /* Allocate the new hash table and initialize all pointers to NULL */ n.size = realsize; n.sizemask = realsize-1; n.table = zcalloc(realsize*sizeof(dictEntry*));// 初始化dictht下的table, 即bucket数组 n.used = 0; /* Is this the first initialization? If so it's not really a rehashing * we just set the first hash table so that it can accept keys. */ // 若是新字典初始化, 直接把dictht结构挂在ht[0]中 if (d->ht[0].table == NULL) { d->ht[0] = n; return DICT_OK; } // 否则, 把新dictht结构挂在ht[1]中, 并开启平滑扩容(置rehashidx为0, 字典处于非扩容状态时, 该字段值为-1) /* Prepare a second hash table for incremental rehashing */ d->ht[1] = n; d->rehashidx = 0; return DICT_OK; } \",\"下面是平滑扩容的实现:\",\"static void _dictRehashStep(dict *d) { // 若字典上还运行着安全迭代器, 则不迁移结点 // 否则每次迁移一个旧bucket索引上的所有结点 if (d->iterators == 0) dictRehash(d,1); } int dictRehash(dict *d, int n) { int empty_visits = n*10; /* Max number of empty buckets to visit. */ if (!dictIsRehashing(d)) return 0; while(n-- && d->ht[0].used != 0) { dictEntry *de, *nextde; /* Note that rehashidx can't overflow as we are sure there are more * elements because ht[0].used != 0 */ assert(d->ht[0].size > (unsigned long)d->rehashidx); // 在旧bucket中, 找到下一个非空的索引位 while(d->ht[0].table[d->rehashidx] == NULL) { d->rehashidx++; if (--empty_visits == 0) return 1; } // 取出该索引位上的结点链表 de = d->ht[0].table[d->rehashidx]; /* Move all the keys in this bucket from the old to the new hash HT */ // 把所有结点迁移到新bucket中去 while(de) { uint64_t h; nextde = de->next; /* Get the index in the new hash table */ h = dictHashKey(d, de->key) & d->ht[1].sizemask; de->next = d->ht[1].table[h]; d->ht[1].table[h] = de; d->ht[0].used--; d->ht[1].used++; de = nextde; } d->ht[0].table[d->rehashidx] = NULL; d->rehashidx++; } /* Check if we already rehashed the whole table... */ // 检查是否旧表中的所有结点都被迁移到了新表 // 如果是, 则置先释放原旧bucket数组, 再置ht[1]为ht[0] // 最后再置rehashidx=-1, 以示字典不处于平滑扩容状态 if (d->ht[0].used == 0) { zfree(d->ht[0].table); d->ht[0] = d->ht[1]; _dictReset(&d->ht[1]); d->rehashidx = -1; return 0; } /* More to rehash... */ return 1; } \",\"总结:\",\"字典的实现很复杂, 主要是实现了平滑扩容逻辑 用户数据均是以指针形式间接由dictEntry结构持有, 故在平滑扩容过程中, 不涉及用户数据的拷贝 有安全迭代器可用, 安全迭代器保证, 在迭代起始时, 字典中的所有结点, 都会被迭代到, 即使在迭代过程中对字典有插入操作 字典内部使用的默认散列函数其实也非常有讲究, 不过限于篇幅, 这里不展开讲. 并且字典的实现给了使用者非常大的灵活性(dictType结构与dict.privdata字段), 对于一些特定场合使用的键数据, 用户可以自行选择更高效更特定化的散列函数\"]},\"297\":{\"h\":\"2.4 zskiplist\",\"t\":[\"zskiplist是Redis实现的一种特殊的跳跃表. 跳跃表是一种基于线性表实现简单的搜索结构, 其最大的特点就是: 实现简单, 性能能逼近各种搜索树结构. 血统纯正的跳跃表的介绍在维基百科中即可查阅. 在Redis中, 在原版跳跃表的基础上, 进行了一些小改动, 即是现在要介绍的zskiplist结构.\",\"其定义在src/server.h中, 如下:\",\"/* ZSETs use a specialized version of Skiplists */ typedef struct zskiplistNode { sds ele; double score; struct zskiplistNode *backward; struct zskiplistLevel { struct zskiplistNode *forward; unsigned int span; } level[]; } zskiplistNode; typedef struct zskiplist { struct zskiplistNode *header, *tail; unsigned long length; int level; } zskiplist; \",\"其内存布局如下图:\",\"zskiplist的核心设计要点为:\",\"头结点不持有任何数据, 且其level[]的长度为32\",\"每个结点, 除了持有数据的ele字段, 还有一个字段score, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.\",\"每个结点持有一个backward指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.\",\"每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段.\",\"forward字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在level[]中的索引为X, 则其forward字段指向的结点, 其level[]字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.\",\"span字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1.\",\"zskiplist中持有字段level, 用以记录所有结点(除过头结点外), level[]数组最长的长度.\",\"跳跃表主要用于, 在给定一个分值的情况下, 查找与该分值最接近的结点. 搜索时, 伪代码如下:\",\"int level = zskiplist->level - 1; zskiplistNode p = zskiplist->head; while(1 && p) { zskiplistNode q = (p->level)[level]->forward: if(q->score > 分值) { if(level > 0) { level--; } else { return : q为整个跳跃表中, 分值大于指定分值的第一个结点 q->backward为整个跳跃表中, 分值小于或等于指定分值的最后一个结点 } } else { p = q; } } \",\"跳跃表的实现比较简单, 最复杂的操作即是插入与删除结点, 需要仔细处理邻近结点的所有level[]中的所有zskiplistLevel结点中的forward与span的值的变更.\",\"另外, 关于新创建的结点, 其level[]数组长度的随机算法, 在接口zslInsert的实现中, 核心代码片断如下:\",\"zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) { //... level = zslRandomLevel(); // 随机生成新结点的, level[]数组的长度 if (level > zsl->level) { // 若生成的新结点的level[]数组的长度比当前表中所有结点的level[]的长度都大 // 那么头结点中需要新增几个指向该结点的指针 // 并刷新ziplist中的level字段 for (i = zsl->level; i < level; i++) { rank[i] = 0; update[i] = zsl->header; update[i]->level[i].span = zsl->length; } zsl->level = level; } x = zslCreateNode(level,score,ele); // 创建新结点 //... 执行插入操作 } // 按幂次定律生成小于32的随机数的函数 // 宏 ZSKIPLIST_MAXLEVEL 的定义为32, 宏 ZSKIPLIST_P 被设定为 0.25 // 即 // level == 1的概率为 75% // level == 2的概率为 75% * 25% // level == 3的概率为 75% * 25% * 25% // ... // level == 31的概率为 0.75 * 0.25^30 // 而 // level == 32的概率为 0.75 * sum(i = 31 ~ +INF){ 0.25^i } int zslRandomLevel(void) { int level = 1; while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF)) level += 1; return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; } \"]},\"298\":{\"h\":\"2.5 intset\",\"t\":[\"这是一个用于存储在序的整数的数据结构, 也底层数据结构中最简单的一个, 其定义与实现在src/intest.h与src/intset.c中, 关键定义如下:\",\"typedef struct intset { uint32_t encoding; uint32_t length; int8_t contents[]; } intset; #define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) \",\"inset结构中的encoding的取值有三个, 分别是宏INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64. length代表其中存储的整数的个数, contents指向实际存储数值的连续内存区域. 其内存布局如下图所示:\",\"intset中各字段, 包括contents中存储的数值, 都是以主机序(小端字节序)存储的. 这意味着Redis若运行在PPC这样的大端字节序的机器上时, 存取数据都会有额外的字节序转换开销\",\"当encoding == INTSET_ENC_INT16时, contents中以int16_t的形式存储着数值. 类似的, 当encoding == INTSET_ENC_INT32时, contents中以int32_t的形式存储着数值.\",\"但凡有一个数值元素的值超过了int32_t的取值范围, 整个intset都要进行升级, 即所有的数值都需要以int64_t的形式存储. 显然升级的开销是很大的.\",\"intset中的数值是以升序排列存储的, 插入与删除的复杂度均为O(n). 查找使用二分法, 复杂度为O(log_2(n))\",\"intset的代码实现中, 不预留空间, 即每一次插入操作都会调用zrealloc接口重新分配内存. 每一次删除也会调用zrealloc接口缩减占用的内存. 省是省了, 但内存操作的时间开销上升了.\",\"intset的编码方式一经升级, 不会再降级.\",\"总之, intset适合于如下数据的存储:\",\"所有数据都位于一个稳定的取值范围中. 比如均位于int16_t或int32_t的取值范围中\",\"数据稳定, 插入删除操作不频繁. 能接受O(lgn)级别的查找开销\"]},\"299\":{\"h\":\"2.6 ziplist\",\"t\":[\"ziplist是Redis底层数据结构中, 最苟的一个结构. 它的设计宗旨就是: 省内存, 从牙缝里省内存. 设计思路和TLV一致, 但为了从牙缝里节省内存, 做了很多额外工作.\",\"ziplist的内存布局与intset一样: 就是一块连续的内存空间. 但区域划分比较复杂, 概览如下图:\",\"和intset一样, ziplist中的所有值都是以小端序存储的\",\"zlbytes字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数\",\"zltail字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作\",\"zllen字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占16位, 所以蛋疼的地方就来了: 如果ziplist中entry的数目小于65535, 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.\",\"zlend是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255\",\"在画图展示entry的内存布局之前, 先讲一下entry中都存储了哪些信息:\",\"每个entry中存储了它前一个entry所占用的字节数. 这样支持ziplist反向遍历.\",\"每个entry用单独的一块区域, 存储着当前结点的类型: 所谓的类型, 包括当前结点存储的数据是什么(二进制, 还是数值), 如何编码(如果是数值, 数值如何存储, 如果是二进制数据, 二进制数据的长度)\",\"最后就是真实的数据了\",\"entry的内存布局如下所示:\",\"prevlen即是\\\"前一个entry所占用的字节数\\\", 它本身是一个变长字段, 规约如下:\",\"若前一个entry占用的字节数小于 254, 则prevlen字段占一字节\",\"若前一个entry占用的字节数等于或大于 254, 则prevlen字段占五字节: 第一个字节值为 254, 即0xfe, 另外四个字节, 以uint32_t存储着值.\",\"encoding字段的规约就复杂了许多\",\"若数据是二进制数据, 且二进制数据长度小于64字节(不包括64), 那么encoding占一字节. 在这一字节中, 高两位值固定为0, 低六位值以无符号整数的形式存储着二进制数据的长度. 即 00xxxxxx, 其中低六位bitxxxxxx是用二进制保存的数据长度.\",\"若数据是二进制数据, 且二进制数据长度大于或等于64字节, 但小于16384(不包括16384)字节, 那么encoding占用两个字节. 在这两个字节16位中, 第一个字节的高两位固定为01, 剩余的14个位, 以小端序无符号整数的形式存储着二进制数据的长度, 即 01xxxxxx, yyyyyyyy, 其中yyyyyyyy是高八位, xxxxxx是低六位.\",\"若数据是二进制数据, 且二进制数据的长度大于或等于16384字节, 但小于2^32-1字节, 则encoding占用五个字节. 第一个字节是固定值10000000, 剩余四个字节, 按小端序uint32_t的形式存储着二进制数据的长度. 这也是ziplist能存储的二进制数据的最大长度, 超过2^32-1字节的二进制数据, ziplist无法存储.\",\"若数据是整数值, 则encoding和data的规约如下: \",\"首先, 所有存储数值的entry, 其encoding都仅占用一个字节. 并且最高两位均是11\",\"若数值取值范围位于[0, 12]中, 则encoding和data挤在同一个字节中. 即为1111 0001~1111 1101, 高四位是固定值, 低四位的值从0001至1101, 分别代表 0 ~ 12这十五个数值\",\"若数值取值范围位于[-128, -1] [13, 127]中, 则encoding == 0b 1111 1110. 数值存储在紧邻的下一个字节, 以int8_t形式编码\",\"若数值取值范围位于[-32768, -129] [128, 32767]中, 则encoding == 0b 1100 0000. 数值存储在紧邻的后两个字节中, 以小端序int16_t形式编码\",\"若数值取值范围位于[-8388608, -32769] [32768, 8388607]中, 则encoding == 0b 1111 0000. 数值存储在紧邻的后三个字节中, 以小端序存储, 占用三个字节.\",\"若数值取值范围位于[-2^31, -8388609] [8388608, 2^31 - 1]中, 则encoding == 0b 1101 0000. 数值存储在紧邻的后四个字节中, 以小端序int32_t形式编码\",\"若数值取值均不在上述范围, 但位于int64_t所能表达的范围内, 则encoding == 0b 1110 0000, 数值存储在紧邻的后八个字节中, 以小端序int64_t形式编码\",\"在大规模数值存储中, ziplist几乎不浪费内存空间, 其苟的程序到达了字节级别, 甚至对于[0, 12]区间的数值, 连data里的那一个字节也要省下来. 显然, ziplist是一种特别节省内存的数据结构, 但它的缺点也十分明显:\",\"和intset一样, ziplist也不预留内存空间, 并且在移除结点后, 也是立即缩容, 这代表每次写操作都会进行内存分配操作.\",\"ziplist最蛋疼的一个问题是: 结点如果扩容, 导致结点占用的内存增长, 并且超过254字节的话, 可能会导致链式反应: 其后一个结点的entry.prevlen需要从一字节扩容至五字节. 最坏情况下, 第一个结点的扩容, 会导致整个ziplist表中的后续所有结点的entry.prevlen字段扩容. 虽然这个内存重分配的操作依然只会发生一次, 但代码中的时间复杂度是o(N)级别, 因为链式扩容只能一步一步的计算. 但这种情况的概率十分的小, 一般情况下链式扩容能连锁反映五六次就很不幸了. 之所以说这是一个蛋疼问题, 是因为, 这样的坏场景下, 其实时间复杂度并不高: 依次计算每个entry新的空间占用, 也就是o(N), 总体占用计算出来后, 只执行一次内存重分配, 与对应的memmove操作, 就可以了. 蛋疼说的是: 代码特别难写, 难读. 下面放一段处理插入结点时处理链式反应的代码片断, 大家自行感受一下:\",\"unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) { size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen; unsigned int prevlensize, prevlen = 0; size_t offset; int nextdiff = 0; unsigned char encoding = 0; long long value = 123456789; /* initialized to avoid warning. Using a value that is easy to see if for some reason we use it uninitialized. */ zlentry tail; /* Find out prevlen for the entry that is inserted. */ if (p[0] != ZIP_END) { ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); } else { unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl); if (ptail[0] != ZIP_END) { prevlen = zipRawEntryLength(ptail); } } /* See if the entry can be encoded */ if (zipTryEncoding(s,slen,&value,&encoding)) { /* 'encoding' is set to the appropriate integer encoding */ reqlen = zipIntSize(encoding); } else { /* 'encoding' is untouched, however zipStoreEntryEncoding will use the * string length to figure out how to encode it. */ reqlen = slen; } /* We need space for both the length of the previous entry and * the length of the payload. */ reqlen += zipStorePrevEntryLength(NULL,prevlen); reqlen += zipStoreEntryEncoding(NULL,encoding,slen); /* When the insert position is not equal to the tail, we need to * make sure that the next entry can hold this entry's length in * its prevlen field. */ int forcelarge = 0; nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0; if (nextdiff == -4 && reqlen < 4) { nextdiff = 0; forcelarge = 1; } /* Store offset because a realloc may change the address of zl. */ offset = p-zl; zl = ziplistResize(zl,curlen+reqlen+nextdiff); p = zl+offset; /* Apply memory move when necessary and update tail offset. */ if (p[0] != ZIP_END) { /* Subtract one because of the ZIP_END bytes */ memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff); /* Encode this entry's raw length in the next entry. */ if (forcelarge) zipStorePrevEntryLengthLarge(p+reqlen,reqlen); else zipStorePrevEntryLength(p+reqlen,reqlen); /* Update offset for tail */ ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen); /* When the tail contains more than one entry, we need to take * \\\"nextdiff\\\" in account as well. Otherwise, a change in the * size of prevlen doesn't have an effect on the *tail* offset. */ zipEntry(p+reqlen, &tail); if (p[reqlen+tail.headersize+tail.len] != ZIP_END) { ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff); } } else { /* This element will be the new tail. */ ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl); } /* When nextdiff != 0, the raw length of the next entry has changed, so * we need to cascade the update throughout the ziplist */ if (nextdiff != 0) { offset = p-zl; zl = __ziplistCascadeUpdate(zl,p+reqlen); p = zl+offset; } /* Write the entry */ p += zipStorePrevEntryLength(p,prevlen); p += zipStoreEntryEncoding(p,encoding,slen); if (ZIP_IS_STR(encoding)) { memcpy(p,s,slen); } else { zipSaveInteger(p,value,encoding); } ZIPLIST_INCR_LENGTH(zl,1); return zl; } unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) { size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize; size_t offset, noffset, extra; unsigned char *np; zlentry cur, next; while (p[0] != ZIP_END) { zipEntry(p, &cur); rawlen = cur.headersize + cur.len; rawlensize = zipStorePrevEntryLength(NULL,rawlen); /* Abort if there is no next entry. */ if (p[rawlen] == ZIP_END) break; zipEntry(p+rawlen, &next); /* Abort when \\\"prevlen\\\" has not changed. */ if (next.prevrawlen == rawlen) break; if (next.prevrawlensize < rawlensize) { /* The \\\"prevlen\\\" field of \\\"next\\\" needs more bytes to hold * the raw length of \\\"cur\\\". */ offset = p-zl; extra = rawlensize-next.prevrawlensize; zl = ziplistResize(zl,curlen+extra); p = zl+offset; /* Current pointer and offset for next element. */ np = p+rawlen; noffset = np-zl; /* Update tail offset when next element is not the tail element. */ if ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) { ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra); } /* Move the tail to the back. */ memmove(np+rawlensize, np+next.prevrawlensize, curlen-noffset-next.prevrawlensize-1); zipStorePrevEntryLength(np,rawlen); /* Advance the cursor */ p += rawlen; curlen += extra; } else { if (next.prevrawlensize > rawlensize) { /* This would result in shrinking, which we want to avoid. * So, set \\\"rawlen\\\" in the available bytes. */ zipStorePrevEntryLengthLarge(p+rawlen,rawlen); } else { zipStorePrevEntryLength(p+rawlen,rawlen); } /* Stop here, as the raw length of \\\"next\\\" has not changed. */ break; } } return zl; } \",\"这种代码的特点就是: 最好由作者去维护, 最好一次性写对. 因为读起来真的费劲, 改起来也很费劲.\"]},\"300\":{\"h\":\"2.7 quicklist\",\"t\":[\"如果说ziplist是整个Redis中为了节省内存, 而写的最苟的数据结构, 那么称quicklist就是在最苟的基础上, 再苟了一层. 这个结构是Redis在3.2版本后新加的, 在3.2版本之前, 我们可以讲, dict是最复杂的底层数据结构, ziplist是最苟的底层数据结构. 在3.2版本之后, 这两个记录被双双刷新了.\",\"这是一种, 以ziplist为结点的, 双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist.\",\"它的定义与实现分别在src/quicklist.h与src/quicklist.c中, 其中关键定义如下:\",\"/* Node, quicklist, and Iterator are the only data structures used currently. */ /* quicklistNode is a 32 byte struct describing a ziplist for a quicklist. * We use bit fields keep the quicklistNode at 32 bytes. * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually < 32k). * encoding: 2 bits, RAW=1, LZF=2. * container: 2 bits, NONE=1, ZIPLIST=2. * recompress: 1 bit, bool, true if node is temporarry decompressed for usage. * attempted_compress: 1 bit, boolean, used for verifying during testing. * extra: 12 bits, free for future use; pads out the remainder of 32 bits */ typedef struct quicklistNode { struct quicklistNode *prev; struct quicklistNode *next; unsigned char *zl; unsigned int sz; /* ziplist size in bytes */ unsigned int count : 16; /* count of items in ziplist */ unsigned int encoding : 2; /* RAW==1 or LZF==2 */ unsigned int container : 2; /* NONE==1 or ZIPLIST==2 */ unsigned int recompress : 1; /* was this node previous compressed? */ unsigned int attempted_compress : 1; /* node can't compress; too small */ unsigned int extra : 10; /* more bits to steal for future usage */ } quicklistNode; /* quicklistLZF is a 4+N byte struct holding 'sz' followed by 'compressed'. * 'sz' is byte length of 'compressed' field. * 'compressed' is LZF data with total (compressed) length 'sz' * NOTE: uncompressed length is stored in quicklistNode->sz. * When quicklistNode->zl is compressed, node->zl points to a quicklistLZF */ typedef struct quicklistLZF { unsigned int sz; /* LZF size in bytes*/ char compressed[]; } quicklistLZF; /* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist. * 'count' is the number of total entries. * 'len' is the number of quicklist nodes. * 'compress' is: -1 if compression disabled, otherwise it's the number * of quicklistNodes to leave uncompressed at ends of quicklist. * 'fill' is the user-requested (or default) fill factor. */ typedef struct quicklist { quicklistNode *head; quicklistNode *tail; unsigned long count; /* total count of all entries in all ziplists */ unsigned long len; /* number of quicklistNodes */ int fill : 16; /* fill factor for individual nodes */ unsigned int compress : 16; /* depth of end nodes not to compress;0=off */ } quicklist; typedef struct quicklistIter { const quicklist *quicklist; quicklistNode *current; unsigned char *zi; long offset; /* offset in current ziplist */ int direction; } quicklistIter; typedef struct quicklistEntry { const quicklist *quicklist; quicklistNode *node; unsigned char *zi; unsigned char *value; long long longval; unsigned int sz; int offset; } quicklistEntry; \",\"这里定义了五个结构体:\",\"quicklistNode, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例\",\"quicklistLZF, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例\",\"quicklist. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.\",\"quicklistIter是一个迭代器\",\"quicklistEntry是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下.\",\"quicklist的内存布局图如下所示:\",\"下面是有关quicklist的更多额外信息:\",\"quicklist.fill的值影响着每个链表结点中, ziplist的长度.\",\"当数值为负数时, 代表以字节数限制单个ziplist的最大长度. 具体为: \",\"-1 不超过4kb\",\"-2 不超过 8kb\",\"-3 不超过 16kb\",\"-4 不超过 32kb\",\"-5 不超过 64kb\",\"当数值为正数时, 代表以entry数目限制单个ziplist的长度. 值即为数目. 由于该字段仅占16位, 所以以entry数目限制ziplist的容量时, 最大值为2^15个\",\"quicklist.compress的值影响着quicklistNode.zl字段指向的是原生的ziplist, 还是经过压缩包装后的quicklistLZF \",\"0 表示不压缩, zl字段直接指向ziplist\",\"1 表示quicklist的链表头尾结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF\",\"2 表示quicklist的链表头两个, 与末两个结点不压缩, 其余结点的zl字段指向的是经过压缩后的quicklistLZF\",\"以此类推, 最大值为2^16\",\"quicklistNode.encoding字段, 以指示本链表结点所持有的ziplist是否经过了压缩. 1代表未压缩, 持有的是原生的ziplist, 2代表压缩过\",\"quicklistNode.container字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2\",\"quicklistNode.recompress字段指示的是当前结点所持有的ziplist是否经过了解压. 如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.\",\"quicklist的具体实现代码篇幅很长, 这里就不贴代码片断了, 从内存布局上也能看出来, 由于每个结点持有的ziplist是有上限长度的, 所以在与操作时要考虑的分支情况比较多. 想想都蛋疼.\",\"quicklist有自己的优点, 也有缺点, 对于使用者来说, 其使用体验类似于线性数据结构, list作为最传统的双链表, 结点通过指针持有数据, 指针字段会耗费大量内存. ziplist解决了耗费内存这个问题. 但引入了新的问题: 每次写操作整个ziplist的内存都需要重分配. quicklist在两者之间做了一个平衡. 并且使用者可以通过自定义quicklist.fill, 根据实际业务情况, 经验主义调参.\"]},\"301\":{\"h\":\"2.8 zipmap\",\"t\":[\"dict作为字典结构, 优点很多, 扩展性强悍, 支持平滑扩容等等, 但对于字典中的键值均为二进制数据, 且长度都很小时, dict的中的一坨指针会浪费不少内存, 因此Redis又实现了一个轻量级的字典, 即为zipmap.\",\"zipmap适合使用的场合是:\",\"键值对量不大, 单个键, 单个值长度小\",\"键值均是二进制数据, 而不是复合结构或复杂结构. dict支持各种嵌套, 字典本身并不持有数据, 而仅持有数据的指针. 但zipmap是直接持有数据的.\",\"zipmap的定义与实现在src/zipmap.h与src/zipmap.c两个文件中, 其定义与实现均未定义任何struct结构体, 因为zipmap的内存布局就是一块连续的内存空间. 其内存布局如下所示:\",\"zipmap起始的第一个字节存储的是zipmap中键值对的个数. 如果键值对的个数大于254的话, 那么这个字节的值就是固定值254, 真实的键值对个数需要遍历才能获得.\",\"zipmap的最后一个字节是固定值0xFF\",\"zipmap中的每一个键值对, 称为一个entry, 其内存占用如上图, 分别六部分: \",\"len_of_key, 一字节或五字节. 存储的是键的二进制长度. 如果长度小于254, 则用1字节存储, 否则用五个字节存储, 第一个字节的值固定为0xFE, 后四个字节以小端序uint32_t类型存储着键的二进制长度.\",\"key_data为键的数据\",\"len_of_val, 一字节或五字节, 存储的是值的二进制长度. 编码方式同len_of_key\",\"len_of_free, 固定值1字节, 存储的是entry中未使用的空间的字节数. 未使用的空间即为图中的free, 它一般是由于键值对中的值被替换发生的. 比如, 键值对hello <-> word被修改为hello <-> w后, 就空了四个字节的闲置空间\",\"val_data, 为值的数据\",\"free, 为闲置空间. 由于len_of_free的值最大只能是254, 所以如果值的变更导致闲置空间大于254的话, zipmap就会回收内存空间.\"]},\"302\":{\"c\":[\"redis\"]},\"303\":{\"c\":[\"redis\",\"面试\",\"面试总结\"]},\"304\":{\"h\":\"Redis主从复制原理\",\"t\":[\"相信很多小伙伴都已经配置过主从复制，但是对于redis主从复制的工作流程和常见问题很多都没有深入的了解。咔咔这次用时俩天时间给大家整理一份redis主从复制的全部知识点。本文实现所需环境 centos7.0 redis4.0\"]},\"305\":{\"h\":\"一、什么是Redis主从复制？\",\"t\":[\"主从复制就是现在有俩台redis服务器，把一台redis的数据同步到另一台redis数据库上。前者称之为主节点（master），后者为从节点（slave）。数据是只能master往slave同步单向。\",\"但是在实际过程中是不可能只有俩台redis服务器来做主从复制的，这也就意味这每台redis服务器都有可能会称为主节点（master）\",\"下图案例中，我们的slave3既是master的从节点，也是slave的主节点。\",\"先知道这么个概念，更多详解继续查看下文。\"]},\"306\":{\"h\":\"二、为什么需要Redis主从复制？\",\"t\":[\"假设我们现在就一台redis服务器，也就是单机状态。\",\"在这种情况下会出现的第一个问题就是服务器宕机，直接导致数据丢失。如果项目是跟￥占关系的，那造成的后果就可想而知。\",\"第二个情况就是内存问题了，当只有一台服务器时内存肯定会到达峰值的，不可能对一台服务器进行无限升级的。\",\"所以针对以上俩个问题，我们就多准备几台服务器，配置主从复制。将数据保存在多个服务器上。并且保证每个服务器的数据是同步的。即使有一个服务器宕机了，也不会影响用户的使用。redis可以继续实现高可用、同时实现数据的冗余备份。\",\"这会应该会有很多疑问，master跟slave怎么连接呢？ 如何同步数据呢？ 假如master服务器宕机了呢？别着急，一点一点解决你的问题。\"]},\"307\":{\"h\":\"三、Redis主从复制的作用\",\"t\":[\"在上边我们说了为什么使用redis的主从复制，那么主从复制的作用就是针对为什么使用它来讲了。\",\"我们继续使用这个图来谈论\",\"第一点是数据冗余了，实现了数据的热备份，是持久化之外的另一种方式。\",\"第二点是针对单机故障问题。当主节点也就是master出现问题时，可以由从节点来提供服务也就是slave，实现了快速恢复故障，也就是服务冗余。\",\"第三点是读写分离，master服务器主要是写，slave主要用来读数据，可以提高服务器的负载能力。同时可以根据需求的变化，添加从节点的数量。\",\"第四点是负载均衡，配合读写分离，有主节点提供写服务，从节点提供读服务，分担服务器负载，尤其在写少读多的情况下，通过多个从节点分担读负载，可以大大提高redis服务器的并发量和负载。\",\"第五点是高可用的基石，主从复制是哨兵和集群能够实施的基础，因此我们可以说主从复制是高可用的基石。\"]},\"308\":{\"h\":\"四、配置Redis主从复制\",\"t\":[\"说了这么多，我们先简单的配置一个主从复制案例，然后在谈实现的原理。\",\"redis存储路径为：usr/local/redis\",\"日志跟配置文件存储在：usr/local/redis/data\",\"首先我们先配置俩个配置文件，分别为redis6379.conf 和 redis6380.conf\",\"修改配置文件，主要就是修改端口。为了查看方便在把日志文件和持久化文件的名字都用各自的端口来做标识。\",\"然后分别开启俩个redis服务，一个端口为6379，一个端口为6380。执行命令redis-server redis6380.conf,然后使用redis-cli -p 6380连接，因为redis的默认端口就是6379所以我们启动另外一台redis服务器直接使用redis-server redis6379.conf 然后直接使用redis-cli直接连接就可以。\",\"这个时候我们就成功的配置了俩个redis服务，一台为6380，一台为6379，这里只是为了演示。实际工作中是需要配置在俩台不同的服务器的。\"]},\"309\":{\"h\":\"1. 使用客户端命令行启动\",\"t\":[\"我们先得有一个概念，就是在配置主从复制时，所有的操作都是在从节点来操作，也就是slave。\",\"那么我们在从节点执行一个命令为 slaveof 127.0.0.1 6379，执行完就代表我们连接上了。\",\"我们先测试一下看是否实现主从复制。在master这台服务器上执行俩个set kaka 123 和 set master 127.0.0.1，然后在slave6380端口是可以成功获取到的，也就说明我们的主从复制就已经配置完成了。但是在实现生产环境可不是就这样完事了，后边会在进一步对主从复制进行优化，直到实现高可用。\"]},\"310\":{\"h\":\"2. 使用配置文件启用\",\"t\":[\"在使用配置文件启动主从复制之前呢！先需要把之前使用客户端命令行连接的断开，在从主机执行slaveof no one即可断开主从复制。\",\"在哪可以查看从节点已经断开了主节点呢！在主节点的客户端输入命令行info查看\",\"这张图是使用从节点使用客户端命令行连接主节点后，在主节点的客户端输入info打印的信息，可以看到有一个slave0的一个信息。\",\"这个图是在从节点执行完slaveof no one 后，在主节点打印的info，说明从节点已经跟主节点断开连接了。\",\"在根据配置文件启动redis服务，redis-server redis6380.conf\",\"当在从节点重新启动后就可以在主节点直接查看到从节点的连接信息。\",\"测试数据，主节点写的东西，从节点还是会自动同步的。\"]},\"311\":{\"h\":\"3. 启动redis服务器时启动\",\"t\":[\"这种方式配置也是很简单，在启动redis服务器时直接就启动主从复制，执行命令：redis-server --slaveof host port 即可。\"]},\"312\":{\"h\":\"4. 主从复制启动后的日志信息查看\",\"t\":[\"这个是主节点的日志信息\",\"这个是从节点的信息，其中有连接主节点信息，还有RDB快照保存。\"]},\"313\":{\"h\":\"五、主从复制工作原理\"},\"314\":{\"h\":\"1. 主从复制的三个阶段\",\"t\":[\"主从复制完整的工作流程分为以下三个阶段。每一段都有自己的内部工作流程，那么我们会对这三个过程进行谈论。\",\"建立连接过程：这个过程就是slave跟master连接的过程\",\"数据同步过程：是master给slave同步数据的过程\",\"命令传播过程：是反复同步数据\"]},\"315\":{\"h\":\"2. 第一阶段：建立连接过程\",\"t\":[\"上图是一个完整主从复制建立连接工作流程。然后使用简短的话语来描述上边的工作流程。\",\"设置master的地址和端口，保存master的信息\",\"建立socket连接（这个连接做的事情下文会说）\",\"持续发送ping命令\",\"身份验证\",\"发送slave端口信息\",\"在建立连接的过程中，从节点会保存master的地址和端口、主节点master保存从节点slave的端口。\"]},\"316\":{\"h\":\"3. 第二阶段：数据同步阶段过程\",\"t\":[\"这张图是详细描述第一次从节点连接主节点时的数据同步过程。 当从节点第一次连接主节点时，先会执行一次全量复制这次的全量复制是无法避免的。 全量复制执行完成后，主节点就会发送复制积压缓冲区的数据，然后从节点就会执行bgrewriteaof恢复数据，这也就是部分复制。 在这个阶段提到了三个新点，全量复制、部分复制、复制缓冲积压区。会在下文的常见问题里详细说明这几个点。\"]},\"317\":{\"h\":\"4. 第三阶段：命令传播阶段\",\"t\":[\"当master数据库被修改后，主从服务器的数据不一致后，此时就会让主从数据同步到一致，这个过程称之为命令传播。 master会将接收到的数据变更命令发送给slave，slave接收命令后执行命令，让主从数据达到一致。 命令传播阶段的部分复制\",\"在命令传播阶段出现断网的情况，或者网络抖动时会导致连接断开（connection lost）\",\"这个时候主节点master还是会继续往replbackbuffer（复制缓冲积压区）写数据\",\"从节点会继续尝试连接主机（connect to master）\",\"当从节点把自己的runid和复制偏移量发送给主节点，并且执行pysnc命令同步\",\"如果master判断偏移量是在复制缓冲区范围内，就会返回continue命令。并且发送复制缓冲区的数据给从节点。\",\"从节点接收数据执行bgrewriteaof，恢复数据\"]},\"318\":{\"h\":\"六. 详细介绍主从复制原理（全量复制+部分复制）\",\"t\":[\"这个过程就是主从复制最齐全的流程讲解。那么下来我们对每一步进程简单的介绍\",\"从节点发送指令psync ? 1 psync runid offset 找对应的runid索取数据。但是这里可以考虑一下，当从节点第一次连接的时候根本就不知道主节点的runid 和 offset 。所以第一次发送的指令是psync ？ 1意思就是主节点的数据我全要。\",\"主节点开始执行bgsave生成RDB文件，记录当前的复制偏移量offset\",\"主节点这个时候会把自己的runid 和 offset 通过 +FULLRESYNC runid offset 指令 通过socket发送RDB文件给从节点。\",\"从节点接收到+FULLRESYNC 保存主节点的runid和offset 然后清空当前所有数据，通过socket接收RDB文件，开始恢复RDB数据。\",\"在全量复制后，从节点已经获取到了主节点的runid和offset，开始发送指令 psync runid offset\",\"主节点接收指令，判断runid是否匹配，判断offset是否在复制缓冲区中。\",\"主节点判断runid和offset有一个不满足，就会在返回到步骤2继续执行全量复制。这里的runid不匹配只有的可能是从节点重启了这个问题后边会解决，offset（偏移量）不匹配就是复制积压缓冲区溢出了。 如果runid或offset校验通过，从节点的offset和主节点的offset相同时则忽略。 如果runid或offset检验通过，从节点的offset与offset不相同，则会发送 +CONTINUE offset(这个offset为主节点的)，通过socket发送复制缓冲区中从节点offset到主节点offset的数据。\",\"从节点收到+CONTINUE 保存master的offset 通过socket接收到信息后，执行bgrewriteaof，恢复数据。\",\"1-4是全量复制 5-8是部分复制\",\"在主节点的第3步下面 主节点在主从复制的期间是一直在接收客户端的数据，主节点的offset是一直变化的。只有有变化就会给每个slave进行发送，这个发送的过程称之为心跳机制\"]},\"319\":{\"h\":\"七. 心跳机制\",\"t\":[\"在命令传播阶段是，主节点与从节点之间一直都需要进行信息互换，使用心跳机制进行维护，实现主节点和从节点连接保持在线。\",\"master心跳 \",\"指令：ping\",\"默认10秒进行一次，是由参数repl-ping-slave-period决定的\",\"主要做的事情就是判断从节点是否在线\",\"可以使用info replication 来查看从节点租后一次连接时间的间隔，lag为0或者为1就是正常状态。\",\"slave心跳任务 \",\"指令：replconf ack\",\"每秒执行一次\",\"主要做的事情是给主节点发送自己的复制偏移量，从主节点获取到最新的数据变更命令，还做一件事情就是判断主节点是否在线。\",\"心跳阶段的注意事项 主节点为保障数据稳定性，当从节点挂掉的数量或者延迟过高时。将会拒绝所有信息同步。\",\"这里有俩个参数可以进行配置调整：\",\"min-slaves-to-write 2 min-slaves-max-lag 8 \",\"这俩个参数表示从节点的数量就剩余2个，或者从节点的延迟大于8秒时，主节点就会强制关闭maste功能，停止数据同步。\",\"那么主节点是如何知道从节点挂掉的数量和延迟时间呢！ 在心跳机制里边slave 会每隔一秒发送perlconf ack 这个指令，这个指令可携带偏移量，也可以携带从节点的延迟时间和从节点的数量。\"]},\"320\":{\"h\":\"八、部分复制的三个核心要素\"},\"321\":{\"h\":\"1. 服务器的运行id （run id）\",\"t\":[\"我们先看一下这个run id是什么，执行info命令即可看到。在上文中我们查看启动日志信息也可以看到。\",\"redis在启动时会自动生成一个随机的id（这里需要注意的是每次启动的id都会不一样），是由40个随机的十六进制字符串组成，用来唯一识别一个redis节点。 在主从复制初次启动时，master会把自己的runid发送给slave，slave会保存master的这个id，我们可以使用info命令查看\",\"当断线重连时，slave把这个id发送给master，如果slave保存的runid与master现在的runid相同，master会尝试使用部分复制（这块能否复制成功还有一个因素就是偏移量）。如果slave保存的runid与master现在的runid不同，则会直接进行全量复制。\"]},\"322\":{\"h\":\"2. 复制积压缓冲区\",\"t\":[\"复制缓冲积压区是一个先进先出的队列，用户存储master收集数据的命令记录。复制缓冲区的默认存储空间是1M。 可以在配置文件修改repl-backlog-size 1mb来控制缓冲区大小，这个比例可以根据自己的服务器内存来修改，咔咔这边是预留出了30%左右。\",\"复制缓冲区到底存储的是什么？\",\"当执行一个命令为set name kaka时，我们可以查看持久化文件查看\",\"那么复制积压缓冲区就是存储的aof持久化的数据，并且以字节分开，并且每个字节都有自己的偏移量。这个偏移量也就是复制偏移量（offset）\",\"那为什么会说复制缓冲积压区有可能会导致全量复制呢 在命令传播阶段，主节点会把收集的数据存储到复制缓冲区中，然后在发送给从节点。就是这里出现了问题，当主节点数据量在一瞬间特别大的时候，超出了复制缓冲区的内存，就会有一部分数据会被挤出去，从而导致主节点和从节点的数据不一致。从而进行全量复制。如果这个缓冲区大小设置不合理那么很大可能会造成死循环，从节点就会一直全量复制，清空数据，全量复制。\"]},\"323\":{\"h\":\"3. 复制偏移量（offset）\",\"t\":[\"主节点复制偏移量是给从节点发送一次记录一次，从节点是接收一次记录一次。 用于同步信息，对比主节点和从节点的差异，当slave断联时恢复数据使用。 这个值也就是来自己于复制缓冲积压区里边的那个偏移量。\"]},\"324\":{\"h\":\"九. 主从复制常见的问题\"},\"325\":{\"h\":\"1. 主节点重启问题（内部优化）\",\"t\":[\"当主节点重启后，runid的值将发生变化，会导致所有的从节点进行全量复制。\",\"这个问题我们无需考虑，知道系统是怎么优化的即可。\",\"在建立完主从复制后主节点会创建master-replid变量，这个生成的策略跟runid一样，长度是41位，runid长度是40位，然后发送给从节点。\",\"在主节点执行shutdown save命令时，进行了一次RDB持久化会把runid 和 offset保存到RDB文件中。可以使用命令redis-check-rdb查看该信息。\",\"主节点重启后加载RDB文件，将文件中的repl-id 和repl-offset加载到内存中。纵使让所有从节点认为还是之前的主节点。\"]},\"326\":{\"h\":\"2. 从节点网络中断偏移量越界导致全量复制\",\"t\":[\"由于网络环境不佳，从节点网络中断。复制积压缓冲区内存过小导致数据溢出，伴随着从节点偏移量越界，导致全量复制。有可能会导致反复的全量复制。 解决方案：修改复制积压缓冲区的大小：repl-backlog-size 设置建议：测试主节点连接从节点的时间，获取主节点每秒平均产生的命令总量write_size_per_second 复制缓冲区空间设置 = 2 * 主从连接时间 * 主节点每秒产生的数据总量\"]},\"327\":{\"h\":\"3. 频繁的网路中断\",\"t\":[\"由于主节点的cpu占用过高，或者从节点频繁连接。出现这种情况造成的结果就是主节点各种资源被严重占用，其中包括但不限于缓冲区，宽带，连接等。 为什么会出现主节点资源被严重占用？ 在心跳机制中，从节点每秒会发送一个指令replconf ack指令到主节点。 从节点执行了慢查询，占用大量的cpu 主节点每秒调用复制定时函数replicationCron，然后从节点长时间没有相应。\",\"解决方案：\",\"设置从节点超时释放\",\"设置参数：repl-timeout\",\"这个参数默认为60秒。超过60秒，释放slave。\"]},\"328\":{\"h\":\"4. 数据不一致问题\",\"t\":[\"由于网络因素，多个从节点的数据会不一致。这个因素是没有办法避免的。\",\"关于这个问题给出俩个解决方案：\",\"第一个数据需要高度一致配置一台redis服务器，读写都用一台服务器，这种方式仅限于少量数据，并且数据需高度一直。\",\"第二个监控主从节点的偏移量，如果从节点的延迟过大，暂时屏蔽客户端对该从节点的访问。设置参数为slave-serve-stale-data yes|no。 这个参数一但设置就只能响应info slaveof等少数命令。\",\"5. 从节点故障\",\"这个问题直接在客户端维护一个可用节点列表，当从节点故障时，切换到其他节点进行工作，这个问题在后边集群会说到。\"]},\"329\":{\"h\":\"十. 总结\",\"t\":[\"本文主要讲解了什么是主从复制、主从复制工作的三大阶段以及工作流程、部分复制的三大核心。命令传播阶段的心跳机制。最后说明了主从复制常见问题。\",\"作者：原来是咔咔\\n链接：https://juejin.im/post/5ed5ccb66fb9a047df7ca9a4\\n来源：掘金\\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\"]},\"330\":{\"c\":[\"redis\"]},\"331\":{\"c\":[\"redis\",\"面试\",\"面试总结\"]},\"332\":{\"h\":\"Redis内存分析\"},\"333\":{\"h\":\"背景\",\"t\":[\"想知道自己 Redis 实例中数据的内存分布情况。为了不影响线上实例的使用，我们一般会采用 bgsave 生成 dump.rdb 文件，再结合 redis-rdb-tools 和 sqlite 来进行静态分析。总的来说，整个分析的过程简单而实用，是每一个 Redis 的用户都非常值得掌握的一个方法。\"]},\"334\":{\"h\":\"创建备份\",\"t\":[\"自建 Redis 可在客户端执行 bgsave 生成 rdb 文件。云数据库 Redis 版可以在控制台上可以进行数据备份和下载的操作，下载后的数据为 rdb 格式文件。\"]},\"335\":{\"h\":\"生成内存快照\",\"t\":[\"redis-rdb-tools 是一个 python 的解析 rdb 文件的工具，在分析内存的时候，我们主要用它生成内存快照。主要有以下三个功能：\",\"生成内存快照\",\"转储成 json 格式\",\"使用标准的 diff 工具比较两个 dump 文件\"]},\"336\":{\"h\":\"redis-rdb-tools 安装\",\"t\":[\"redis-rdb-tools 有两种安装方式，任选其一即可。\"]},\"337\":{\"h\":\"使用 PYPI 安装\",\"t\":[\"pip install rdbtools \"]},\"338\":{\"h\":\"从源码安装\",\"t\":[\"git clone https://github.com/sripathikrishnan/redis-rdb-tools cd redis-rdb-tools sudo python setup.py install \"]},\"339\":{\"h\":\"使用 redis-rdb-tools 生成内存快照\",\"t\":[\"生成内存快照的命令为：\",\"rdb -c memory dump.rdb > memory.csv \",\"生成 CSV 格式的内存报告。包含的列有：数据库 ID，数据类型，key，内存使用量(byte)，编码。内存使用量包含 key、value 和其他值。\",\"注意：内存使用量是理论上的近似值，在一般情况下，略低于实际值。memory.csv 例子：\",\"$head memory.csv database,type,key,size_in_bytes,encoding,num_elements,len_largest_element 0,string,\\\"orderAt:377671748\\\",96,string,8,8 0,string,\\\"orderAt:413052773\\\",96,string,8,8 0,sortedset,\\\"Artical:Comments:7386\\\",81740,skiplist,479,41 0,sortedset,\\\"pay:id:18029\\\",2443,ziplist,84,16 0,string,\\\"orderAt:452389458\\\",96,string,8,8 \"]},\"340\":{\"h\":\"分析内存快照\",\"t\":[\"SQLite 是一款轻型的数据库。我们可以将前面生成的 csv 导入到数据库中之后，就可以利用 sql 语句很方便的对 Redis 的内存数据进行各种分析了。\",\"注意：SQLite版本必须是3.16.0以上。\"]},\"341\":{\"h\":\"导入方法\",\"t\":[\"sqlite3 memory.db sqlite> create table memory(database int,type varchar(128),key varchar(128),size_in_bytes int,encoding varchar(128),num_elements int,len_largest_element varchar(128)); sqlite>.mode csv memory sqlite>.import memory.csv memory \",\"数据导入以后，接下来想怎么分析就怎么分析了，举几个简单的例子：\",\"查询key个数\",\"sqlite>select count(*) from memory; \",\"查询总的内存占用\",\"sqlite>select sum(size_in_bytes) from memory; \",\"查询内存占用最高的10个 key\",\"sqlite>select * from memory order by size_in_bytes desc limit 10; \",\"查询成员个数1000个以上的 list\",\"sqlite>select * from memory where type='list' and num_elements > 1000; \"]},\"342\":{\"h\":\"总结\",\"t\":[\"通过使用 redis-rdb-tools + sqlite 的方式，可以方便的对 redis 实例的内存情况进行静态的分析。整个过程也比较简单，获取到 rdb 之后即可。\",\"rdb -c memory dump.rdb > memory.csv; sqlite3 memory.db sqlite> create table memory(database int,type varchar(128),key varchar(128),size_in_bytes int,encoding varchar(128),num_elements int,len_largest_element varchar(128)); sqlite>.mode csv memory sqlite>.import memory.csv memory \",\"一个 List 积攒了10多 GB 的内容，43 MB 以上的 string 类型的 value， 往往不仅能解答问题，而且能够帮助用户排除业务中潜在的风险点，找到业务性能瓶颈。\"]},\"343\":{\"c\":[\"redis\"]},\"344\":{\"c\":[\"redis\",\"源码\",\"面试\",\"面试总结\"]},\"345\":{\"h\":\"Redis中内存淘汰算法实现\",\"t\":[\"Redis的maxmemory支持的内存淘汰机制使得其成为一种有效的缓存方案，成为memcached的有效替代方案。\",\"当内存达到maxmemory后，Redis会按照maxmemory-policy启动淘汰策略。\",\"Redis 3.0中已有淘汰机制：\",\"noeviction\",\"allkeys-lru\",\"volatile-lru\",\"allkeys-random\",\"volatile-random\",\"volatile-ttl\",\"maxmemory-policy\",\"含义\",\"特性\",\"noeviction\",\"不淘汰\",\"内存超限后写命令会返回错误(如OOM, del命令除外)\",\"allkeys-lru\",\"所有key的LRU机制 在\",\"所有key中按照最近最少使用LRU原则剔除key，释放空间\",\"volatile-lru\",\"易失key的LRU\",\"仅以设置过期时间key范围内的LRU(如均为设置过期时间，则不会淘汰)\",\"allkeys-random\",\"所有key随机淘汰\",\"一视同仁，随机\",\"volatile-random\",\"易失Key的随机\",\"仅设置过期时间key范围内的随机\",\"volatile-ttl\",\"易失key的TTL淘汰\",\"按最小TTL的key优先淘汰\",\"其中LRU(less recently used)经典淘汰算法在Redis实现中有一定优化设计，来保证内存占用与实际效果的平衡，这也体现了工程应用是空间与时间的平衡性。\",\"PS：值得注意的，在主从复制模式Replication下，从节点达到maxmemory时不会有任何异常日志信息，但现象为增量数据无法同步至从节点。\"]},\"346\":{\"h\":\"Redis 3.0中近似LRU算法\",\"t\":[\"Redis中LRU是近似LRU实现，并不能取出理想LRU理论中最佳淘汰Key，而是通过从小部分采样后的样本中淘汰局部LRU键。\",\"Redis 3.0中近似LRU算法通过增加待淘汰元素池的方式进一步优化，最终实现与精确LRU非常接近的表现。\",\"精确LRU会占用较大内存记录历史状态，而近似LRU则用较小内存支出实现近似效果。\",\"以下是理论LRU和近似LRU的效果对比：\",\"按时间顺序接入不同键，此时最早写入也就是最佳淘汰键\",\"浅灰色区域：被淘汰的键\",\"灰色区域：未被淘汰的键\",\"绿色区域：新增写入的键\",\"总结图中展示规律，\",\"图1Theoretical LRU符合预期：最早写入键逐步被淘汰\",\"图2Approx LRU Redis 3.0 10 samples：Redis 3.0中近似LRU算法(采样值为10)\",\"图3Approx LRU Redis 2.8 5 samples：Redis 2.8中近似LRU算法(采样值为5)\",\"图4Approx LRU Redis 3.0 5 samples：Redis 3.0中近似LRU算法(采样值为5)\",\"结论：\",\"通过图4和图3对比：得出相同采样值下，3.0比2.8的LRU淘汰机制更接近理论LRU\",\"通过图4和图2对比：得出增加采样值，在3.0中将进一步改善LRU淘汰效果逼近理论LRU\",\"对比图2和图1：在3.0中采样值为10时，效果非常接近理论LRU\",\"采样值设置通过maxmemory-samples指定，可通过CONFIG SET maxmemory-samples \",\"源码解析\",\"int freeMemoryIfNeeded(void){ while (mem_freed < mem_tofree) { if (server.maxmemory_policy == REDIS_MAXMEMORY_NO_EVICTION) return REDIS_ERR; /* We need to free memory, but policy forbids. */ if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU || server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM) {......} /* volatile-random and allkeys-random policy */ if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM || server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_RANDOM) {......} /* volatile-lru and allkeys-lru policy */ else if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU || server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU) { // 淘汰池函数 evictionPoolPopulate(dict, db->dict, db->eviction_pool); while(bestkey == NULL) { evictionPoolPopulate(dict, db->dict, db->eviction_pool); // 从后向前逐一淘汰 for (k = REDIS_EVICTION_POOL_SIZE-1; k >= 0; k--) { if (pool[k].key == NULL) continue; de = dictFind(dict,pool[k].key); // 定位目标 /* Remove the entry from the pool. */ sdsfree(pool[k].key); /* Shift all elements on its right to left. */ memmove(pool+k,pool+k+1, sizeof(pool[0])*(REDIS_EVICTION_POOL_SIZE-k-1)); /* Clear the element on the right which is empty * since we shifted one position to the left. */ pool[REDIS_EVICTION_POOL_SIZE-1].key = NULL; pool[REDIS_EVICTION_POOL_SIZE-1].idle = 0; /* If the key exists, is our pick. Otherwise it is * a ghost and we need to try the next element. */ if (de) { bestkey = dictGetKey(de); // 确定删除键 break; } else { /* Ghost... */ continue; } } } } /* volatile-ttl */ else if (server.maxmemory_policy == EDIS_MAXMEMORY_VOLATILE_TTL) {......} // 最终选定待删除键bestkey if (bestkey) { long long delta; robj *keyobj = createStringObject(bestkey,sdslenbestkey)); // 目标对象 propagateExpire(db,keyobj); latencyStartMonitor(eviction_latency); // 延迟监控开始 dbDelete(db,keyobj); // 从db删除对象 latencyEndMonitor(eviction_latency);// 延迟监控结束 latencyAddSampleIfNeeded(\\\"eviction-del\\\",iction_latency); // 延迟采样 latencyRemoveNestedEvent(latency,eviction_latency); delta -= (long long) zmalloc_used_memory(); mem_freed += delta; // 释放内存计数 server.stat_evictedkeys++; // 淘汰key计数，info中可见 notifyKeyspaceEvent(REDIS_NOTIFY_EVICTED, \\\"evicted\\\", keyobj, db->id); // 事件通知 decrRefCount(keyobj); // 引用计数更新 keys_freed++; // 避免删除较多键导致的主从延迟，在循环内同步 if (slaves) flushSlavesOutputBuffers(); } } } \"]},\"347\":{\"h\":\"Redis 4.0中新的LFU算法\",\"t\":[\"从Redis4.0开始，新增LFU淘汰机制，提供更好缓存命中率。LFU(Least Frequently Used)通过记录键使用频率来定位最可能淘汰的键。\",\"对比LRU与LFU的差别：\",\"在LRU中，某个键很少被访问，但在刚刚被访问后其被淘汰概率很低，从而出现这类异常持续存在的缓存；相对的，其他可能被访问的键会被淘汰\",\"而LFU中，按访问频次淘汰最少被访问的键\",\"Redis 4.0中新增两种LFU淘汰机制：\",\"volatile-lfu：设置过期时间的键按LFU淘汰\",\"allkeys-lfu：所有键按LFU淘汰\",\"LFU使用Morris counters计数器占用少量位数来评估每个对象的访问频率，并随时间更新计数器。此机制实现与近似LRU中采样类似。但与LRU不同，LFU提供明确参数来指定计数更新频率。\",\"lfu-log-factor：0-255之间，饱和因子，值越小代表饱和速度越快\",\"lfu-decay-time：衰减周期，单位分钟，计数器衰减的分钟数\",\"这两个因子形成一种平衡，通过少量访问 VS 多次访问 的评价标准最终形成对键重要性的评判。\",\"原文： http://fivezh.github.io/2019/01/10/Redis-LRU-algorithm/\"]},\"348\":{\"c\":[\"redis\"]},\"349\":{\"c\":[\"redis\",\"面试\",\"面试总结\"]},\"350\":{\"h\":\"Redis持久化的原理及优化\",\"t\":[\"Redis为持久化提供了两种方式：\",\"RDB：在指定的时间间隔能对你的数据进行快照存储。\",\"AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。\",\"本文将通过下面内容的介绍，希望能够让大家更全面、清晰的认识这两种持久化方式，同时理解这种保存数据的思路，应用于自己的系统设计中。\",\"持久化的配置\",\"RDB与AOF持久化的工作原理\",\"如何从持久化中恢复数据\",\"关于性能与实践建议\"]},\"351\":{\"h\":\"持久化的配置\",\"t\":[\"为了使用持久化的功能，我们需要先知道该如何开启持久化的功能。\"]},\"352\":{\"h\":\"RDB的持久化配置\",\"t\":[\"# 时间策略 save 900 1 save 300 10 save 60 10000 # 文件名称 dbfilename dump.rdb # 文件保存路径 dir /home/work/app/redis/data/ # 如果持久化出错，主进程是否停止写入 stop-writes-on-bgsave-error yes # 是否压缩 rdbcompression yes # 导入时是否检查 rdbchecksum yes \",\"配置其实非常简单，这里说一下持久化的时间策略具体是什么意思。\",\"save 900 1 表示900s内如果有1条是写入命令，就触发产生一次快照，可以理解为就进行一次备份\",\"save 300 10 表示300s内有10条写入，就产生快照\",\"下面的类似，那么为什么需要配置这么多条规则呢？因为Redis每个时段的读写请求肯定不是均衡的，为了平衡性能与数据安全，我们可以自由定制什么情况下触发备份。所以这里就是根据自身Redis写入情况来进行合理配置。\",\"stop-writes-on-bgsave-error yes 这个配置也是非常重要的一项配置，这是当备份进程出错时，主进程就停止接受新的写入操作，是为了保护持久化的数据一致性问题。如果自己的业务有完善的监控系统，可以禁止此项配置， 否则请开启。\",\"关于压缩的配置 rdbcompression yes ，建议没有必要开启，毕竟Redis本身就属于CPU密集型服务器，再开启压缩会带来更多的CPU消耗，相比硬盘成本，CPU更值钱。\",\"当然如果你想要禁用RDB配置，也是非常容易的，只需要在save的最后一行写上：save \\\"\\\"\"]},\"353\":{\"h\":\"AOF的配置\",\"t\":[\" # 是否开启aof appendonly yes # 文件名称 appendfilename \\\"appendonly.aof\\\" # 同步方式 appendfsync everysec # aof重写期间是否同步 no-appendfsync-on-rewrite no # 重写触发配置 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb # 加载aof时如果有错如何处理 aof-load-truncated yes # 文件重写策略 aof-rewrite-incremental-fsync yes \",\"复制代码还是重点解释一些关键的配置：\",\"appendfsync everysec 它其实有三种模式:\",\"always：把每个写命令都立即同步到aof，很慢，但是很安全\",\"everysec：每秒同步一次，是折中方案\",\"no：redis不处理交给OS来处理，非常快，但是也最不安全\",\"一般情况下都采用 everysec 配置，这样可以兼顾速度与安全，最多损失1s的数据。\",\"aof-load-truncated yes 如果该配置启用，在加载时发现aof尾部不正确是，会向客户端写入一个log，但是会继续执行，如果设置为 no ，发现错误就会停止，必须修复后才能重新加载。\"]},\"354\":{\"h\":\"工作原理\",\"t\":[\"关于原理部分，我们主要来看RDB与AOF是如何完成持久化的，他们的过程是如何。\",\"在介绍原理之前先说下Redis内部的定时任务机制，定时任务执行的频率可以在配置文件中通过 hz 10 来设置（这个配置表示1s内执行10次，也就是每100ms触发一次定时任务）。该值最大能够设置为：500，但是不建议超过：100，因为值越大说明执行频率越频繁越高，这会带来CPU的更多消耗，从而影响主进程读写性能。\",\"定时任务使用的是Redis自己实现的 TimeEvent，它会定时去调用一些命令完成定时任务，这些任务可能会阻塞主进程导致Redis性能下降。因此我们在配置Redis时，一定要整体考虑一些会触发定时任务的配置，根据实际情况进行调整。\"]},\"355\":{\"h\":\"RDB的原理\",\"t\":[\"在Redis中RDB持久化的触发分为两种：自己手动触发与Redis定时触发。\",\"针对RDB方式的持久化，手动触发可以使用：\",\"save：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。\",\"bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。\",\"而自动触发的场景主要是有以下几点：\",\"根据我们的 save m n 配置规则自动触发；\",\"从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 bgsave；\",\"执行 debug reload 时；\",\"执行 shutdown时，如果没有开启aof，也会触发。\",\"由于 save 基本不会被使用到，我们重点看看 bgsave 这个命令是如何完成RDB的持久化的。\",\"这里注意的是 fork 操作会阻塞，导致Redis读写性能下降。我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。\"]},\"356\":{\"h\":\"AOF的原理\",\"t\":[\"AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是 appendfsync everysec 配置，会有1s损耗），第二步是对aof文件的重写。 对于增量追加到文件这一步主要的流程是：命令写入=>追加到aof_buf =>同步到aof磁盘。那么这里为什么要先写入buf在同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。 aof重写是为了减少aof文件的大小，可以手动或者自动触发，关于自动触发的规则请看上面配置部分。fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。 手动触发： bgrewriteaof，自动触发 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。\",\"下面来看看重写的一个流程图：\",\"对于上图有四个关键点补充一下：\",\"在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。 为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。 重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。 AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。\",\"不能是RDB还是AOF都是先写入一个临时文件，然后通过 rename 完成文件的替换工作。\"]},\"357\":{\"h\":\"从持久化中恢复数据\",\"t\":[\"数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？ 其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：\",\"启动时会先检查AOF文件是否存在，如果不存在就尝试加载RDB。那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。\"]},\"358\":{\"h\":\"性能与实践\",\"t\":[\"通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。\",\"降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；\",\"控制Redis最大使用内存，防止fork耗时过长；\",\"使用更牛逼的硬件；\",\"合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。\",\"在线上我们到底该怎么做？我提供一些自己的实践经验。\",\"如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；\",\"自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；\",\"单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；\",\"可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；\",\"RDB持久化与AOF持久化可以同时存在，配合使用。\",\"作者：大愚Talk\\n链接：https://juejin.im/post/5b70dfcf518825610f1f5c16\\n来源：掘金\\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\"]},\"359\":{\"c\":[\"redis\"]},\"360\":{\"c\":[\"redis\",\"面试\",\"面试总结\"]},\"361\":{\"h\":\"Golang 常见面试题目解析\"},\"362\":{\"h\":\"Golang 常见面试题目解析\",\"t\":[\"交替打印数字和字母\",\"判断字符串中字符是否全都不同\",\"翻转字符串\",\"判断两个给定的字符串排序后是否一致\",\"字符串替换问题\",\"机器人坐标计算\",\"语法题目\",\"定时与painc恢复\"]},\"363\":{\"c\":[\"golang\"]},\"364\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"365\":{\"h\":\"交替打印数字和字母\"},\"366\":{\"h\":\"交替打印数字和字母\",\"t\":[\"问题描述\",\"使用两个 goroutine 交替打印序列，一个 goroutine 打印数字， 另外一个 goroutine 打印字母， 最终效果如下：\",\"12AB34CD56EF78GH910IJ1112KL1314MN1516OP1718QR1920ST2122UV2324WX2526YZ2728 \",\"解题思路\",\"问题很简单，使用 channel 来控制打印的进度。使用两个 channel ，来分别控制数字和字母的打印序列， 数字打印完成后通过 channel 通知字母打印, 字母打印完成后通知数字打印，然后周而复始的工作。\",\"源码参考\",\" letter,number := make(chan bool),make(chan bool) wait := sync.WaitGroup{} go func() { i := 1 for { select { case <-number: fmt.Print(i) i++ fmt.Print(i) i++ letter <- true } } }() wait.Add(1) go func(wait *sync.WaitGroup) { i := 'A' for{ select { case <-letter: if i >= 'Z' { wait.Done() return } fmt.Print(string(i)) i++ fmt.Print(string(i)) i++ number <- true } } }(&wait) number<-true wait.Wait() \",\"源码解析\",\"这里用到了两个channel负责通知，letter负责通知打印字母的goroutine来打印字母，number用来通知打印数字的goroutine打印数字。\",\"wait用来等待字母打印完成后退出循环。\"]},\"367\":{\"c\":[\"golang\"]},\"368\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"369\":{\"h\":\"判断字符串中字符是否全都不同\"},\"370\":{\"h\":\"判断字符串中字符是否全都不同\",\"t\":[\"问题描述\",\"请实现一个算法，确定一个字符串的所有字符【是否全都不同】。这里我们要求【不允许使用额外的存储结构】。 给定一个string，请返回一个bool值,true代表所有字符全都不同，false代表存在相同的字符。 保证字符串中的字符为【ASCII字符】。字符串的长度小于等于【3000】。\",\"解题思路\",\"这里有几个重点，第一个是ASCII字符，ASCII字符字符一共有256个，其中128个是常用字符，可以在键盘上输入。128之后的是键盘上无法找到的。\",\"然后是全部不同，也就是字符串中的字符没有重复的，再次，不准使用额外的储存结构，且字符串小于等于3000。\",\"如果允许其他额外储存结构，这个题目很好做。如果不允许的话，可以使用golang内置的方式实现。\",\"源码参考\",\"通过strings.Count 函数判断：\",\"func isUniqueString(s string) bool { if strings.Count(s,\\\"\\\") > 3000{ return false } for _,v := range s { if v > 127 { return false } if strings.Count(s,string(v)) > 1 { return false } } return true } \",\"通过strings.Index和strings.LastIndex函数判断：\",\"func isUniqueString2(s string) bool { if strings.Count(s,\\\"\\\") > 3000{ return false } for k,v := range s { if v > 127 { return false } if strings.Index(s,string(v)) != k { return false } } return true } \",\"通过位运算判断\",\"func isUniqString3(s string) bool { if len(s) == 0 || len(s) > 3000 { return false } // 256 个字符 256 = 64 + 64 + 64 + 64 var mark1, mark2, mark3, mark4 uint64 var mark *uint64 for _, r := range s { n := uint64(r) if n < 64 { mark = &mark1 } else if n < 128 { mark = &mark2 n -= 64 } else if n < 192 { mark = &mark3 n -= 128 } else { mark = &mark4 n -= 192 } if (*mark)&(1<<n) != 0 { return false } *mark = (*mark) | uint64(1<<n) } return true } \",\"源码解析\",\"以上三种方法都可以实现这个算法。\",\"第一个方法使用的是golang内置方法strings.Count,可以用来判断在一个字符串中包含的另外一个字符串的数量。\",\"第二个方法使用的是golang内置方法strings.Index和strings.LastIndex，用来判断指定字符串在另外一个字符串的索引未知，分别是第一次发现位置和最后发现位置。\",\"第三个方法使用的是位运算来判断是否重复，时间复杂度为o(n)，相比前两个方法时间复杂度低\"]},\"371\":{\"c\":[\"golang\"]},\"372\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"373\":{\"h\":\"翻转字符串\"},\"374\":{\"h\":\"翻转字符串\",\"t\":[\"问题描述\",\"请实现一个算法，在不使用【额外数据结构和储存空间】的情况下，翻转一个给定的字符串(可以使用单个过程变量)。\",\"给定一个string，请返回一个string，为翻转后的字符串。保证字符串的长度小于等于5000。\",\"解题思路\",\"翻转字符串其实是将一个字符串以中间字符为轴，前后翻转，即将str[len]赋值给str[0],将str[0] 赋值 str[len]。\",\"源码参考\",\"func reverString(s string) (string, bool) { str := []rune(s) l := len(str) if l > 5000 { return s, false } for i := 0; i < l/2; i++ { str[i], str[l-1-i] = str[l-1-i], str[i] } return string(str), true } \",\"源码解析\",\"以字符串长度的1/2为轴，前后赋值\"]},\"375\":{\"c\":[\"golang\"]},\"376\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"377\":{\"h\":\"判断两个给定的字符串排序后是否一致\"},\"378\":{\"h\":\"判断两个给定的字符串排序后是否一致\",\"t\":[\"问题描述\",\"给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 这里规定【大小写为不同字符】，且考虑字符串重点空格。给定一个string s1和一个string s2，请返回一个bool，代表两串是否重新排列后可相同。 保证两串的长度都小于等于5000。\",\"解题思路\",\"首先要保证字符串长度小于5000。之后只需要一次循环遍历s1中的字符在s2是否都存在即可。\",\"源码参考\",\"func isRegroup(s1,s2 string) bool { sl1 := len([]rune(s1)) sl2 := len([]rune(s2)) if sl1 > 5000 || sl2 > 5000 || sl1 != sl2{ return false } for _,v := range s1 { if strings.Count(s1,string(v)) != strings.Count(s2,string(v)) { return false } } return true } \",\"源码解析\",\"这里还是使用golang内置方法 strings.Count 来判断字符是否一致。\"]},\"379\":{\"c\":[\"golang\"]},\"380\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"381\":{\"h\":\"字符串替换问题\"},\"382\":{\"h\":\"字符串替换问题\",\"t\":[\"问题描述\",\"请编写一个方法，将字符串中的空格全部替换为“%20”。 假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由【大小写的英文字母组成】。 给定一个string为原始的串，返回替换后的string。\",\"解题思路\",\"两个问题，第一个是只能是英文字母，第二个是替换空格。\",\"源码参考\",\"func replaceBlank(s string) (string, bool) { if len([]rune(s)) > 1000 { return s, false } for _, v := range s { if string(v) != \\\" \\\" && unicode.IsLetter(v) == false { return s, false } } return strings.Replace(s, \\\" \\\", \\\"%20\\\", -1), true } \",\"源码解析\",\"这里使用了golang内置方法unicode.IsLetter判断字符是否是字母，之后使用strings.Replace来替换空格。\"]},\"383\":{\"c\":[\"golang\"]},\"384\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"385\":{\"h\":\"机器人坐标问题\"},\"386\":{\"h\":\"机器人坐标问题\",\"t\":[\"问题描述\",\"有一个机器人，给一串指令，L左转 R右转，F前进一步，B后退一步，问最后机器人的坐标，最开始，机器人位于 0 0，方向为正Y。 可以输入重复指令n ： 比如 R2(LF) 这个等于指令 RLFLF。 问最后机器人的坐标是多少？\",\"解题思路\",\"这里的一个难点是解析重复指令。主要指令解析成功，计算坐标就简单了。\",\"源码参考\",\"package main import ( \\\"unicode\\\" ) const ( Left = iota Top Right Bottom ) func main() { println(move(\\\"R2(LF)\\\", 0, 0, Top)) } func move(cmd string, x0 int, y0 int, z0 int) (x, y, z int) { x, y, z = x0, y0, z0 repeat := 0 repeatCmd := \\\"\\\" for _, s := range cmd { switch { case unicode.IsNumber(s): repeat = repeat*10 + (int(s) - '0') case s == ')': for i := 0; i < repeat; i++ { x, y, z = move(repeatCmd, x, y, z) } repeat = 0 repeatCmd = \\\"\\\" case repeat > 0 && s != '(' && s != ')': repeatCmd = repeatCmd + string(s) case s == 'L': z = (z + 1) % 4 case s == 'R': z = (z - 1 + 4) % 4 case s == 'F': switch { case z == Left || z == Right: x = x - z + 1 case z == Top || z == Bottom: y = y - z + 2 } case s == 'B': switch { case z == Left || z == Right: x = x + z - 1 case z == Top || z == Bottom: y = y + z - 2 } } } return } \",\"源码解析\",\"这里使用三个值表示机器人当前的状况，分别是：x表示x坐标，y表示y坐标，z表示当前方向。 L、R 命令会改变值z，F、B命令会改变值x、y。 值x、y的改变还受当前的z值影响。\",\"如果是重复指令，那么将重复次数和重复的指令存起来递归调用即可。\"]},\"387\":{\"c\":[\"golang\"]},\"388\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"389\":{\"h\":\"语法题目\"},\"390\":{\"h\":\"常见语法题目 一\"},\"391\":{\"h\":\"1、下面代码能运行吗？为什么。\",\"t\":[\"type Param map[string]interface{} type Show struct { Param } func main1() { s := new(Show) s.Param[\\\"RMB\\\"] = 10000 } \",\"解析\",\"共发现两个问题：\",\"main 函数不能加数字。\",\"new 关键字无法初始化 Show 结构体中的 Param 属性，所以直接对 s.Param 操作会出错。\"]},\"392\":{\"h\":\"2、请说出下面代码存在什么问题。\",\"t\":[\"type student struct { Name string } func zhoujielun(v interface{}) { switch msg := v.(type) { case *student, student: msg.Name } } \",\"解析：\",\"golang中有规定，switch type的case T1，类型列表只有一个，那么v := m.(type)中的v的类型就是T1类型。\",\"如果是case T1, T2，类型列表中有多个，那v的类型还是多对应接口的类型，也就是m的类型。\",\"所以这里msg的类型还是interface{}，所以他没有Name这个字段，编译阶段就会报错。具体解释见： https://golang.org/ref/spec#Type_switches\"]},\"393\":{\"h\":\"3、写出打印的结果。\",\"t\":[\"type People struct { name string `json:\\\"name\\\"` } func main() { js := `{ \\\"name\\\":\\\"11\\\" }` var p People err := json.Unmarshal([]byte(js), &p) if err != nil { fmt.Println(\\\"err: \\\", err) return } fmt.Println(\\\"people: \\\", p) } \",\"解析：\",\"按照 golang 的语法，小写开头的方法、属性或 struct 是私有的，同样，在json 解码或转码的时候也无法上线私有属性的转换。\",\"题目中是无法正常得到People的name值的。而且，私有属性name也不应该加json的标签。\"]},\"394\":{\"h\":\"4、下面的代码是有问题的，请说明原因。\",\"t\":[\"type People struct { Name string } func (p *People) String() string { return fmt.Sprintf(\\\"print: %v\\\", p) } func main() { p := &People{} p.String() } \",\"解析：\",\"在golang中String() string 方法实际上是实现了String的接口的，该接口定义在fmt/print.go 中：\",\"type Stringer interface { String() string } \",\"在使用 fmt 包中的打印方法时，如果类型实现了这个接口，会直接调用。而题目中打印 p 的时候会直接调用 p 实现的 String() 方法，然后就产生了循环调用。\"]},\"395\":{\"h\":\"5、请找出下面代码的问题所在。\",\"t\":[\"func main() { ch := make(chan int, 1000) go func() { for i := 0; i < 10; i++ { ch <- i } }() go func() { for { a, ok := <-ch if !ok { fmt.Println(\\\"close\\\") return } fmt.Println(\\\"a: \\\", a) } }() close(ch) fmt.Println(\\\"ok\\\") time.Sleep(time.Second * 100) } \",\"解析：\",\"在 golang 中 goroutine 的调度时间是不确定的，在题目中，第一个写 channel 的 goroutine 可能还未调用，或已调用但没有写完时直接 close 管道，可能导致写失败，既然出现 panic 错误。\"]},\"396\":{\"h\":\"6、请说明下面代码书写是否正确。\",\"t\":[\"var value int32 func SetValue(delta int32) { for { v := value if atomic.CompareAndSwapInt32(&value, v, (v+delta)) { break } } } \",\"解析：\",\"atomic.CompareAndSwapInt32 函数不需要循环调用。\"]},\"397\":{\"h\":\"7、下面的程序运行后为什么会爆异常。\",\"t\":[\"type Project struct{} func (p *Project) deferError() { if err := recover(); err != nil { fmt.Println(\\\"recover: \\\", err) } } func (p *Project) exec(msgchan chan interface{}) { for msg := range msgchan { m := msg.(int) fmt.Println(\\\"msg: \\\", m) } } func (p *Project) run(msgchan chan interface{}) { for { defer p.deferError() go p.exec(msgchan) time.Sleep(time.Second * 2) } } func (p *Project) Main() { a := make(chan interface{}, 100) go p.run(a) go func() { for { a <- \\\"1\\\" time.Sleep(time.Second) } }() time.Sleep(time.Second * 100000000000000) } func main() { p := new(Project) p.Main() } \",\"解析：\",\"有一下几个问题：\",\"time.Sleep 的参数数值太大，超过了 1<<63 - 1 的限制。\",\"defer p.deferError() 需要在协程开始出调用，否则无法捕获 panic。\"]},\"398\":{\"h\":\"8、请说出下面代码哪里写错了\",\"t\":[\"func main() { abc := make(chan int, 1000) for i := 0; i < 10; i++ { abc <- i } go func() { for a := range abc { fmt.Println(\\\"a: \\\", a) } }() close(abc) fmt.Println(\\\"close\\\") time.Sleep(time.Second * 100) } \",\"解析：\",\"协程可能还未启动，管道就关闭了。\"]},\"399\":{\"h\":\"9、请说出下面代码，执行时为什么会报错\",\"t\":[\"type Student struct { name string } func main() { m := map[string]Student{\\\"people\\\": {\\\"zhoujielun\\\"}} m[\\\"people\\\"].name = \\\"wuyanzu\\\" } \",\"解析：\",\"map的value本身是不可寻址的，因为map中的值会在内存中移动，并且旧的指针地址在map改变时会变得无效。故如果需要修改map值，可以将map中的非指针类型value，修改为指针类型，比如使用map[string]*Student.\"]},\"400\":{\"h\":\"10、请说出下面的代码存在什么问题？\",\"t\":[\"type query func(string) string func exec(name string, vs ...query) string { ch := make(chan string) fn := func(i int) { ch <- vs[i](name) } for i, _ := range vs { go fn(i) } return <-ch } func main() { ret := exec(\\\"111\\\", func(n string) string { return n + \\\"func1\\\" }, func(n string) string { return n + \\\"func2\\\" }, func(n string) string { return n + \\\"func3\\\" }, func(n string) string { return n + \\\"func4\\\" }) fmt.Println(ret) } \",\"解析：\",\"依据4个goroutine的启动后执行效率，很可能打印111func4，但其他的111func*也可能先执行，exec只会返回一条信息。\"]},\"401\":{\"h\":\"11、下面这段代码为什么会卡死？\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"runtime\\\" ) func main() { var i byte go func() { for i = 0; i <= 255; i++ { } }() fmt.Println(\\\"Dropping mic\\\") // Yield execution to force executing other goroutines runtime.Gosched() runtime.GC() fmt.Println(\\\"Done\\\") } \",\"解析：\",\"Golang 中，byte 其实被 alias 到 uint8 上了。所以上面的 for 循环会始终成立，因为 i++ 到 i=255 的时候会溢出，i <= 255 一定成立。\",\"也即是， for 循环永远无法退出，所以上面的代码其实可以等价于这样：\",\"go func() { for {} } \",\"正在被执行的 goroutine 发生以下情况时让出当前 goroutine 的执行权，并调度后面的 goroutine 执行：\",\"IO 操作\",\"Channel 阻塞\",\"system call\",\"运行较长时间\",\"如果一个 goroutine 执行时间太长，scheduler 会在其 G 对象上打上一个标志（ preempt），当这个 goroutine 内部发生函数调用的时候，会先主动检查这个标志，如果为 true 则会让出执行权。\",\"main 函数里启动的 goroutine 其实是一个没有 IO 阻塞、没有 Channel 阻塞、没有 system call、没有函数调用的死循环。\",\"也就是，它无法主动让出自己的执行权，即使已经执行很长时间，scheduler 已经标志了 preempt。\",\"而 golang 的 GC 动作是需要所有正在运行 goroutine 都停止后进行的。因此，程序会卡在 runtime.GC() 等待所有协程退出。\"]},\"402\":{\"c\":[\"golang\"]},\"403\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"404\":{\"h\":\"常见语法题目 二\"},\"405\":{\"h\":\"1、写出下面代码输出内容。\",\"t\":[\"package main import ( \\\"fmt\\\" ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(\\\"打印前\\\") }() defer func() { fmt.Println(\\\"打印中\\\") }() defer func() { fmt.Println(\\\"打印后\\\") }() panic(\\\"触发异常\\\") } \",\"解析：\",\"defer 关键字的实现跟go关键字很类似，不同的是它调用的是runtime.deferproc而不是runtime.newproc。\",\"在defer出现的地方，插入了指令call runtime.deferproc，然后在函数返回之前的地方，插入指令call runtime.deferreturn。\",\"goroutine的控制结构中，有一张表记录defer，调用runtime.deferproc时会将需要defer的表达式记录在表中，而在调用runtime.deferreturn的时候，则会依次从defer表中出栈并执行。\",\"因此，题目最后输出顺序应该是defer 定义顺序的倒序。panic 错误并不能终止 defer 的执行。\"]},\"406\":{\"h\":\"2、 以下代码有什么问题，说明原因\",\"t\":[\"type student struct { Name string Age int } func pase_student() { m := make(map[string]*student) stus := []student{ {Name: \\\"zhou\\\", Age: 24}, {Name: \\\"li\\\", Age: 23}, {Name: \\\"wang\\\", Age: 22}, } for _, stu := range stus { m[stu.Name] = &stu } } \",\"解析：\",\"golang 的 for ... range 语法中，stu 变量会被复用，每次循环会将集合中的值复制给这个变量，因此，会导致最后m中的map中储存的都是stus最后一个student的值。\"]},\"407\":{\"h\":\"3、下面的代码会输出什么，并说明原因\",\"t\":[\"func main() { runtime.GOMAXPROCS(1) wg := sync.WaitGroup{} wg.Add(20) for i := 0; i < 10; i++ { go func() { fmt.Println(\\\"i: \\\", i) wg.Done() }() } for i := 0; i < 10; i++ { go func(i int) { fmt.Println(\\\"i: \\\", i) wg.Done() }(i) } wg.Wait() } \",\"解析：\",\"这个输出结果决定来自于调度器优先调度哪个G。从runtime的源码可以看到，当创建一个G时，会优先放入到下一个调度的runnext字段上作为下一次优先调度的G。因此，最先输出的是最后创建的G，也就是9.\",\"func newproc(siz int32, fn *funcval) { argp := add(unsafe.Pointer(&fn), sys.PtrSize) gp := getg() pc := getcallerpc() systemstack(func() { newg := newproc1(fn, argp, siz, gp, pc) _p_ := getg().m.p.ptr() //新创建的G会调用这个方法来决定如何调度 runqput(_p_, newg, true) if mainStarted { wakep() } }) } ... if next { retryNext: oldnext := _p_.runnext //当next是true时总会将新进来的G放入下一次调度字段中 if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) { goto retryNext } if oldnext == 0 { return } // Kick the old runnext out to the regular run queue. gp = oldnext.ptr() } \"]},\"408\":{\"h\":\"4、下面代码会输出什么？\",\"t\":[\"type People struct{} func (p *People) ShowA() { fmt.Println(\\\"showA\\\") p.ShowB() } func (p *People) ShowB() { fmt.Println(\\\"showB\\\") } type Teacher struct { People } func (t *Teacher) ShowB() { fmt.Println(\\\"teacher showB\\\") } func main() { t := Teacher{} t.ShowA() } \",\"解析：\",\"输出结果为showA、showB。golang 语言中没有继承概念，只有组合，也没有虚方法，更没有重载。因此，*Teacher 的 ShowB 不会覆写被组合的 People 的方法。\"]},\"409\":{\"h\":\"5、下面代码会触发异常吗？请详细说明\",\"t\":[\"func main() { runtime.GOMAXPROCS(1) int_chan := make(chan int, 1) string_chan := make(chan string, 1) int_chan <- 1 string_chan <- \\\"hello\\\" select { case value := <-int_chan: fmt.Println(value) case value := <-string_chan: panic(value) } } \",\"解析：\",\"结果是随机执行。golang 在多个case 可读的时候会公平的选中一个执行。\"]},\"410\":{\"h\":\"6、下面代码输出什么？\",\"t\":[\"func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret } func main() { a := 1 b := 2 defer calc(\\\"1\\\", a, calc(\\\"10\\\", a, b)) a = 0 defer calc(\\\"2\\\", a, calc(\\\"20\\\", a, b)) b = 1 } \",\"解析：\",\"输出结果为：\",\"10 1 2 3 20 0 2 2 2 0 2 2 1 1 3 4 \",\"defer 在定义的时候会计算好调用函数的参数，所以会优先输出10、20 两个参数。然后根据定义的顺序倒序执行。\"]},\"411\":{\"h\":\"7、请写出以下输入内容\",\"t\":[\"func main() { s := make([]int, 5) s = append(s, 1, 2, 3) fmt.Println(s) } \",\"解析：\",\"输出为 0 0 0 0 0 1 2 3。\",\"make 在初始化切片时指定了长度，所以追加数据时会从len(s) 位置开始填充数据。\"]},\"412\":{\"h\":\"8、下面的代码有什么问题?\",\"t\":[\"type UserAges struct { ages map[string]int sync.Mutex } func (ua *UserAges) Add(name string, age int) { ua.Lock() defer ua.Unlock() ua.ages[name] = age } func (ua *UserAges) Get(name string) int { if age, ok := ua.ages[name]; ok { return age } return -1 } \",\"解析：\",\"在执行 Get方法时可能被thorw。\",\"虽然有使用sync.Mutex做写锁，但是map是并发读写不安全的。map属于引用类型，并发读写时多个协程见是通过指针访问同一个地址，即访问共享变量，此时同时读写资源存在竞争关系。会报错误信息:“fatal error: concurrent map read and map write”。\",\"因此，在 Get 中也需要加锁，因为这里只是读，建议使用读写锁 sync.RWMutex。\"]},\"413\":{\"h\":\"9、下面的迭代会有什么问题？\",\"t\":[\"func (set *threadSafeSet) Iter() <-chan interface{} { ch := make(chan interface{}) go func() { set.RLock() for elem := range set.s { ch <- elem } close(ch) set.RUnlock() }() return ch } \",\"解析：\",\"默认情况下 make 初始化的 channel 是无缓冲的，也就是在迭代写时会阻塞。\"]},\"414\":{\"h\":\"10、以下代码能编译过去吗？为什么？\",\"t\":[\"package main import ( \\\"fmt\\\" ) type People interface { Speak(string) string } type Student struct{} func (stu *Student) Speak(think string) (talk string) { if think == \\\"bitch\\\" { talk = \\\"You are a good boy\\\" } else { talk = \\\"hi\\\" } return } func main() { var peo People = Student{} think := \\\"bitch\\\" fmt.Println(peo.Speak(think)) } \",\"解析：\",\"编译失败，值类型 Student{} 未实现接口People的方法，不能定义为 People类型。\",\"在 golang 语言中，Student 和 *Student 是两种类型，第一个是表示 Student 本身，第二个是指向 Student 的指针。\"]},\"415\":{\"h\":\"11、以下代码打印出来什么内容，说出为什么。。。\",\"t\":[\"package main import ( \\\"fmt\\\" ) type People interface { Show() } type Student struct{} func (stu *Student) Show() { } func live() People { var stu *Student return stu } func main() { if live() == nil { fmt.Println(\\\"AAAAAAA\\\") } else { fmt.Println(\\\"BBBBBBB\\\") } } \",\"解析：\",\"跟上一题一样，不同的是*Student 的定义后本身没有初始化值，所以 *Student 是 nil的，但是*Student 实现了 People 接口，接口不为 nil。\"]},\"416\":{\"c\":[\"golang\"]},\"417\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"418\":{\"h\":\"在 golang 协程和channel配合使用\",\"t\":[\"写代码实现两个 goroutine，其中一个产生随机数并写入到 go channel 中，另外一个从 channel 中读取数字并打印到标准输出。最终输出五个随机数。\",\"解析\",\"这是一道很简单的golang基础题目，实现方法也有很多种，一般想答让面试官满意的答案还是有几点注意的地方。\",\"goroutine 在golang中式非阻塞的\",\"channel 无缓冲情况下，读写都是阻塞的，且可以用for循环来读取数据，当管道关闭后，for 退出。\",\"golang 中有专用的select case 语法从管道读取数据。\",\"示例代码如下：\",\"func main() { out := make(chan int) wg := sync.WaitGroup{} wg.Add(2) go func() { defer wg.Done() for i := 0; i < 5; i++ { out <- rand.Intn(5) } close(out) }() go func() { defer wg.Done() for i := range out { fmt.Println(i) } }() wg.Wait() } \"]},\"419\":{\"c\":[\"golang\"]},\"420\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"421\":{\"h\":\"实现阻塞读且并发安全的map\",\"t\":[\"GO里面MAP如何实现key不存在 get操作等待 直到key存在或者超时，保证并发安全，且需要实现以下接口：\",\"type sp interface { Out(key string, val interface{}) //存入key /val，如果该key读取的goroutine挂起，则唤醒。此方法不会阻塞，时刻都可以立即执行并返回 Rd(key string, timeout time.Duration) interface{} //读取一个key，如果key不存在阻塞，等待key存在或者超时 } \",\"解析：\",\"看到阻塞协程第一个想到的就是channel，题目中要求并发安全，那么必须用锁，还要实现多个goroutine读的时候如果值不存在则阻塞，直到写入值，那么每个键值需要有一个阻塞goroutine 的 channel。\",\"实现如下：\",\"type Map struct { c map[string]*entry rmx *sync.RWMutex } type entry struct { ch chan struct{} value interface{} isExist bool } func (m *Map) Out(key string, val interface{}) { m.rmx.Lock() defer m.rmx.Unlock() item, ok := m.c[key] if !ok { m.c[key] = &entry{ value: val, isExist: true, } return } item.value = val if !item.isExist { if item.ch != nil { close(item.ch) item.ch = nil } } return } \"]},\"422\":{\"c\":[\"golang\"]},\"423\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"424\":{\"h\":\"高并发下的锁与map的读写\",\"t\":[\"场景：在一个高并发的web服务器中，要限制IP的频繁访问。现模拟100个IP同时并发访问服务器，每个IP要重复访问1000次。\",\"每个IP三分钟之内只能访问一次。修改以下代码完成该过程，要求能成功输出 success:100\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) type Ban struct { visitIPs map[string]time.Time } func NewBan() *Ban { return &Ban{visitIPs: make(map[string]time.Time)} } func (o *Ban) visit(ip string) bool { if _, ok := o.visitIPs[ip]; ok { return true } o.visitIPs[ip] = time.Now() return false } func main() { success := 0 ban := NewBan() for i := 0; i < 1000; i++ { for j := 0; j < 100; j++ { go func() { ip := fmt.Sprintf(\\\"192.168.1.%d\\\", j) if !ban.visit(ip) { success++ } }() } } fmt.Println(\\\"success:\\\", success) } \",\"解析\",\"该问题主要考察了并发情况下map的读写问题，而给出的初始代码，又存在for循环中启动goroutine时变量使用问题以及goroutine执行滞后问题。\",\"因此，首先要保证启动的goroutine得到的参数是正确的，然后保证map的并发读写，最后保证三分钟只能访问一次。\",\"多CPU核心下修改int的值极端情况下会存在不同步情况，因此需要原子性的修改int值。\",\"下面给出的实例代码，是启动了一个协程每分钟检查一下map中的过期ip，for启动协程时传参。\",\"package main import ( \\\"context\\\" \\\"fmt\\\" \\\"sync\\\" \\\"sync/atomic\\\" \\\"time\\\" ) type Ban struct { visitIPs map[string]time.Time lock sync.Mutex } func NewBan(ctx context.Context) *Ban { o := &Ban{visitIPs: make(map[string]time.Time)} go func() { timer := time.NewTimer(time.Minute * 1) for { select { case <-timer.C: o.lock.Lock() for k, v := range o.visitIPs { if time.Now().Sub(v) >= time.Minute*1 { delete(o.visitIPs, k) } } o.lock.Unlock() timer.Reset(time.Minute * 1) case <-ctx.Done(): return } } }() return o } func (o *Ban) visit(ip string) bool { o.lock.Lock() defer o.lock.Unlock() if _, ok := o.visitIPs[ip]; ok { return true } o.visitIPs[ip] = time.Now() return false } func main() { success := int64(0) ctx, cancel := context.WithCancel(context.Background()) defer cancel() ban := NewBan(ctx) wait := &sync.WaitGroup{} wait.Add(1000 * 100) for i := 0; i < 1000; i++ { for j := 0; j < 100; j++ { go func(j int) { defer wait.Done() ip := fmt.Sprintf(\\\"192.168.1.%d\\\", j) if !ban.visit(ip) { atomic.AddInt64(&success, 1) } }(j) } } wait.Wait() fmt.Println(\\\"success:\\\", success) } \"]},\"425\":{\"c\":[\"golang\"]},\"426\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"427\":{\"h\":\"定时与painc恢复\"},\"428\":{\"h\":\"1. 写出以下逻辑，要求每秒钟调用一次proc并保证程序不退出?\",\"t\":[\"package main func main() { go func() { // 1 在这里需要你写算法 // 2 要求每秒钟调用一次proc函数 // 3 要求程序不能退出 }() select {} } func proc() { panic(\\\"ok\\\") } \",\"解析\",\"题目主要考察了两个知识点：\",\"定时执行执行任务\",\"捕获 panic 错误\",\"题目中要求每秒钟执行一次，首先想到的就是 time.Ticker对象，该函数可每秒钟往chan中放一个Time,正好符合我们的要求。\",\"在 golang 中捕获 panic 一般会用到 recover() 函数。\",\"package main import ( \\\"fmt\\\" \\\"time\\\" ) func main() { go func() { // 1 在这里需要你写算法 // 2 要求每秒钟调用一次proc函数 // 3 要求程序不能退出 t := time.NewTicker(time.Second * 1) for { select { case <-t.C: go func() { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() proc() }() } } }() select {} } func proc() { panic(\\\"ok\\\") } \"]},\"429\":{\"c\":[\"golang\"]},\"430\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"431\":{\"h\":\"为 sync.WaitGroup 中Wait函数支持 WaitTimeout 功能.\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"sync\\\" \\\"time\\\" ) func main() { wg := sync.WaitGroup{} c := make(chan struct{}) for i := 0; i < 10; i++ { wg.Add(1) go func(num int, close <-chan struct{}) { defer wg.Done() <-close fmt.Println(num) }(i, c) } if WaitTimeout(&wg, time.Second*5) { close(c) fmt.Println(\\\"timeout exit\\\") } time.Sleep(time.Second * 10) } func WaitTimeout(wg *sync.WaitGroup, timeout time.Duration) bool { // 要求手写代码 // 要求sync.WaitGroup支持timeout功能 // 如果timeout到了超时时间返回true // 如果WaitGroup自然结束返回false } \",\"解析\",\"首先 sync.WaitGroup 对象的 Wait 函数本身是阻塞的，同时，超时用到的time.Timer 对象也需要阻塞的读。\",\"同时阻塞的两个对象肯定要每个启动一个协程,每个协程去处理一个阻塞，难点在于怎么知道哪个阻塞先完成。\",\"目前我用的方式是声明一个没有缓冲的chan，谁先完成谁优先向管道中写入数据。\",\"package main import ( \\\"fmt\\\" \\\"sync\\\" \\\"time\\\" ) func main() { wg := sync.WaitGroup{} c := make(chan struct{}) for i := 0; i < 10; i++ { wg.Add(1) go func(num int, close <-chan struct{}) { defer wg.Done() <-close fmt.Println(num) }(i, c) } if WaitTimeout(&wg, time.Second*5) { close(c) fmt.Println(\\\"timeout exit\\\") } time.Sleep(time.Second * 10) } func WaitTimeout(wg *sync.WaitGroup, timeout time.Duration) bool { // 要求手写代码 // 要求sync.WaitGroup支持timeout功能 // 如果timeout到了超时时间返回true // 如果WaitGroup自然结束返回false ch := make(chan bool, 1) go time.AfterFunc(timeout, func() { ch <- true }) go func() { wg.Wait() ch <- false }() return <- ch } \"]},\"432\":{\"c\":[\"golang\"]},\"433\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"434\":{\"h\":\"语法找错题\"},\"435\":{\"h\":\"写出以下代码出现的问题\",\"t\":[\"package main import ( \\\"fmt\\\" ) func main() { var x string = nil if x == nil { x = \\\"default\\\" } fmt.Println(x) } \",\"golang 中字符串是不能赋值 nil 的，也不能跟 nil 比较。\"]},\"436\":{\"h\":\"写出以下打印内容\",\"t\":[\" package main import \\\"fmt\\\" const ( a = iota b = iota ) const ( name = \\\"menglu\\\" c = iota d = iota ) func main() { fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) } \"]},\"437\":{\"h\":\"找出下面代码的问题\",\"t\":[\"package main import \\\"fmt\\\" type query func(string) string func exec(name string, vs ...query) string { ch := make(chan string) fn := func(i int) { ch <- vs[i](name) } for i, _ := range vs { go fn(i) } return <-ch } func main() { ret := exec(\\\"111\\\", func(n string) string { return n + \\\"func1\\\" }, func(n string) string { return n + \\\"func2\\\" }, func(n string) string { return n + \\\"func3\\\" }, func(n string) string { return n + \\\"func4\\\" }) fmt.Println(ret) } \",\"上面的代码有严重的内存泄漏问题，出错的位置是 go fn(i)，实际上代码执行后会启动 4 个协程，但是因为 ch 是非缓冲的，只可能有一个协程写入成功。而其他三个协程会一直在后台等待写入。\"]},\"438\":{\"h\":\"写出以下打印结果，并解释下为什么这么打印的。\",\"t\":[\"package main import ( \\\"fmt\\\" ) func main() { str1 := []string{\\\"a\\\", \\\"b\\\", \\\"c\\\"} str2 := str1[1:] str2[1] = \\\"new\\\" fmt.Println(str1) str2 = append(str2, \\\"z\\\", \\\"x\\\", \\\"y\\\") fmt.Println(str1) } \",\"golang 中的切片底层其实使用的是数组。当使用str1[1:] 使，str2 和 str1 底层共享一个数组，这回导致 str2[1] = \\\"new\\\" 语句影响 str1。\",\"而 append 会导致底层数组扩容，生成新的数组，因此追加数据后的 str2 不会影响 str1。\",\"但是为什么对 str2 复制后影响的确实 str1 的第三个元素呢？这是因为切片 str2 是从数组的第二个元素开始，str2 索引为 1 的元素对应的是 str1 索引为 2 的元素。\"]},\"439\":{\"h\":\"写出以下打印结果\",\"t\":[\"package main import ( \\\"fmt\\\" ) type Student struct { Name string } func main() { fmt.Println(&Student{Name: \\\"menglu\\\"} == &Student{Name: \\\"menglu\\\"}) fmt.Println(Student{Name: \\\"menglu\\\"} == Student{Name: \\\"menglu\\\"}) } \",\"个人理解：指针类型比较的是指针地址，非指针类型比较的是每个属性的值。\"]},\"440\":{\"h\":\"写出以下代码的问题\",\"t\":[\"package main import ( \\\"fmt\\\" ) func main() { fmt.Println([...]string{\\\"1\\\"} == [...]string{\\\"1\\\"}) fmt.Println([]string{\\\"1\\\"} == []string{\\\"1\\\"}) } \",\"数组只能与相同纬度长度以及类型的其他数组比较，切片之间不能直接比较。。\"]},\"441\":{\"h\":\"下面代码写法有什么问题？\",\"t\":[\"package main import ( \\\"fmt\\\" ) type Student struct { Age int } func main() { kv := map[string]Student{\\\"menglu\\\": {Age: 21}} kv[\\\"menglu\\\"].Age = 22 s := []Student{{Age: 21}} s[0].Age = 22 fmt.Println(kv, s) } \",\"golang中的map 通过key获取到的实际上是两个值，第一个是获取到的值，第二个是是否存在该key。因此不能直接通过key来赋值对象。\"]},\"442\":{\"c\":[\"golang\"]},\"443\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"444\":{\"h\":\"golang 并发题目测试\",\"t\":[\"题目来源： Go并发编程小测验： 你能答对几道题？\"]},\"445\":{\"h\":\"1 Mutex\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) var mu sync.Mutex var chain string func main() { chain = \\\"main\\\" A() fmt.Println(chain) } func A() { mu.Lock() defer mu.Unlock() chain = chain + \\\" --> A\\\" B() } func B() { chain = chain + \\\" --> B\\\" C() } func C() { mu.Lock() defer mu.Unlock() chain = chain + \\\" --> C\\\" } \",\"A: 不能编译\",\"B: 输出 main --> A --> B --> C\",\"C: 输出 main\",\"D: panic\"]},\"446\":{\"h\":\"2 RWMutex\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"sync\\\" \\\"time\\\" ) var mu sync.RWMutex var count int func main() { go A() time.Sleep(2 * time.Second) mu.Lock() defer mu.Unlock() count++ fmt.Println(count) } func A() { mu.RLock() defer mu.RUnlock() B() } func B() { time.Sleep(5 * time.Second) C() } func C() { mu.RLock() defer mu.RUnlock() } \",\"A: 不能编译\",\"B: 输出 1\",\"C: 程序hang住\",\"D: panic\"]},\"447\":{\"h\":\"3 Waitgroup\",\"t\":[\"package main import ( \\\"sync\\\" \\\"time\\\" ) func main() { var wg sync.WaitGroup wg.Add(1) go func() { time.Sleep(time.Millisecond) wg.Done() wg.Add(1) }() wg.Wait() } \",\"A: 不能编译\",\"B: 无输出，正常退出\",\"C: 程序hang住\",\"D: panic\"]},\"448\":{\"h\":\"4 双检查实现单例\",\"t\":[\"package doublecheck import ( \\\"sync\\\" ) type Once struct { m sync.Mutex done uint32 } func (o *Once) Do(f func()) { if o.done == 1 { return } o.m.Lock() defer o.m.Unlock() if o.done == 0 { o.done = 1 f() } } \",\"A: 不能编译\",\"B: 可以编译，正确实现了单例\",\"C: 可以编译，有并发问题，f函数可能会被执行多次\",\"D: 可以编译，但是程序运行会panic\"]},\"449\":{\"h\":\"5 Mutex\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) type MyMutex struct { count int sync.Mutex } func main() { var mu MyMutex mu.Lock() var mu2 = mu mu.count++ mu.Unlock() mu2.Lock() mu2.count++ mu2.Unlock() fmt.Println(mu.count, mu2.count) } \",\"A: 不能编译\",\"B: 输出 1, 1\",\"C: 输出 1, 2\",\"D: panic\"]},\"450\":{\"h\":\"6 Pool\",\"t\":[\"package main import ( \\\"bytes\\\" \\\"fmt\\\" \\\"runtime\\\" \\\"sync\\\" \\\"time\\\" ) var pool = sync.Pool{New: func() interface{} { return new(bytes.Buffer) }} func main() { go func() { for { processRequest(1 << 28) // 256MiB } }() for i := 0; i < 1000; i++ { go func() { for { processRequest(1 << 10) // 1KiB } }() } var stats runtime.MemStats for i := 0; ; i++ { runtime.ReadMemStats(&stats) fmt.Printf(\\\"Cycle %d: %dB\\\\n\\\", i, stats.Alloc) time.Sleep(time.Second) runtime.GC() } } func processRequest(size int) { b := pool.Get().(*bytes.Buffer) time.Sleep(500 * time.Millisecond) b.Grow(size) pool.Put(b) time.Sleep(1 * time.Millisecond) } \",\"A: 不能编译\",\"B: 可以编译，运行时正常，内存稳定\",\"C: 可以编译，运行时内存可能暴涨\",\"D: 可以编译，运行时内存先暴涨，但是过一会会回收掉\"]},\"451\":{\"h\":\"7 channel\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"runtime\\\" \\\"time\\\" ) func main() { var ch chan int go func() { ch = make(chan int, 1) ch <- 1 }() go func(ch chan int) { time.Sleep(time.Second) <-ch }(ch) c := time.Tick(1 * time.Second) for range c { fmt.Printf(\\\"#goroutines: %d\\\\n\\\", runtime.NumGoroutine()) } } \",\"A: 不能编译\",\"B: 一段时间后总是输出 #goroutines: 1\",\"C: 一段时间后总是输出 #goroutines: 2\",\"D: panic\"]},\"452\":{\"h\":\"8 channel\",\"t\":[\"package main import \\\"fmt\\\" func main() { var ch chan int var count int go func() { ch <- 1 }() go func() { count++ close(ch) }() <-ch fmt.Println(count) } \",\"A: 不能编译\",\"B: 输出 1\",\"C: 输出 0\",\"D: panic\"]},\"453\":{\"h\":\"9 Map\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) func main() { var m sync.Map m.LoadOrStore(\\\"a\\\", 1) m.Delete(\\\"a\\\") fmt.Println(m.Len()) } \",\"A: 不能编译\",\"B: 输出 1\",\"C: 输出 0\",\"D: panic\"]},\"454\":{\"h\":\"10 happens before\",\"t\":[\"package main var c = make(chan int) var a int func f() { a = 1 <-c } func main() { go f() c <- 0 print(a) } \",\"A: 不能编译\",\"B: 输出 1\",\"C: 输出 0\",\"D: panic\"]},\"455\":{\"h\":\"答案\"},\"456\":{\"h\":\"1. D\",\"t\":[\"会产生死锁panic，因为Mutex 是互斥锁。\"]},\"457\":{\"h\":\"2. D\",\"t\":[\"会产生死锁panic，根据sync/rwmutex.go 中注释可以知道，读写锁当有一个协程在等待写锁时，其他协程是不能获得读锁的，而在A和C中同一个调用链中间需要让出读锁，让写锁优先获取，而A的读锁又要求C调用完成，因此死锁。\"]},\"458\":{\"h\":\"3. D\",\"t\":[\"WaitGroup 在调用 Wait 之后是不能再调用 Add 方法的。\"]},\"459\":{\"h\":\"4. C\",\"t\":[\"在多核CPU中，因为CPU缓存会导致多个核心中变量值不同步。\"]},\"460\":{\"h\":\"5. D\",\"t\":[\"加锁后复制变量，会将锁的状态也复制，所以mu1 其实是已经加锁状态，再加锁会死锁。\"]},\"461\":{\"h\":\"6. C\",\"t\":[\"个人理解，在单核CPU中，内存可能会稳定在256MB，如果是多核可能会暴涨。\"]},\"462\":{\"h\":\"7. C\",\"t\":[\"因为 ch 未初始化，写和读都会阻塞，之后被第一个协程重新赋值，导致写的ch 都阻塞。\"]},\"463\":{\"h\":\"8. D\",\"t\":[\"ch 未有被初始化，关闭时会报错。\"]},\"464\":{\"h\":\"9. A\",\"t\":[\"sync.Map 没有 Len 方法。\"]},\"465\":{\"h\":\"10. B\",\"t\":[\"c <- 0 会阻塞依赖于 f() 的执行。\"]},\"466\":{\"c\":[\"golang\"]},\"467\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"468\":{\"h\":\"记一道字节跳动的算法面试题\"},\"469\":{\"h\":\"题目\",\"t\":[\"这其实是一道变形的链表反转题，大致描述如下 给定一个单链表的头节点 head,实现一个调整单链表的函数，使得每K个节点之间为一组进行逆序，并且从链表的尾部开始组起，头部剩余节点数量不够一组的不需要逆序。（不能使用队列或者栈作为辅助）\",\"例如：\",\"链表:1->2->3->4->5->6->7->8->null, K = 3。那么 6->7->8，3->4->5，1->2各位一组。调整后：1->2->5->4->3->8->7->6->null。其中 1，2不调整，因为不够一组。\",\"解析\",\"原文： https://juejin.im/post/5d4f76325188253b49244dd0\"]},\"470\":{\"c\":[\"golang\"]},\"471\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"472\":{\"h\":\"多协程查询切片问题\"},\"473\":{\"h\":\"题目\",\"t\":[\"假设有一个超长的切片，切片的元素类型为int，切片中的元素为乱序排序。限时5秒，使用多个goroutine查找切片中是否存在给定的值，在查找到目标值或者超时后立刻结束所有goroutine的执行。\",\"比如，切片 [23,32,78,43,76,65,345,762,......915,86]，查找目标值为 345 ，如果切片中存在，则目标值输出\\\"Found it!\\\"并立即取消仍在执行查询任务的goroutine。\",\"如果在超时时间未查到目标值程序，则输出\\\"Timeout！Not Found\\\"，同时立即取消仍在执行的查找任务的goroutine。\",\"答案: https://mp.weixin.qq.com/s/GhC2WDw3VHP91DrrFVCnag\"]},\"474\":{\"c\":[\"golang\"]},\"475\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"476\":{\"h\":\"对已经关闭的的chan进行读写，会怎么样？为什么？\"},\"477\":{\"h\":\"题目\",\"t\":[\"对已经关闭的的 chan 进行读写，会怎么样？为什么？\"]},\"478\":{\"h\":\"回答\",\"t\":[\"读已经关闭的 chan 能一直读到东西，但是读到的内容根据通道内关闭前是否有元素而不同。 \",\"如果 chan 关闭前，buffer 内有元素还未读 , 会正确读到 chan 内的值，且返回的第二个 bool 值（是否读成功）为 true。\",\"如果 chan 关闭前，buffer 内有元素已经被读完，chan 内无值，接下来所有接收的值都会非阻塞直接成功，返回 channel 元素的零值，但是第二个 bool 值一直为 false。\",\"写已经关闭的 chan 会 panic\"]},\"479\":{\"h\":\"示例\"},\"480\":{\"h\":\"1. 写已经关闭的 chan\",\"t\":[\"func main(){ c := make(chan int,3) close(c) c <- 1 } //输出结果 panic: send on closed channel goroutine 1 [running] main.main() ... \",\"注意这个 send on closed channel，待会会提到。\"]},\"481\":{\"h\":\"2. 读已经关闭的 chan\",\"t\":[\"package main import \\\"fmt\\\" func main() { fmt.Println(\\\"以下是数值的chan\\\") ci:=make(chan int,3) ci<-1 close(ci) num,ok := <- ci fmt.Printf(\\\"读chan的协程结束，num=%v， ok=%v\\\\n\\\",num,ok) num1,ok1 := <-ci fmt.Printf(\\\"再读chan的协程结束，num=%v， ok=%v\\\\n\\\",num1,ok1) num2,ok2 := <-ci fmt.Printf(\\\"再再读chan的协程结束，num=%v， ok=%v\\\\n\\\",num2,ok2) fmt.Println(\\\"以下是字符串chan\\\") cs := make(chan string,3) cs <- \\\"aaa\\\" close(cs) str,ok := <- cs fmt.Printf(\\\"读chan的协程结束，str=%v， ok=%v\\\\n\\\",str,ok) str1,ok1 := <-cs fmt.Printf(\\\"再读chan的协程结束，str=%v， ok=%v\\\\n\\\",str1,ok1) str2,ok2 := <-cs fmt.Printf(\\\"再再读chan的协程结束，str=%v， ok=%v\\\\n\\\",str2,ok2) fmt.Println(\\\"以下是结构体chan\\\") type MyStruct struct{ Name string } cstruct := make(chan MyStruct,3) cstruct <- MyStruct{Name: \\\"haha\\\"} close(cstruct) stru,ok := <- cstruct fmt.Printf(\\\"读chan的协程结束，stru=%v， ok=%v\\\\n\\\",stru,ok) stru1,ok1 := <-cs fmt.Printf(\\\"再读chan的协程结束，stru=%v， ok=%v\\\\n\\\",stru1,ok1) stru2,ok2 := <-cs fmt.Printf(\\\"再再读chan的协程结束，stru=%v， ok=%v\\\\n\\\",stru2,ok2) } \",\"输出结果\",\"以下是数值的chan 读chan的协程结束，num=1， ok=true 再读chan的协程结束，num=0， ok=false 再再读chan的协程结束，num=0， ok=false 以下是字符串chan 读chan的协程结束，str=aaa， ok=true 再读chan的协程结束，str=， ok=false 再再读chan的协程结束，str=， ok=false 以下是结构体chan 读chan的协程结束，stru={haha}， ok=true 再读chan的协程结束，stru=， ok=false 再再读chan的协程结束，stru=， ok=false \"]},\"482\":{\"h\":\"多问一句\"},\"483\":{\"h\":\"1. 为什么写已经关闭的 chan 就会 panic 呢？\",\"t\":[\"//在 src/runtime/chan.go func chansend(c *hchan,ep unsafe.Pointer,block bool,callerpc uintptr) bool { //省略其他 if c.closed != 0 { unlock(&c.lock) panic(plainError(\\\"send on closed channel\\\")) } //省略其他 } \",\"当 c.closed != 0 则为通道关闭，此时执行写，源码提示直接 panic，输出的内容就是上面提到的 \\\"send on closed channel\\\"。\"]},\"484\":{\"h\":\"2. 为什么读已关闭的 chan 会一直能读到值？\",\"t\":[\"func chanrecv(c *hchan,ep unsafe.Pointer,block bool) (selected,received bool) { //省略部分逻辑 lock(&c.lock) //当chan被关闭了，而且缓存为空时 //ep 是指 val,ok := <-c 里的val地址 if c.closed != 0 && c.qcount == 0 { if receenabled { raceacquire(c.raceaddr()) } unlock(&c.lock) //如果接受之的地址不空，那接收值将获得一个该值类型的零值 //typedmemclr 会根据类型清理响应的内存 //这就解释了上面代码为什么关闭的chan 会返回对应类型的零值 if ep != null { typedmemclr(c.elemtype,ep) } //返回两个参数 selected,received // 第二个采纳数就是 val,ok := <- c 里的 ok //也就解释了为什么读关闭的chan会一直返回false return true,false } } \",\"c.closed != 0 && c.qcount == 0 指通道已经关闭，且缓存为空的情况下（已经读完了之前写到通道里的值）\",\"如果接收值的地址 ep 不为空 \",\"那接收值将获得是一个该类型的零值\",\"typedmemclr 会根据类型清理相应地址的内存\",\"这就解释了上面代码为什么关闭的 chan 会返回对应类型的零值\"]},\"485\":{\"c\":[\"golang\"]},\"486\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"487\":{\"h\":\"简单聊聊内存逃逸？\"},\"488\":{\"h\":\"问题\",\"t\":[\"知道golang的内存逃逸吗？什么情况下会发生内存逃逸？\"]},\"489\":{\"h\":\"回答\",\"t\":[\"golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。\",\"能引起变量逃逸到堆上的典型情况：\",\"在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。\",\"发送指针或带有指针的值到 channel 中。 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。\",\"在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。\",\"slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。\",\"在 interface 类型上调用方法。 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。\"]},\"490\":{\"h\":\"举例\",\"t\":[\"通过一个例子加深理解，接下来尝试下怎么通过 go build -gcflags=-m 查看逃逸的情况。\",\"package main import \\\"fmt\\\" type A struct { s string } // 这是上面提到的 \\\"在方法内把局部变量指针返回\\\" 的情况 func foo(s string) *A { a := new(A) a.s = s return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆 } func main() { a := foo(\\\"hello\\\") b := a.s + \\\" world\\\" c := b + \\\"!\\\" fmt.Println(c) } \",\"执行go build -gcflags=-m main.go\",\"go build -gcflags=-m main.go # command-line-arguments ./main.go:7:6: can inline foo ./main.go:13:10: inlining call to foo ./main.go:16:13: inlining call to fmt.Println /var/folders/45/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/go-build409982591/b001/_gomod_.go:6:6: can inline init.0 ./main.go:7:10: leaking param: s ./main.go:8:10: new(A) escapes to heap ./main.go:16:13: io.Writer(os.Stdout) escapes to heap ./main.go:16:13: c escapes to heap ./main.go:15:9: b + \\\"!\\\" escapes to heap ./main.go:13:10: main new(A) does not escape ./main.go:14:11: main a.s + \\\" world\\\" does not escape ./main.go:16:13: main []interface {} literal does not escape <autogenerated>:1: os.(*File).close .this does not escape \",\"./main.go:8:10: new(A) escapes to heap 说明 new(A) 逃逸了,符合上述提到的常见情况中的第一种。\",\"./main.go:14:11: main a.s + \\\" world\\\" does not escape 说明 b 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。\",\"./main.go:15:9: b + \\\"!\\\" escapes to heap 说明 c 变量逃逸，通过fmt.Println(a ...interface{})打印的变量，都会发生逃逸，感兴趣的朋友可以去查查为什么。\",\"以上操作其实就叫逃逸分析。下篇文章，跟大家聊聊怎么用一个比较trick的方法使变量不逃逸。方便大家在面试官面前秀一波。\",\"原文 https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ\"]},\"491\":{\"c\":[\"golang\"]},\"492\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"493\":{\"h\":\"字符串转成byte数组，会发生内存拷贝吗？\"},\"494\":{\"h\":\"问题\",\"t\":[\"字符串转成byte数组，会发生内存拷贝吗？\"]},\"495\":{\"h\":\"回答\",\"t\":[\"字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。那么问题来了。\",\"频繁的内存拷贝操作听起来对性能不大友好。有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢？\"]},\"496\":{\"h\":\"解释\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"reflect\\\" \\\"unsafe\\\" ) func main() { a :=\\\"aaa\\\" ssh := *(*reflect.StringHeader)(unsafe.Pointer(&a)) b := *(*[]byte)(unsafe.Pointer(&ssh)) fmt.Printf(\\\"%v\\\",b) } \",\"StringHeader 是字符串在go的底层结构。\",\"type StringHeader struct { Data uintptr Len int } \",\"SliceHeader 是切片在go的底层结构。\",\"type SliceHeader struct { Data uintptr Len int Cap int } \",\"那么如果想要在底层转换二者，只需要把 StringHeader 的地址强转成 SliceHeader 就行。那么go有个很强的包叫 unsafe 。\",\"unsafe.Pointer(&a)方法可以得到变量a的地址。\",\"(*reflect.StringHeader)(unsafe.Pointer(&a)) 可以把字符串a转成底层结构的形式。\",\"(*[]byte)(unsafe.Pointer(&ssh)) 可以把ssh底层结构体转成byte的切片的指针。\",\"再通过 *转为指针指向的实际内容。\"]},\"497\":{\"c\":[\"golang\"]},\"498\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"499\":{\"h\":\"http包的内存泄漏\"},\"500\":{\"h\":\"问题\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"io/ioutil\\\" \\\"net/http\\\" \\\"runtime\\\" ) func main() { num := 6 for index := 0; index < num; index++ { resp, _ := http.Get(\\\"https://www.baidu.com\\\") _, _ = ioutil.ReadAll(resp.Body) } fmt.Printf(\\\"此时goroutine个数= %d\\\\n\\\", runtime.NumGoroutine()) } \",\"上面这道题在不执行resp.Body.Close()的情况下，泄漏了吗？如果泄漏，泄漏了多少个goroutine?\"]},\"501\":{\"h\":\"怎么答\",\"t\":[\"不进行resp.Body.Close()，泄漏是一定的。但是泄漏的goroutine个数就让我迷糊了。由于执行了6遍，每次泄漏一个读和写goroutine，就是12个goroutine，加上main函数本身也是一个goroutine，所以答案是13. 然而执行程序，发现答案是3，出入有点大，为什么呢？\"]},\"502\":{\"h\":\"解释\",\"t\":[\"我们直接看源码。golang 的 http 包。\",\"http.Get() -- DefaultClient.Get ----func (c *Client) do(req *Request) ------func send(ireq *Request, rt RoundTripper, deadline time.Time) -------- resp, didTimeout, err = send(req, c.transport(), deadline) // 以上代码在 go/1.12.7/libexec/src/net/http/client:174 func (c *Client) transport() RoundTripper { if c.Transport != nil { return c.Transport } return DefaultTransport } \",\"说明 http.Get 默认使用 DefaultTransport 管理连接。\",\"DefaultTransport 是干嘛的呢？\",\"// It establishes network connections as needed // and caches them for reuse by subsequent calls. \",\"DefaultTransport 的作用是根据需要建立网络连接并缓存它们以供后续调用重用。\",\"那么 DefaultTransport 什么时候会建立连接呢？\",\"接着上面的代码堆栈往下翻\",\"func send(ireq *Request, rt RoundTripper, deadline time.Time) --resp, err = rt.RoundTrip(req) // 以上代码在 go/1.12.7/libexec/src/net/http/client:250 func (t *Transport) RoundTrip(req *http.Request) func (t *Transport) roundTrip(req *Request) func (t *Transport) getConn(treq *transportRequest, cm connectMethod) func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistConn, error) { ... go pconn.readLoop() // 启动一个读goroutine go pconn.writeLoop() // 启动一个写goroutine return pconn, nil } \",\"一次建立连接，就会启动一个读goroutine和写goroutine。这就是为什么一次http.Get()会泄漏两个goroutine的来源。\",\"泄漏的来源知道了，也知道是因为没有执行close\",\"那为什么不执行 close 会泄漏呢？\",\"回到刚刚启动的读goroutine 的 readLoop() 代码里\",\"func (pc *persistConn) readLoop() { alive := true for alive { ... // Before looping back to the top of this function and peeking on // the bufio.Reader, wait for the caller goroutine to finish // reading the response body. (or for cancelation or death) select { case bodyEOF := <-waitForBodyRead: pc.t.setReqCanceler(rc.req, nil) // before pc might return to idle pool alive = alive && bodyEOF && !pc.sawEOF && pc.wroteRequest() && tryPutIdleConn(trace) if bodyEOF { eofc <- struct{}{} } case <-rc.req.Cancel: alive = false pc.t.CancelRequest(rc.req) case <-rc.req.Context().Done(): alive = false pc.t.cancelRequest(rc.req, rc.req.Context().Err()) case <-pc.closech: alive = false } ... } } \",\"其中第一个 body 被读取完或关闭这个 case:\",\"alive = alive && bodyEOF && !pc.sawEOF && pc.wroteRequest() && tryPutIdleConn(trace) \",\"bodyEOF 来源于到一个通道 waitForBodyRead，这个字段的 true 和 false 直接决定了 alive 变量的值（alive=true那读goroutine继续活着，循环，否则退出goroutine）。\",\"那么这个通道的值是从哪里过来的呢？\",\"// go/1.12.7/libexec/src/net/http/transport.go: 1758 body := &bodyEOFSignal{ body: resp.Body, earlyCloseFn: func() error { waitForBodyRead <- false <-eofc // will be closed by deferred call at the end of the function return nil }, fn: func(err error) error { isEOF := err == io.EOF waitForBodyRead <- isEOF if isEOF { <-eofc // see comment above eofc declaration } else if err != nil { if cerr := pc.canceled(); cerr != nil { return cerr } } return err }, } \",\"如果执行 earlyCloseFn ，waitForBodyRead 通道输入的是 false，alive 也会是 false，那 readLoop() 这个 goroutine 就会退出。\",\"如果执行 fn ，其中包括正常情况下 body 读完数据抛出 io.EOF 时的 case，waitForBodyRead 通道输入的是 true，那 alive 会是 true，那么 readLoop() 这个 goroutine 就不会退出，同时还顺便执行了 tryPutIdleConn(trace) 。\",\"// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting // a new request. // If pconn is no longer needed or not in a good state, tryPutIdleConn returns // an error explaining why it wasn't registered. // tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that. func (t *Transport) tryPutIdleConn(pconn *persistConn) error \",\"tryPutIdleConn 将 pconn 添加到等待新请求的空闲持久连接列表中，也就是之前说的连接会复用。\",\"那么问题又来了，什么时候会执行这个 fn 和 earlyCloseFn 呢？\",\"func (es *bodyEOFSignal) Close() error { es.mu.Lock() defer es.mu.Unlock() if es.closed { return nil } es.closed = true if es.earlyCloseFn != nil && es.rerr != io.EOF { return es.earlyCloseFn() // 关闭时执行 earlyCloseFn } err := es.body.Close() return es.condfn(err) } \",\"上面这个其实就是我们比较收悉的 resp.Body.Close() ,在里面会执行 earlyCloseFn，也就是此时 readLoop() 里的 waitForBodyRead 通道输入的是 false，alive 也会是 false，那 readLoop() 这个 goroutine 就会退出，goroutine 不会泄露。\",\"b, err = ioutil.ReadAll(resp.Body) --func ReadAll(r io.Reader) ----func readAll(r io.Reader, capacity int64) ------func (b *Buffer) ReadFrom(r io.Reader) // go/1.12.7/libexec/src/bytes/buffer.go:207 func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) { for { ... m, e := r.Read(b.buf[i:cap(b.buf)]) // 看这里，是body在执行read方法 ... } } \",\"这个read，其实就是 bodyEOFSignal 里的\",\"func (es *bodyEOFSignal) Read(p []byte) (n int, err error) { ... n, err = es.body.Read(p) if err != nil { ... // 这里会有一个io.EOF的报错，意思是读完了 err = es.condfn(err) } return } func (es *bodyEOFSignal) condfn(err error) error { if es.fn == nil { return err } err = es.fn(err) // 这了执行了 fn es.fn = nil return err } \",\"上面这个其实就是我们比较收悉的读取 body 里的内容。 ioutil.ReadAll() ,在读完 body 的内容时会执行 fn，也就是此时 readLoop() 里的 waitForBodyRead 通道输入的是 true，alive 也会是 true，那 readLoop() 这个 goroutine 就不会退出，goroutine 会泄露，然后执行 tryPutIdleConn(trace) 把连接放回池子里复用。\"]},\"503\":{\"h\":\"总结\",\"t\":[\"所以结论呼之欲出了，虽然执行了 6 次循环，而且每次都没有执行 Body.Close() ,就是因为执行了ioutil.ReadAll()把内容都读出来了，连接得以复用，因此只泄漏了一个读goroutine和一个写goroutine，最后加上main goroutine，所以答案就是3个goroutine。\",\"从另外一个角度说，正常情况下我们的代码都会执行 ioutil.ReadAll()，但如果此时忘了 resp.Body.Close()，确实会导致泄漏。但如果你调用的域名一直是同一个的话，那么只会泄漏一个 读goroutine 和一个写goroutine，这就是为什么代码明明不规范但却看不到明显内存泄漏的原因。\",\"那么问题又来了，为什么上面要特意强调是同一个域名呢？改天，回头，以后有空再说吧。\",\"作者：9號同学 链接：https://juejin.cn/post/6896993332019822605 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\",\"作者：9號同学\\n链接：https://juejin.cn/post/6896993332019822605\\n来源：掘金\\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\"]},\"504\":{\"c\":[\"golang\"]},\"505\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"506\":{\"h\":\"sync.Map 的用法\"},\"507\":{\"h\":\"问题\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"sync\\\" ) func main(){ var m sync.Map m.Store(\\\"address\\\",map[string]string{\\\"province\\\":\\\"江苏\\\",\\\"city\\\":\\\"南京\\\"}) v,_ := m.Load(\\\"address\\\") fmt.Println(v[\\\"province\\\"]) } \",\"A，江苏；\",\"B，v[\\\"province\\\"]取值错误；\",\"C，m.Store存储错误；\",\"D，不知道\"]},\"508\":{\"h\":\"解析\",\"t\":[\"invalid operation: v[\\\"province\\\"] (type interface {} does not support indexing) 因为 func (m *Map) Store(key interface{}, value interface{}) 所以 v类型是 interface {} ，这里需要一个类型断言\",\"fmt.Println(v.(map[string]string)[\\\"province\\\"]) //江苏 \"]},\"509\":{\"c\":[\"golang\"]},\"510\":{\"c\":[\"go\",\"golang\",\"map\",\"interface\",\"struct\",\"源码\",\"面试\",\"面试总结\"]},\"511\":{\"h\":\"Golang\"},\"512\":{\"h\":\"Mysql\"},\"513\":{\"h\":\"Php\"},\"514\":{\"h\":\"Redis\"}},\"dirtCount\":0,\"index\":[[\"南京\",{\"1\":{\"507\":1}}],[\"江苏\",{\"1\":{\"507\":2,\"508\":1}}],[\"次循环\",{\"1\":{\"503\":1}}],[\"管理连接\",{\"1\":{\"502\":1}}],[\"管道就关闭了\",{\"1\":{\"398\":1}}],[\"管道\",{\"1\":{\"395\":1}}],[\"泄漏的来源知道了\",{\"1\":{\"502\":1}}],[\"泄漏是一定的\",{\"1\":{\"501\":1}}],[\"泄漏了多少个goroutine\",{\"1\":{\"500\":1}}],[\"泄漏了吗\",{\"1\":{\"500\":1}}],[\"严格来说\",{\"1\":{\"495\":1}}],[\"感兴趣的朋友可以去查查为什么\",{\"1\":{\"490\":1}}],[\"感兴趣的同学可以自行查阅书籍\",{\"1\":{\"16\":1}}],[\"局部变量原本应该在栈中分配\",{\"1\":{\"489\":1}}],[\"局部运行队列被包含在p结构体的实例对象之中\",{\"1\":{\"29\":1}}],[\"逃逸了\",{\"1\":{\"490\":1}}],[\"逃逸\",{\"1\":{\"489\":1}}],[\"待会会提到\",{\"1\":{\"480\":1}}],[\"元素的零值\",{\"1\":{\"478\":1}}],[\"限时5秒\",{\"1\":{\"473\":1}}],[\"限制访问频率\",{\"1\":{\"268\":1}}],[\"限制同一userid访问频率\",{\"1\":{\"268\":1}}],[\"答案\",{\"0\":{\"455\":1},\"1\":{\"473\":1}}],[\"答案是可以的\",{\"1\":{\"260\":1}}],[\"答案是有的\",{\"1\":{\"52\":1}}],[\"双检查实现单例\",{\"0\":{\"448\":1}}],[\"双端链表结构\",{\"1\":{\"300\":1}}],[\"个人理解\",{\"1\":{\"439\":1,\"461\":1}}],[\"个协程\",{\"1\":{\"437\":1}}],[\"个字段\",{\"1\":{\"246\":2}}],[\"个字符\",{\"1\":{\"175\":1,\"246\":2,\"370\":1}}],[\"出入有点大\",{\"1\":{\"501\":1}}],[\"出错的位置是\",{\"1\":{\"437\":1}}],[\"出现这种情况造成的结果就是主节点各种资源被严重占用\",{\"1\":{\"327\":1}}],[\"出现缓存数据不一致问题\",{\"1\":{\"288\":1}}],[\"出现缓存旧数据问题\",{\"1\":{\"287\":1}}],[\"谁先完成谁优先向管道中写入数据\",{\"1\":{\"431\":1}}],[\"功能\",{\"0\":{\"431\":1}}],[\"捕获\",{\"1\":{\"428\":1}}],[\"现模拟100个ip同时并发访问服务器\",{\"1\":{\"424\":1}}],[\"现在假设我们要查找id>=18并且id<40的用户数据\",{\"1\":{\"72\":1}}],[\"现在我们应该知道这就是聚集索引\",{\"1\":{\"72\":1}}],[\"场景\",{\"1\":{\"424\":1}}],[\"退出\",{\"1\":{\"418\":1}}],[\"位置开始填充数据\",{\"1\":{\"411\":1}}],[\"位于栈顶\",{\"1\":{\"19\":1}}],[\"输出的内容就是上面提到的\",{\"1\":{\"483\":1}}],[\"输出结果\",{\"1\":{\"480\":1,\"481\":1}}],[\"输出结果为\",{\"1\":{\"410\":1}}],[\"输出结果为showa\",{\"1\":{\"408\":1}}],[\"输出\",{\"1\":{\"445\":2,\"446\":1,\"449\":2,\"452\":2,\"453\":2,\"454\":2}}],[\"输出为\",{\"1\":{\"411\":1}}],[\"输出30\",{\"1\":{\"48\":1}}],[\"变量的值\",{\"1\":{\"502\":1}}],[\"变量逃逸\",{\"1\":{\"490\":1}}],[\"变量没有逃逸\",{\"1\":{\"490\":1}}],[\"变量会被复用\",{\"1\":{\"406\":1}}],[\"变量v是拷贝切片中的数据\",{\"1\":{\"63\":1}}],[\"题目\",{\"0\":{\"469\":1,\"473\":1,\"477\":1}}],[\"题目来源\",{\"1\":{\"444\":1}}],[\"题目主要考察了两个知识点\",{\"1\":{\"428\":1}}],[\"题目中要求每秒钟执行一次\",{\"1\":{\"428\":1}}],[\"题目中要求并发安全\",{\"1\":{\"421\":1}}],[\"题目中是无法正常得到people的name值的\",{\"1\":{\"393\":1}}],[\"题目最后输出顺序应该是defer\",{\"1\":{\"405\":1}}],[\"触发异常\",{\"1\":{\"405\":1}}],[\"触发器\",{\"1\":{\"170\":1}}],[\"触发器的使用场景有哪些\",{\"0\":{\"170\":1}}],[\"循环\",{\"1\":{\"502\":1}}],[\"循环永远无法退出\",{\"1\":{\"401\":1}}],[\"循环会始终成立\",{\"1\":{\"401\":1}}],[\"到\",{\"1\":{\"401\":2}}],[\"依据4个goroutine的启动后执行效率\",{\"1\":{\"400\":1}}],[\"依次计算每个entry新的空间占用\",{\"1\":{\"299\":1}}],[\"既然出现\",{\"1\":{\"395\":1}}],[\"既然说到全局运行队列\",{\"1\":{\"29\":1}}],[\"私有属性name也不应该加json的标签\",{\"1\":{\"393\":1}}],[\"编译失败\",{\"1\":{\"414\":1}}],[\"编译阶段就会报错\",{\"1\":{\"392\":1}}],[\"编码\",{\"1\":{\"339\":1}}],[\"编码方式同len\",{\"1\":{\"301\":1}}],[\"共发现两个问题\",{\"1\":{\"391\":1}}],[\"共享锁都相斥\",{\"1\":{\"157\":1}}],[\"共享锁可以同时加上多个\",{\"1\":{\"157\":1}}],[\"共享锁\",{\"1\":{\"157\":1}}],[\"赋值\",{\"1\":{\"374\":1}}],[\"赋值给str\",{\"1\":{\"374\":1}}],[\"翻转一个给定的字符串\",{\"1\":{\"374\":1}}],[\"翻转字符串其实是将一个字符串以中间字符为轴\",{\"1\":{\"374\":1}}],[\"翻转字符串\",{\"0\":{\"373\":1,\"374\":1},\"1\":{\"362\":1}}],[\"打印的变量\",{\"1\":{\"490\":1}}],[\"打印后\",{\"1\":{\"405\":1}}],[\"打印中\",{\"1\":{\"405\":1}}],[\"打印前\",{\"1\":{\"405\":1}}],[\"打印字母\",{\"1\":{\"366\":1}}],[\"打印数字\",{\"1\":{\"366\":1}}],[\"机器人位于\",{\"1\":{\"386\":1}}],[\"机器人坐标问题\",{\"0\":{\"385\":1,\"386\":1}}],[\"机器人坐标计算\",{\"1\":{\"362\":1}}],[\"机制的原理及实现\",{\"0\":{\"210\":1}}],[\"交替打印序列\",{\"1\":{\"366\":1}}],[\"交替打印数字和字母\",{\"0\":{\"365\":1,\"366\":1},\"1\":{\"362\":1}}],[\"交叉连接\",{\"0\":{\"137\":1},\"1\":{\"137\":1,\"174\":2}}],[\"控制redis最大使用内存\",{\"1\":{\"358\":1}}],[\"降低fork的频率\",{\"1\":{\"358\":1}}],[\"降低mysql的读写压力\",{\"1\":{\"274\":1}}],[\"性能与实践\",{\"0\":{\"358\":1}}],[\"性能能逼近各种搜索树结构\",{\"1\":{\"297\":1}}],[\"完成文件的替换工作\",{\"1\":{\"356\":1}}],[\"完成身份验证后\",{\"1\":{\"123\":1}}],[\"追加方便\",{\"1\":{\"356\":1}}],[\"追加写\",{\"1\":{\"244\":1}}],[\"影响整体性能\",{\"1\":{\"356\":1}}],[\"线上应该禁止使用\",{\"1\":{\"355\":1}}],[\"线程本地存储其实就是线程私有的全局变量\",{\"1\":{\"29\":1}}],[\"线程模型与调度器\",{\"0\":{\"28\":1}}],[\"线程数等于cpu个数的原因是\",{\"1\":{\"19\":1}}],[\"线程与锁\",{\"1\":{\"16\":1}}],[\"手动触发\",{\"1\":{\"356\":1}}],[\"手动触发可以使用\",{\"1\":{\"355\":1}}],[\"手册地址\",{\"1\":{\"238\":1,\"262\":1}}],[\"针对rdb方式的持久化\",{\"1\":{\"355\":1}}],[\"针对于精确查询hash更加稳定\",{\"1\":{\"253\":1}}],[\"针对于大数据表\",{\"1\":{\"252\":1}}],[\"必须在堆上分配\",{\"1\":{\"489\":1}}],[\"必须修复后才能重新加载\",{\"1\":{\"353\":1}}],[\"必须注意\",{\"1\":{\"6\":1}}],[\"毕竟redis本身就属于cpu密集型服务器\",{\"1\":{\"352\":1}}],[\"希望能够让大家更全面\",{\"1\":{\"350\":1}}],[\"衰减周期\",{\"1\":{\"347\":1}}],[\"饱和因子\",{\"1\":{\"347\":1}}],[\"延迟采样\",{\"1\":{\"346\":1}}],[\"延迟监控结束\",{\"1\":{\"346\":1}}],[\"延迟监控开始\",{\"1\":{\"346\":1}}],[\"目标对象\",{\"1\":{\"346\":1}}],[\"目前我用的方式是声明一个没有缓冲的chan\",{\"1\":{\"431\":1}}],[\"目前redis没有提供其它实现\",{\"1\":{\"300\":1}}],[\"目前已出现的事务id的最大值\",{\"1\":{\"215\":1}}],[\"淘汰key计数\",{\"1\":{\"346\":1}}],[\"淘汰池函数\",{\"1\":{\"346\":1}}],[\"淘宝和天猫是两种不同的系统\",{\"1\":{\"265\":1}}],[\"淘宝\",{\"1\":{\"85\":1}}],[\"效果非常接近理论lru\",{\"1\":{\"346\":1}}],[\"效率大于索引合并\",{\"1\":{\"143\":1}}],[\"效率是否稳定\",{\"1\":{\"88\":1}}],[\"得出增加采样值\",{\"1\":{\"346\":1}}],[\"得出相同采样值下\",{\"1\":{\"346\":1}}],[\"采样值设置通过maxmemory\",{\"1\":{\"346\":1}}],[\"采样值为5\",{\"1\":{\"346\":2}}],[\"采样值为10\",{\"1\":{\"346\":1}}],[\"采用消息队列缓存请求\",{\"1\":{\"268\":1}}],[\"绿色区域\",{\"1\":{\"346\":1}}],[\"灰色区域\",{\"1\":{\"346\":1}}],[\"浅灰色区域\",{\"1\":{\"346\":1}}],[\"精确lru会占用较大内存记录历史状态\",{\"1\":{\"346\":1}}],[\"易失key的ttl淘汰\",{\"1\":{\"345\":1}}],[\"易失key的随机\",{\"1\":{\"345\":1}}],[\"易失key的lru\",{\"1\":{\"345\":1}}],[\"易缓存\",{\"1\":{\"232\":1}}],[\"往往不仅能解答问题\",{\"1\":{\"342\":1}}],[\"往往使用索引时都不尽任意\",{\"1\":{\"252\":1}}],[\"积攒了10多\",{\"1\":{\"342\":1}}],[\"举例\",{\"0\":{\"490\":1}}],[\"举几个简单的例子\",{\"1\":{\"341\":1}}],[\"举个粟子\",{\"1\":{\"292\":1}}],[\"举个简单的例子\",{\"1\":{\"152\":1}}],[\"导入时是否检查\",{\"1\":{\"352\":1}}],[\"导入方法\",{\"0\":{\"341\":1}}],[\"导入到数据库中之后\",{\"1\":{\"340\":1}}],[\"导致写的ch\",{\"1\":{\"462\":1}}],[\"导致redis读写性能下降\",{\"1\":{\"355\":1}}],[\"导致全量复制\",{\"1\":{\"326\":1}}],[\"导致结点占用的内存增长\",{\"1\":{\"299\":1}}],[\"导致无法快速恢复\",{\"1\":{\"285\":1}}],[\"导致数据源请求暴增而崩溃\",{\"1\":{\"284\":1}}],[\"导致数据源压力骤增而崩溃\",{\"1\":{\"283\":1}}],[\"导致大量请求同时进行数据回源\",{\"1\":{\"283\":1}}],[\"导致这个现象的原因其实是二叉查找树变得不平衡了\",{\"1\":{\"68\":1}}],[\"例子\",{\"1\":{\"339\":1}}],[\"例如小说视频等网站需要对用户上传的小说视频做排行榜\",{\"1\":{\"278\":1}}],[\"例如微博的时间轴\",{\"1\":{\"276\":1}}],[\"例如checksum\",{\"1\":{\"203\":1}}],[\"例如zabbix\",{\"1\":{\"202\":1}}],[\"例如可以生成某些业务的编号\",{\"1\":{\"170\":1}}],[\"例如\",{\"1\":{\"42\":1,\"469\":1}}],[\"略低于实际值\",{\"1\":{\"339\":1}}],[\"安装\",{\"0\":{\"336\":1,\"337\":1}}],[\"安全\",{\"1\":{\"296\":1}}],[\"安全迭代器保证\",{\"1\":{\"296\":1}}],[\"安全迭代器\",{\"1\":{\"296\":1}}],[\"安全性越高\",{\"1\":{\"245\":1}}],[\"安全等等\",{\"1\":{\"136\":1}}],[\"转为指针指向的实际内容\",{\"1\":{\"496\":1}}],[\"转储成\",{\"1\":{\"335\":1}}],[\"转成顺序写\",{\"1\":{\"251\":1}}],[\"版可以在控制台上可以进行数据备份和下载的操作\",{\"1\":{\"334\":1}}],[\"版本号\",{\"1\":{\"212\":1}}],[\"版本以前\",{\"1\":{\"126\":1}}],[\"云数据库\",{\"1\":{\"334\":1}}],[\"整个过程也比较简单\",{\"1\":{\"342\":1}}],[\"整个分析的过程简单而实用\",{\"1\":{\"333\":1}}],[\"整个intset都要进行升级\",{\"1\":{\"298\":1}}],[\"生成新的数组\",{\"1\":{\"438\":1}}],[\"生成内存快照的命令为\",{\"1\":{\"339\":1}}],[\"生成内存快照\",{\"0\":{\"335\":1,\"339\":1},\"1\":{\"335\":1}}],[\"生成\",{\"1\":{\"333\":1,\"334\":1,\"339\":1}}],[\"背景\",{\"0\":{\"333\":1}}],[\"十\",{\"0\":{\"329\":1}}],[\"暂时屏蔽客户端对该从节点的访问\",{\"1\":{\"328\":1}}],[\"暂存的处理器\",{\"1\":{\"19\":1}}],[\"宽带\",{\"1\":{\"327\":1}}],[\"测试主节点连接从节点的时间\",{\"1\":{\"326\":1}}],[\"测试数据\",{\"1\":{\"310\":1}}],[\"伴随着从节点偏移量越界\",{\"1\":{\"326\":1}}],[\"纵使让所有从节点认为还是之前的主节点\",{\"1\":{\"325\":1}}],[\"知道golang的内存逃逸吗\",{\"1\":{\"488\":1}}],[\"知道系统是怎么优化的即可\",{\"1\":{\"325\":1}}],[\"知道第一个不满足条件的记录\",{\"1\":{\"250\":1}}],[\"九\",{\"0\":{\"324\":1}}],[\"清晰的认识这两种持久化方式\",{\"1\":{\"350\":1}}],[\"清空数据\",{\"1\":{\"322\":1}}],[\"清除闲置内存空间责任应当由sds的使用者自行担当\",{\"1\":{\"294\":1}}],[\"清除的\",{\"1\":{\"8\":1}}],[\"咔咔这边是预留出了30\",{\"1\":{\"322\":1}}],[\"咔咔这次用时俩天时间给大家整理一份redis主从复制的全部知识点\",{\"1\":{\"304\":1}}],[\"八\",{\"0\":{\"320\":1}}],[\"心跳阶段的注意事项\",{\"1\":{\"319\":1}}],[\"心跳机制\",{\"0\":{\"319\":1}}],[\"七\",{\"0\":{\"319\":1}}],[\"七周七并发模型\",{\"1\":{\"16\":1}}],[\"六\",{\"0\":{\"318\":1}}],[\"部分复制的三大核心\",{\"1\":{\"329\":1}}],[\"部分复制的三个核心要素\",{\"0\":{\"320\":1}}],[\"部分复制\",{\"1\":{\"316\":1}}],[\"身份验证\",{\"1\":{\"315\":1}}],[\"五\",{\"0\":{\"313\":1}}],[\"启动一个写goroutine\",{\"1\":{\"502\":1}}],[\"启动一个读goroutine\",{\"1\":{\"502\":1}}],[\"启动时会先检查aof文件是否存在\",{\"1\":{\"357\":1}}],[\"启动redis服务器时启动\",{\"0\":{\"311\":1}}],[\"启用熔断限流机制\",{\"1\":{\"285\":1}}],[\"启用后将会对在未来版本中可能无法正常工作的代码给出警告\",{\"1\":{\"262\":1}}],[\"启用\",{\"1\":{\"262\":1}}],[\"四\",{\"0\":{\"308\":1}}],[\"尤其在写少读多的情况下\",{\"1\":{\"307\":1}}],[\"别着急\",{\"1\":{\"306\":1}}],[\"别的线程都无法修改这些记录\",{\"1\":{\"98\":1}}],[\"别的线程都得拒之门外~\",{\"1\":{\"98\":1}}],[\"固定值1字节\",{\"1\":{\"301\":1}}],[\"称为一个entry\",{\"1\":{\"301\":1}}],[\"扩展性强悍\",{\"1\":{\"301\":1}}],[\"扩容操作是步进式的\",{\"1\":{\"296\":1}}],[\"扩容整个过程仅是各种指针的操作\",{\"1\":{\"296\":1}}],[\"扩容的操作是平滑的\",{\"1\":{\"296\":1}}],[\"扩容等问题\",{\"1\":{\"86\":1}}],[\"想像一个\",{\"1\":{\"489\":1}}],[\"想知道自己\",{\"1\":{\"333\":1}}],[\"想想都蛋疼\",{\"1\":{\"300\":1}}],[\"想要查找数据我们还需要根据主键再去聚集索引中进行查找\",{\"1\":{\"71\":1}}],[\"持久化做完了\",{\"1\":{\"357\":1}}],[\"持久化的配置\",{\"0\":{\"351\":1},\"1\":{\"350\":1}}],[\"持久性\",{\"1\":{\"106\":1,\"107\":1,\"194\":1,\"223\":1,\"245\":1}}],[\"持续发送ping命令\",{\"1\":{\"315\":1}}],[\"持有的是原生的ziplist\",{\"1\":{\"300\":1}}],[\"值一直为\",{\"1\":{\"478\":1}}],[\"值\",{\"1\":{\"478\":1}}],[\"值x\",{\"1\":{\"386\":1}}],[\"值越小代表饱和速度越快\",{\"1\":{\"347\":1}}],[\"值得注意的\",{\"1\":{\"345\":1}}],[\"值即为数目\",{\"1\":{\"300\":1}}],[\"值类型\",{\"1\":{\"414\":1}}],[\"值类型的实例的method\",{\"1\":{\"46\":1}}],[\"值类型实例是一个method\",{\"1\":{\"46\":1}}],[\"值类型和指针类型\",{\"1\":{\"43\":1}}],[\"微观上\",{\"1\":{\"300\":1}}],[\"蛋疼说的是\",{\"1\":{\"299\":1}}],[\"级别\",{\"1\":{\"299\":1}}],[\"级别的查找开销\",{\"1\":{\"298\":1}}],[\"甚至对于\",{\"1\":{\"299\":1}}],[\"低四位的值从0001至1101\",{\"1\":{\"299\":1}}],[\"低六位值以无符号整数的形式存储着二进制数据的长度\",{\"1\":{\"299\":1}}],[\"规约如下\",{\"1\":{\"299\":1}}],[\"概览如下图\",{\"1\":{\"299\":1}}],[\"概念\",{\"1\":{\"1\":1}}],[\"省略部分逻辑\",{\"1\":{\"484\":1}}],[\"省略其他\",{\"1\":{\"483\":2}}],[\"省内存\",{\"1\":{\"299\":1}}],[\"省是省了\",{\"1\":{\"298\":1}}],[\"宏观上\",{\"1\":{\"300\":2}}],[\"宏\",{\"1\":{\"297\":2}}],[\"核心代码片断如下\",{\"1\":{\"297\":1}}],[\"伪代码如下\",{\"1\":{\"297\":1}}],[\"伪装成一个\",{\"1\":{\"116\":1}}],[\"紧邻的两个结点之间的距离定义为1\",{\"1\":{\"297\":1}}],[\"距离当前结点的距离\",{\"1\":{\"297\":1}}],[\"跳跃表的实现比较简单\",{\"1\":{\"297\":1}}],[\"跳跃表主要用于\",{\"1\":{\"297\":1}}],[\"跳跃表中的结点按结点的得分升序排列\",{\"1\":{\"297\":1}}],[\"跳跃表是一种基于线性表实现简单的搜索结构\",{\"1\":{\"297\":1}}],[\"头结点不持有任何数据\",{\"1\":{\"297\":1}}],[\"头部剩余节点数量不够一组的不需要逆序\",{\"1\":{\"469\":1}}],[\"头部\",{\"1\":{\"294\":3}}],[\"头部的类型\",{\"1\":{\"294\":1}}],[\"血统纯正的跳跃表的介绍在维基百科中即可查阅\",{\"1\":{\"297\":1}}],[\"检查是否旧表中的所有结点都被迁移到了新表\",{\"1\":{\"296\":1}}],[\"检索\",{\"1\":{\"246\":1}}],[\"置rehashidx为0\",{\"1\":{\"296\":1}}],[\"探测是否需要扩容\",{\"1\":{\"296\":1}}],[\"迭代器\",{\"1\":{\"296\":1}}],[\"迭代器listiter的定义\",{\"1\":{\"295\":1}}],[\"旧表一个索引位上的\",{\"1\":{\"296\":1}}],[\"旧数据\",{\"1\":{\"287\":1,\"288\":1}}],[\"速度非常快\",{\"1\":{\"296\":1}}],[\"速度慢的原因\",{\"1\":{\"231\":1}}],[\"迁移所有结点必然会导致耗时陡增\",{\"1\":{\"296\":1}}],[\"迁移到新表后\",{\"1\":{\"296\":2}}],[\"迁移到ht\",{\"1\":{\"296\":1}}],[\"迁移的进度保存在rehashidx这个字段中\",{\"1\":{\"296\":1}}],[\"替换\",{\"1\":{\"296\":2}}],[\"顺序表中存储的是dictentry的指针\",{\"1\":{\"296\":1}}],[\"传统的哈希表实现\",{\"1\":{\"296\":1}}],[\"传输数据\",{\"1\":{\"187\":1}}],[\"入参指向的字符串中的所有字符\",{\"1\":{\"294\":1}}],[\"拷贝initlen个字节\",{\"1\":{\"294\":1}}],[\"带数据创建一个sds\",{\"1\":{\"294\":2}}],[\"占一字节\",{\"1\":{\"294\":3}}],[\"占用大量的cpu\",{\"1\":{\"327\":1}}],[\"占用三个字节\",{\"1\":{\"299\":1}}],[\"占用空间大\",{\"1\":{\"183\":1}}],[\"占用2个机器字长\",{\"1\":{\"45\":1}}],[\"末尾\",{\"1\":{\"294\":3}}],[\"剩余四个字节\",{\"1\":{\"299\":1}}],[\"剩余的14个位\",{\"1\":{\"299\":1}}],[\"剩余的字节数\",{\"1\":{\"294\":1}}],[\"剩余字节数\",{\"1\":{\"294\":1}}],[\"附加了后向指针的跳跃表\",{\"1\":{\"292\":1}}],[\"各个type的value到底如何存储\",{\"1\":{\"292\":1}}],[\"各个字段\",{\"1\":{\"42\":1}}],[\"底层共享一个数组\",{\"1\":{\"438\":1}}],[\"底层数据结构\",{\"0\":{\"292\":1,\"293\":1},\"1\":{\"292\":1}}],[\"底层是数组\",{\"1\":{\"41\":1}}],[\"推荐cache\",{\"1\":{\"288\":1}}],[\"架构设计应根据实际场景取舍\",{\"1\":{\"288\":1}}],[\"技术选型\",{\"1\":{\"288\":1}}],[\"成为memcached的有效替代方案\",{\"1\":{\"345\":1}}],[\"成本较高\",{\"1\":{\"288\":1}}],[\"成立说明秒杀失败\",{\"1\":{\"268\":1}}],[\"成立的话就说明秒杀失败\",{\"1\":{\"268\":1}}],[\"成立故可见则返回\",{\"1\":{\"219\":1}}],[\"成立故可见\",{\"1\":{\"219\":1}}],[\"成立故返回发现前面的\",{\"1\":{\"219\":1}}],[\"成立故返回\",{\"1\":{\"219\":2}}],[\"需跟踪哪些cache更新\",{\"1\":{\"288\":1}}],[\"需要在协程开始出调用\",{\"1\":{\"397\":1}}],[\"需要仔细处理邻近结点的所有level\",{\"1\":{\"297\":1}}],[\"需要特别注意的是带\",{\"1\":{\"262\":1}}],[\"需要合理优化你的索引\",{\"1\":{\"159\":1}}],[\"需要准备好面试官问你的分库分表相关问题呀\",{\"1\":{\"109\":1}}],[\"需要用分布式事务啦\",{\"1\":{\"86\":1}}],[\"需要等待多少读锁释放的数量\",{\"1\":{\"58\":1}}],[\"需要重复写if结构\",{\"1\":{\"48\":1}}],[\"需要引入一个数据结构来保存cpu寄存器的值以及goroutine的其它一些状态信息\",{\"1\":{\"29\":1}}],[\"需要强调的是\",{\"1\":{\"28\":1}}],[\"需要监听端口\",{\"1\":{\"12\":1}}],[\"需要注意的是要记住\",{\"1\":{\"262\":1}}],[\"需要注意的是\",{\"1\":{\"7\":1}}],[\"强一致性和高性能的冲突\",{\"1\":{\"288\":1}}],[\"合理配置linux的内存分配策略\",{\"1\":{\"358\":1}}],[\"合理使用子查询\",{\"1\":{\"232\":1}}],[\"合并多个操作\",{\"1\":{\"288\":1}}],[\"何时更新缓存呢\",{\"1\":{\"288\":1}}],[\"何时使用聚簇索引与非聚簇索引\",{\"0\":{\"151\":1}}],[\"何时使用聚集索引或非聚集索引\",{\"1\":{\"92\":1}}],[\"几点要求\",{\"1\":{\"288\":1}}],[\"几种更新缓存的策略\",{\"0\":{\"288\":1}}],[\"几种排序信息\",{\"1\":{\"130\":1}}],[\"失效缓存\",{\"1\":{\"288\":1}}],[\"命中缓存时\",{\"1\":{\"288\":1}}],[\"命中缓存则返回\",{\"1\":{\"287\":1}}],[\"命令会改变值z\",{\"1\":{\"386\":1}}],[\"命令合并\",{\"1\":{\"356\":1}}],[\"命令写入=>追加到aof\",{\"1\":{\"356\":1}}],[\"命令传播阶段的心跳机制\",{\"1\":{\"329\":1}}],[\"命令传播阶段的部分复制\",{\"1\":{\"317\":1}}],[\"命令传播阶段\",{\"0\":{\"317\":1}}],[\"命令传播过程\",{\"1\":{\"314\":1}}],[\"命令其实只是把记录的位置\",{\"1\":{\"255\":1}}],[\"命令\",{\"1\":{\"238\":1}}],[\"命令观察\",{\"1\":{\"190\":1}}],[\"命令了解各种\",{\"1\":{\"103\":1}}],[\"过滤器实现机制和数据一致性要求\",{\"1\":{\"286\":1}}],[\"防穿透\",{\"1\":{\"286\":1}}],[\"防止出现内存\",{\"1\":{\"358\":1}}],[\"防止fork耗时过长\",{\"1\":{\"358\":1}}],[\"防止新写的file丢失数据\",{\"1\":{\"356\":1}}],[\"防止了内存泄漏\",{\"1\":{\"8\":1}}],[\"防止内存泄漏\",{\"1\":{\"8\":1}}],[\"专用过滤\",{\"1\":{\"286\":1}}],[\"布隆过滤器bloomfilter或压缩filter过滤有效资源\",{\"1\":{\"286\":1}}],[\"仍有其他缓存系统可用\",{\"1\":{\"285\":1}}],[\"事件通知\",{\"1\":{\"346\":1}}],[\"事后\",{\"1\":{\"285\":1}}],[\"事后不同阶段考虑\",{\"1\":{\"285\":1}}],[\"事前\",{\"1\":{\"285\":1}}],[\"事故中\",{\"1\":{\"285\":2}}],[\"事务默认都是开启的\",{\"1\":{\"245\":1}}],[\"事务隔离的实现\",{\"1\":{\"245\":1}}],[\"事务c有一次进行了\",{\"1\":{\"219\":1}}],[\"事务c产生的\",{\"1\":{\"218\":1}}],[\"事务b已经进行了提交\",{\"1\":{\"219\":1}}],[\"事务b\",{\"1\":{\"218\":1}}],[\"事务b的id为3\",{\"1\":{\"218\":1}}],[\"事务在进行\",{\"1\":{\"215\":1}}],[\"事务在插入新记录产生的undo\",{\"1\":{\"215\":1}}],[\"事务的隔离级别\",{\"1\":{\"245\":1}}],[\"事务的隔离级别有哪些\",{\"0\":{\"95\":1}}],[\"事务的特性\",{\"1\":{\"245\":1}}],[\"事务的回滚日志\",{\"1\":{\"215\":1}}],[\"事务字段\",{\"1\":{\"215\":1}}],[\"事务id\",{\"1\":{\"215\":2,\"219\":1}}],[\"事务开始时给\",{\"1\":{\"212\":1}}],[\"事务是如何通过日志来实现的\",{\"0\":{\"199\":1}}],[\"事务\",{\"0\":{\"245\":1},\"1\":{\"154\":1,\"218\":1}}],[\"事务版本号\",{\"1\":{\"115\":1}}],[\"事务之间是相互隔离的\",{\"1\":{\"106\":1}}],[\"事务作为一个整体被执行\",{\"1\":{\"106\":1}}],[\"事务acid特性的实现思想\",{\"0\":{\"107\":1}}],[\"事务a查询一个范围的结果集\",{\"1\":{\"96\":1}}],[\"事务a被事务b干扰到了\",{\"1\":{\"96\":1}}],[\"事务a\",{\"1\":{\"96\":1}}],[\"事务问题\",{\"1\":{\"86\":1,\"109\":1}}],[\"且缓存为空的情况下\",{\"1\":{\"484\":1}}],[\"且返回的第二个\",{\"1\":{\"478\":1}}],[\"且需要实现以下接口\",{\"1\":{\"421\":1}}],[\"且需要在下一次操作时重新压缩\",{\"1\":{\"300\":1}}],[\"且可以用for循环来读取数据\",{\"1\":{\"418\":1}}],[\"且考虑字符串重点空格\",{\"1\":{\"378\":1}}],[\"且字符串小于等于3000\",{\"1\":{\"370\":1}}],[\"且长度都很小时\",{\"1\":{\"301\":1}}],[\"且二进制数据的长度大于或等于16384字节\",{\"1\":{\"299\":1}}],[\"且二进制数据长度大于或等于64字节\",{\"1\":{\"299\":1}}],[\"且二进制数据长度小于64字节\",{\"1\":{\"299\":1}}],[\"且其level\",{\"1\":{\"297\":1}}],[\"且新的索引位的值可能比旧的索引位要低\",{\"1\":{\"296\":1}}],[\"且由于缓存系统故障无法回写缓存\",{\"1\":{\"285\":1}}],[\"且主键的取值不能缺失\",{\"1\":{\"172\":1}}],[\"具有动态扩容的特点\",{\"1\":{\"294\":1}}],[\"具备持续扩容能力\",{\"1\":{\"282\":1}}],[\"具体解释见\",{\"1\":{\"392\":1}}],[\"具体为\",{\"1\":{\"300\":1}}],[\"具体数据在内存中以何种数据结构存放\",{\"1\":{\"292\":1}}],[\"具体参考\",{\"1\":{\"262\":1}}],[\"具体可参考\",{\"1\":{\"262\":1}}],[\"具体可参考php官方手册\",{\"1\":{\"262\":1}}],[\"具体可以参考\",{\"1\":{\"234\":1,\"235\":1}}],[\"具体使用方法可以参考php官方手册\",{\"1\":{\"262\":1}}],[\"具体相关实现可以参考\",{\"1\":{\"238\":1}}],[\"具体视图相关可以参考\",{\"1\":{\"235\":1}}],[\"具体字段代替\",{\"1\":{\"189\":1}}],[\"具体到goroutine调度器代码\",{\"1\":{\"29\":1}}],[\"具体的查找过程如下\",{\"1\":{\"72\":1}}],[\"具体的调整方式这里就不介绍了\",{\"1\":{\"68\":1}}],[\"具体的实现原理和细节将从本章开始进行全面介绍\",{\"1\":{\"28\":1}}],[\"具体的执行请求返回响应的方法\",{\"1\":{\"12\":1}}],[\"具体处理请求的代码是这个\",{\"1\":{\"12\":1}}],[\"具体连接的处理在conn\",{\"1\":{\"12\":1}}],[\"具体要看\",{\"1\":{\"12\":1}}],[\"较少使用\",{\"1\":{\"282\":1}}],[\"受机械磁盘寻道性能限制\",{\"1\":{\"282\":1}}],[\"极大减轻原始数据读取的压力\",{\"1\":{\"282\":1}}],[\"穿透\",{\"0\":{\"281\":1}}],[\"做了很多额外工作\",{\"1\":{\"299\":1}}],[\"做排行\",{\"1\":{\"278\":1}}],[\"做一些简单的逻辑处理\",{\"1\":{\"268\":1}}],[\"榜单可以按照用户关注数\",{\"1\":{\"278\":1}}],[\"收藏等\",{\"1\":{\"277\":1}}],[\"点赞\",{\"1\":{\"277\":1}}],[\"差集\",{\"1\":{\"277\":1}}],[\"集合中的元素是无序的\",{\"1\":{\"277\":1}}],[\"集合类型也是用来保存多个字符串的元素\",{\"1\":{\"277\":1}}],[\"集合\",{\"0\":{\"277\":1}}],[\"展示新的列表信息\",{\"1\":{\"276\":1}}],[\"消息队列\",{\"1\":{\"276\":1}}],[\"消耗\",{\"1\":{\"251\":2}}],[\"消耗资源多\",{\"1\":{\"238\":1}}],[\"消耗资源并不多\",{\"1\":{\"190\":1}}],[\"视频信息等\",{\"1\":{\"275\":1}}],[\"视图\",{\"0\":{\"235\":1}}],[\"视图对重构数据库提供了一定程度的逻辑独立性\",{\"1\":{\"166\":1}}],[\"视图使用户能以多种角度看待同一数据\",{\"1\":{\"166\":1}}],[\"视图能简化用户的操作\",{\"1\":{\"166\":1}}],[\"视图可返回与底层表的表示和格式不同的数据\",{\"1\":{\"165\":1}}],[\"视图用途\",{\"1\":{\"164\":1}}],[\"视图的优点\",{\"0\":{\"166\":1}}],[\"视图的常见使用场景\",{\"0\":{\"165\":1}}],[\"视图的建立和删除不影响基本表\",{\"1\":{\"164\":1}}],[\"视图的列可以来自不同的表\",{\"1\":{\"164\":1}}],[\"视图是由基本表\",{\"1\":{\"164\":1}}],[\"视图是一个虚拟的表\",{\"1\":{\"162\":1}}],[\"视图特点\",{\"0\":{\"164\":1}}],[\"视图有哪些特点\",{\"0\":{\"163\":1}}],[\"视图由一个预定义的查询select语句组成\",{\"1\":{\"162\":1}}],[\"图4approx\",{\"1\":{\"346\":1}}],[\"图3approx\",{\"1\":{\"346\":1}}],[\"图2approx\",{\"1\":{\"346\":1}}],[\"图1theoretical\",{\"1\":{\"346\":1}}],[\"图片或者视频等信息放到redis中\",{\"1\":{\"274\":1}}],[\"图中的每个节点称为页\",{\"1\":{\"69\":1}}],[\"图中的p节点为指向子节点的指针\",{\"1\":{\"69\":1}}],[\"图中的圆为二叉查找树的节点\",{\"1\":{\"67\":1}}],[\"经典淘汰算法在redis实现中有一定优化设计\",{\"1\":{\"345\":1}}],[\"经典使用场景\",{\"1\":{\"274\":1}}],[\"经验主义调参\",{\"1\":{\"300\":1}}],[\"经过一系列相关处理\",{\"1\":{\"12\":1}}],[\"抢购失败\",{\"1\":{\"269\":1}}],[\"抢占调度标志\",{\"1\":{\"33\":1}}],[\"抢占调度也会用到stackguard0\",{\"1\":{\"33\":1}}],[\"抢占信号\",{\"1\":{\"19\":1}}],[\"超时用到的time\",{\"1\":{\"431\":1}}],[\"超过了\",{\"1\":{\"397\":1}}],[\"超过60秒\",{\"1\":{\"327\":1}}],[\"超过2^32\",{\"1\":{\"299\":1}}],[\"超出了复制缓冲区的内存\",{\"1\":{\"322\":1}}],[\"超卖问题\",{\"0\":{\"269\":1}}],[\"超键\",{\"0\":{\"172\":1},\"1\":{\"172\":1}}],[\"停止数据同步\",{\"1\":{\"319\":1}}],[\"停止所有后续插入\",{\"1\":{\"268\":1}}],[\"停止检索\",{\"1\":{\"250\":1}}],[\"库存数量便是原子变量的最大值\",{\"1\":{\"268\":1}}],[\"库存修改\",{\"1\":{\"268\":1}}],[\"作为一种数据结构工具使用\",{\"1\":{\"295\":1}}],[\"作为排序的依据\",{\"1\":{\"278\":1}}],[\"作为key\",{\"1\":{\"268\":1}}],[\"作者\",{\"1\":{\"23\":1,\"207\":1,\"219\":1,\"329\":1,\"358\":1,\"503\":2}}],[\"随机\",{\"1\":{\"345\":1}}],[\"随机生成新结点的\",{\"1\":{\"297\":1}}],[\"随机选取用户执行秒杀逻辑\",{\"1\":{\"268\":1}}],[\"随着插入操作\",{\"1\":{\"296\":1}}],[\"随着请求的增加怎么保持服务的快速响应\",{\"1\":{\"268\":1}}],[\"随着后面对代码逐步深入的分析\",{\"1\":{\"30\":1}}],[\"缓存不满足强一致性要求\",{\"1\":{\"288\":1}}],[\"缓存异步批量更新数据源\",{\"1\":{\"288\":1}}],[\"缓存已过期\",{\"1\":{\"288\":1}}],[\"缓存过期的背景下\",{\"1\":{\"288\":1}}],[\"缓存失效时回源取数据\",{\"1\":{\"288\":1}}],[\"缓存失效时间离散化\",{\"1\":{\"284\":1}}],[\"缓存中为旧数据\",{\"1\":{\"287\":1}}],[\"缓存更新的套路系统了解\",{\"1\":{\"287\":1}}],[\"缓存更新与数据一致性\",{\"0\":{\"287\":1},\"1\":{\"281\":1}}],[\"缓存时间的设置视情况而定\",{\"1\":{\"284\":1}}],[\"缓存时间设置原则\",{\"1\":{\"284\":1}}],[\"缓存数据持久化\",{\"1\":{\"285\":1}}],[\"缓存数据不一致的敏感性\",{\"1\":{\"284\":1}}],[\"缓存数据访问规律\",{\"1\":{\"284\":1}}],[\"缓存同时失效\",{\"0\":{\"284\":1}}],[\"缓存分类\",{\"1\":{\"282\":1}}],[\"缓存定位\",{\"1\":{\"282\":1}}],[\"缓存穿透是指访问不存在数据\",{\"1\":{\"286\":1}}],[\"缓存穿透\",{\"0\":{\"286\":1},\"1\":{\"281\":1}}],[\"缓存雪崩是指缓存系统失效\",{\"1\":{\"283\":1}}],[\"缓存雪崩\",{\"0\":{\"283\":1},\"1\":{\"281\":1}}],[\"缓存应用的典型场景\",{\"0\":{\"282\":1},\"1\":{\"281\":1}}],[\"缓存系统维护简单\",{\"1\":{\"288\":1}}],[\"缓存系统数据的更新策略是需要专门开题来说的\",{\"1\":{\"287\":1}}],[\"缓存系统空间利用较好\",{\"1\":{\"286\":1}}],[\"缓存系统被填充大量非法值\",{\"1\":{\"286\":1}}],[\"缓存系统整体故障\",{\"1\":{\"285\":1}}],[\"缓存系统故障\",{\"0\":{\"285\":1}}],[\"缓存系统崩溃\",{\"1\":{\"283\":1}}],[\"缓存系统一定程度上极大提升系统并发能力\",{\"1\":{\"281\":1}}],[\"缓存系统中面临的雪崩\",{\"0\":{\"281\":1}}],[\"缓存\",{\"1\":{\"274\":1,\"275\":1},\"2\":{\"290\":1}}],[\"缓存也是可以应对写请求的\",{\"1\":{\"268\":1}}],[\"缓存的计时器\",{\"1\":{\"19\":1}}],[\"业务分离\",{\"1\":{\"268\":1}}],[\"业务正确性优先\",{\"1\":{\"250\":1}}],[\"静态资源可以使用cdn加速\",{\"1\":{\"268\":1}}],[\"禁止重复提交和无限刷新等\",{\"1\":{\"268\":1}}],[\"购买按钮禁止\",{\"1\":{\"268\":1}}],[\"像秒杀活动页面一般都是访问比较高的\",{\"1\":{\"268\":1}}],[\"高四位是固定值\",{\"1\":{\"299\":1}}],[\"高两位值固定为0\",{\"1\":{\"299\":1}}],[\"高5位未使用\",{\"1\":{\"294\":1}}],[\"高可用和高性能的冲突终究会使trade\",{\"1\":{\"288\":1}}],[\"高性能\",{\"1\":{\"282\":1}}],[\"高并发下的锁与map的读写\",{\"0\":{\"424\":1}}],[\"高并发下的秒杀活动页面快速响应\",{\"1\":{\"268\":1}}],[\"高并发的同时\",{\"1\":{\"285\":1}}],[\"高并发的数据读取能力\",{\"1\":{\"282\":1}}],[\"高度也会很低\",{\"1\":{\"69\":1}}],[\"高度也会及其高\",{\"1\":{\"69\":1}}],[\"商品库存\",{\"1\":{\"268\":1}}],[\"商品库存的增减等等都是要考虑的\",{\"1\":{\"268\":1}}],[\"商品相关信息等\",{\"1\":{\"268\":1}}],[\"商品信息和库存都是固定的\",{\"1\":{\"268\":1}}],[\"商业转载请联系作者获得授权\",{\"1\":{\"23\":1,\"207\":1,\"219\":1,\"329\":1,\"358\":1,\"503\":2}}],[\"秒杀队列的key\",{\"1\":{\"268\":1}}],[\"秒杀限制库存\",{\"1\":{\"268\":1}}],[\"秒杀是指在指定时间范围内有限库存限制下的售卖行为\",{\"1\":{\"268\":1}}],[\"秒杀设计\",{\"0\":{\"268\":1}}],[\"秒杀活动\",{\"1\":{\"267\":1}}],[\"秒杀活动和超卖\",{\"0\":{\"267\":1}}],[\"容忍较小概率的不一致\",{\"1\":{\"288\":1}}],[\"容灾性\",{\"1\":{\"266\":1}}],[\"容量规划\",{\"1\":{\"86\":1}}],[\"容量为3\",{\"1\":{\"63\":1}}],[\"容量超过\",{\"1\":{\"63\":1}}],[\"容量变成原来的1\",{\"1\":{\"63\":1}}],[\"容量变成原来的\",{\"1\":{\"63\":1}}],[\"容量小于\",{\"1\":{\"63\":1}}],[\"容量的\",{\"1\":{\"63\":1}}],[\"容量满之前不会阻塞\",{\"1\":{\"3\":1}}],[\"均衡性\",{\"1\":{\"266\":1}}],[\"响应时间短的优先分配\",{\"1\":{\"266\":1}}],[\"轮询算法\",{\"1\":{\"266\":1}}],[\"算法\",{\"1\":{\"266\":1}}],[\"负载均衡相关知识可参考\",{\"1\":{\"266\":1}}],[\"负载均衡的主要作用就是根据不同的算法分发请求至服务集群中的某个节点\",{\"1\":{\"266\":1}}],[\"负载均衡是集群方案中的一种策略\",{\"1\":{\"266\":1}}],[\"负载均衡\",{\"0\":{\"266\":1}}],[\"负责对数据库的请求识别出读还是写\",{\"1\":{\"191\":1}}],[\"域名也不一样\",{\"1\":{\"265\":1}}],[\"浏览器有一种同源策略\",{\"1\":{\"265\":1}}],[\"地址\",{\"1\":{\"264\":1}}],[\"文件重写策略\",{\"1\":{\"353\":1}}],[\"文件保存路径\",{\"1\":{\"352\":1}}],[\"文件名称\",{\"1\":{\"352\":1,\"353\":1}}],[\"文件的工具\",{\"1\":{\"335\":1}}],[\"文件\",{\"1\":{\"333\":1,\"334\":1,\"335\":1}}],[\"文件级缓存依赖磁盘i\",{\"1\":{\"282\":1}}],[\"文件级缓存\",{\"1\":{\"282\":1}}],[\"文件改变它\",{\"1\":{\"264\":1}}],[\"文件写到一定大小后会切换到下一个\",{\"1\":{\"244\":1}}],[\"格式的内存报告\",{\"1\":{\"339\":1}}],[\"格式的话是记sql语句\",{\"1\":{\"244\":1}}],[\"格式\",{\"1\":{\"335\":1}}],[\"格式文件\",{\"1\":{\"334\":1}}],[\"格式如下\",{\"1\":{\"264\":1}}],[\"客户端收到cookie后会在每次请求的时候带上cookie\",{\"1\":{\"264\":1}}],[\"客户端和服务器端\",{\"1\":{\"264\":1}}],[\"及\",{\"1\":{\"262\":1}}],[\"错误并不能终止\",{\"1\":{\"405\":1}}],[\"错误\",{\"1\":{\"395\":1,\"428\":1}}],[\"错误的更新策略可能会先删除缓存\",{\"1\":{\"284\":1}}],[\"错误恢复脚本继续执行等等\",{\"1\":{\"262\":1}}],[\"错误和异常统一处理\",{\"1\":{\"262\":1}}],[\"错误异常处理类\",{\"1\":{\"262\":1}}],[\"错误处理\",{\"0\":{\"262\":1}}],[\"官方手册地址\",{\"1\":{\"262\":1}}],[\"官方考虑到go语言的发展\",{\"1\":{\"19\":1}}],[\"异步批量更新数据源\",{\"1\":{\"288\":1}}],[\"异步模式\",{\"1\":{\"3\":1}}],[\"异常处理\",{\"1\":{\"262\":1}}],[\"描述了最后错误的信息\",{\"1\":{\"262\":1}}],[\"标签\",{\"1\":{\"277\":1}}],[\"标准错误处理程序\",{\"1\":{\"262\":1}}],[\"标志为true\",{\"1\":{\"219\":1}}],[\"|\",{\"1\":{\"262\":4,\"370\":1}}],[\"||\",{\"1\":{\"219\":1,\"296\":3,\"346\":3,\"370\":1,\"378\":2,\"386\":4}}],[\"$head\",{\"1\":{\"339\":1}}],[\"$handler\",{\"1\":{\"264\":3}}],[\"$nums<=0\",{\"1\":{\"268\":1}}],[\"$nums\",{\"1\":{\"268\":1}}],[\"$request\",{\"1\":{\"266\":1}}],[\"$redis\",{\"1\":{\"264\":3,\"268\":3,\"269\":5}}],[\"$data\",{\"1\":{\"264\":2}}],[\"$id\",{\"1\":{\"264\":6}}],[\"$sessionname\",{\"1\":{\"264\":1}}],[\"$server\",{\"1\":{\"260\":1}}],[\"$savepath\",{\"1\":{\"264\":1}}],[\"$client\",{\"1\":{\"264\":3}}],[\"$context\",{\"1\":{\"262\":1}}],[\"$\",{\"1\":{\"264\":2}}],[\"$a\",{\"1\":{\"262\":2}}],[\"$type\",{\"1\":{\"262\":2}}],[\"$traceoffset\",{\"1\":{\"262\":1}}],[\"$this\",{\"1\":{\"262\":6,\"264\":6}}],[\"$exprie\",{\"1\":{\"264\":3}}],[\"$e\",{\"1\":{\"262\":1}}],[\"$errline\",{\"1\":{\"262\":2}}],[\"$errfile\",{\"1\":{\"262\":2}}],[\"$errstr\",{\"1\":{\"262\":2}}],[\"$errno\",{\"1\":{\"262\":2}}],[\"$error\",{\"1\":{\"262\":11}}],[\"$lifetime\",{\"1\":{\"264\":1}}],[\"$line\",{\"1\":{\"262\":2}}],[\"$level\",{\"1\":{\"262\":3}}],[\"$file\",{\"1\":{\"262\":2}}],[\"$message\",{\"1\":{\"262\":2}}],[\"致命错误和语法错误\",{\"1\":{\"262\":1}}],[\"致命错误\",{\"1\":{\"262\":1}}],[\"嗯\",{\"1\":{\"259\":1}}],[\"今天面试主要和面试官讨论这些问题\",{\"1\":{\"259\":1}}],[\"未有被初始化\",{\"1\":{\"463\":1}}],[\"未初始化\",{\"1\":{\"462\":1}}],[\"未实现接口people的方法\",{\"1\":{\"414\":1}}],[\"未被淘汰的键\",{\"1\":{\"346\":1}}],[\"未被同步到从服务器里\",{\"1\":{\"118\":1}}],[\"未使用的空间即为图中的free\",{\"1\":{\"301\":1}}],[\"未指定条件下\",{\"1\":{\"256\":1}}],[\"她可以存储在共享表空间里\",{\"1\":{\"255\":1}}],[\"她的心只属于当前事务\",{\"1\":{\"101\":1}}],[\"倒序和哈希两种方法都不支持范围查询\",{\"1\":{\"253\":1}}],[\"取值错误\",{\"1\":{\"507\":1}}],[\"取出该索引位上的结点链表\",{\"1\":{\"296\":1}}],[\"取前几个创建前缀索引\",{\"1\":{\"253\":1}}],[\"取得两张表中满足存在连接匹配关系的记录\",{\"1\":{\"137\":2}}],[\"里的内容\",{\"1\":{\"502\":1}}],[\"里的\",{\"1\":{\"484\":1,\"502\":3}}],[\"里的val地址\",{\"1\":{\"484\":1}}],[\"里的数据发生了变化\",{\"1\":{\"251\":1}}],[\"里指定的错误类型都会绕过\",{\"1\":{\"262\":1}}],[\"里面对应一棵\",{\"1\":{\"246\":1}}],[\"里面包括\",{\"1\":{\"199\":1}}],[\"里面\",{\"1\":{\"198\":1}}],[\"里面的权限是全局级的\",{\"1\":{\"139\":1}}],[\"里面的sql效率自然就高了\",{\"1\":{\"119\":1}}],[\"里面的属性一个是互斥锁\",{\"1\":{\"58\":1}}],[\"里面放一些case语句块\",{\"1\":{\"7\":1}}],[\"账单流水表\",{\"1\":{\"250\":1}}],[\"继续查找下一个记录\",{\"1\":{\"250\":1}}],[\"继续把12和当前节点的键值13比较\",{\"1\":{\"67\":1}}],[\"考虑此问题\",{\"1\":{\"285\":1}}],[\"考虑到存储空间的问题\",{\"1\":{\"246\":1}}],[\"考虑分表\",{\"1\":{\"182\":1}}],[\"父节点又小于右儿子\",{\"1\":{\"246\":1}}],[\"范围查询效率贼低\",{\"1\":{\"246\":1}}],[\"哈希表即是dictht结构\",{\"1\":{\"296\":1}}],[\"哈希冲突时使用链表把相同hash的值搞在一块\",{\"1\":{\"246\":1}}],[\"哈希\",{\"0\":{\"275\":1},\"1\":{\"246\":1}}],[\"哈哈\",{\"1\":{\"152\":1}}],[\"长事务是指执行时间长的sql变更\",{\"1\":{\"245\":1}}],[\"长事务占用大量的锁资源\",{\"1\":{\"245\":1}}],[\"长事务会占用较大的磁盘空间\",{\"1\":{\"245\":1}}],[\"长度是41位\",{\"1\":{\"325\":1}}],[\"长度为\",{\"1\":{\"176\":2}}],[\"长度为1\",{\"1\":{\"63\":1}}],[\"长度不够时会扩展\",{\"1\":{\"63\":1}}],[\"幻读\",{\"1\":{\"245\":1}}],[\"引用计数更新\",{\"1\":{\"346\":1}}],[\"引入了sizemask字段\",{\"1\":{\"296\":1}}],[\"引入了新的故障点\",{\"1\":{\"285\":1}}],[\"引入新的解决方案\",{\"1\":{\"285\":1}}],[\"引入的\",{\"1\":{\"127\":1}}],[\"引导mysql使用我们期望的索引\",{\"1\":{\"252\":1}}],[\"引擎将刚刚写入的redolog改成commit状态\",{\"1\":{\"244\":1}}],[\"拿到记录后执行器对指定字段的结果进行更改\",{\"1\":{\"244\":1}}],[\"属性或\",{\"1\":{\"393\":1}}],[\"属性\",{\"1\":{\"238\":1,\"391\":1}}],[\"属于索引组织表\",{\"1\":{\"87\":1}}],[\"属于内存级别的通信\",{\"1\":{\"1\":1}}],[\"搞清楚文档\",{\"1\":{\"238\":1}}],[\"参考文章\",{\"1\":{\"238\":1}}],[\"参数把\",{\"1\":{\"198\":1}}],[\"参数长度等信息以及调度相关属性更新之后\",{\"1\":{\"21\":1}}],[\"参数起始地址\",{\"1\":{\"21\":1}}],[\"顾名思义就是一行一行复制\",{\"1\":{\"238\":1}}],[\"备库\",{\"1\":{\"238\":1}}],[\"配合使用\",{\"1\":{\"358\":1}}],[\"配合读写分离\",{\"1\":{\"307\":1}}],[\"配合db权限表对给定主机上数据库级操作权限作更细致的控制\",{\"1\":{\"139\":1}}],[\"配置规则自动触发\",{\"1\":{\"355\":1}}],[\"配置\",{\"1\":{\"353\":1,\"356\":1}}],[\"配置其实非常简单\",{\"1\":{\"352\":1}}],[\"配置redis主从复制\",{\"0\":{\"308\":1}}],[\"配置主从复制\",{\"1\":{\"306\":1}}],[\"配置好之后\",{\"1\":{\"238\":1}}],[\"配置优化\",{\"0\":{\"237\":1}}],[\"绑定变量\",{\"0\":{\"236\":1}}],[\"子查询尽量少用\",{\"1\":{\"232\":1}}],[\"子节点的个数一般称为阶\",{\"1\":{\"69\":1}}],[\"拆分复杂的查询\",{\"1\":{\"232\":1}}],[\"单机如果部署多个实例\",{\"1\":{\"358\":1}}],[\"单个值长度小\",{\"1\":{\"301\":1}}],[\"单个键\",{\"1\":{\"301\":1}}],[\"单次磁盘读取时间10ms左右\",{\"1\":{\"282\":1}}],[\"单次内存寻址100ns\",{\"1\":{\"282\":1}}],[\"单独放在专门用来做秒杀活动的服务器集群上\",{\"1\":{\"268\":1}}],[\"单台服务器就无法满足业务需求\",{\"1\":{\"266\":1}}],[\"单点登录\",{\"0\":{\"263\":1}}],[\"单以name=\",{\"1\":{\"246\":1}}],[\"单位分钟\",{\"1\":{\"347\":1}}],[\"单位秒\",{\"1\":{\"237\":1}}],[\"单位字节\",{\"1\":{\"236\":1}}],[\"单列\",{\"1\":{\"231\":1}}],[\"单纯依靠更快的硬件已经无法得到满足\",{\"1\":{\"16\":1}}],[\"慎用\",{\"1\":{\"225\":1}}],[\"设计思路和tlv一致\",{\"1\":{\"299\":1}}],[\"设计表的时候选择合适的数据类型\",{\"1\":{\"224\":1}}],[\"设想在运行迭代器的过程中\",{\"1\":{\"296\":1}}],[\"设置过期时间的键按lfu淘汰\",{\"1\":{\"347\":1}}],[\"设置参数为slave\",{\"1\":{\"328\":1}}],[\"设置参数\",{\"1\":{\"327\":1}}],[\"设置从节点超时释放\",{\"1\":{\"327\":1}}],[\"设置建议\",{\"1\":{\"326\":1}}],[\"设置master的地址和端口\",{\"1\":{\"315\":1}}],[\"设置将不会起到作用而你的错误处理函数继续会被调用\",{\"1\":{\"262\":1}}],[\"设置sql语句操作超时时间\",{\"1\":{\"245\":1}}],[\"设置preempt为true\",{\"1\":{\"33\":1}}],[\"设置成私有了\",{\"1\":{\"19\":1}}],[\"慢查询衡量标准\",{\"1\":{\"237\":1}}],[\"慢查询是否开启\",{\"1\":{\"237\":1}}],[\"慢查询日志\",{\"1\":{\"224\":1}}],[\"慢查询的统计\",{\"1\":{\"182\":1}}],[\"隐藏字段\",{\"1\":{\"219\":1}}],[\"隐藏的自增id\",{\"1\":{\"215\":1}}],[\"模式来处理异常\",{\"1\":{\"262\":1}}],[\"模式下\",{\"1\":{\"219\":1}}],[\"模拟死锁案发\",{\"1\":{\"81\":1}}],[\"结果是随机执行\",{\"1\":{\"409\":1}}],[\"结果应该是这样的\",{\"1\":{\"219\":1}}],[\"结论\",{\"1\":{\"346\":1}}],[\"结点通过指针持有数据\",{\"1\":{\"300\":1}}],[\"结点如果扩容\",{\"1\":{\"299\":1}}],[\"结点之间凭借得分来判断先后顺序\",{\"1\":{\"297\":1}}],[\"结点数目与bucket数组长度比例达到1\",{\"1\":{\"296\":1}}],[\"结点本身是散布在内存中的\",{\"1\":{\"296\":1}}],[\"结点复制以及查找匹配时\",{\"1\":{\"295\":1}}],[\"结束\",{\"1\":{\"250\":1}}],[\"结构由字段\",{\"1\":{\"42\":1}}],[\"结构体中的\",{\"1\":{\"391\":1}}],[\"结构体中有两个字段\",{\"1\":{\"52\":1}}],[\"结构体有时候并不能直接比较\",{\"1\":{\"44\":1}}],[\"结构体的所有成员变量按其本类型初始化为其类型的0值\",{\"1\":{\"37\":1}}],[\"结构体p中存储了性能追踪\",{\"1\":{\"20\":1}}],[\"结构体里保存了goroutine的堆栈信息\",{\"1\":{\"18\":1}}],[\"示例\",{\"0\":{\"479\":1}}],[\"示例代码如下\",{\"1\":{\"418\":1}}],[\"示例二\",{\"0\":{\"219\":1}}],[\"示例一\",{\"0\":{\"218\":1}}],[\"故如果需要修改map值\",{\"1\":{\"399\":1}}],[\"故在平滑扩容过程中\",{\"1\":{\"296\":1}}],[\"故该结构有所谓的\",{\"1\":{\"292\":1}}],[\"故结果应该为\",{\"1\":{\"219\":1}}],[\"故也符合可见性\",{\"1\":{\"218\":1}}],[\"故符合可见性\",{\"1\":{\"218\":1}}],[\"故再次进行判断\",{\"1\":{\"218\":1}}],[\"故再进入下一步\",{\"1\":{\"218\":1}}],[\"跟大家聊聊怎么用一个比较trick的方法使变量不逃逸\",{\"1\":{\"490\":1}}],[\"跟上一题一样\",{\"1\":{\"415\":1}}],[\"跟上面一样\",{\"1\":{\"218\":1}}],[\"跟一下demo来看更刺激吧\",{\"1\":{\"112\":1}}],[\"符合上述提到的常见情况中的第一种\",{\"1\":{\"490\":1}}],[\"符合\",{\"1\":{\"218\":1}}],[\"活跃事务列表中\",{\"1\":{\"218\":1}}],[\"进入下一步判断\",{\"1\":{\"218\":1}}],[\"进行读写\",{\"1\":{\"477\":1}}],[\"进行了一次rdb持久化会把runid\",{\"1\":{\"325\":1}}],[\"进行了一些小改动\",{\"1\":{\"297\":1}}],[\"进行了快照读\",{\"1\":{\"218\":1}}],[\"进行相应的调整\",{\"1\":{\"190\":1}}],[\"进行模糊查询的时候\",{\"1\":{\"134\":1}}],[\"进行权限校验\",{\"1\":{\"126\":1}}],[\"进行内存对齐之后\",{\"1\":{\"63\":1}}],[\"进行等值比较的数据类型\",{\"1\":{\"41\":1}}],[\"忘记回去看一下那三个字段\",{\"1\":{\"218\":1}}],[\"真实的键值对个数需要遍历才能获得\",{\"1\":{\"301\":1}}],[\"真正对磁盘数据页的修改是通过将内存里脏页的数据刷回磁盘来完成的\",{\"1\":{\"251\":1}}],[\"真正获取read\",{\"1\":{\"218\":1}}],[\"真的最后了\",{\"1\":{\"219\":1}}],[\"真是居家必备之良品\",{\"1\":{\"20\":1}}],[\"学生姓名\",{\"1\":{\"217\":2}}],[\"学生id\",{\"1\":{\"217\":2}}],[\"准备数据\",{\"0\":{\"217\":1}}],[\"准确的说应该是聚集索引\",{\"1\":{\"70\":1}}],[\"准确使用定时器\",{\"0\":{\"8\":1}}],[\"判断两个给定的字符串排序后是否一致\",{\"0\":{\"377\":1,\"378\":1},\"1\":{\"362\":1}}],[\"判断字符串中字符是否全都不同\",{\"0\":{\"369\":1,\"370\":1},\"1\":{\"362\":1}}],[\"判断offset是否在复制缓冲区中\",{\"1\":{\"318\":1}}],[\"判断runid是否匹配\",{\"1\":{\"318\":1}}],[\"判断错误级别是否是设置的\",{\"1\":{\"262\":1}}],[\"判断有没有冲突\",{\"1\":{\"250\":1}}],[\"判断\",{\"1\":{\"218\":1}}],[\"判断该条记录的\",{\"1\":{\"215\":1}}],[\"判断28在键值17和35之间\",{\"1\":{\"69\":1}}],[\"去作比较\",{\"1\":{\"215\":1}}],[\"去和\",{\"1\":{\"215\":1}}],[\"去执行shedule函数\",{\"1\":{\"28\":1}}],[\"万事俱备\",{\"1\":{\"215\":1}}],[\"万变不离其宗\",{\"1\":{\"29\":1}}],[\"呢\",{\"0\":{\"483\":1},\"1\":{\"215\":1,\"265\":1,\"502\":1}}],[\"特殊的读操作\",{\"1\":{\"214\":1}}],[\"特性\",{\"1\":{\"1\":1,\"345\":1}}],[\"快照读\",{\"1\":{\"214\":1,\"215\":1,\"219\":3}}],[\"悲观\",{\"1\":{\"212\":1}}],[\"悲观锁后\",{\"1\":{\"101\":1}}],[\"悲观锁她专一且缺乏安全感了\",{\"1\":{\"101\":1}}],[\"悲观锁\",{\"0\":{\"101\":1},\"1\":{\"156\":1,\"212\":2}}],[\"悲观锁思想就是\",{\"1\":{\"98\":1}}],[\"给一串指令\",{\"1\":{\"386\":1}}],[\"给定一个单链表的头节点\",{\"1\":{\"469\":1}}],[\"给定一个string为原始的串\",{\"1\":{\"382\":1}}],[\"给定一个string\",{\"1\":{\"370\":1,\"374\":1,\"378\":1}}],[\"给定两个字符串\",{\"1\":{\"378\":1}}],[\"给用户添加标签\",{\"1\":{\"277\":1}}],[\"给\",{\"1\":{\"212\":1,\"244\":1}}],[\"给清理掉了\",{\"1\":{\"8\":1}}],[\"监控的工具有很多\",{\"1\":{\"202\":1}}],[\"监听端口\",{\"1\":{\"12\":1}}],[\"监听http端口\",{\"1\":{\"12\":1}}],[\"免登通了就行\",{\"1\":{\"201\":1}}],[\"免费的午餐已经终结\",{\"1\":{\"16\":1}}],[\"工作原理\",{\"0\":{\"354\":1}}],[\"工作线程睡眠在这个park成员上\",{\"1\":{\"34\":1}}],[\"工作线程执行的代码是如何找到属于自己的那个m结构体实例对象的呢\",{\"1\":{\"29\":1}}],[\"工作线程优先使用自己的局部运行队列\",{\"1\":{\"29\":1}}],[\"工具比较两个\",{\"1\":{\"335\":1}}],[\"工具\",{\"1\":{\"201\":1}}],[\"崩溃恢复时\",{\"1\":{\"199\":1}}],[\"崩溃恢复能力的事务安全\",{\"1\":{\"87\":1}}],[\"存入key\",{\"1\":{\"421\":1}}],[\"存取数据都会有额外的字节序转换开销\",{\"1\":{\"298\":1}}],[\"存放在\",{\"1\":{\"198\":1}}],[\"存储着当前结点的类型\",{\"1\":{\"299\":1}}],[\"存储的是entry中未使用的空间的字节数\",{\"1\":{\"301\":1}}],[\"存储的是值的二进制长度\",{\"1\":{\"301\":1}}],[\"存储的是键的二进制长度\",{\"1\":{\"301\":1}}],[\"存储的是键值和主键\",{\"1\":{\"72\":1}}],[\"存储的\",{\"1\":{\"298\":1}}],[\"存储时间与时区有关\",{\"1\":{\"193\":1}}],[\"存储时间与时区无关\",{\"1\":{\"193\":1}}],[\"存储精度都为秒\",{\"1\":{\"193\":1}}],[\"存储\",{\"1\":{\"175\":1}}],[\"存储过程在服务器端运行\",{\"1\":{\"169\":1}}],[\"存储过程是一个预编译的代码块\",{\"1\":{\"169\":1}}],[\"存储过程\",{\"1\":{\"169\":1}}],[\"存储在salary列中的值的范围是从\",{\"1\":{\"132\":1}}],[\"存储引擎将数据写到内存\",{\"1\":{\"244\":1}}],[\"存储引擎层\",{\"1\":{\"242\":1}}],[\"存储引擎操作\",{\"1\":{\"130\":1}}],[\"存储引擎提供了具有提交\",{\"1\":{\"87\":1}}],[\"存储数据多少\",{\"1\":{\"88\":1}}],[\"存储空间较小\",{\"1\":{\"87\":1}}],[\"存储了表中所有的数据\",{\"1\":{\"71\":1}}],[\"谈谈mysql的explain\",{\"0\":{\"195\":1}}],[\"谈谈六种关联查询\",{\"0\":{\"174\":1}}],[\"年\",{\"1\":{\"193\":2}}],[\"区间的数值\",{\"1\":{\"299\":1}}],[\"区分度\",{\"1\":{\"252\":1}}],[\"区分度低的数据列不适合做索引列\",{\"1\":{\"144\":1}}],[\"区分度低的字段不适合加索引\",{\"1\":{\"79\":1}}],[\"区别是\",{\"1\":{\"278\":1}}],[\"区别在于changebuffer是在共享表空间ibdata1里\",{\"1\":{\"251\":1}}],[\"区别\",{\"1\":{\"193\":1}}],[\"纪录了所有增删改sql语句\",{\"1\":{\"192\":1}}],[\"增加锁机制\",{\"1\":{\"288\":1}}],[\"增加多级缓存\",{\"1\":{\"285\":1}}],[\"增加缓存系统高可用方案设计\",{\"1\":{\"285\":1}}],[\"增加从服务器喽\",{\"1\":{\"119\":1}}],[\"增删改等写操作命令发给主库\",{\"1\":{\"191\":1}}],[\"飙升\",{\"1\":{\"190\":1}}],[\"连data里的那一个字节也要省下来\",{\"1\":{\"299\":1}}],[\"连进来导致\",{\"1\":{\"190\":1}}],[\"连接得以复用\",{\"1\":{\"503\":1}}],[\"连接等\",{\"1\":{\"327\":1}}],[\"连接器\",{\"1\":{\"242\":1,\"243\":1,\"244\":1}}],[\"连接复用\",{\"1\":{\"124\":1}}],[\"连接池基本原理\",{\"0\":{\"122\":1}}],[\"连接到主库\",{\"1\":{\"117\":1,\"192\":1}}],[\"掉这些线程\",{\"1\":{\"190\":1}}],[\"让写锁优先获取\",{\"1\":{\"457\":1}}],[\"让持久化变为串行\",{\"1\":{\"358\":1}}],[\"让主从数据达到一致\",{\"1\":{\"317\":1}}],[\"让其对其他级别的错误进行处理\",{\"1\":{\"262\":1}}],[\"让缓存的效率更高\",{\"1\":{\"188\":1}}],[\"让我们先来看下b+树的结构图\",{\"1\":{\"70\":1}}],[\"让我们先看一张图\",{\"1\":{\"67\":1}}],[\"盐\",{\"1\":{\"186\":1}}],[\"密码散列\",{\"1\":{\"186\":1}}],[\"插入指令call\",{\"1\":{\"405\":1}}],[\"插入了指令call\",{\"1\":{\"405\":1}}],[\"插入删除操作不频繁\",{\"1\":{\"298\":1}}],[\"插入与删除的复杂度均为o\",{\"1\":{\"298\":1}}],[\"插入值\",{\"1\":{\"250\":1}}],[\"插入\",{\"1\":{\"214\":1,\"215\":1}}],[\"插入数据效率慢\",{\"1\":{\"183\":1}}],[\"插入缓冲\",{\"1\":{\"141\":1}}],[\"选择最小的头部类型\",{\"1\":{\"294\":2}}],[\"选择的列最好有索引\",{\"1\":{\"234\":1}}],[\"选择合适的索引顺序至关重要\",{\"1\":{\"230\":1}}],[\"选择自增id\",{\"1\":{\"183\":1}}],[\"选择更好的硬件设备作为slave\",{\"1\":{\"119\":1}}],[\"运行较长时间\",{\"1\":{\"401\":1}}],[\"运行时内存先暴涨\",{\"1\":{\"450\":1}}],[\"运行时内存可能暴涨\",{\"1\":{\"450\":1}}],[\"运行时正常\",{\"1\":{\"450\":1}}],[\"运行时通知\",{\"1\":{\"262\":2}}],[\"运行时警告\",{\"1\":{\"262\":1}}],[\"运行程序正常输出\",{\"1\":{\"52\":1}}],[\"运维会定期统计给我们\",{\"1\":{\"182\":1}}],[\"统计过慢查询吗\",{\"0\":{\"182\":1}}],[\"统一的连接管理\",{\"1\":{\"124\":1}}],[\"难点在于怎么知道哪个阻塞先完成\",{\"1\":{\"431\":1}}],[\"难读\",{\"1\":{\"299\":1}}],[\"难以优化引用了可空列的查询\",{\"1\":{\"181\":1}}],[\"难道m要等他们完事了再继续执行\",{\"1\":{\"21\":1}}],[\"计算坐标就简单了\",{\"1\":{\"386\":1}}],[\"计算指定键在哈希表中的索引时\",{\"1\":{\"296\":1}}],[\"计算的结果中值越接近1的就越往前\",{\"1\":{\"230\":1}}],[\"计数器衰减的分钟数\",{\"1\":{\"347\":1}}],[\"计数器\",{\"1\":{\"274\":1}}],[\"计划对列进行索引\",{\"1\":{\"181\":1}}],[\"计时器等相关的字段外\",{\"1\":{\"20\":1}}],[\"释放内存计数\",{\"1\":{\"346\":1}}],[\"释放空间\",{\"1\":{\"345\":1}}],[\"释放slave\",{\"1\":{\"327\":1}}],[\"释放函数\",{\"1\":{\"296\":1}}],[\"释放资源\",{\"1\":{\"179\":1}}],[\"释放锁行为可以在另一个goroutine中操作\",{\"1\":{\"59\":1}}],[\"释放锁\",{\"1\":{\"57\":1}}],[\"解释\",{\"0\":{\"496\":1,\"502\":1}}],[\"解码或转码的时候也无法上线私有属性的转换\",{\"1\":{\"393\":1}}],[\"解析\",{\"0\":{\"508\":1},\"1\":{\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"396\":1,\"397\":1,\"398\":1,\"399\":1,\"400\":1,\"401\":1,\"405\":1,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"410\":1,\"411\":1,\"412\":1,\"413\":1,\"414\":1,\"415\":1,\"418\":1,\"421\":1,\"424\":1,\"428\":1,\"431\":1,\"469\":1}}],[\"解析并生成执行计划\",{\"1\":{\"179\":1}}],[\"解题思路\",{\"1\":{\"366\":1,\"370\":1,\"374\":1,\"378\":1,\"382\":1,\"386\":1}}],[\"解决并发问题\",{\"1\":{\"288\":1}}],[\"解决缓存穿透的思路\",{\"1\":{\"286\":1}}],[\"解决索引问题\",{\"1\":{\"159\":1}}],[\"解决死锁思路\",{\"1\":{\"159\":1}}],[\"解决方案的话\",{\"1\":{\"113\":1}}],[\"解决方案\",{\"1\":{\"109\":1,\"326\":1,\"327\":1}}],[\"解决方法\",{\"1\":{\"4\":1}}],[\"解决这一问题可以分两次查询实现\",{\"1\":{\"86\":1}}],[\"逐行删除\",{\"1\":{\"177\":1}}],[\"联合查询\",{\"1\":{\"174\":1}}],[\"联合索引的最左\",{\"1\":{\"246\":1}}],[\"联合索引创建\",{\"1\":{\"246\":1}}],[\"联合索引\",{\"1\":{\"78\":1,\"246\":1}}],[\"约束\",{\"1\":{\"173\":1}}],[\"约束字段唯一\",{\"1\":{\"173\":1}}],[\"约束字段唯一性\",{\"1\":{\"173\":1}}],[\"约束字段的内容一定不能为null\",{\"1\":{\"173\":1}}],[\"约束有哪几种呢\",{\"0\":{\"173\":1}}],[\"能引起变量逃逸到堆上的典型情况\",{\"1\":{\"489\":1}}],[\"能一直读到东西\",{\"1\":{\"478\":1}}],[\"能否变成另一个字符串\",{\"1\":{\"378\":1}}],[\"能够保证数据不丢失\",{\"1\":{\"356\":1}}],[\"能够对机密数据提供安全保护\",{\"1\":{\"166\":1}}],[\"能接受o\",{\"1\":{\"298\":1}}],[\"能迅速判断\",{\"1\":{\"294\":1}}],[\"能直观\",{\"1\":{\"275\":1}}],[\"能自动剔除\",{\"1\":{\"266\":1}}],[\"能唯一知标识元组的属性集称为超键\",{\"1\":{\"172\":1}}],[\"候选键\",{\"0\":{\"172\":1},\"1\":{\"172\":1}}],[\"候车大厅\",{\"1\":{\"21\":1}}],[\"类似的\",{\"1\":{\"298\":1}}],[\"类似方法的复用\",{\"1\":{\"169\":1}}],[\"类型上调用方法都是动态调度的\",{\"1\":{\"489\":1}}],[\"类型上调用方法\",{\"1\":{\"489\":1}}],[\"类型列表中有多个\",{\"1\":{\"392\":1}}],[\"类型列表只有一个\",{\"1\":{\"392\":1}}],[\"类型\",{\"1\":{\"177\":1,\"292\":1}}],[\"类型的变量\",{\"1\":{\"489\":1}}],[\"类型的\",{\"1\":{\"46\":2,\"342\":1}}],[\"允许模块化程序设计\",{\"1\":{\"169\":1}}],[\"允许为null值\",{\"1\":{\"143\":2}}],[\"游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制\",{\"1\":{\"168\":1}}],[\"游标提供了一种对从表中检索出的数据进行操作的灵活手段\",{\"1\":{\"168\":1}}],[\"逻辑数据独立性\",{\"1\":{\"166\":1}}],[\"讲一下\",{\"0\":{\"166\":1}}],[\"兼容老的表结构\",{\"1\":{\"164\":1}}],[\"虚表\",{\"1\":{\"164\":1}}],[\"虚拟地址空间\",{\"1\":{\"27\":1}}],[\"产生的表\",{\"1\":{\"164\":1}}],[\"产生死锁\",{\"1\":{\"6\":1}}],[\"哪些使用场景\",{\"0\":{\"163\":1}}],[\"尽管其后面的数组可能是在栈上分配的\",{\"1\":{\"489\":1}}],[\"尽管一个是数据对象值\",{\"1\":{\"42\":1}}],[\"尽可能做到一次锁定所需要的所有资源\",{\"1\":{\"159\":1}}],[\"尽量拦截浏览器请求\",{\"1\":{\"268\":1}}],[\"尽量使用count\",{\"1\":{\"256\":1}}],[\"尽量使用not\",{\"1\":{\"224\":1}}],[\"尽量避免使用长事务\",{\"1\":{\"245\":1}}],[\"尽量避免并发形成环路\",{\"1\":{\"159\":1}}],[\"尽量优化查询\",{\"1\":{\"232\":1}}],[\"尽量约定以相同的顺序访问表\",{\"1\":{\"159\":1}}],[\"环路等待条件\",{\"1\":{\"159\":1}}],[\"请写出以下输入内容\",{\"0\":{\"411\":1}}],[\"请详细说明\",{\"0\":{\"409\":1}}],[\"请找出下面代码的问题所在\",{\"0\":{\"395\":1}}],[\"请说出下面的代码存在什么问题\",{\"0\":{\"400\":1}}],[\"请说出下面代码\",{\"0\":{\"399\":1}}],[\"请说出下面代码哪里写错了\",{\"0\":{\"398\":1}}],[\"请说出下面代码存在什么问题\",{\"0\":{\"392\":1}}],[\"请说明下面代码书写是否正确\",{\"0\":{\"396\":1}}],[\"请说明原因\",{\"0\":{\"394\":1}}],[\"请编写一个方法\",{\"1\":{\"382\":1}}],[\"请编写程序\",{\"1\":{\"378\":1}}],[\"请返回一个bool\",{\"1\":{\"378\":1}}],[\"请返回一个bool值\",{\"1\":{\"370\":1}}],[\"请返回一个string\",{\"1\":{\"374\":1}}],[\"请实现一个算法\",{\"1\":{\"370\":1,\"374\":1}}],[\"请求回源\",{\"1\":{\"284\":1}}],[\"请求\",{\"1\":{\"282\":1}}],[\"请求和保持条件\",{\"1\":{\"159\":1}}],[\"请仔细看下图中红字的解释\",{\"1\":{\"72\":1}}],[\"互斥条件\",{\"1\":{\"159\":1}}],[\"互斥锁\",{\"1\":{\"57\":1}}],[\"互斥锁和读写锁有啥区别\",{\"1\":{\"56\":1}}],[\"他们的过程是如何\",{\"1\":{\"354\":1}}],[\"他们被用于保存与金钱有关的数据\",{\"1\":{\"132\":1}}],[\"他和其他的排他锁\",{\"1\":{\"157\":1}}],[\"锁级别是行级锁\",{\"1\":{\"223\":1}}],[\"锁\",{\"0\":{\"212\":1}}],[\"锁兼容性如下\",{\"1\":{\"157\":1}}],[\"锁机制与innodb锁算法\",{\"0\":{\"156\":1}}],[\"锁定粒度介于表锁和行锁之间\",{\"1\":{\"133\":1}}],[\"锁定粒度小\",{\"1\":{\"133\":1}}],[\"锁定力度大\",{\"1\":{\"133\":1}}],[\"隔离级别越高\",{\"1\":{\"245\":1}}],[\"隔离级别就是依赖锁和mvcc实现的\",{\"1\":{\"155\":1}}],[\"隔离级别与锁的关系\",{\"0\":{\"155\":1}}],[\"隔离性\",{\"1\":{\"106\":1,\"107\":1,\"194\":1,\"223\":1,\"245\":1}}],[\"已经读完了之前写到通道里的值\",{\"1\":{\"484\":1}}],[\"已经标志了\",{\"1\":{\"401\":1}}],[\"已经包含了age信息\",{\"1\":{\"152\":1}}],[\"已用字节数\",{\"1\":{\"294\":1}}],[\"已阻塞的\",{\"1\":{\"58\":1}}],[\"小写开头的方法\",{\"1\":{\"393\":1}}],[\"小端字节序\",{\"1\":{\"298\":1}}],[\"小亮\",{\"1\":{\"219\":2}}],[\"小强\",{\"1\":{\"218\":2}}],[\"小张的记录\",{\"1\":{\"219\":1}}],[\"小张\",{\"1\":{\"217\":1,\"218\":6,\"219\":3}}],[\"小方\",{\"1\":{\"217\":1,\"218\":6,\"219\":5}}],[\"小明和小方的两条记录和上面一样是可见的这里我就不重复分析了\",{\"1\":{\"219\":1}}],[\"小明\",{\"1\":{\"217\":1,\"218\":2,\"219\":5}}],[\"小于等于1000\",{\"1\":{\"382\":1}}],[\"小于\",{\"1\":{\"215\":1,\"218\":1}}],[\"小数目的不同值\",{\"1\":{\"151\":1}}],[\"小的数据集驱动大的数据集\",{\"1\":{\"112\":1}}],[\"列\",{\"1\":{\"230\":1}}],[\"列不要太多\",{\"1\":{\"224\":1}}],[\"列值为null也是可以走索引的\",{\"1\":{\"181\":1}}],[\"列值为null时\",{\"0\":{\"181\":1}}],[\"列名\",{\"0\":{\"167\":1},\"1\":{\"167\":1,\"189\":1}}],[\"列经常被分组排序\",{\"1\":{\"151\":1}}],[\"列举一下\",{\"0\":{\"133\":1}}],[\"动作是需要所有正在运行\",{\"1\":{\"401\":1}}],[\"动作描述\",{\"1\":{\"151\":1}}],[\"动态数组\",{\"1\":{\"63\":1}}],[\"换句话说查询列要被所使用的索引覆盖\",{\"1\":{\"149\":1}}],[\"叶子节点可能存储了当前的key值\",{\"1\":{\"150\":1}}],[\"叶子节点则同时存放键和值\",{\"1\":{\"148\":1}}],[\"叶子节点中的数据是通过单向链表连接的\",{\"1\":{\"70\":1}}],[\"百万级别或以上的数据\",{\"0\":{\"146\":1}}],[\"频繁的内存拷贝操作听起来对性能不大友好\",{\"1\":{\"495\":1}}],[\"频繁的网路中断\",{\"0\":{\"327\":1}}],[\"频繁修改索引列\",{\"1\":{\"151\":1}}],[\"频繁更新的列\",{\"1\":{\"151\":1}}],[\"频繁更新的字段不适合创建索引\",{\"1\":{\"144\":1}}],[\"频繁作为查询条件的字段才去创建索引\",{\"1\":{\"144\":1}}],[\"组合九\",{\"1\":{\"207\":1}}],[\"组合八\",{\"1\":{\"207\":1}}],[\"组合七\",{\"1\":{\"207\":1}}],[\"组合六\",{\"1\":{\"207\":1}}],[\"组合五\",{\"1\":{\"207\":1}}],[\"组合四\",{\"1\":{\"207\":1}}],[\"组合三\",{\"1\":{\"207\":1}}],[\"组合二\",{\"1\":{\"207\":1}}],[\"组合一\",{\"1\":{\"207\":1}}],[\"组合索引是什么\",{\"0\":{\"153\":1}}],[\"组合索引\",{\"1\":{\"143\":1,\"153\":1}}],[\"组成\",{\"1\":{\"42\":1,\"46\":1}}],[\"搜索时\",{\"1\":{\"297\":1}}],[\"搜索\",{\"1\":{\"143\":1}}],[\"普通索引比唯一索引多一次操作\",{\"1\":{\"250\":1}}],[\"普通索引占用的空间也就越小\",{\"1\":{\"246\":1}}],[\"普通索引的叶子节点就越小\",{\"1\":{\"246\":1}}],[\"普通索引\",{\"1\":{\"143\":1,\"250\":2}}],[\"普通操作使用statement记录\",{\"1\":{\"140\":1}}],[\"唯一索引和普通索引的查询消耗的性能对mysql来说是相差不大的\",{\"1\":{\"250\":1}}],[\"唯一索引和普通索引的选择\",{\"0\":{\"250\":1}}],[\"唯一索引无效\",{\"1\":{\"227\":1}}],[\"唯一索引\",{\"1\":{\"143\":1,\"231\":1,\"250\":2}}],[\"唯一索引可以保证数据库表中每一行的数据的唯一性\",{\"1\":{\"142\":1}}],[\"改天\",{\"1\":{\"503\":1}}],[\"改起来也很费劲\",{\"1\":{\"299\":1}}],[\"改内存参数\",{\"1\":{\"190\":1}}],[\"改\",{\"1\":{\"190\":1}}],[\"改的时候\",{\"1\":{\"142\":1}}],[\"改进方法如下\",{\"1\":{\"8\":1}}],[\"删\",{\"1\":{\"142\":1}}],[\"删除缓存\",{\"1\":{\"287\":1}}],[\"删除无用索引\",{\"1\":{\"252\":1}}],[\"删除标志\",{\"1\":{\"219\":1}}],[\"删除\",{\"1\":{\"215\":1}}],[\"删除操作\",{\"1\":{\"214\":1}}],[\"删除速度最快\",{\"1\":{\"177\":1}}],[\"删除速度快\",{\"1\":{\"177\":1}}],[\"删除速度慢\",{\"1\":{\"177\":1}}],[\"删除速度\",{\"1\":{\"177\":1}}],[\"删除表中的所有数据\",{\"1\":{\"177\":1}}],[\"删除表的全部或者一部分数据行\",{\"1\":{\"177\":1}}],[\"删除内容\",{\"1\":{\"177\":1}}],[\"删除和修改\",{\"1\":{\"164\":1}}],[\"删除和查找\",{\"1\":{\"52\":1}}],[\"删除完成后重新创建索引\",{\"1\":{\"146\":1}}],[\"删除不再使用或者很少使用的索引\",{\"1\":{\"144\":1}}],[\"删除了数据\",{\"1\":{\"96\":1}}],[\"删除指定的key\",{\"1\":{\"41\":1}}],[\"缺点在于空间有限\",{\"1\":{\"282\":1}}],[\"缺点\",{\"0\":{\"166\":1},\"1\":{\"142\":1,\"169\":1}}],[\"优势\",{\"1\":{\"288\":2}}],[\"优先考虑uuid吧\",{\"1\":{\"183\":1}}],[\"优先考虑扩展索引\",{\"1\":{\"144\":1}}],[\"优点很多\",{\"1\":{\"301\":1}}],[\"优点\",{\"1\":{\"142\":1,\"169\":1,\"286\":2}}],[\"优化器是根据索引的\",{\"1\":{\"252\":1}}],[\"优化器\",{\"1\":{\"242\":1}}],[\"优化器进行确定执行方案\",{\"1\":{\"126\":1}}],[\"优化特定类型的查询语句\",{\"0\":{\"189\":1}}],[\"优化慢查询\",{\"1\":{\"182\":1}}],[\"优化索引结构\",{\"1\":{\"129\":1}}],[\"优化sql\",{\"1\":{\"129\":1}}],[\"优化sql结构\",{\"1\":{\"82\":1,\"129\":1,\"182\":1}}],[\"优化shema\",{\"1\":{\"120\":1}}],[\"优化表结构\",{\"1\":{\"110\":1}}],[\"预读\",{\"1\":{\"141\":1}}],[\"自己制定策略定期检查redis的情况\",{\"1\":{\"358\":1}}],[\"自己手动触发与redis定时触发\",{\"1\":{\"355\":1}}],[\"自建\",{\"1\":{\"334\":1}}],[\"自定义会话管理可以实现共享session\",{\"1\":{\"264\":1}}],[\"自动触发\",{\"1\":{\"356\":1}}],[\"自动创建的id\",{\"1\":{\"215\":1}}],[\"自动执行这些代码\",{\"1\":{\"170\":1}}],[\"自增id用完后\",{\"1\":{\"184\":1}}],[\"自增id\",{\"1\":{\"183\":1}}],[\"自增主键往往是更合理的选择\",{\"1\":{\"246\":1}}],[\"自增主键可以避免页分裂\",{\"1\":{\"246\":1}}],[\"自增主键可能用完问题\",{\"1\":{\"113\":1}}],[\"自增主键一般用int类型\",{\"1\":{\"184\":1}}],[\"自增主键会产生表锁\",{\"1\":{\"113\":1}}],[\"自适应哈希索引\",{\"1\":{\"141\":1}}],[\"二\",{\"0\":{\"306\":1,\"404\":1}}],[\"二进制数据的长度\",{\"1\":{\"299\":1}}],[\"二进制\",{\"1\":{\"299\":1}}],[\"二进制日志\",{\"1\":{\"238\":1}}],[\"二叉搜索树\",{\"1\":{\"246\":1}}],[\"二叉查找树和平衡二叉树其实也有\",{\"1\":{\"69\":1}}],[\"二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值\",{\"1\":{\"67\":1}}],[\"二叉查找树\",{\"0\":{\"67\":1}}],[\"二级索引访问需要两次查找\",{\"1\":{\"230\":1}}],[\"二级索引无法直接查询所有列的数据\",{\"1\":{\"149\":1}}],[\"二次写\",{\"1\":{\"141\":1}}],[\"日志跟配置文件存储在\",{\"1\":{\"308\":1}}],[\"日志记录的状态为prepare\",{\"1\":{\"244\":1}}],[\"日志文件大小\",{\"1\":{\"237\":1}}],[\"日志的存放形式\",{\"0\":{\"198\":1}}],[\"日志量太大\",{\"1\":{\"140\":1}}],[\"日常开发中用它分析sql\",{\"1\":{\"103\":1}}],[\"日常工作中你是怎么优化sql的\",{\"0\":{\"82\":1}}],[\"基础\",{\"0\":{\"272\":1}}],[\"基数\",{\"1\":{\"252\":1}}],[\"基于非主键索引的查询需要多扫描一棵索引树\",{\"1\":{\"246\":1}}],[\"基于行的复制\",{\"1\":{\"238\":1}}],[\"基于行\",{\"1\":{\"238\":1}}],[\"基于语句消耗资源少\",{\"1\":{\"238\":1}}],[\"基于语句\",{\"1\":{\"238\":1}}],[\"基于索引来完成行锁的\",{\"1\":{\"158\":1}}],[\"基于这个特性\",{\"1\":{\"69\":1}}],[\"基本不会被使用到\",{\"1\":{\"355\":1}}],[\"基本配置\",{\"1\":{\"237\":1}}],[\"基本的索引类型\",{\"1\":{\"143\":1}}],[\"基本是可以全部记下来但是由于很多操作\",{\"1\":{\"140\":1}}],[\"节省空间\",{\"1\":{\"253\":1}}],[\"节约内存和网络开销\",{\"1\":{\"236\":1}}],[\"节约了io\",{\"1\":{\"140\":1}}],[\"节点的子节点树\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"节点中存储了键\",{\"1\":{\"67\":1}}],[\"减少回表率\",{\"1\":{\"246\":1}}],[\"减少回表次数\",{\"1\":{\"127\":1,\"246\":1}}],[\"减少io磁盘读写读取正行数据\",{\"1\":{\"246\":1}}],[\"减少了读磁盘的次数\",{\"1\":{\"250\":1}}],[\"减少了一次扫描索引树\",{\"1\":{\"246\":1}}],[\"减少了sql注入和攻击\",{\"1\":{\"236\":1}}],[\"减少了binlog日志量\",{\"1\":{\"140\":1}}],[\"减少冗余记录查询\",{\"1\":{\"232\":1}}],[\"减少冗余记录的查询\",{\"1\":{\"188\":1}}],[\"减少查询时扫描的行数\",{\"1\":{\"232\":1}}],[\"减少查询时间\",{\"1\":{\"142\":1}}],[\"减少不必要列的查询\",{\"1\":{\"232\":1}}],[\"减少客户端的压力\",{\"1\":{\"169\":1}}],[\"减少死锁产生概率\",{\"1\":{\"159\":1}}],[\"权限表存放在mysql数据库里\",{\"1\":{\"139\":1}}],[\"笛卡尔积\",{\"1\":{\"137\":1}}],[\"笛卡尔积呢\",{\"0\":{\"137\":1}}],[\"显著提升查询性能\",{\"1\":{\"246\":1}}],[\"显示的值也依赖于时区\",{\"1\":{\"193\":1}}],[\"显示长度是\",{\"1\":{\"176\":1}}],[\"显示两张表所有记录一一对应\",{\"1\":{\"137\":1}}],[\"显然升级的开销是很大的\",{\"1\":{\"298\":1}}],[\"显然是用于设计作为字符串使用的\",{\"1\":{\"294\":1}}],[\"显然\",{\"1\":{\"47\":1,\"112\":1,\"299\":1}}],[\"显然不会\",{\"1\":{\"21\":1}}],[\"外键\",{\"1\":{\"172\":1}}],[\"外键分别是什么\",{\"0\":{\"172\":1}}],[\"外键列\",{\"1\":{\"151\":1}}],[\"外连接\",{\"0\":{\"137\":1},\"1\":{\"137\":1,\"174\":1}}],[\"外部struct覆盖内部struct的同名字段\",{\"1\":{\"42\":1}}],[\"授权认证\",{\"1\":{\"136\":1}}],[\"页面静态化\",{\"1\":{\"268\":1}}],[\"页\",{\"1\":{\"246\":1}}],[\"页锁\",{\"1\":{\"133\":1,\"156\":1}}],[\"页就是我们上面说的磁盘块\",{\"1\":{\"69\":1}}],[\"行锁\",{\"1\":{\"133\":1,\"156\":1}}],[\"行级锁\",{\"1\":{\"87\":1}}],[\"货币在数据库中mysql常用decimal和numric类型表示\",{\"1\":{\"132\":1}}],[\"字母打印完成后通知数字打印\",{\"1\":{\"366\":1}}],[\"字典本身并不持有数据\",{\"1\":{\"301\":1}}],[\"字典内部使用的默认散列函数其实也非常有讲究\",{\"1\":{\"296\":1}}],[\"字典中的所有结点\",{\"1\":{\"296\":1}}],[\"字典中持有的所有结点都会被遍历到\",{\"1\":{\"296\":1}}],[\"字典中持有的所有结点\",{\"1\":{\"296\":1}}],[\"字典的实现很复杂\",{\"1\":{\"296\":1}}],[\"字典的使用者可以最大化的自定义字典的实现\",{\"1\":{\"296\":1}}],[\"字典处于非扩容状态时\",{\"1\":{\"296\":1}}],[\"字典正处于平滑扩容过程中\",{\"1\":{\"296\":1}}],[\"字典正处于平滑扩容的过程中\",{\"1\":{\"296\":1}}],[\"字典是不会继续进行结点迁移平滑扩容的\",{\"1\":{\"296\":1}}],[\"字典会持有两个dictht的实例\",{\"1\":{\"296\":1}}],[\"字典为了缓解性能下降\",{\"1\":{\"296\":1}}],[\"字典为了支持平滑扩容\",{\"1\":{\"296\":1}}],[\"字典dict仅持有一个哈希表dictht的实例\",{\"1\":{\"296\":1}}],[\"字数等打分\",{\"1\":{\"278\":1}}],[\"字节\",{\"1\":{\"193\":2,\"299\":1}}],[\"字节字符串\",{\"1\":{\"131\":1}}],[\"字段的容量至少是x+1\",{\"1\":{\"297\":1}}],[\"字段值的前几个创建前缀索引\",{\"1\":{\"253\":1}}],[\"字段加\",{\"1\":{\"244\":1}}],[\"字段为什么要求定义为not\",{\"0\":{\"185\":1}}],[\"字段最多存放\",{\"1\":{\"175\":1}}],[\"字符串转成切片\",{\"1\":{\"495\":1}}],[\"字符串转成byte数组\",{\"0\":{\"493\":1},\"1\":{\"494\":1}}],[\"字符串的长度小于等于\",{\"1\":{\"370\":1}}],[\"字符串替换问题\",{\"0\":{\"381\":1,\"382\":1},\"1\":{\"362\":1}}],[\"字符串\",{\"1\":{\"274\":2}}],[\"字符串类型\",{\"0\":{\"274\":1}}],[\"字符串类型的字段如何加索引\",{\"0\":{\"253\":1}}],[\"字符串列名为\",{\"1\":{\"229\":1}}],[\"字符串所占空间是一样的\",{\"1\":{\"175\":1}}],[\"字符字符串\",{\"1\":{\"131\":1}}],[\"字面量声明\",{\"1\":{\"63\":1}}],[\"服务端实现session共享\",{\"1\":{\"265\":1}}],[\"服务器的运行id\",{\"0\":{\"321\":1}}],[\"服务器校验请求是否正确\",{\"1\":{\"264\":1}}],[\"服务器端响应\",{\"1\":{\"264\":1}}],[\"服务器端指的是session\",{\"1\":{\"264\":1}}],[\"服务器模式\",{\"1\":{\"237\":1}}],[\"服务器也只对器进行一次解析\",{\"1\":{\"236\":1}}],[\"服务器与数据库建立连接\",{\"1\":{\"179\":1}}],[\"服务器正在执行的命令\",{\"1\":{\"130\":1}}],[\"服务的具体执行者就是我们的gin框架\",{\"1\":{\"12\":1}}],[\"返回局部变量a\",{\"1\":{\"490\":1}}],[\"返回两个参数\",{\"1\":{\"484\":1}}],[\"返回\",{\"1\":{\"478\":1}}],[\"返回替换后的string\",{\"1\":{\"382\":1}}],[\"返回缓存数据\",{\"1\":{\"288\":1}}],[\"返回了一个关联数组\",{\"1\":{\"262\":1}}],[\"返回某范围内的数据\",{\"1\":{\"151\":1}}],[\"返回执行结果\",{\"1\":{\"126\":1}}],[\"返回上次查询的最大记录\",{\"1\":{\"93\":1}}],[\"提供更好缓存命中率\",{\"1\":{\"347\":1}}],[\"提供高性能\",{\"1\":{\"282\":1}}],[\"提升检索速度\",{\"1\":{\"246\":1}}],[\"提交读\",{\"1\":{\"223\":1}}],[\"提高通信速率\",{\"1\":{\"169\":1}}],[\"提高开发效率\",{\"1\":{\"164\":1}}],[\"提高性能\",{\"1\":{\"140\":1}}],[\"提高了工作线程的并发性\",{\"1\":{\"29\":1}}],[\"提取\",{\"1\":{\"126\":1}}],[\"资源重用\",{\"1\":{\"124\":1}}],[\"等待key存在或者超时\",{\"1\":{\"421\":1}}],[\"等待所有协程退出\",{\"1\":{\"401\":1}}],[\"等待数据载入之后开启索引\",{\"1\":{\"225\":1}}],[\"等待数据库验证用户身份\",{\"1\":{\"123\":1}}],[\"等于当前事务id\",{\"1\":{\"215\":1}}],[\"等多线程工具同时操作多台服务\",{\"1\":{\"201\":1}}],[\"等12个字段\",{\"1\":{\"195\":1}}],[\"等价于\",{\"1\":{\"43\":2}}],[\"应用于自己的系统设计中\",{\"1\":{\"350\":1}}],[\"应用程序根据业务逻辑来判断\",{\"1\":{\"191\":1}}],[\"应用程序和数据库建立连接的过程\",{\"0\":{\"123\":1}}],[\"应从事前\",{\"1\":{\"285\":1}}],[\"应考虑将缓存时间离散化\",{\"1\":{\"284\":1}}],[\"应该怎么办\",{\"1\":{\"265\":1}}],[\"应该使用char而不是varchar来存储\",{\"1\":{\"186\":1}}],[\"应该使用什么字段进行存储\",{\"0\":{\"186\":1}}],[\"应该也使用defalut语句块\",{\"1\":{\"7\":1}}],[\"应尽量避免把它设置为可空\",{\"1\":{\"181\":1}}],[\"应\",{\"1\":{\"151\":11}}],[\"维护一定数量的数据库连接\",{\"1\":{\"122\":1}}],[\"步骤五\",{\"1\":{\"117\":1,\"192\":1}}],[\"步骤四\",{\"1\":{\"117\":1,\"192\":1}}],[\"步骤三\",{\"1\":{\"117\":1,\"192\":1}}],[\"步骤二\",{\"1\":{\"117\":1,\"192\":1}}],[\"步骤一\",{\"1\":{\"117\":1,\"192\":1}}],[\"嘻嘻\",{\"1\":{\"117\":1}}],[\"协程和channel配合使用\",{\"0\":{\"418\":1}}],[\"协程可能还未启动\",{\"1\":{\"398\":1}}],[\"协程是不为操作系统所知的\",{\"1\":{\"19\":1}}],[\"协议\",{\"1\":{\"116\":1}}],[\"适用于精确查询\",{\"1\":{\"246\":1}}],[\"适合大量数据的插入和更新操作\",{\"1\":{\"183\":1}}],[\"适合使用in\",{\"1\":{\"112\":1}}],[\"适当分批量进行\",{\"1\":{\"82\":1}}],[\"申请空间再翻一倍\",{\"1\":{\"294\":1}}],[\"申请链接释放反复重复\",{\"1\":{\"112\":1}}],[\"申请读锁和写锁将会阻塞\",{\"1\":{\"58\":1}}],[\"很可能打印111func4\",{\"1\":{\"400\":1}}],[\"很慢\",{\"1\":{\"353\":1}}],[\"很容易有以下sql\",{\"1\":{\"112\":1}}],[\"很多人认为\",{\"1\":{\"213\":1}}],[\"很多人都知道mysql的索引主要以b+树为主\",{\"1\":{\"66\":1}}],[\"很多时候想要同时操作多个channel\",{\"1\":{\"7\":1}}],[\"假定该字符串有足够的空间存放新增的字符\",{\"1\":{\"382\":1}}],[\"假设有一个超长的切片\",{\"1\":{\"473\":1}}],[\"假设我们现在就一台redis服务器\",{\"1\":{\"306\":1}}],[\"假设我们在学生表的上建立了索引\",{\"1\":{\"152\":1}}],[\"假设商品库存有10个\",{\"1\":{\"268\":1}}],[\"假设表名为testcity\",{\"1\":{\"229\":1}}],[\"假设表a表示某企业的员工表\",{\"1\":{\"112\":1}}],[\"假设链接了两次\",{\"1\":{\"112\":1}}],[\"假如master服务器宕机了呢\",{\"1\":{\"306\":1}}],[\"假如a账户给b账户转10块钱\",{\"1\":{\"106\":1}}],[\"假如我们要查找id=28的用户信息\",{\"1\":{\"69\":1}}],[\"假如外部struct中的字段名和内部struct的字段名相同\",{\"1\":{\"42\":1}}],[\"假如有很多g\",{\"1\":{\"21\":1}}],[\"假如有四个内核\",{\"1\":{\"19\":1}}],[\"啊哈哈\",{\"1\":{\"112\":1}}],[\"确实会导致泄漏\",{\"1\":{\"503\":1}}],[\"确实如此\",{\"1\":{\"29\":1}}],[\"确定其中一个字符串的字符重新排列后\",{\"1\":{\"378\":1}}],[\"确定一个字符串的所有字符\",{\"1\":{\"370\":1}}],[\"确定删除键\",{\"1\":{\"346\":1}}],[\"确定是不是有消耗资源的sql在运行\",{\"1\":{\"190\":1}}],[\"确定是mysqld导致还是其他原因\",{\"1\":{\"190\":1}}],[\"确保最左匹配原则有效\",{\"1\":{\"111\":1}}],[\"复杂度为o\",{\"1\":{\"298\":1}}],[\"复制后影响的确实\",{\"1\":{\"438\":1}}],[\"复制代码还是重点解释一些关键的配置\",{\"1\":{\"353\":1}}],[\"复制代码在go语言中\",{\"1\":{\"19\":1}}],[\"复制偏移量\",{\"0\":{\"323\":1}}],[\"复制缓冲区空间设置\",{\"1\":{\"326\":1}}],[\"复制缓冲区到底存储的是什么\",{\"1\":{\"322\":1}}],[\"复制缓冲区的默认存储空间是1m\",{\"1\":{\"322\":1}}],[\"复制缓冲积压区是一个先进先出的队列\",{\"1\":{\"322\":1}}],[\"复制缓冲积压区\",{\"1\":{\"316\":1,\"317\":1}}],[\"复制积压缓冲区内存过小导致数据溢出\",{\"1\":{\"326\":1}}],[\"复制积压缓冲区\",{\"0\":{\"322\":1}}],[\"复制慢\",{\"1\":{\"238\":1}}],[\"复制模式\",{\"1\":{\"238\":1}}],[\"复制\",{\"0\":{\"238\":1}}],[\"复合索引\",{\"1\":{\"111\":1}}],[\"切换到其他节点进行工作\",{\"1\":{\"328\":1}}],[\"切分规则hash等\",{\"1\":{\"109\":1}}],[\"切片中的元素为乱序排序\",{\"1\":{\"473\":1}}],[\"切片之间不能直接比较\",{\"1\":{\"440\":1}}],[\"切片在扩容时会进行内存对齐\",{\"1\":{\"63\":1}}],[\"切片的元素类型为int\",{\"1\":{\"473\":1}}],[\"切片的扩容\",{\"1\":{\"63\":1}}],[\"切片的data属性是指向切片数组的指针\",{\"1\":{\"63\":1}}],[\"切片的内置结构\",{\"1\":{\"63\":1}}],[\"切片可以通过go内置append方法进行追加元素\",{\"1\":{\"63\":1}}],[\"切片可以追加元素\",{\"1\":{\"63\":1}}],[\"切片声明如下\",{\"1\":{\"63\":1}}],[\"切片描述的是一块数据\",{\"1\":{\"63\":1}}],[\"切片不是数组\",{\"1\":{\"63\":1}}],[\"切片是引用类型\",{\"1\":{\"63\":1}}],[\"切片是一种数据结构\",{\"1\":{\"63\":1}}],[\"切片是golang中特有的数据类型\",{\"1\":{\"63\":1}}],[\"切片\",{\"0\":{\"63\":1},\"1\":{\"473\":1}}],[\"切片初始化为nil切片\",{\"1\":{\"37\":1}}],[\"恢复数据\",{\"1\":{\"317\":1,\"318\":1}}],[\"恢复\",{\"1\":{\"107\":1,\"194\":1}}],[\"恢复上下文的时候用到\",{\"1\":{\"19\":1}}],[\"简单聊聊内存逃逸\",{\"0\":{\"487\":1}}],[\"简单来讲\",{\"1\":{\"300\":1}}],[\"简单了解下\",{\"1\":{\"234\":1}}],[\"简单的查询可以减少锁的竞争\",{\"1\":{\"232\":1}}],[\"简单的\",{\"1\":{\"214\":1}}],[\"简单点的话可以考虑使用uuid哈\",{\"1\":{\"113\":1}}],[\"简化缓存系统复杂度\",{\"1\":{\"288\":1}}],[\"简化复杂的sql操作\",{\"1\":{\"165\":1}}],[\"简化sql查询\",{\"1\":{\"164\":1}}],[\"简称\",{\"1\":{\"154\":1}}],[\"简言之\",{\"1\":{\"106\":1,\"192\":1}}],[\"简直是恶魔啊\",{\"1\":{\"21\":1}}],[\"包\",{\"1\":{\"502\":1}}],[\"包中的打印方法时\",{\"1\":{\"394\":1}}],[\"包含的列有\",{\"1\":{\"339\":1}}],[\"包含在其中的对数据库的操作要么全部被执行\",{\"1\":{\"106\":1}}],[\"包的形式提供轻量级服务的\",{\"1\":{\"116\":1}}],[\"包括当前结点存储的数据是什么\",{\"1\":{\"299\":1}}],[\"包括contents中存储的数值\",{\"1\":{\"298\":1}}],[\"包括散列函数\",{\"1\":{\"296\":1}}],[\"包括重复行\",{\"1\":{\"178\":1}}],[\"包括了忽略所有列\",{\"1\":{\"167\":1}}],[\"包括了所有的列\",{\"1\":{\"167\":1}}],[\"包括了所有正在临界区里面的读者或者被写锁阻塞的等待进入临界区读者的数量\",{\"1\":{\"58\":1}}],[\"包括内置简单数据类型\",{\"1\":{\"42\":1}}],[\"包括函数\",{\"1\":{\"41\":1}}],[\"包括下面的m0\",{\"1\":{\"37\":1}}],[\"包括栈\",{\"1\":{\"33\":1}}],[\"包括栈顶和栈底位置\",{\"1\":{\"31\":1}}],[\"没用索引\",{\"1\":{\"105\":1}}],[\"没有函数调用的死循环\",{\"1\":{\"401\":1}}],[\"没有\",{\"1\":{\"401\":2,\"464\":1}}],[\"没有发生键数据与值数据的拷贝或移动\",{\"1\":{\"296\":1}}],[\"没有发生panic\",{\"1\":{\"52\":1}}],[\"没有选取到的用户返回秒杀失败\",{\"1\":{\"268\":1}}],[\"没有顺序\",{\"1\":{\"218\":1}}],[\"没有唯一性的限制\",{\"1\":{\"143\":1}}],[\"没有匹配关系进行筛选\",{\"1\":{\"137\":1}}],[\"没有子节点的节点我们称之为叶节点\",{\"1\":{\"67\":1}}],[\"没有必要费力气建索引再去查找\",{\"1\":{\"66\":1}}],[\"没有定义任何接口方法\",{\"1\":{\"47\":1}}],[\"没有goroutine需要运行时\",{\"1\":{\"34\":1}}],[\"含义\",{\"0\":{\"105\":1},\"1\":{\"345\":1}}],[\"体现在\",{\"1\":{\"102\":1}}],[\"乐观\",{\"1\":{\"213\":1}}],[\"乐观情绪\",{\"1\":{\"102\":1}}],[\"乐观锁的\",{\"1\":{\"102\":1}}],[\"乐观锁\",{\"0\":{\"102\":1},\"1\":{\"156\":1,\"212\":2,\"213\":1}}],[\"乐观锁一般会使用版本号机制或cas算法实现\",{\"1\":{\"99\":1,\"102\":1}}],[\"乐观锁思想就是\",{\"1\":{\"99\":1}}],[\"获得数据后\",{\"1\":{\"112\":1}}],[\"获得\",{\"1\":{\"101\":1}}],[\"获取到\",{\"1\":{\"342\":1}}],[\"获取到参数之后\",{\"1\":{\"260\":1}}],[\"获取主节点每秒平均产生的命令总量write\",{\"1\":{\"326\":1}}],[\"获取最后一次错误\",{\"1\":{\"262\":1}}],[\"获取最后发生的错误\",{\"1\":{\"262\":1}}],[\"获取\",{\"1\":{\"260\":1}}],[\"获取map的长度\",{\"1\":{\"41\":1}}],[\"获取一个key值\",{\"1\":{\"41\":1}}],[\"~\",{\"1\":{\"98\":1,\"297\":1,\"299\":1}}],[\"~0\",{\"1\":{\"33\":1}}],[\"却返回了不同的数据\",{\"1\":{\"96\":1}}],[\"却又发现和\",{\"1\":{\"8\":1}}],[\"脏读\",{\"0\":{\"96\":1}}],[\"串行化没幻读\",{\"1\":{\"245\":1}}],[\"串行化\",{\"1\":{\"95\":1,\"223\":1,\"245\":1}}],[\"9號同学\",{\"1\":{\"503\":2}}],[\"98\",{\"0\":{\"205\":1}}],[\"97\",{\"0\":{\"204\":1}}],[\"96\",{\"0\":{\"203\":1},\"1\":{\"339\":3}}],[\"967\",{\"1\":{\"200\":1}}],[\"95\",{\"0\":{\"202\":1}}],[\"94\",{\"0\":{\"201\":1}}],[\"93\",{\"0\":{\"200\":1}}],[\"92\",{\"0\":{\"196\":1}}],[\"915\",{\"1\":{\"473\":1}}],[\"91\",{\"0\":{\"195\":1}}],[\"900\",{\"1\":{\"352\":2}}],[\"90\",{\"0\":{\"194\":1}}],[\"9999\",{\"1\":{\"193\":1}}],[\"9999999\",{\"1\":{\"132\":1}}],[\"99\",{\"0\":{\"206\":1},\"1\":{\"132\":1}}],[\"99到9999999\",{\"1\":{\"132\":1}}],[\"9\",{\"0\":{\"94\":1,\"399\":1,\"413\":1,\"453\":1,\"464\":1},\"1\":{\"132\":2,\"490\":2}}],[\"条件\",{\"1\":{\"93\":1}}],[\"偏移量\",{\"1\":{\"93\":1,\"318\":1}}],[\"方便大家在面试官面前秀一波\",{\"1\":{\"490\":1}}],[\"方向为正y\",{\"1\":{\"386\":1}}],[\"方案四\",{\"1\":{\"93\":1}}],[\"方案三\",{\"1\":{\"93\":1}}],[\"方案二\",{\"1\":{\"93\":1}}],[\"方案一\",{\"1\":{\"93\":1}}],[\"方法可以得到变量a的地址\",{\"1\":{\"496\":1}}],[\"方法的真正实现只能在运行时知道\",{\"1\":{\"489\":1}}],[\"方法的\",{\"1\":{\"458\":1}}],[\"方法的p是一个指针类型的person实例\",{\"1\":{\"43\":1}}],[\"方法实际上是实现了string的接口的\",{\"1\":{\"394\":1}}],[\"方法让错误和异常都在这里进行处理\",{\"1\":{\"262\":1}}],[\"方法如下\",{\"1\":{\"229\":1}}],[\"方法获取锁\",{\"1\":{\"57\":1}}],[\"方法集是类型的方法集合\",{\"1\":{\"46\":1}}],[\"方法集\",{\"0\":{\"46\":1}}],[\"方法\",{\"1\":{\"45\":1,\"394\":1,\"464\":1}}],[\"方法内部访问的和修改的都是原始的实例数据结构\",{\"1\":{\"43\":1}}],[\"方法内部访问的和修改的都是实例的副本\",{\"1\":{\"43\":1}}],[\"方法就是函数\",{\"1\":{\"43\":1}}],[\"方法中是指针类型的receiver\",{\"1\":{\"43\":1}}],[\"方法中是值类型的receiver\",{\"1\":{\"43\":1}}],[\"方法也有值类型的方法和指针类型的区别\",{\"1\":{\"43\":1}}],[\"方法将报错\",{\"1\":{\"42\":1}}],[\"方法来执行具体的gin\",{\"1\":{\"12\":1}}],[\"方法执行完毕关闭当前连接\",{\"1\":{\"12\":1}}],[\"方法代码如下\",{\"1\":{\"12\":1}}],[\"8的lru淘汰机制更接近理论lru\",{\"1\":{\"346\":1}}],[\"8中近似lru算法\",{\"1\":{\"346\":1}}],[\"8是部分复制\",{\"1\":{\"318\":1}}],[\"8kb\",{\"1\":{\"300\":1}}],[\"89\",{\"0\":{\"193\":1}}],[\"88\",{\"0\":{\"192\":1},\"1\":{\"266\":1}}],[\"87\",{\"0\":{\"191\":1}}],[\"86\",{\"0\":{\"190\":1},\"1\":{\"473\":1}}],[\"85\",{\"0\":{\"189\":1}}],[\"84\",{\"0\":{\"188\":1},\"1\":{\"339\":1}}],[\"8388609\",{\"1\":{\"299\":1}}],[\"8388607\",{\"1\":{\"299\":1}}],[\"8388608\",{\"1\":{\"299\":2}}],[\"83\",{\"0\":{\"187\":1}}],[\"82\",{\"0\":{\"186\":1}}],[\"81740\",{\"1\":{\"339\":1}}],[\"81\",{\"0\":{\"185\":1}}],[\"80365212\",{\"1\":{\"266\":1}}],[\"80\",{\"0\":{\"184\":1},\"1\":{\"266\":1}}],[\"8080\",{\"1\":{\"12\":1}}],[\"8\",{\"0\":{\"93\":1,\"301\":1,\"398\":1,\"412\":1,\"452\":1,\"463\":1},\"1\":{\"193\":1,\"243\":1,\"262\":1,\"319\":1,\"339\":6,\"346\":1,\"490\":2}}],[\"物理存储不按照索引排序\",{\"1\":{\"92\":1}}],[\"物理存储按照索引排序\",{\"1\":{\"92\":1}}],[\"链表中的每个结点都是一个ziplist\",{\"1\":{\"300\":1}}],[\"链表结点不直接持有数据\",{\"1\":{\"295\":1}}],[\"链表\",{\"0\":{\"276\":1},\"1\":{\"469\":1}}],[\"链表连着的\",{\"1\":{\"91\":1,\"148\":1}}],[\"链接\",{\"1\":{\"23\":1,\"207\":1,\"219\":1,\"329\":1,\"358\":1,\"503\":2}}],[\"树\",{\"1\":{\"246\":2}}],[\"树的高度也会降低\",{\"1\":{\"90\":1}}],[\"树就会更矮更胖\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"比较\",{\"1\":{\"435\":1}}],[\"比较有名引擎包括\",{\"1\":{\"242\":1}}],[\"比\",{\"1\":{\"87\":1}}],[\"比如均位于int16\",{\"1\":{\"298\":1}}],[\"比如商品实际库存\",{\"1\":{\"268\":1}}],[\"比如可以手动来触发rdb生成快照\",{\"1\":{\"358\":1}}],[\"比如可以多个结点持有同一份数据的地址\",{\"1\":{\"295\":1}}],[\"比如可以采取ip限流\",{\"1\":{\"268\":1}}],[\"比如可以判断某接口如果是a类型\",{\"1\":{\"48\":1}}],[\"比如倒计时\",{\"1\":{\"268\":1}}],[\"比如双十一的商品秒杀\",{\"1\":{\"267\":1}}],[\"比如淘宝和天猫\",{\"1\":{\"265\":1}}],[\"比如用户登录\",{\"1\":{\"264\":1}}],[\"比如错误页面啊\",{\"1\":{\"262\":1}}],[\"比如在开发模式下\",{\"1\":{\"262\":2}}],[\"比如thinkphp5和yii框架都实现了这个功能\",{\"1\":{\"260\":1}}],[\"比如日志表\",{\"1\":{\"250\":1}}],[\"比如字段\",{\"1\":{\"246\":1}}],[\"比如使用map\",{\"1\":{\"399\":1}}],[\"比如使用普通索引去查询主键字段或普通索引上的字段\",{\"1\":{\"246\":1}}],[\"比如使用select\",{\"1\":{\"189\":1}}],[\"比如有存储过程的语句\",{\"1\":{\"238\":1}}],[\"比如自增id\",{\"1\":{\"230\":1}}],[\"比如下面这个语句\",{\"1\":{\"230\":1}}],[\"比如locked\",{\"1\":{\"224\":1}}],[\"比如一个事务在进行\",{\"1\":{\"215\":1}}],[\"比如乐观锁会通过一个版本号控制\",{\"1\":{\"212\":1}}],[\"比如说限制连接数等\",{\"1\":{\"190\":1}}],[\"比如说加索引\",{\"1\":{\"190\":1}}],[\"比如alter\",{\"1\":{\"140\":1}}],[\"比如关键词是否正确等等\",{\"1\":{\"126\":1}}],[\"比如sync\",{\"1\":{\"119\":1}}],[\"比如\",{\"1\":{\"98\":1,\"134\":1,\"212\":1,\"214\":2,\"230\":1,\"234\":2,\"244\":1,\"246\":1,\"255\":1,\"260\":1,\"265\":1,\"301\":1,\"386\":1,\"473\":1}}],[\"比如1\",{\"1\":{\"72\":1}}],[\"比如goroutine的运行队列\",{\"1\":{\"35\":1}}],[\"比如goroutine的创建\",{\"1\":{\"19\":1}}],[\"比如从ch1\",{\"1\":{\"7\":1}}],[\"与aof重写\",{\"1\":{\"358\":1}}],[\"与末两个结点不压缩\",{\"1\":{\"300\":1}}],[\"与对应的memmove操作\",{\"1\":{\"299\":1}}],[\"与bucket数组长度的比值达到一个阈值\",{\"1\":{\"296\":1}}],[\"与相关接口的实现\",{\"1\":{\"295\":1}}],[\"与redis\",{\"0\":{\"292\":1}}],[\"与\",{\"0\":{\"167\":1},\"1\":{\"87\":1,\"292\":1,\"296\":1}}],[\"与线程的数量一一对应\",{\"1\":{\"20\":1}}],[\"按访问频次淘汰最少被访问的键\",{\"1\":{\"347\":1}}],[\"按访问url的hash结果来分配请求\",{\"1\":{\"266\":1}}],[\"按时间顺序接入不同键\",{\"1\":{\"346\":1}}],[\"按最小ttl的key优先淘汰\",{\"1\":{\"345\":1}}],[\"按小端序uint32\",{\"1\":{\"299\":1}}],[\"按幂次定律生成小于32的随机数的函数\",{\"1\":{\"297\":1}}],[\"按幂次定律随机生成\",{\"1\":{\"297\":1}}],[\"按strlen\",{\"1\":{\"294\":1}}],[\"按initlen的值\",{\"1\":{\"294\":1}}],[\"按read\",{\"1\":{\"288\":1}}],[\"按缓存系统所处位置不同\",{\"1\":{\"282\":1}}],[\"按后端服务器的响应时间来分配请求\",{\"1\":{\"266\":1}}],[\"按锁机制分有\",{\"1\":{\"156\":1}}],[\"按锁粒度分有\",{\"1\":{\"156\":1}}],[\"按记录插入顺序保存\",{\"1\":{\"87\":1}}],[\"按照\",{\"1\":{\"393\":1}}],[\"按照官方说法是在一行开头的content里面\",{\"1\":{\"215\":1}}],[\"按照锁的粒度分\",{\"0\":{\"156\":1}}],[\"按照字段的活跃性\",{\"1\":{\"84\":1}}],[\"按照业务归属不同\",{\"1\":{\"84\":1}}],[\"按照一定策略\",{\"1\":{\"84\":2}}],[\"多问一句\",{\"0\":{\"482\":1}}],[\"多协程查询切片问题\",{\"0\":{\"472\":1}}],[\"多协程操作时需要注意\",{\"1\":{\"41\":1}}],[\"多cpu核心下修改int的值极端情况下会存在不同步情况\",{\"1\":{\"424\":1}}],[\"多次访问\",{\"1\":{\"347\":1}}],[\"多个从节点的数据会不一致\",{\"1\":{\"328\":1}}],[\"多个缓存数据同时失效\",{\"1\":{\"283\":1}}],[\"多个事务并发访问时\",{\"1\":{\"106\":1}}],[\"多列索引及前缀索引\",{\"1\":{\"231\":1}}],[\"多列索引\",{\"0\":{\"230\":1}}],[\"多列值组成一个索引\",{\"1\":{\"143\":1}}],[\"多熟悉熟悉就能更深刻理解这个算法了\",{\"1\":{\"219\":1}}],[\"多库合并\",{\"1\":{\"183\":1}}],[\"多版本并发控制\",{\"1\":{\"87\":1,\"114\":1,\"212\":1}}],[\"支持平滑扩容等等\",{\"1\":{\"301\":1}}],[\"支持平滑扩容的字典\",{\"1\":{\"292\":1}}],[\"支持自动动态扩容的字节数组\",{\"1\":{\"292\":1}}],[\"支持集合间的操作\",{\"1\":{\"277\":1}}],[\"支持表级锁\",{\"1\":{\"223\":1}}],[\"支持四个事务隔离级别\",{\"1\":{\"223\":1}}],[\"支持\",{\"1\":{\"87\":1}}],[\"后\",{\"1\":{\"310\":1}}],[\"后边会在进一步对主从复制进行优化\",{\"1\":{\"309\":1}}],[\"后者为从节点\",{\"1\":{\"305\":1}}],[\"后者在排序时会消耗更多内存\",{\"1\":{\"175\":1}}],[\"后四个字节以小端序uint32\",{\"1\":{\"301\":1}}],[\"后续每一次的插入\",{\"1\":{\"296\":1}}],[\"后端的角度可以这样搞\",{\"1\":{\"268\":1}}],[\"后端服务器为缓存时比较有效\",{\"1\":{\"266\":1}}],[\"后面事务a和事务b都进行了提交的动作\",{\"1\":{\"219\":1}}],[\"后面出现的所有的线程一词均是指操作系统线程\",{\"1\":{\"27\":1}}],[\"后台加大pagesize处理\",{\"1\":{\"86\":1}}],[\"跨域\",{\"0\":{\"263\":1}}],[\"跨分片的排序分页问题\",{\"1\":{\"86\":1}}],[\"跨节点的count\",{\"1\":{\"86\":1}}],[\"跨节点join的问题\",{\"1\":{\"86\":1,\"109\":1}}],[\"谷歌开发的数据库中间件\",{\"1\":{\"85\":1}}],[\"常见语法题目\",{\"0\":{\"390\":1,\"404\":1}}],[\"常见面试题目解析\",{\"0\":{\"361\":1,\"362\":1}}],[\"常见方案spring\",{\"1\":{\"274\":1}}],[\"常见的索引数据结构\",{\"1\":{\"246\":1}}],[\"常见的并发模型有七种\",{\"1\":{\"16\":1}}],[\"常用的分库分表中间件\",{\"0\":{\"85\":1}}],[\"主进程就停止接受新的写入操作\",{\"1\":{\"352\":1}}],[\"主进程是否停止写入\",{\"1\":{\"352\":1}}],[\"主节点会触发\",{\"1\":{\"355\":1}}],[\"主节点会把收集的数据存储到复制缓冲区中\",{\"1\":{\"322\":1}}],[\"主节点发送rdb文件给从节点完成复制操作\",{\"1\":{\"355\":1}}],[\"主节点每秒调用复制定时函数replicationcron\",{\"1\":{\"327\":1}}],[\"主节点每秒产生的数据总量\",{\"1\":{\"326\":1}}],[\"主节点重启后加载rdb文件\",{\"1\":{\"325\":1}}],[\"主节点重启问题\",{\"0\":{\"325\":1}}],[\"主节点复制偏移量是给从节点发送一次记录一次\",{\"1\":{\"323\":1}}],[\"主节点就会强制关闭maste功能\",{\"1\":{\"319\":1}}],[\"主节点就会发送复制积压缓冲区的数据\",{\"1\":{\"316\":1}}],[\"主节点为保障数据稳定性\",{\"1\":{\"319\":1}}],[\"主节点与从节点之间一直都需要进行信息互换\",{\"1\":{\"319\":1}}],[\"主节点的offset是一直变化的\",{\"1\":{\"318\":1}}],[\"主节点在主从复制的期间是一直在接收客户端的数据\",{\"1\":{\"318\":1}}],[\"主节点判断runid和offset有一个不满足\",{\"1\":{\"318\":1}}],[\"主节点接收指令\",{\"1\":{\"318\":1}}],[\"主节点这个时候会把自己的runid\",{\"1\":{\"318\":1}}],[\"主节点开始执行bgsave生成rdb文件\",{\"1\":{\"318\":1}}],[\"主节点master保存从节点slave的端口\",{\"1\":{\"315\":1}}],[\"主节点写的东西\",{\"1\":{\"310\":1}}],[\"主索引和增量索引都要定时维护\",{\"1\":{\"238\":1}}],[\"主库配置二进制文件地址\",{\"1\":{\"238\":1}}],[\"主库从库配置server\",{\"1\":{\"238\":1}}],[\"主库\",{\"1\":{\"238\":1}}],[\"主库的更新事件\",{\"1\":{\"117\":1,\"192\":1}}],[\"主数据库有个bin\",{\"1\":{\"192\":1}}],[\"主服务器要负责更新操作\",{\"1\":{\"119\":1}}],[\"主服务器的sql大量积压\",{\"1\":{\"118\":1}}],[\"主从连接时间\",{\"1\":{\"326\":1}}],[\"主从服务器的数据不一致后\",{\"1\":{\"317\":1}}],[\"主从一致性校验有多种工具\",{\"1\":{\"203\":1}}],[\"主从复制工作的三大阶段以及工作流程\",{\"1\":{\"329\":1}}],[\"主从复制工作原理\",{\"0\":{\"313\":1}}],[\"主从复制常见的问题\",{\"0\":{\"324\":1}}],[\"主从复制完整的工作流程分为以下三个阶段\",{\"1\":{\"314\":1}}],[\"主从复制的三个阶段\",{\"0\":{\"314\":1}}],[\"主从复制启动后的日志信息查看\",{\"0\":{\"312\":1}}],[\"主从复制是哨兵和集群能够实施的基础\",{\"1\":{\"307\":1}}],[\"主从复制就是现在有俩台redis服务器\",{\"1\":{\"305\":1}}],[\"主从复制开启步骤\",{\"1\":{\"238\":1}}],[\"主从复制原理\",{\"1\":{\"192\":1}}],[\"主从复制\",{\"1\":{\"120\":1}}],[\"主从复制分了五个步骤进行\",{\"1\":{\"117\":1}}],[\"主从同步延迟的解决办法\",{\"0\":{\"119\":1}}],[\"主从同步延迟的原因\",{\"0\":{\"118\":1}}],[\"主键长度越小\",{\"1\":{\"246\":1}}],[\"主键最好使用整数类型\",{\"1\":{\"224\":1}}],[\"主键使用自增id还是uuid\",{\"0\":{\"183\":1}}],[\"主键\",{\"0\":{\"172\":1},\"1\":{\"172\":1}}],[\"主键列\",{\"1\":{\"151\":1}}],[\"主键索引重建\",{\"1\":{\"246\":1}}],[\"主键索引的b+树的叶子节点存储的是page\",{\"1\":{\"246\":1}}],[\"主键索引\",{\"1\":{\"143\":1,\"231\":1,\"246\":1}}],[\"主键的话就是表锁\",{\"1\":{\"105\":1}}],[\"主键啦\",{\"1\":{\"105\":1}}],[\"主表和扩展表\",{\"1\":{\"84\":1}}],[\"主要指令解析成功\",{\"1\":{\"386\":1}}],[\"主要有以下三个功能\",{\"1\":{\"335\":1}}],[\"主要做的事情是给主节点发送自己的复制偏移量\",{\"1\":{\"319\":1}}],[\"主要做的事情就是判断从节点是否在线\",{\"1\":{\"319\":1}}],[\"主要通过\",{\"1\":{\"262\":1}}],[\"主要节省的则是随机读磁盘的\",{\"1\":{\"251\":1}}],[\"主要节省的是随机写磁盘的\",{\"1\":{\"251\":1}}],[\"主要从更新性能考虑\",{\"1\":{\"250\":1}}],[\"主要就是修改端口\",{\"1\":{\"308\":1}}],[\"主要就是因为还没有引出聚集索引和非聚集索引的概念\",{\"1\":{\"72\":1}}],[\"主要就是考察面试者对锁和channel的知识\",{\"1\":{\"53\":1}}],[\"主要包括cpu的几个寄存器的值\",{\"1\":{\"32\":1}}],[\"主要是兼容性好\",{\"1\":{\"356\":1}}],[\"主要是通过主键来实现\",{\"1\":{\"230\":1}}],[\"主要是几个寄存器的值\",{\"1\":{\"33\":1}}],[\"主要是寄存器的值\",{\"1\":{\"28\":1,\"29\":1}}],[\"主要是实现了平滑扩容逻辑\",{\"1\":{\"296\":1}}],[\"主要是实现\",{\"1\":{\"12\":1}}],[\"主要表现在以下两个方面\",{\"1\":{\"27\":1}}],[\"主要用来解决操作系统线程太\",{\"1\":{\"27\":1}}],[\"主要工作就是回收垃圾\",{\"1\":{\"23\":1}}],[\"主要存储执行栈\",{\"1\":{\"19\":1}}],[\"垂直分表\",{\"1\":{\"84\":1,\"109\":2}}],[\"垂直分库\",{\"1\":{\"84\":1}}],[\"水平分表\",{\"1\":{\"84\":1,\"109\":2}}],[\"水平分库\",{\"1\":{\"84\":1}}],[\"说出为什么\",{\"0\":{\"415\":1}}],[\"说了这么多\",{\"1\":{\"308\":1}}],[\"说白了就是链表\",{\"1\":{\"276\":1}}],[\"说一下数据库的三大范式\",{\"0\":{\"138\":1}}],[\"说一下大表查询的优化方案\",{\"0\":{\"120\":1}}],[\"说说mysql\",{\"0\":{\"136\":1}}],[\"说说分库与分表的设计\",{\"0\":{\"83\":1}}],[\"说明\",{\"1\":{\"490\":3,\"502\":1}}],[\"说明原因\",{\"0\":{\"406\":1}}],[\"说明从节点已经跟主节点断开连接了\",{\"1\":{\"310\":1}}],[\"说明每个磁盘块仅仅存储一个键值和数据\",{\"1\":{\"69\":1}}],[\"说明锁起到了作用\",{\"1\":{\"52\":1}}],[\"避免因为物理内存不足导致fork失败\",{\"1\":{\"358\":1}}],[\"避免删除较多键导致的主从延迟\",{\"1\":{\"346\":1}}],[\"避免全部流量压垮系统\",{\"1\":{\"285\":1}}],[\"避免出现系统性故障\",{\"1\":{\"285\":1}}],[\"避免同时失效的情况下大量回源请求\",{\"1\":{\"284\":1}}],[\"避免数据回源\",{\"1\":{\"282\":1}}],[\"避免数据库连接泄漏\",{\"1\":{\"124\":1}}],[\"避免只读事务\",{\"1\":{\"245\":1}}],[\"避免长事务\",{\"1\":{\"245\":1}}],[\"避免排序和临时表\",{\"1\":{\"228\":1}}],[\"避免使用字符串类型\",{\"1\":{\"224\":1}}],[\"避免不必要的索引\",{\"1\":{\"144\":1}}],[\"避免返回不必要的数据\",{\"1\":{\"82\":1}}],[\"避免每次创建goroutine时都重新分配内存\",{\"1\":{\"36\":1}}],[\"找对应的runid索取数据\",{\"1\":{\"318\":1}}],[\"找到业务性能瓶颈\",{\"1\":{\"342\":1}}],[\"找到下一个非空的索引位\",{\"1\":{\"296\":1}}],[\"找到主键后我们需要再到聚集索引中查找具体对应的数据信息\",{\"1\":{\"72\":1}}],[\"找出下面代码的问题\",{\"0\":{\"437\":1}}],[\"找出消耗高的\",{\"1\":{\"190\":1}}],[\"找出死锁sql\",{\"1\":{\"81\":1}}],[\"你能答对几道题\",{\"1\":{\"444\":1}}],[\"你可以把session存储到一个公共的服务器或集群中\",{\"1\":{\"264\":1}}],[\"你可以通过配置\",{\"1\":{\"264\":1}}],[\"你只要知道有就行了\",{\"1\":{\"215\":1}}],[\"你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录\",{\"0\":{\"206\":1}}],[\"你如何优化\",{\"0\":{\"129\":1}}],[\"你们数据库是否支持emoji表情存储\",{\"0\":{\"204\":1}}],[\"你们的慢日志都是怎么查询的\",{\"0\":{\"202\":1}}],[\"你打算怎么做\",{\"0\":{\"203\":1}}],[\"你在设计索引是怎么抉择的\",{\"0\":{\"134\":1}}],[\"你怎么解决\",{\"0\":{\"117\":1}}],[\"你怎么来保证这个map是线程安全的呢\",{\"1\":{\"52\":1}}],[\"你这样回答\",{\"1\":{\"109\":1}}],[\"你是否做过主从一致性校验\",{\"0\":{\"203\":1}}],[\"你是如何监控你们的数据库的\",{\"0\":{\"202\":1}}],[\"你是如何删除的\",{\"0\":{\"146\":1}}],[\"你是如何解决的\",{\"0\":{\"81\":1}}],[\"你是怎么解决的呢\",{\"0\":{\"93\":1}}],[\"遇到过死锁问题吗\",{\"0\":{\"81\":1}}],[\"回头\",{\"1\":{\"503\":1}}],[\"回到刚刚启动的读goroutine\",{\"1\":{\"502\":1}}],[\"回答\",{\"0\":{\"478\":1,\"489\":1,\"495\":1}}],[\"回答这个问题\",{\"1\":{\"155\":1}}],[\"回写缓存\",{\"1\":{\"287\":1}}],[\"回滚日志\",{\"1\":{\"215\":1,\"245\":1}}],[\"回滚指针字段\",{\"1\":{\"215\":1}}],[\"回滚指针\",{\"1\":{\"215\":3,\"217\":1,\"219\":1}}],[\"回滚\",{\"1\":{\"87\":1,\"177\":1}}],[\"回表等这些\",{\"0\":{\"149\":1}}],[\"回表\",{\"1\":{\"80\":1,\"149\":1}}],[\"回收长时间系统调度阻塞的p\",{\"1\":{\"23\":1}}],[\"覆盖索引可以减少树的搜索次数\",{\"1\":{\"246\":1}}],[\"覆盖索引就是这么回事\",{\"1\":{\"152\":1}}],[\"覆盖索引\",{\"0\":{\"149\":1},\"1\":{\"80\":1,\"127\":1,\"143\":1,\"149\":1,\"246\":2}}],[\"左右\",{\"1\":{\"322\":1}}],[\"左右两边都能进行插入和删除数据\",{\"1\":{\"276\":1}}],[\"左连接\",{\"0\":{\"135\":1}}],[\"左连接查询或者右连接查询查询关联的字段编码格式不一样\",{\"1\":{\"78\":1}}],[\"左边的1表示的是索引的键值\",{\"1\":{\"72\":1}}],[\">null\",{\"1\":{\"469\":2}}],[\">next\",{\"1\":{\"296\":4}}],[\">8\",{\"1\":{\"469\":3}}],[\">7\",{\"1\":{\"469\":3}}],[\">6\",{\"1\":{\"469\":2}}],[\">5\",{\"1\":{\"469\":3}}],[\">4\",{\"1\":{\"469\":3}}],[\">3\",{\"1\":{\"469\":2}}],[\">2各位一组\",{\"1\":{\"469\":1}}],[\">2\",{\"1\":{\"469\":2}}],[\">eviction\",{\"1\":{\"346\":2}}],[\">exprie\",{\"1\":{\"264\":2}}],[\">exceptionhandler\",{\"1\":{\"262\":1}}],[\">dict\",{\"1\":{\"346\":2}}],[\">decr\",{\"1\":{\"268\":1,\"269\":1}}],[\">delete\",{\"1\":{\"264\":1}}],[\">zl\",{\"1\":{\"300\":2}}],[\">length\",{\"1\":{\"297\":1}}],[\">level\",{\"1\":{\"297\":6}}],[\">backward为整个跳跃表中\",{\"1\":{\"297\":1}}],[\">sz\",{\"1\":{\"300\":1}}],[\">score\",{\"1\":{\"297\":1}}],[\">setexprie\",{\"1\":{\"264\":1}}],[\">setsetex\",{\"1\":{\"264\":1}}],[\">forward\",{\"1\":{\"297\":1}}],[\">fatalexceptionfromerror\",{\"1\":{\"262\":1}}],[\">id\",{\"1\":{\"346\":1}}],[\">iterators\",{\"1\":{\"296\":1}}],[\">isfatal\",{\"1\":{\"262\":1}}],[\">key\",{\"1\":{\"296\":3}}],[\">k与dict\",{\"1\":{\"296\":1}}],[\">used++\",{\"1\":{\"296\":1}}],[\">utf8mb4\",{\"1\":{\"204\":1}}],[\">v分别指向的实际数据\",{\"1\":{\"296\":1}}],[\">table\",{\"1\":{\"296\":4}}],[\">type\",{\"1\":{\"296\":1}}],[\">header\",{\"1\":{\"297\":1}}],[\">head\",{\"1\":{\"297\":1}}],[\">ht\",{\"1\":{\"296\":33}}],[\">hashfunction\",{\"1\":{\"296\":1}}],[\">rehashidx++\",{\"1\":{\"296\":2}}],[\">rehashidx\",{\"1\":{\"296\":6}}],[\">redis这样的方案\",{\"1\":{\"285\":1}}],[\">rpush\",{\"1\":{\"268\":1,\"269\":1}}],[\">memcached\",{\"1\":{\"285\":1}}],[\">multi\",{\"1\":{\"269\":1}}],[\">无缓存则读取原始数据源\",{\"1\":{\"282\":1}}],[\">命中缓存则返回数据\",{\"1\":{\"282\":1}}],[\">缓存\",{\"1\":{\"282\":1}}],[\">watch\",{\"1\":{\"269\":1}}],[\">open\",{\"1\":{\"264\":1}}],[\">get\",{\"1\":{\"264\":1,\"268\":1,\"269\":1}}],[\">client\",{\"1\":{\"264\":4}}],[\">10\",{\"1\":{\"246\":1}}],[\">存储引擎\",{\"1\":{\"244\":2}}],[\">执行器\",{\"1\":{\"243\":1,\"244\":2}}],[\">优化器\",{\"1\":{\"243\":1,\"244\":1}}],[\">分析器\",{\"1\":{\"243\":1,\"244\":1}}],[\">查询缓存\",{\"1\":{\"243\":1}}],[\">=\",{\"1\":{\"218\":2,\"219\":3,\"294\":1,\"296\":1,\"346\":1,\"366\":1,\"424\":1}}],[\">\",{\"1\":{\"78\":1,\"195\":10,\"262\":1,\"296\":3,\"297\":3,\"299\":1,\"301\":2,\"339\":1,\"341\":1,\"342\":1,\"370\":6,\"374\":1,\"378\":2,\"382\":1,\"386\":1,\"445\":6}}],[\"否则退出goroutine\",{\"1\":{\"502\":1}}],[\"否则就说它\",{\"1\":{\"489\":1}}],[\"否则就是是行锁\",{\"1\":{\"105\":1}}],[\"否则无法捕获\",{\"1\":{\"397\":1}}],[\"否则请开启\",{\"1\":{\"352\":1}}],[\"否则用五个字节存储\",{\"1\":{\"301\":1}}],[\"否则每次迁移一个旧bucket索引上的所有结点\",{\"1\":{\"296\":1}}],[\"否则\",{\"1\":{\"296\":1}}],[\"否则会造成数据库及应用程序的维护困难\",{\"1\":{\"170\":1}}],[\"否则索引失效\",{\"1\":{\"78\":1}}],[\"否则f2一直阻塞\",{\"1\":{\"5\":1}}],[\"查到满足条件的第一个记录后\",{\"1\":{\"250\":1}}],[\"查到第一个满足条件的记录后\",{\"1\":{\"250\":1}}],[\"查看逃逸的情况\",{\"1\":{\"490\":1}}],[\"查看binlog日志的名字\",{\"1\":{\"238\":1}}],[\"查看session情况\",{\"1\":{\"190\":1}}],[\"查看mysql执行日志\",{\"1\":{\"129\":1}}],[\"查看执行计划\",{\"1\":{\"129\":1}}],[\"查看是否涉及多表和子查询\",{\"1\":{\"129\":1}}],[\"查看死锁日志show\",{\"1\":{\"81\":1}}],[\"查完就走\",{\"1\":{\"112\":1}}],[\"查询成员个数1000个以上的\",{\"1\":{\"341\":1}}],[\"查询内存占用最高的10个\",{\"1\":{\"341\":1}}],[\"查询总的内存占用\",{\"1\":{\"341\":1}}],[\"查询key个数\",{\"1\":{\"341\":1}}],[\"查询结果是联合索引的字段或是主键\",{\"1\":{\"246\":1}}],[\"查询缓存在每次表数据更新的时候就会清除缓存\",{\"1\":{\"243\":1}}],[\"查询优化相关\",{\"0\":{\"232\":1}}],[\"查询中的条件的列不能是一个表达式或函数的参数\",{\"1\":{\"228\":1}}],[\"查询sql数据表关联不要过多\",{\"1\":{\"224\":1}}],[\"查询数\",{\"1\":{\"224\":1}}],[\"查询线程数\",{\"1\":{\"224\":1}}],[\"查询命令发给备库\",{\"1\":{\"191\":1}}],[\"查询是否会用到索引\",{\"0\":{\"181\":1}}],[\"查询是否够快\",{\"1\":{\"88\":1}}],[\"查询简单化\",{\"1\":{\"166\":1}}],[\"查询列要被所建的索引覆盖\",{\"1\":{\"143\":1,\"149\":1}}],[\"查询语句\",{\"0\":{\"126\":1}}],[\"查询a的员工\",{\"1\":{\"112\":1}}],[\"查询所有部门的所有员工\",{\"1\":{\"112\":1}}],[\"查询效率高\",{\"1\":{\"183\":1}}],[\"查询效率就快啦\",{\"1\":{\"90\":1}}],[\"查询效率快得多\",{\"1\":{\"90\":1}}],[\"查询时的条件列不是联合索引中的第一个列\",{\"1\":{\"78\":1}}],[\"查询条件包含or\",{\"1\":{\"78\":1}}],[\"查找目标值为\",{\"1\":{\"473\":1}}],[\"查找使用二分法\",{\"1\":{\"298\":1}}],[\"查找与该分值最接近的结点\",{\"1\":{\"297\":1}}],[\"查找操作执行时\",{\"1\":{\"296\":1}}],[\"查找操作\",{\"1\":{\"296\":1}}],[\"查找的流程跟聚集索引一样\",{\"1\":{\"72\":1}}],[\"查找效率更稳定\",{\"1\":{\"68\":1,\"89\":1}}],[\"查找流程如下\",{\"1\":{\"67\":1}}],[\"详细介绍主从复制原理\",{\"0\":{\"318\":1}}],[\"详细说明了为什么mysql用b+树作为数据的索引\",{\"1\":{\"73\":1}}],[\"详见下面定义中的注释\",{\"1\":{\"34\":1}}],[\"右边的用不到\",{\"1\":{\"228\":1}}],[\"右边的1表示的是主键值\",{\"1\":{\"72\":1}}],[\"右连接有什么区别\",{\"0\":{\"135\":1}}],[\"右子节点的键值都大于当前节点的键值\",{\"1\":{\"67\":1}}],[\"7之前默认是基于语句\",{\"1\":{\"238\":1}}],[\"79\",{\"0\":{\"183\":1}}],[\"78273656\",{\"1\":{\"266\":1}}],[\"78\",{\"0\":{\"182\":1},\"1\":{\"473\":1}}],[\"777\",{\"1\":{\"200\":1}}],[\"77\",{\"0\":{\"181\":1}}],[\"762\",{\"1\":{\"473\":1}}],[\"76\",{\"0\":{\"180\":1},\"1\":{\"473\":1}}],[\"75\",{\"0\":{\"179\":1},\"1\":{\"297\":5}}],[\"74\",{\"0\":{\"178\":1}}],[\"7386\",{\"1\":{\"339\":1}}],[\"73\",{\"0\":{\"177\":1}}],[\"72\",{\"0\":{\"176\":1}}],[\"71\",{\"0\":{\"175\":1}}],[\"7080278\",{\"1\":{\"238\":1}}],[\"70\",{\"0\":{\"174\":1}}],[\"7以后的innodb也支持全文索引\",{\"1\":{\"87\":1}}],[\"7\",{\"0\":{\"92\":1,\"300\":1,\"397\":1,\"411\":1,\"451\":1,\"462\":1},\"1\":{\"72\":1,\"238\":1,\"490\":2,\"502\":4}}],[\"z表示当前方向\",{\"1\":{\"386\":1}}],[\"z0\",{\"1\":{\"386\":2}}],[\"z\",{\"1\":{\"366\":1,\"386\":20,\"438\":1}}],[\"zi\",{\"1\":{\"300\":2}}],[\"zipsaveinteger\",{\"1\":{\"299\":1}}],[\"zipstorepreventrylengthlarge\",{\"1\":{\"299\":2}}],[\"zipstorepreventrylength\",{\"1\":{\"299\":6}}],[\"zipstoreentryencoding\",{\"1\":{\"299\":3}}],[\"zipentry\",{\"1\":{\"299\":3}}],[\"zipprevlenbytediff\",{\"1\":{\"299\":1}}],[\"zipintsize\",{\"1\":{\"299\":1}}],[\"ziptryencoding\",{\"1\":{\"299\":1}}],[\"ziprawentrylength\",{\"1\":{\"299\":1}}],[\"zip\",{\"1\":{\"299\":10}}],[\"zipmap就会回收内存空间\",{\"1\":{\"301\":1}}],[\"zipmap中的每一个键值对\",{\"1\":{\"301\":1}}],[\"zipmap的最后一个字节是固定值0xff\",{\"1\":{\"301\":1}}],[\"zipmap的定义与实现在src\",{\"1\":{\"301\":1}}],[\"zipmap起始的第一个字节存储的是zipmap中键值对的个数\",{\"1\":{\"301\":1}}],[\"zipmap适合使用的场合是\",{\"1\":{\"301\":1}}],[\"zipmap\",{\"0\":{\"301\":1},\"1\":{\"292\":1,\"301\":2}}],[\"ziplist解决了耗费内存这个问题\",{\"1\":{\"300\":1}}],[\"ziplist的长度\",{\"1\":{\"300\":1}}],[\"ziplist的内存布局与intset一样\",{\"1\":{\"299\":1}}],[\"ziplists\",{\"1\":{\"300\":1}}],[\"ziplist==2\",{\"1\":{\"300\":1}}],[\"ziplist=2\",{\"1\":{\"300\":1}}],[\"ziplistcascadeupdate\",{\"1\":{\"299\":2}}],[\"ziplistresize\",{\"1\":{\"299\":2}}],[\"ziplistinsert\",{\"1\":{\"299\":1}}],[\"ziplist最蛋疼的一个问题是\",{\"1\":{\"299\":1}}],[\"ziplist也不预留内存空间\",{\"1\":{\"299\":1}}],[\"ziplist是一段连续的内存\",{\"1\":{\"300\":1}}],[\"ziplist是一种特别节省内存的数据结构\",{\"1\":{\"299\":1}}],[\"ziplist是最苟的底层数据结构\",{\"1\":{\"300\":1}}],[\"ziplist是redis底层数据结构中\",{\"1\":{\"299\":1}}],[\"ziplist几乎不浪费内存空间\",{\"1\":{\"299\":1}}],[\"ziplist无法存储\",{\"1\":{\"299\":1}}],[\"ziplist保证任何情况下\",{\"1\":{\"299\":1}}],[\"ziplist中的所有值都是以小端序存储的\",{\"1\":{\"299\":1}}],[\"ziplist\",{\"0\":{\"299\":1},\"1\":{\"292\":1,\"299\":13,\"300\":4,\"339\":1}}],[\"zl字段直接指向ziplist\",{\"1\":{\"300\":1}}],[\"zl字段指向的是原生的ziplist\",{\"1\":{\"300\":1}}],[\"zl字段指向的就不是一个ziplist实例\",{\"1\":{\"300\":1}}],[\"zl+intrev32ifbe\",{\"1\":{\"299\":1}}],[\"zl+offset\",{\"1\":{\"299\":3}}],[\"zlentry\",{\"1\":{\"299\":2}}],[\"zlend是一个终止字节\",{\"1\":{\"299\":1}}],[\"zl\",{\"1\":{\"299\":28,\"300\":2}}],[\"zllen字段的类型是uint16\",{\"1\":{\"299\":1}}],[\"zltail字段的类型是uint32\",{\"1\":{\"299\":1}}],[\"zlbytes字段的类型是uint32\",{\"1\":{\"299\":1}}],[\"zfree\",{\"1\":{\"296\":1}}],[\"zcalloc\",{\"1\":{\"296\":1}}],[\"zmalloc\",{\"1\":{\"296\":1,\"346\":1}}],[\"zhou\",{\"1\":{\"406\":1}}],[\"zhoujielun\",{\"1\":{\"392\":1,\"399\":1}}],[\"zh\",{\"1\":{\"262\":7,\"264\":3}}],[\"zslcreatenode\",{\"1\":{\"297\":1}}],[\"zslrandomlevel\",{\"1\":{\"297\":2}}],[\"zsl\",{\"1\":{\"297\":6}}],[\"zslinsert\",{\"1\":{\"297\":1}}],[\"zskiplist中持有字段level\",{\"1\":{\"297\":1}}],[\"zskiplist的核心设计要点为\",{\"1\":{\"297\":1}}],[\"zskiplistlevel\",{\"1\":{\"297\":1}}],[\"zskiplistnode\",{\"1\":{\"297\":8}}],[\"zskiplist是redis实现的一种特殊的跳跃表\",{\"1\":{\"297\":1}}],[\"zskiplist\",{\"0\":{\"297\":1},\"1\":{\"292\":1,\"297\":9}}],[\"zsets\",{\"1\":{\"297\":1}}],[\"zset\",{\"0\":{\"278\":1},\"1\":{\"292\":1}}],[\"zs\",{\"1\":{\"72\":1}}],[\"zero\",{\"1\":{\"57\":1}}],[\"什么时候会执行这个\",{\"1\":{\"502\":1}}],[\"什么时候会建立连接呢\",{\"1\":{\"502\":1}}],[\"什么情况下会发生内存逃逸\",{\"1\":{\"488\":1}}],[\"什么是redis主从复制\",{\"0\":{\"305\":1}}],[\"什么是触发器\",{\"0\":{\"170\":1}}],[\"什么是存储过程\",{\"0\":{\"169\":1}}],[\"什么是游标\",{\"0\":{\"168\":1}}],[\"什么是视图\",{\"0\":{\"160\":1,\"162\":1}}],[\"什么是死锁\",{\"0\":{\"159\":1}}],[\"什么是数据库事务\",{\"0\":{\"154\":1}}],[\"什么是数据库连接池\",{\"0\":{\"121\":1}}],[\"什么是最左匹配原则\",{\"0\":{\"147\":1}}],[\"什么是最左前缀原则\",{\"0\":{\"147\":1}}],[\"什么是内连接\",{\"0\":{\"137\":1}}],[\"什么是幻读\",{\"0\":{\"96\":1}}],[\"什么\",{\"1\":{\"72\":1}}],[\"yield\",{\"1\":{\"401\":1}}],[\"y的改变还受当前的z值影响\",{\"1\":{\"386\":1}}],[\"y表示y坐标\",{\"1\":{\"386\":1}}],[\"y0\",{\"1\":{\"386\":2}}],[\"yyyyyyyy\",{\"1\":{\"299\":1}}],[\"you\",{\"1\":{\"296\":1,\"414\":1}}],[\"yac\",{\"1\":{\"282\":1}}],[\"ywlaker\",{\"1\":{\"265\":1}}],[\"y\",{\"1\":{\"72\":1,\"386\":9,\"438\":1}}],[\"yu\",{\"1\":{\"72\":1}}],[\"yes|no\",{\"1\":{\"328\":1}}],[\"yes\",{\"1\":{\"44\":1,\"352\":5,\"353\":4}}],[\"定时执行执行任务\",{\"1\":{\"428\":1}}],[\"定时与painc恢复\",{\"0\":{\"427\":1},\"1\":{\"362\":1}}],[\"定时任务使用的是redis自己实现的\",{\"1\":{\"354\":1}}],[\"定时任务执行的频率可以在配置文件中通过\",{\"1\":{\"354\":1}}],[\"定时任务预热\",{\"1\":{\"284\":1}}],[\"定位目标\",{\"1\":{\"346\":1}}],[\"定位到页8\",{\"1\":{\"72\":1}}],[\"定位到页3\",{\"1\":{\"72\":1}}],[\"定义顺序的倒序\",{\"1\":{\"405\":1}}],[\"定义了ht\",{\"1\":{\"296\":1}}],[\"定义有外键的数据列一定要建立索引\",{\"1\":{\"144\":1}}],[\"定义\",{\"1\":{\"57\":1,\"283\":1,\"286\":1}}],[\"定义一个线程私有全局变量\",{\"1\":{\"29\":1}}],[\"定义一个全局的m结构体变量就行了\",{\"1\":{\"29\":1}}],[\"明白了聚集索引和非聚集索引的定义\",{\"1\":{\"71\":1}}],[\"明确指定了要拷贝的对象是指针类型的实例\",{\"1\":{\"43\":1}}],[\"以后有空再说吧\",{\"1\":{\"503\":1}}],[\"以后在程序中就可以调用该过程任意次\",{\"1\":{\"169\":1}}],[\"以字符串长度的1\",{\"1\":{\"374\":1}}],[\"以字段为依据\",{\"1\":{\"84\":3}}],[\"以上代码在\",{\"1\":{\"502\":2}}],[\"以上操作其实就叫逃逸分析\",{\"1\":{\"490\":1}}],[\"以上三种方法都可以实现这个算法\",{\"1\":{\"370\":1}}],[\"以上的\",{\"1\":{\"342\":1}}],[\"以上这条sql语句会锁定了user表中所有符合检索条件\",{\"1\":{\"98\":1}}],[\"以指示本链表结点所持有的ziplist是否经过了压缩\",{\"1\":{\"300\":1}}],[\"以此类推\",{\"1\":{\"300\":1}}],[\"以ziplist为结点的\",{\"1\":{\"300\":1}}],[\"以小端序int64\",{\"1\":{\"299\":1}}],[\"以小端序int32\",{\"1\":{\"299\":1}}],[\"以小端序int16\",{\"1\":{\"299\":1}}],[\"以小端序存储\",{\"1\":{\"299\":1}}],[\"以小端序无符号整数的形式存储着二进制数据的长度\",{\"1\":{\"299\":1}}],[\"以int8\",{\"1\":{\"299\":1}}],[\"以innodb作为存储引擎的表\",{\"1\":{\"71\":1}}],[\"以uint32\",{\"1\":{\"299\":1}}],[\"以快速完成pop等操作\",{\"1\":{\"299\":1}}],[\"以示字典不处于平滑扩容状态\",{\"1\":{\"296\":1}}],[\"以链式方式解决冲突\",{\"1\":{\"296\":1}}],[\"以void\",{\"1\":{\"295\":1}}],[\"以低三位标示着头部的类型\",{\"1\":{\"294\":1}}],[\"以应对在不同的应用场景中\",{\"1\":{\"292\":1}}],[\"以下代码打印出来什么内容\",{\"0\":{\"415\":1}}],[\"以下代码能编译过去吗\",{\"0\":{\"414\":1}}],[\"以下代码有什么问题\",{\"0\":{\"406\":1}}],[\"以下是结构体chan\",{\"1\":{\"481\":2}}],[\"以下是字符串chan\",{\"1\":{\"481\":2}}],[\"以下是数值的chan\",{\"1\":{\"481\":2}}],[\"以下是理论lru和近似lru的效果对比\",{\"1\":{\"346\":1}}],[\"以下是简单的实现思路\",{\"1\":{\"262\":1}}],[\"以下级别的错误不能由用户定义的函数来处理\",{\"1\":{\"262\":1}}],[\"以该错误的\",{\"1\":{\"262\":1}}],[\"以确保代码具有最佳的互操作性和向前兼容性\",{\"1\":{\"262\":1}}],[\"以age=1\",{\"1\":{\"246\":1}}],[\"以最左原则进行where检索\",{\"1\":{\"246\":1}}],[\"以二进制的方式向服务端发送参数和句柄\",{\"1\":{\"236\":1}}],[\"以表中的数据进行增\",{\"1\":{\"142\":1}}],[\"以表为依据\",{\"1\":{\"84\":1}}],[\"以便保存那些值的小数精度\",{\"1\":{\"132\":1}}],[\"以及上面提到的自动触发的频率减少fork次数\",{\"1\":{\"355\":1}}],[\"以及可以附带私有数据\",{\"1\":{\"296\":1}}],[\"以及键的比较函数\",{\"1\":{\"296\":1}}],[\"以及varchar\",{\"0\":{\"176\":1}}],[\"以及某张表\",{\"1\":{\"137\":1}}],[\"以及并发情况下的隔离性\",{\"1\":{\"107\":1,\"194\":1}}],[\"以及查找磁盘次数\",{\"1\":{\"88\":1}}],[\"以及在innodb中数据库如何通过b+树索引来存储数据以及查找数据\",{\"1\":{\"73\":1}}],[\"以主键以外的列值作为键值构建的b+树索引\",{\"1\":{\"71\":1}}],[\"聚簇索引是一种数据存储方式\",{\"1\":{\"230\":1}}],[\"聚簇索引\",{\"1\":{\"71\":1}}],[\"聚集索引与非聚集索引的区别\",{\"0\":{\"92\":1}}],[\"聚集索引和非聚集索引的叶子节点都会存储数据的文件地址\",{\"1\":{\"72\":1}}],[\"聚集索引和非聚集索引下面会讲到\",{\"1\":{\"70\":1}}],[\"聚集索引\",{\"0\":{\"71\":1},\"1\":{\"71\":1,\"92\":2}}],[\"分担服务器负载\",{\"1\":{\"307\":1}}],[\"分值小于或等于指定分值的最后一个结点\",{\"1\":{\"297\":1}}],[\"分值大于指定分值的第一个结点\",{\"1\":{\"297\":1}}],[\"分值\",{\"1\":{\"297\":1}}],[\"分布式系统解决缓存容量问题\",{\"1\":{\"282\":1}}],[\"分布式缓存\",{\"1\":{\"282\":2}}],[\"分布式事务等\",{\"1\":{\"109\":1}}],[\"分为本地缓存\",{\"1\":{\"282\":1}}],[\"分为两类\",{\"1\":{\"215\":1}}],[\"分数\",{\"1\":{\"278\":1}}],[\"分区列不能在表达式中\",{\"1\":{\"234\":1}}],[\"分区列和索引列匹配\",{\"1\":{\"234\":1}}],[\"分区的维护成本比较高\",{\"1\":{\"234\":1}}],[\"分区的时候最好不要选择默认为null的列\",{\"1\":{\"234\":1}}],[\"分区在查询的时候需要锁住所有的底层表\",{\"1\":{\"234\":1}}],[\"分区\",{\"0\":{\"234\":1},\"1\":{\"234\":1}}],[\"分解关联查询\",{\"1\":{\"188\":1,\"232\":1}}],[\"分主键列完全依赖于主键\",{\"1\":{\"138\":1}}],[\"分表方案\",{\"1\":{\"109\":1}}],[\"分表\",{\"1\":{\"109\":1,\"129\":1}}],[\"分别为redis6379\",{\"1\":{\"308\":1}}],[\"分别六部分\",{\"1\":{\"301\":1}}],[\"分别代表\",{\"1\":{\"299\":1}}],[\"分别如下\",{\"1\":{\"294\":1}}],[\"分别有什么区别\",{\"0\":{\"140\":1}}],[\"分别在各个节点上得到结果后在应用程序端进行合并\",{\"1\":{\"86\":1}}],[\"分别是第一次发现位置和最后发现位置\",{\"1\":{\"370\":1}}],[\"分别是宏intset\",{\"1\":{\"298\":1}}],[\"分别是未提交读\",{\"1\":{\"223\":1}}],[\"分别是\",{\"1\":{\"195\":1,\"264\":1,\"268\":1,\"292\":1,\"294\":1,\"386\":1}}],[\"分别是add\",{\"1\":{\"52\":1}}],[\"分别是goroutine\",{\"1\":{\"18\":1}}],[\"分库分表一些问题\",{\"1\":{\"109\":1}}],[\"分库分表可能遇到的问题\",{\"0\":{\"86\":1},\"1\":{\"83\":1}}],[\"分库分表中间件\",{\"1\":{\"83\":1,\"109\":1}}],[\"分库分表方案\",{\"0\":{\"84\":1},\"1\":{\"83\":1}}],[\"分库分表\",{\"0\":{\"109\":1},\"1\":{\"82\":1,\"120\":1}}],[\"分析内存快照\",{\"0\":{\"340\":1}}],[\"分析器\",{\"1\":{\"242\":1}}],[\"分析器进行词法分析\",{\"1\":{\"126\":1}}],[\"分析你的sql\",{\"1\":{\"189\":1}}],[\"分析sql执行句话\",{\"1\":{\"182\":1}}],[\"分析sql加锁情况\",{\"1\":{\"81\":1}}],[\"分析语句\",{\"1\":{\"182\":1}}],[\"分析是否有其他方面的问题\",{\"1\":{\"129\":1}}],[\"分析低效\",{\"1\":{\"103\":1}}],[\"分析死锁结果\",{\"1\":{\"81\":1}}],[\"分析死锁日志\",{\"1\":{\"81\":1}}],[\"分组查找以及去重查找变得异常简单\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"排行榜\",{\"1\":{\"278\":1}}],[\"排查过程\",{\"1\":{\"190\":1}}],[\"排序查找\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"排他锁只可以加一个\",{\"1\":{\"157\":1}}],[\"排他锁\",{\"1\":{\"57\":1,\"157\":1}}],[\"键值对hello\",{\"1\":{\"301\":1}}],[\"键值对量不大\",{\"1\":{\"301\":1}}],[\"键值均是二进制数据\",{\"1\":{\"301\":1}}],[\"键值28对应的用户信息为\",{\"1\":{\"69\":1}}],[\"键与值的复制函数\",{\"1\":{\"296\":1}}],[\"键\",{\"1\":{\"296\":1}}],[\"键和值即存放在内部节点又存放在叶子节点\",{\"1\":{\"148\":1}}],[\"键对应user表中的id\",{\"1\":{\"67\":1}}],[\"总的来说\",{\"1\":{\"333\":1}}],[\"总之\",{\"1\":{\"298\":1}}],[\"总字节数\",{\"1\":{\"294\":1}}],[\"总体占用计算出来后\",{\"1\":{\"299\":1}}],[\"总体来说\",{\"1\":{\"288\":1}}],[\"总体的查找速度也更快\",{\"1\":{\"68\":1,\"89\":1}}],[\"总是会用到会话管理\",{\"1\":{\"264\":1}}],[\"总结图中展示规律\",{\"1\":{\"346\":1}}],[\"总结\",{\"0\":{\"73\":1,\"329\":1,\"342\":1,\"503\":1},\"1\":{\"219\":1,\"294\":1,\"296\":1}}],[\"总结下来就是\",{\"1\":{\"57\":1}}],[\"总共12条记录\",{\"1\":{\"72\":1}}],[\"利用一台从机器进行备份处理\",{\"1\":{\"358\":1}}],[\"利用缓存应对写请求\",{\"1\":{\"268\":1}}],[\"利用缓存应对读请求\",{\"1\":{\"268\":1}}],[\"利用缓存分担数据库压力\",{\"1\":{\"268\":1}}],[\"利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求\",{\"1\":{\"268\":1}}],[\"利用中间件来做代理\",{\"1\":{\"191\":1}}],[\"利用zookeeper生成唯一id\",{\"1\":{\"94\":1}}],[\"利用延迟关联或者子查询优化超多分页场景\",{\"1\":{\"93\":1}}],[\"利用非聚集索引查找数据\",{\"1\":{\"72\":1}}],[\"利用聚集索引查找数据\",{\"1\":{\"72\":1}}],[\"利用聚集索引和非聚集索引查找数据\",{\"0\":{\"72\":1}}],[\"利用二叉查找树我们只需要3次即可找到匹配的数据\",{\"1\":{\"67\":1}}],[\"利用我们创建的二叉查找树索引\",{\"1\":{\"67\":1}}],[\"满足条件\",{\"1\":{\"67\":1}}],[\"把内容都读出来了\",{\"1\":{\"503\":1}}],[\"把连接放回池子里复用\",{\"1\":{\"502\":1}}],[\"把连接关闭\",{\"1\":{\"123\":1}}],[\"把每个写命令都立即同步到aof\",{\"1\":{\"353\":1}}],[\"把一台redis的数据同步到另一台redis数据库上\",{\"1\":{\"305\":1}}],[\"把一台从服务器当度作为备份使用\",{\"1\":{\"119\":1}}],[\"把所有结点迁移到新bucket中去\",{\"1\":{\"296\":1}}],[\"把新dictht结构挂在ht\",{\"1\":{\"296\":1}}],[\"把常用信息\",{\"1\":{\"274\":1}}],[\"把用户id作为value\",{\"1\":{\"268\":1}}],[\"把binlog的内容发送到从库\",{\"1\":{\"117\":1,\"192\":1}}],[\"把12和当前节点的键值12对比\",{\"1\":{\"67\":1}}],[\"把12与当前节点的键值10比较\",{\"1\":{\"67\":1}}],[\"把当前节点的左子节点作为当前节点\",{\"1\":{\"67\":1}}],[\"发生以下情况时让出当前\",{\"1\":{\"401\":1}}],[\"发生锁冲突的概率低\",{\"1\":{\"133\":1}}],[\"发生锁冲突概率高\",{\"1\":{\"133\":1}}],[\"发现答案是3\",{\"1\":{\"501\":1}}],[\"发现错误就会停止\",{\"1\":{\"353\":1}}],[\"发现链表头部的\",{\"1\":{\"218\":1}}],[\"发现此时\",{\"1\":{\"218\":1}}],[\"发现此时是\",{\"1\":{\"218\":1}}],[\"发现这个\",{\"1\":{\"218\":1}}],[\"发现\",{\"1\":{\"218\":1,\"219\":1}}],[\"发现他们两的\",{\"1\":{\"218\":2}}],[\"发现41大于40\",{\"1\":{\"72\":1}}],[\"发现有匹配的键值28\",{\"1\":{\"69\":1}}],[\"发现12小于13\",{\"1\":{\"67\":1}}],[\"发送指针或带有指针的值到\",{\"1\":{\"489\":1}}],[\"发送slave端口信息\",{\"1\":{\"315\":1}}],[\"发送结果到客户端\",{\"1\":{\"179\":1}}],[\"发送数据库用户账号密码\",{\"1\":{\"123\":1}}],[\"发送\",{\"1\":{\"2\":1}}],[\"将字符串中的空格全部替换为\",{\"1\":{\"382\":1}}],[\"将str\",{\"1\":{\"374\":1}}],[\"将文件中的repl\",{\"1\":{\"325\":1}}],[\"将会拒绝所有信息同步\",{\"1\":{\"319\":1}}],[\"将数据保存在多个服务器上\",{\"1\":{\"306\":1}}],[\"将数据页读到内存\",{\"1\":{\"250\":1}}],[\"将回源数据\",{\"1\":{\"288\":1}}],[\"将大流量请求写到消息队列缓存\",{\"1\":{\"268\":1}}],[\"将秒杀业务系统和其他业务分离\",{\"1\":{\"268\":1}}],[\"将查找频繁的数据进行靠左创建索引\",{\"1\":{\"246\":1}}],[\"将表的数据变成下面这个样子\",{\"1\":{\"217\":1}}],[\"将表中字段拆到不同的表\",{\"1\":{\"84\":1}}],[\"将更新内容写入到slave的db\",{\"1\":{\"117\":1,\"192\":1}}],[\"将\",{\"1\":{\"116\":1,\"502\":1}}],[\"将持久地保存在数据库之中\",{\"1\":{\"106\":1}}],[\"将不同的表拆分到不同的库中\",{\"1\":{\"84\":1}}],[\"将一个大的查询分为多个小的相同的查询\",{\"1\":{\"188\":1}}],[\"将一个表中的数据拆分到多个表中\",{\"1\":{\"84\":1}}],[\"将一个库中的数据拆分到多个库中\",{\"1\":{\"84\":1}}],[\"将页8读取到内存中后\",{\"1\":{\"72\":1}}],[\"将28和页8中的键值相比较\",{\"1\":{\"69\":1}}],[\"将28和页3中的键值相比较\",{\"1\":{\"69\":1}}],[\"将根节点作为当前节点\",{\"1\":{\"67\":1}}],[\"将延时器放到for循环之外定义\",{\"1\":{\"8\":1}}],[\"顶端的节点我们称为根节点\",{\"1\":{\"67\":1}}],[\"建立socket连接\",{\"1\":{\"315\":1}}],[\"建立连接过程\",{\"0\":{\"315\":1},\"1\":{\"314\":1}}],[\"建立合适的索引\",{\"1\":{\"232\":1}}],[\"建立了一个二叉查找树的索引\",{\"1\":{\"67\":1}}],[\"建议没有必要开启\",{\"1\":{\"352\":1}}],[\"建议阅读左耳朵耗子\",{\"1\":{\"287\":1}}],[\"建议总是作为一个单独的文件来存储\",{\"1\":{\"255\":1}}],[\"建议指定确切路径和文件名\",{\"1\":{\"238\":1}}],[\"建议使用读写锁\",{\"1\":{\"412\":1}}],[\"建议使用单调顺序自增类型\",{\"1\":{\"230\":1}}],[\"建议使用指针作为参数值进行传递\",{\"1\":{\"42\":1}}],[\"建议跟业务讨论\",{\"1\":{\"93\":1}}],[\"建议条件允许的情况下加上defer\",{\"1\":{\"2\":1}}],[\"平滑扩容过程中\",{\"1\":{\"296\":1}}],[\"平滑扩容的重点在于两个策略\",{\"1\":{\"296\":1}}],[\"平平无奇的链表\",{\"1\":{\"292\":1}}],[\"平时积累吧\",{\"1\":{\"189\":1}}],[\"平衡二叉树相比于二叉查找树来说\",{\"1\":{\"68\":1,\"89\":1}}],[\"平衡二叉树会进行调整树上的节点来保持平衡\",{\"1\":{\"68\":1}}],[\"平衡二叉树保证了树的构造是平衡的\",{\"1\":{\"68\":1}}],[\"平衡二叉树又称avl树\",{\"1\":{\"68\":1}}],[\"平衡二叉树\",{\"0\":{\"68\":1}}],[\"平衡二叉树和b树这三种数据结构\",{\"1\":{\"66\":1}}],[\"平也\",{\"1\":{\"23\":1}}],[\"全量复制+部分复制\",{\"0\":{\"318\":1}}],[\"全量复制\",{\"1\":{\"316\":1,\"322\":1}}],[\"全量复制执行完成后\",{\"1\":{\"316\":1}}],[\"全字段加入索引\",{\"1\":{\"253\":1}}],[\"全连接\",{\"1\":{\"174\":1}}],[\"全文索引\",{\"1\":{\"66\":1,\"143\":1,\"235\":1}}],[\"全称communicating\",{\"1\":{\"17\":1}}],[\"索引为\",{\"1\":{\"438\":2}}],[\"索引值减小了\",{\"1\":{\"296\":1}}],[\"索引选择是要根据业务来做的\",{\"1\":{\"250\":1}}],[\"索引总结\",{\"1\":{\"246\":1}}],[\"索引总是遵循最左前缀\",{\"1\":{\"228\":1}}],[\"索引重建过程\",{\"1\":{\"246\":1}}],[\"索引遵循最左前缀原则\",{\"1\":{\"246\":1}}],[\"索引和值分离\",{\"1\":{\"231\":1}}],[\"索引和权限也会被删除\",{\"1\":{\"177\":1}}],[\"索引可以将随机i\",{\"1\":{\"228\":1}}],[\"索引可以减少服务器扫描的数据量\",{\"1\":{\"228\":1}}],[\"索引可以加快数据查询速度\",{\"1\":{\"142\":1}}],[\"索引相关\",{\"0\":{\"228\":1}}],[\"索引列不能参与计算\",{\"1\":{\"144\":1}}],[\"索引有哪几种类型\",{\"0\":{\"143\":1}}],[\"索引有哪些优缺点\",{\"0\":{\"142\":1}}],[\"索引也要动态的维护\",{\"1\":{\"142\":1}}],[\"索引需要占物理空间\",{\"1\":{\"142\":1}}],[\"索引优化\",{\"0\":{\"110\":1}}],[\"索引\",{\"0\":{\"246\":1},\"1\":{\"93\":1}}],[\"索引的区分度越好\",{\"1\":{\"252\":1}}],[\"索引的出现其实就是为了提高数据查询的效率\",{\"1\":{\"246\":1}}],[\"索引的叶节点就是数据节点\",{\"1\":{\"92\":1}}],[\"索引的一些潜规则\",{\"0\":{\"80\":1}}],[\"索引是否缺失\",{\"1\":{\"190\":1}}],[\"索引是通过二叉树的数据结构来描述的\",{\"1\":{\"92\":1}}],[\"索引是一种数据结构\",{\"1\":{\"66\":1}}],[\"索引中列的顺序不同效果也不一样\",{\"1\":{\"228\":1}}],[\"索引中的列不能被跳过\",{\"1\":{\"228\":1}}],[\"索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同\",{\"1\":{\"92\":1}}],[\"索引中键值的逻辑顺序决定了表中相应行的物理顺序\",{\"1\":{\"92\":1}}],[\"索引下推优化是\",{\"1\":{\"127\":1}}],[\"索引下推\",{\"1\":{\"80\":1,\"127\":1,\"246\":2}}],[\"索引数据结构\",{\"1\":{\"80\":1}}],[\"索引字段上使用is\",{\"1\":{\"78\":1}}],[\"索引字段上使用\",{\"1\":{\"78\":1}}],[\"索引失效\",{\"1\":{\"78\":3}}],[\"索引规则\",{\"1\":{\"77\":1}}],[\"索引不适合哪些场景\",{\"0\":{\"79\":1},\"1\":{\"77\":1}}],[\"索引哪些情况会失效\",{\"0\":{\"78\":1},\"1\":{\"77\":1}}],[\"索引使用有哪些注意事项呢\",{\"0\":{\"77\":1}}],[\"索引即数据\",{\"1\":{\"71\":1,\"73\":1}}],[\"索引就是这样存储的\",{\"1\":{\"70\":1}}],[\"索引在mysql数据库中分三类\",{\"1\":{\"66\":1}}],[\"索引最形象的比喻就是图书的目录了\",{\"1\":{\"66\":1}}],[\"索引这个词\",{\"1\":{\"66\":1}}],[\"恐怕很少有人能把前因后果讲述的很完整\",{\"1\":{\"66\":1}}],[\"修改以下代码完成该过程\",{\"1\":{\"424\":1}}],[\"修改为指针类型\",{\"1\":{\"399\":1}}],[\"修改复制积压缓冲区的大小\",{\"1\":{\"326\":1}}],[\"修改配置文件\",{\"1\":{\"308\":1}}],[\"修改查询语句\",{\"1\":{\"252\":1}}],[\"修改记录中其他字段的值\",{\"1\":{\"128\":1}}],[\"修改拷贝数据不会对原切片有影响\",{\"1\":{\"63\":1}}],[\"修改和简化处理\",{\"1\":{\"28\":1}}],[\"王五\",{\"1\":{\"63\":2}}],[\"李四\",{\"1\":{\"63\":2}}],[\"张三\",{\"1\":{\"63\":2,\"246\":2}}],[\"访问不了int1追加的元素\",{\"1\":{\"63\":1}}],[\"倍\",{\"1\":{\"63\":1}}],[\"大致描述如下\",{\"1\":{\"469\":1}}],[\"大小写的英文字母组成\",{\"1\":{\"382\":1}}],[\"大小写为不同字符\",{\"1\":{\"378\":1}}],[\"大愚talk\",{\"1\":{\"358\":1}}],[\"大家自行感受一下\",{\"1\":{\"299\":1}}],[\"大家可以参考下\",{\"1\":{\"53\":1}}],[\"大家可以对代码进行修改试一试\",{\"1\":{\"53\":1}}],[\"大量非法请求时\",{\"1\":{\"286\":1}}],[\"大量数据源读取操作\",{\"1\":{\"286\":1}}],[\"大量回源请求\",{\"1\":{\"285\":1}}],[\"大量占用存储空间\",{\"1\":{\"215\":1}}],[\"大部分请求是查询请求\",{\"1\":{\"268\":1}}],[\"大多数mysql存储引擎都实现了b\",{\"1\":{\"228\":1}}],[\"大于等于\",{\"1\":{\"215\":1}}],[\"大于等于老\",{\"1\":{\"63\":1}}],[\"大数目的不同值\",{\"1\":{\"151\":1}}],[\"新创建的g会调用这个方法来决定如何调度\",{\"1\":{\"407\":1}}],[\"新增lfu淘汰机制\",{\"1\":{\"347\":1}}],[\"新增写入的键\",{\"1\":{\"346\":1}}],[\"新增一个针对于当前字段的hash值列\",{\"1\":{\"253\":1}}],[\"新建一个dictht结构\",{\"1\":{\"296\":1}}],[\"新的资源分配手段\",{\"1\":{\"124\":1}}],[\"新\",{\"1\":{\"63\":3}}],[\"最先输出的是最后创建的g\",{\"1\":{\"407\":1}}],[\"最开始\",{\"1\":{\"386\":1}}],[\"最早写入键逐步被淘汰\",{\"1\":{\"346\":1}}],[\"最好一次性写对\",{\"1\":{\"299\":1}}],[\"最好由作者去维护\",{\"1\":{\"299\":1}}],[\"最坏情况下\",{\"1\":{\"299\":1}}],[\"最苟的一个结构\",{\"1\":{\"299\":1}}],[\"最复杂的操作即是插入与删除结点\",{\"1\":{\"297\":1}}],[\"最简单的key\",{\"1\":{\"268\":1}}],[\"最简单可以考虑uuid\",{\"1\":{\"86\":1}}],[\"最大值为2^16\",{\"1\":{\"300\":1}}],[\"最大值为2^15个\",{\"1\":{\"300\":1}}],[\"最大连接数\",{\"1\":{\"237\":1}}],[\"最大扩展到capacity的长度\",{\"1\":{\"63\":1}}],[\"最终输出五个随机数\",{\"1\":{\"418\":1}}],[\"最终效果如下\",{\"1\":{\"366\":1}}],[\"最终选定待删除键bestkey\",{\"1\":{\"346\":1}}],[\"最终实现与精确lru非常接近的表现\",{\"1\":{\"346\":1}}],[\"最终判断不可见之后通过回滚指针查看旧版本\",{\"1\":{\"218\":1}}],[\"最终我们找到满足条件的所有数据为\",{\"1\":{\"72\":1}}],[\"最后加上main\",{\"1\":{\"503\":1}}],[\"最后保证三分钟只能访问一次\",{\"1\":{\"424\":1}}],[\"最后说明了主从复制常见问题\",{\"1\":{\"329\":1}}],[\"最后就是真实的数据了\",{\"1\":{\"299\":1}}],[\"最后再置rehashidx=\",{\"1\":{\"296\":1}}],[\"最后会发现\",{\"1\":{\"219\":1}}],[\"最后的小亮也是如此\",{\"1\":{\"219\":1}}],[\"最后一个判断小亮这条记录\",{\"1\":{\"219\":1}}],[\"最后\",{\"1\":{\"218\":1,\"219\":1}}],[\"最重要的\",{\"1\":{\"215\":1}}],[\"最近修改\",{\"1\":{\"215\":1}}],[\"最左前缀\",{\"1\":{\"246\":1}}],[\"最左前缀可以是联合索引的最左\",{\"1\":{\"246\":1}}],[\"最左前缀匹配原则\",{\"1\":{\"144\":1}}],[\"最左前缀原则\",{\"1\":{\"80\":1,\"127\":1,\"147\":1}}],[\"最多损失1s的数据\",{\"1\":{\"353\":1}}],[\"最多只能创建maxmcount个工作线程\",{\"1\":{\"36\":1}}],[\"最多会有gomaxprocs个活跃线程能够正常运行\",{\"1\":{\"19\":1}}],[\"下篇文章\",{\"1\":{\"490\":1}}],[\"下载后的数据为\",{\"1\":{\"334\":1}}],[\"下图案例中\",{\"1\":{\"305\":1}}],[\"下图即是一颗b树\",{\"1\":{\"69\":1}}],[\"下一次读操作\",{\"1\":{\"288\":1}}],[\"下的cookie\",{\"1\":{\"265\":1}}],[\"下标未满足条件\",{\"1\":{\"63\":1}}],[\"下表截取创建\",{\"1\":{\"63\":1}}],[\"下面给出的实例代码\",{\"1\":{\"424\":1}}],[\"下面代码写法有什么问题\",{\"0\":{\"441\":1}}],[\"下面代码输出什么\",{\"0\":{\"410\":1}}],[\"下面代码会触发异常吗\",{\"0\":{\"409\":1}}],[\"下面代码会输出什么\",{\"0\":{\"408\":1}}],[\"下面代码能运行吗\",{\"0\":{\"391\":1}}],[\"下面这段代码为什么会卡死\",{\"0\":{\"401\":1}}],[\"下面来看看重写的一个流程图\",{\"1\":{\"356\":1}}],[\"下面的迭代会有什么问题\",{\"0\":{\"413\":1}}],[\"下面的代码有什么问题\",{\"0\":{\"412\":1}}],[\"下面的代码会输出什么\",{\"0\":{\"407\":1}}],[\"下面的代码是有问题的\",{\"0\":{\"394\":1}}],[\"下面的程序运行后为什么会爆异常\",{\"0\":{\"397\":1}}],[\"下面的类似\",{\"1\":{\"352\":1}}],[\"下面的示例将会展示map的相关操作\",{\"1\":{\"41\":1}}],[\"下面放一段处理插入结点时处理链式反应的代码片断\",{\"1\":{\"299\":1}}],[\"下面针对缓存系统设计与使用中面临的常见问题展开\",{\"1\":{\"281\":1}}],[\"下面添加一个前缀索引\",{\"1\":{\"229\":1}}],[\"下面我画了一个可见性的算法的流程图\",{\"1\":{\"215\":1}}],[\"下面我来介绍一下\",{\"1\":{\"215\":1}}],[\"下面我们通过讲解如何通过聚集索引以及非聚集索引查找数据表中数据的方式介绍一下b+树索引查找数据方法\",{\"1\":{\"72\":1}}],[\"下面我们来看一下go的调度代码中对上述的几个结构体的定义\",{\"1\":{\"29\":1}}],[\"下面看下具体的查找流程图\",{\"1\":{\"72\":2}}],[\"下面是有关quicklist的更多额外信息\",{\"1\":{\"300\":1}}],[\"下面是平滑扩容的实现\",{\"1\":{\"296\":1}}],[\"下面是平衡二叉树和非平衡二叉树的对比\",{\"1\":{\"68\":1}}],[\"下面是计算bucket索引值的函数\",{\"1\":{\"296\":1}}],[\"下面是字典的扩容操作中的核心代码\",{\"1\":{\"296\":1}}],[\"下面是简单样例\",{\"1\":{\"268\":1}}],[\"下面是这些算法的介绍\",{\"1\":{\"266\":1}}],[\"下面是利用\",{\"1\":{\"264\":1}}],[\"下面是对这几种错误级别的介绍\",{\"1\":{\"262\":1}}],[\"下面是多协程在channel方法下对同一个key进行操作的结果\",{\"1\":{\"53\":1}}],[\"下面是g\",{\"1\":{\"29\":1}}],[\"下面两个成员用于栈溢出检查\",{\"1\":{\"33\":1}}],[\"下面各结构体的定义略去了跟调度器无关的成员\",{\"1\":{\"30\":1}}],[\"下面介绍的这些结构体中的字段非常多\",{\"1\":{\"30\":1}}],[\"仅设置过期时间key范围内的随机\",{\"1\":{\"345\":1}}],[\"仅以设置过期时间key范围内的lru\",{\"1\":{\"345\":1}}],[\"仅给出提示信息\",{\"1\":{\"262\":1}}],[\"仅保存哪条记录被修改\",{\"1\":{\"140\":1}}],[\"仅存储键值\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"仅针对读的性能来说\",{\"1\":{\"59\":1}}],[\"仅仅从上面这个伪代码来看\",{\"1\":{\"29\":1}}],[\"仅仅有g结构体对象是不够的\",{\"1\":{\"29\":1}}],[\"虽然执行了\",{\"1\":{\"503\":1}}],[\"虽然有使用sync\",{\"1\":{\"412\":1}}],[\"虽然这个内存重分配的操作依然只会发生一次\",{\"1\":{\"299\":1}}],[\"虽然要分析很多\",{\"1\":{\"219\":1}}],[\"虽然读锁不冲突\",{\"1\":{\"58\":1}}],[\"虽然不严谨\",{\"1\":{\"47\":1}}],[\"撤销单次\",{\"1\":{\"58\":1}}],[\"相比前两个方法时间复杂度低\",{\"1\":{\"370\":1}}],[\"相比硬盘成本\",{\"1\":{\"352\":1}}],[\"相比string更节省空间\",{\"1\":{\"275\":1}}],[\"相对的\",{\"1\":{\"347\":1}}],[\"相对安全\",{\"1\":{\"236\":1}}],[\"相关参考文章\",{\"1\":{\"238\":1}}],[\"相关参数\",{\"1\":{\"236\":1,\"238\":1}}],[\"相关知识点\",{\"1\":{\"238\":1}}],[\"相关操作如下\",{\"1\":{\"225\":1}}],[\"相反建立了上百万次链接\",{\"1\":{\"112\":1}}],[\"相当于行数\",{\"1\":{\"167\":1}}],[\"相当于创建了\",{\"1\":{\"111\":1,\"147\":1}}],[\"相当于全表扫描\",{\"1\":{\"89\":1}}],[\"相当于是当前调用了\",{\"1\":{\"58\":1}}],[\"相应的树的阶数\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"相信很多小伙伴都已经配置过主从复制\",{\"1\":{\"304\":1}}],[\"相信很多人都听说过go语言天然支持高并发\",{\"1\":{\"15\":1}}],[\"相信大多数人已经相当熟悉了\",{\"1\":{\"66\":1}}],[\"相信你排队取号的时候看到其他窗口没人排队也会过去的\",{\"1\":{\"21\":1}}],[\"根据sync\",{\"1\":{\"457\":1}}],[\"根据自己的机制来完成持久化\",{\"1\":{\"355\":1}}],[\"根据我们的\",{\"1\":{\"355\":1}}],[\"根据实际情况进行调整\",{\"1\":{\"354\":1}}],[\"根据实际业务情况\",{\"1\":{\"300\":1}}],[\"根据实际业务创建相关汇总表和缓存表\",{\"1\":{\"224\":1}}],[\"根据资源设置拦截机制\",{\"1\":{\"286\":1}}],[\"根据缓存数据访问规律和缓存数据不一致的敏感性要求来选择缓存时间\",{\"1\":{\"284\":1}}],[\"根据当前业务场景做出相应的动作\",{\"1\":{\"262\":2}}],[\"根据错误级别记录错误日志\",{\"1\":{\"262\":2}}],[\"根据创建联合索引的顺序\",{\"1\":{\"246\":1}}],[\"根据验证结果\",{\"1\":{\"112\":1}}],[\"根据上图我们来看下b+树和b树有什么不同\",{\"1\":{\"70\":1}}],[\"根据上述的结论\",{\"1\":{\"57\":1}}],[\"根据某种算法从私有的局部运行队列中找出一个需要运行的goroutine\",{\"1\":{\"29\":1}}],[\"根据某种算法从全局运行队列中找出一个需要运行的goroutine\",{\"1\":{\"29\":1}}],[\"根据某种算法从m个goroutine中找出一个需要运行的goroutine\",{\"1\":{\"28\":1}}],[\"某个键很少被访问\",{\"1\":{\"347\":1}}],[\"某个表有近千万数据\",{\"1\":{\"109\":1}}],[\"某游戏的内测号等等\",{\"1\":{\"267\":1}}],[\"某一时间点只有一个goroutine访问到这部分\",{\"1\":{\"57\":1}}],[\"某次评估过程中如果有满足条件的case\",{\"1\":{\"7\":1}}],[\"记一道字节跳动的算法面试题\",{\"0\":{\"468\":1}}],[\"记两条\",{\"1\":{\"244\":1}}],[\"记住\",{\"1\":{\"57\":1}}],[\"记录每次对服务器写的操作\",{\"1\":{\"350\":1}}],[\"记录当前的复制偏移量offset\",{\"1\":{\"318\":1}}],[\"记录当前这个gobuf对象属于哪个goroutine\",{\"1\":{\"32\":1}}],[\"记录的是这个语句的原始逻辑\",{\"1\":{\"244\":1}}],[\"记录的是\",{\"1\":{\"244\":1}}],[\"记录所有的查询\",{\"1\":{\"224\":1}}],[\"记录所有工作线程的一个链表\",{\"1\":{\"34\":1}}],[\"记录上面的\",{\"1\":{\"215\":1}}],[\"记录\",{\"1\":{\"199\":2}}],[\"记录单元为每一行的改动\",{\"1\":{\"140\":1}}],[\"记录数据列级的操作权限\",{\"1\":{\"139\":1}}],[\"记录数据表级的操作权限\",{\"1\":{\"139\":1}}],[\"记录各个帐号在各个数据库上的操作权限\",{\"1\":{\"139\":1}}],[\"记录允许连接到服务器的用户帐号信息\",{\"1\":{\"139\":1}}],[\"记录了调度器的工作状态\",{\"1\":{\"37\":1}}],[\"记录与当前工作线程绑定的p结构体对象\",{\"1\":{\"34\":1}}],[\"记录该goroutine使用的栈\",{\"1\":{\"33\":1}}],[\"js\",{\"1\":{\"393\":2}}],[\"json\",{\"1\":{\"335\":1,\"393\":1}}],[\"just\",{\"1\":{\"294\":1,\"296\":1}}],[\"juejin\",{\"1\":{\"23\":1,\"207\":1,\"219\":1,\"329\":1,\"358\":1,\"469\":1,\"503\":2}}],[\"jpg图片或者序列化的对象\",{\"1\":{\"274\":1}}],[\"join\",{\"1\":{\"135\":3,\"137\":3}}],[\"java中encache\",{\"1\":{\"282\":1}}],[\"java\",{\"1\":{\"187\":1,\"212\":1}}],[\"jar\",{\"1\":{\"116\":1,\"187\":1}}],[\"jay\",{\"1\":{\"98\":2,\"175\":1,\"207\":1}}],[\"j<b\",{\"1\":{\"112\":1}}],[\"j<a\",{\"1\":{\"112\":1}}],[\"j=0\",{\"1\":{\"112\":2}}],[\"jdbc目前是基于jdbc驱动\",{\"1\":{\"116\":1}}],[\"jdbc等\",{\"1\":{\"109\":1}}],[\"jdbc\",{\"0\":{\"116\":1},\"1\":{\"85\":1,\"116\":2}}],[\"jk\",{\"1\":{\"72\":2}}],[\"j++\",{\"1\":{\"57\":1,\"112\":2,\"424\":2}}],[\"j\",{\"1\":{\"57\":6,\"112\":2,\"424\":8}}],[\"问最后机器人的坐标是多少\",{\"1\":{\"386\":1}}],[\"问最后机器人的坐标\",{\"1\":{\"386\":1}}],[\"问题很简单\",{\"1\":{\"366\":1}}],[\"问题描述\",{\"1\":{\"366\":1,\"370\":1,\"374\":1,\"378\":1,\"382\":1,\"386\":1}}],[\"问题场景\",{\"1\":{\"287\":1}}],[\"问题\",{\"0\":{\"488\":1,\"494\":1,\"500\":1,\"507\":1},\"1\":{\"286\":2,\"288\":2}}],[\"问题就很简单\",{\"1\":{\"29\":1}}],[\"问\",{\"1\":{\"56\":1}}],[\"开发者不需要考虑sessionid的问题\",{\"1\":{\"264\":1}}],[\"开启自动提交\",{\"1\":{\"245\":1}}],[\"开启索引\",{\"0\":{\"227\":1}}],[\"开始发送指令\",{\"1\":{\"318\":1}}],[\"开始恢复rdb数据\",{\"1\":{\"318\":1}}],[\"开始的时候我们判断商品库存是否小于等于0\",{\"1\":{\"268\":1}}],[\"开始执行命令start\",{\"1\":{\"238\":1}}],[\"开始了新一轮的攻势\",{\"1\":{\"56\":1}}],[\"开头\",{\"1\":{\"134\":1}}],[\"开销和加锁速度介于表锁和行锁之间\",{\"1\":{\"133\":1}}],[\"开销大\",{\"1\":{\"133\":1}}],[\"开销小\",{\"1\":{\"133\":1}}],[\"开销较大\",{\"1\":{\"27\":1}}],[\"至于加了是行锁还是表锁\",{\"1\":{\"105\":1}}],[\"至于sync\",{\"1\":{\"53\":1}}],[\"至于为什么面试官不想用sync\",{\"1\":{\"53\":1}}],[\"至少还需要一个存放所有\",{\"1\":{\"29\":1}}],[\"+continue\",{\"1\":{\"318\":1}}],[\"+fullresync\",{\"1\":{\"318\":1}}],[\"+extra\",{\"1\":{\"299\":1}}],[\"+nextdiff\",{\"1\":{\"299\":1}}],[\"+reqlen\",{\"1\":{\"299\":1}}],[\"+inf\",{\"1\":{\"297\":1}}],[\"+=\",{\"1\":{\"294\":1,\"297\":1,\"299\":6,\"346\":1}}],[\"+\",{\"1\":{\"53\":1,\"78\":1,\"93\":1,\"215\":1,\"274\":1,\"294\":1,\"299\":1,\"342\":1,\"370\":3,\"386\":8,\"400\":4,\"410\":1,\"437\":4,\"445\":3,\"490\":6}}],[\"添加到等待新请求的空闲持久连接列表中\",{\"1\":{\"502\":1}}],[\"添加从节点的数量\",{\"1\":{\"307\":1}}],[\"添加\",{\"1\":{\"52\":1,\"164\":1}}],[\"添加路由\",{\"1\":{\"12\":1}}],[\"怎么答\",{\"0\":{\"501\":1}}],[\"怎么限制用户的下单行为\",{\"1\":{\"268\":1}}],[\"怎么做的\",{\"0\":{\"203\":1}}],[\"怎么解决\",{\"0\":{\"159\":1}}],[\"怎么看执行计划\",{\"0\":{\"103\":1}}],[\"怎么都是数字\",{\"1\":{\"72\":1}}],[\"怎么保证线程安全的原生map\",{\"1\":{\"52\":1}}],[\"怎么办呢\",{\"1\":{\"22\":1,\"29\":1}}],[\"众所周知go中有提供线程安全的map\",{\"1\":{\"52\":1}}],[\"直至迭代器运行结束\",{\"1\":{\"296\":1}}],[\"直取数据源\",{\"1\":{\"286\":1}}],[\"直接决定了\",{\"1\":{\"502\":1}}],[\"直接导致数据丢失\",{\"1\":{\"306\":1}}],[\"直接把dictht结构挂在ht\",{\"1\":{\"296\":1}}],[\"直接持有的是数据区的头指针\",{\"1\":{\"294\":1}}],[\"直接将数据写入change\",{\"1\":{\"250\":1}}],[\"直接返回结果\",{\"1\":{\"246\":1}}],[\"直接返回视图\",{\"1\":{\"218\":1}}],[\"直接返回错误信息\",{\"1\":{\"126\":1}}],[\"直接影响基本表\",{\"1\":{\"164\":1}}],[\"直接过滤掉不满足条件的记录\",{\"1\":{\"127\":1}}],[\"直接从内存中读取即可\",{\"1\":{\"72\":1}}],[\"直接对全数据检索也很快\",{\"1\":{\"66\":1}}],[\"直接声明\",{\"1\":{\"63\":1}}],[\"直接用if\",{\"1\":{\"48\":1}}],[\"直到写入值\",{\"1\":{\"421\":1}}],[\"直到key存在或者超时\",{\"1\":{\"421\":1}}],[\"直到持久化完成\",{\"1\":{\"355\":1}}],[\"直到实现高可用\",{\"1\":{\"309\":1}}],[\"直到将页12加载到内存中\",{\"1\":{\"72\":1}}],[\"直到其被unlock\",{\"1\":{\"57\":1}}],[\"直到需要调度其它goroutine时才返回到schedule函数中通过save\",{\"1\":{\"28\":1}}],[\"直到需要调度其它goroutine才返回\",{\"1\":{\"28\":1,\"29\":1}}],[\"直到channel被关闭\",{\"1\":{\"6\":1}}],[\"直到channel为空\",{\"1\":{\"3\":1}}],[\"直到channel容量已满\",{\"1\":{\"3\":1}}],[\"直到sender端向channel发送了一个数据\",{\"1\":{\"3\":1}}],[\"直到receiver端将此数据receive\",{\"1\":{\"3\":1}}],[\"才能转换成什么类型\",{\"1\":{\"48\":1}}],[\"才使得我们在go程序中\",{\"1\":{\"27\":1}}],[\"或已调用但没有写完时直接\",{\"1\":{\"395\":1}}],[\"或内存占用\",{\"1\":{\"292\":1}}],[\"或考虑固态硬盘\",{\"1\":{\"282\":1}}],[\"或点踩\",{\"1\":{\"277\":1}}],[\"或\",{\"1\":{\"246\":1}}],[\"或是联合索引的最左原则字段\",{\"1\":{\"246\":1}}],[\"或两张表\",{\"1\":{\"137\":1}}],[\"或ins\",{\"1\":{\"48\":1}}],[\"或itable\",{\"1\":{\"47\":1}}],[\"或者使用手动触发\",{\"1\":{\"355\":1}}],[\"或者从节点频繁连接\",{\"1\":{\"327\":1}}],[\"或者从节点的延迟大于8秒时\",{\"1\":{\"319\":1}}],[\"或者网络抖动时会导致连接断开\",{\"1\":{\"317\":1}}],[\"或者用户给消息添加标签\",{\"1\":{\"277\":1}}],[\"或者数据页标记为了\",{\"1\":{\"255\":1}}],[\"或者等于当前事务id\",{\"1\":{\"218\":1}}],[\"或者jvm本地缓存\",{\"1\":{\"120\":1}}],[\"或者由于某个sql要进行锁表就会导致\",{\"1\":{\"118\":1}}],[\"或者\",{\"1\":{\"78\":1,\"201\":1,\"215\":2}}],[\"或者其它可以通过\",{\"1\":{\"41\":1}}],[\"或者能确保select不阻塞的语句块\",{\"1\":{\"7\":1}}],[\"或者结束select\",{\"1\":{\"7\":1}}],[\"或者讲无缓冲chan设置为有缓冲chan\",{\"1\":{\"4\":1}}],[\"4yyr1eyfifsnoatxl4q\",{\"1\":{\"490\":1}}],[\"4是全量复制\",{\"1\":{\"318\":1}}],[\"4+n\",{\"1\":{\"300\":1}}],[\"4gb\",{\"1\":{\"200\":1}}],[\"49\",{\"0\":{\"149\":1}}],[\"48\",{\"0\":{\"148\":1}}],[\"479\",{\"1\":{\"339\":1}}],[\"47\",{\"0\":{\"147\":1}}],[\"46\",{\"0\":{\"146\":1}}],[\"452389458\",{\"1\":{\"339\":1}}],[\"45\",{\"0\":{\"145\":1},\"1\":{\"490\":1}}],[\"43\",{\"0\":{\"143\":1},\"1\":{\"342\":1,\"473\":1}}],[\"42\",{\"0\":{\"142\":1}}],[\"413052773\",{\"1\":{\"339\":1}}],[\"41\",{\"0\":{\"141\":1},\"1\":{\"339\":1}}],[\"40\",{\"0\":{\"140\":1},\"1\":{\"300\":1}}],[\"4\",{\"0\":{\"83\":1,\"277\":1,\"297\":1,\"312\":1,\"317\":1,\"328\":1,\"347\":1,\"394\":1,\"408\":1,\"448\":1,\"459\":1},\"1\":{\"63\":3,\"66\":1,\"193\":1,\"200\":1,\"218\":3,\"219\":13,\"299\":2,\"300\":1,\"347\":1,\"386\":3,\"410\":1,\"437\":1}}],[\"44\",{\"0\":{\"144\":1},\"1\":{\"47\":1}}],[\"4<<10\",{\"1\":{\"12\":1}}],[\"5d4f76325188253b49244dd0\",{\"1\":{\"469\":1}}],[\"5da8493ae51d4524b25add55\",{\"1\":{\"219\":1}}],[\"5b70dfcf518825610f1f5c16\",{\"1\":{\"358\":1}}],[\"5ed5ccb66fb9a047df7ca9a4\",{\"1\":{\"329\":1}}],[\"5ec15ab9f265da7bc60e1910\",{\"1\":{\"207\":1}}],[\"5e999ead518825739b2d44d7\",{\"1\":{\"23\":1}}],[\"59\",{\"0\":{\"159\":1}}],[\"58\",{\"0\":{\"158\":1}}],[\"58同城数据库中间件\",{\"1\":{\"85\":1}}],[\"5764978\",{\"1\":{\"238\":1}}],[\"57\",{\"0\":{\"157\":1}}],[\"56\",{\"0\":{\"156\":1}}],[\"55\",{\"0\":{\"155\":1}}],[\"54\",{\"0\":{\"154\":1}}],[\"535\",{\"1\":{\"200\":1}}],[\"53\",{\"0\":{\"153\":1}}],[\"52035072\",{\"1\":{\"238\":1}}],[\"5238682\",{\"1\":{\"235\":1}}],[\"52\",{\"0\":{\"152\":1}}],[\"51\",{\"0\":{\"151\":1}}],[\"5000\",{\"1\":{\"374\":1,\"378\":2}}],[\"50000\",{\"1\":{\"206\":1}}],[\"500\",{\"1\":{\"354\":1,\"450\":1}}],[\"500台db\",{\"0\":{\"201\":1}}],[\"50\",{\"0\":{\"150\":1,\"175\":1},\"1\":{\"175\":2}}],[\"5\",{\"0\":{\"87\":1,\"278\":1,\"298\":1,\"395\":1,\"409\":1,\"449\":1,\"460\":1},\"1\":{\"47\":1,\"58\":1,\"63\":1,\"87\":1,\"127\":1,\"187\":1,\"198\":2,\"218\":1,\"219\":6,\"238\":1,\"246\":1,\"294\":6,\"300\":1,\"318\":1,\"328\":1,\"346\":2,\"411\":1,\"418\":2,\"431\":2,\"446\":1}}],[\"任选其一即可\",{\"1\":{\"336\":1}}],[\"任何一个时间点都只能有一个goroutine执行这段区间的代码\",{\"1\":{\"57\":1}}],[\"任意对象都可以保存到空接口实例变量中\",{\"1\":{\"47\":1}}],[\"任务完成后对chan进行读操作\",{\"1\":{\"6\":1}}],[\"意思是读完了\",{\"1\":{\"502\":1}}],[\"意思是\",{\"1\":{\"274\":1}}],[\"意味着go中的任意对象都可以实现空接口\",{\"1\":{\"47\":1}}],[\"意为通讯顺序进程\",{\"1\":{\"17\":1}}],[\"和其他值\",{\"1\":{\"339\":1}}],[\"和repl\",{\"1\":{\"325\":1}}],[\"和intset一样\",{\"1\":{\"299\":2}}],[\"和在\",{\"1\":{\"262\":1}}],[\"和一个写goroutine\",{\"1\":{\"503\":1}}],[\"和一个\",{\"1\":{\"246\":1}}],[\"和group\",{\"1\":{\"228\":1,\"229\":1}}],[\"和上面一样可见则返回该行\",{\"1\":{\"219\":1}}],[\"和char\",{\"0\":{\"176\":1}}],[\"和服务器之间来往的流量\",{\"1\":{\"130\":1}}],[\"和exists的区别\",{\"0\":{\"112\":1}}],[\"和数据\",{\"1\":{\"67\":1,\"69\":1}}],[\"和unlock\",{\"1\":{\"57\":1}}],[\"和\",{\"0\":{\"251\":1},\"1\":{\"46\":1,\"111\":1,\"147\":1,\"175\":1,\"212\":1,\"215\":1,\"218\":2,\"244\":1,\"262\":2,\"264\":2,\"265\":2,\"308\":1,\"309\":1,\"318\":2,\"325\":1,\"333\":1,\"414\":1,\"438\":1,\"502\":2}}],[\"和buffered\",{\"1\":{\"3\":1}}],[\"额外数据结构和储存空间\",{\"1\":{\"374\":1}}],[\"额\",{\"1\":{\"44\":2}}],[\"被读取完或关闭这个\",{\"1\":{\"502\":1}}],[\"被淘汰的键\",{\"1\":{\"346\":1}}],[\"被设定为\",{\"1\":{\"297\":1}}],[\"被写到binlog\",{\"1\":{\"117\":1,\"192\":1}}],[\"被省略了\",{\"1\":{\"69\":1}}],[\"被要求一定要用结构体比较怎么办\",{\"1\":{\"44\":1}}],[\"被抛弃的\",{\"1\":{\"8\":1}}],[\"语法找错题\",{\"0\":{\"434\":1}}],[\"语法从管道读取数据\",{\"1\":{\"418\":1}}],[\"语法中\",{\"1\":{\"406\":1}}],[\"语法题目\",{\"0\":{\"389\":1},\"1\":{\"362\":1}}],[\"语言中没有继承概念\",{\"1\":{\"408\":1}}],[\"语言中\",{\"1\":{\"44\":1,\"414\":1}}],[\"语句影响\",{\"1\":{\"438\":1}}],[\"语句很方便的对\",{\"1\":{\"340\":1}}],[\"语句更新结束\",{\"1\":{\"250\":1}}],[\"语句里有变量的\",{\"1\":{\"238\":1}}],[\"语句是否有语法错误\",{\"1\":{\"126\":1}}],[\"语句select等的关键元素\",{\"1\":{\"126\":1}}],[\"语句\",{\"1\":{\"8\":1,\"103\":1,\"246\":1}}],[\"中注释可以知道\",{\"1\":{\"457\":1}}],[\"中字符串是不能赋值\",{\"1\":{\"435\":1}}],[\"中wait函数支持\",{\"0\":{\"431\":1}}],[\"中捕获\",{\"1\":{\"428\":1}}],[\"中有专用的select\",{\"1\":{\"418\":1}}],[\"中读取数字并打印到标准输出\",{\"1\":{\"418\":1}}],[\"中也需要加锁\",{\"1\":{\"412\":1}}],[\"中去\",{\"1\":{\"296\":1}}],[\"中主要采用反向代理的方式来实现负载均衡\",{\"1\":{\"266\":1}}],[\"中处理\",{\"1\":{\"262\":1}}],[\"中故不可见\",{\"1\":{\"219\":1}}],[\"中的切片底层其实使用的是数组\",{\"1\":{\"438\":1}}],[\"中的v的类型就是t1类型\",{\"1\":{\"392\":1}}],[\"中的所有zskiplistlevel结点中的forward与span的值的变更\",{\"1\":{\"297\":1}}],[\"中的索引为x\",{\"1\":{\"297\":1}}],[\"中的一个bucket索引位持有的结点链表\",{\"1\":{\"296\":1}}],[\"中的三个属性\",{\"1\":{\"215\":1}}],[\"中的最小事务id\",{\"1\":{\"215\":1}}],[\"中的\",{\"1\":{\"212\":1}}],[\"中事务没有对应的\",{\"1\":{\"199\":1}}],[\"中50的涵义\",{\"0\":{\"175\":1}}],[\"中不满足匹配关系的记录\",{\"1\":{\"137\":1}}],[\"中找到4这个数据\",{\"1\":{\"66\":1}}],[\"中\",{\"1\":{\"43\":2,\"84\":1,\"296\":2,\"299\":5,\"394\":1,\"395\":1,\"401\":1,\"418\":1,\"489\":1}}],[\"再通过\",{\"1\":{\"496\":1}}],[\"再再读chan的协程结束\",{\"1\":{\"481\":6}}],[\"再读chan的协程结束\",{\"1\":{\"481\":6}}],[\"再加锁会死锁\",{\"1\":{\"460\":1}}],[\"再加上协程占用的内存空间极小\",{\"1\":{\"19\":1}}],[\"再加上\",{\"1\":{\"8\":1}}],[\"再次\",{\"1\":{\"370\":1}}],[\"再开启压缩会带来更多的cpu消耗\",{\"1\":{\"352\":1}}],[\"再结合\",{\"1\":{\"333\":1}}],[\"再苟了一层\",{\"1\":{\"300\":1}}],[\"再置ht\",{\"1\":{\"296\":1}}],[\"再重置ht\",{\"1\":{\"296\":1}}],[\"再失效缓存\",{\"1\":{\"288\":1}}],[\"再更新数据源\",{\"1\":{\"287\":1}}],[\"再设置缓存\",{\"1\":{\"284\":1}}],[\"再进行回表查询\",{\"1\":{\"246\":1}}],[\"再记数据页修改的\",{\"1\":{\"199\":1}}],[\"再做出相应的调整\",{\"1\":{\"190\":1}}],[\"再阐述它们的实现原理\",{\"1\":{\"155\":1}}],[\"再查询到想要的数据\",{\"1\":{\"149\":1}}],[\"再从b表做循环\",{\"1\":{\"112\":1}}],[\"再放到子查询中做条件验证\",{\"1\":{\"112\":1}}],[\"再由部门deptid\",{\"1\":{\"112\":1}}],[\"再往下limit\",{\"1\":{\"93\":1}}],[\"再有人问你为什么mysql用b+树做索引\",{\"1\":{\"73\":1}}],[\"再者\",{\"1\":{\"43\":1}}],[\"第五点是高可用的基石\",{\"1\":{\"307\":1}}],[\"第四点是负载均衡\",{\"1\":{\"307\":1}}],[\"第三个方法使用的是位运算来判断是否重复\",{\"1\":{\"370\":1}}],[\"第三阶段\",{\"0\":{\"317\":1}}],[\"第三点是读写分离\",{\"1\":{\"307\":1}}],[\"第三方\",{\"1\":{\"266\":2}}],[\"第三范式\",{\"1\":{\"138\":1}}],[\"第三层是存储引擎\",{\"1\":{\"136\":1}}],[\"第二步是对aof文件的重写\",{\"1\":{\"356\":1}}],[\"第二阶段\",{\"0\":{\"316\":1}}],[\"第二点是针对单机故障问题\",{\"1\":{\"307\":1}}],[\"第二范式\",{\"1\":{\"138\":1}}],[\"第二层负责编译并优化sql\",{\"1\":{\"136\":1}}],[\"第二个采纳数就是\",{\"1\":{\"484\":1}}],[\"第二个是是否存在该key\",{\"1\":{\"441\":1}}],[\"第二个是指向\",{\"1\":{\"414\":1}}],[\"第二个是替换空格\",{\"1\":{\"382\":1}}],[\"第二个方法使用的是golang内置方法strings\",{\"1\":{\"370\":1}}],[\"第二个监控主从节点的偏移量\",{\"1\":{\"328\":1}}],[\"第二个情况就是内存问题了\",{\"1\":{\"306\":1}}],[\"第二个指针就是实例的指针地址\",{\"1\":{\"45\":1}}],[\"第二个规则使得同名属性不会出现歧义\",{\"1\":{\"42\":1}}],[\"第一阶段\",{\"0\":{\"315\":1}}],[\"第一点是数据冗余了\",{\"1\":{\"307\":1}}],[\"第一原则是\",{\"1\":{\"246\":1}}],[\"第一次查询不存在\",{\"1\":{\"245\":1}}],[\"第一范式\",{\"1\":{\"138\":1}}],[\"第一层负责连接处理\",{\"1\":{\"136\":1}}],[\"第一个写\",{\"1\":{\"395\":1}}],[\"第一个方法使用的是golang内置方法strings\",{\"1\":{\"370\":1}}],[\"第一个是获取到的值\",{\"1\":{\"441\":1}}],[\"第一个是表示\",{\"1\":{\"414\":1}}],[\"第一个是只能是英文字母\",{\"1\":{\"382\":1}}],[\"第一个是ascii字符\",{\"1\":{\"370\":1}}],[\"第一个是指针指向实例的类型信息和方法集\",{\"1\":{\"45\":1}}],[\"第一个数据需要高度一致配置一台redis服务器\",{\"1\":{\"328\":1}}],[\"第一个结点的扩容\",{\"1\":{\"299\":1}}],[\"第一个字节的值固定为0xfe\",{\"1\":{\"301\":1}}],[\"第一个字节的高两位固定为01\",{\"1\":{\"299\":1}}],[\"第一个字节是固定值10000000\",{\"1\":{\"299\":1}}],[\"第一个字节值为\",{\"1\":{\"299\":1}}],[\"第一个规则使得go\",{\"1\":{\"42\":1}}],[\"第一章我们讨论操作系统线程及其调度时还说过\",{\"1\":{\"29\":1}}],[\"第一章讨论操作系统线程调度的时候我们曾经提到过\",{\"1\":{\"28\":1}}],[\"匿名字段的名称强制和类型相同\",{\"1\":{\"42\":1}}],[\"`uri`\",{\"1\":{\"234\":1}}],[\"`ip`\",{\"1\":{\"234\":3}}],[\"`idx\",{\"1\":{\"145\":1}}],[\"`id`\",{\"1\":{\"145\":2,\"234\":2}}],[\"`request\",{\"1\":{\"234\":4}}],[\"`sex`\",{\"1\":{\"145\":1}}],[\"`date`\",{\"1\":{\"145\":1}}],[\"`age`\",{\"1\":{\"145\":1}}],[\"`name`\",{\"1\":{\"145\":2}}],[\"`employee`\",{\"1\":{\"145\":1}}],[\"`\",{\"1\":{\"42\":2,\"393\":3}}],[\"`json\",{\"1\":{\"42\":2,\"393\":1}}],[\"注册到脚本运行结束前\",{\"1\":{\"262\":1}}],[\"注释\",{\"1\":{\"42\":1}}],[\"注意这个\",{\"1\":{\"480\":1}}],[\"注意这里的大量\",{\"1\":{\"66\":1}}],[\"注意不要滥用\",{\"1\":{\"170\":1}}],[\"注意它是一个指向m结构体对象的指针\",{\"1\":{\"29\":1}}],[\"注意\",{\"1\":{\"3\":1,\"27\":1,\"48\":1,\"218\":2,\"296\":1,\"339\":1,\"340\":1}}],[\"除过头结点外\",{\"1\":{\"297\":1}}],[\"除过头部与末尾的\",{\"1\":{\"294\":1}}],[\"除非回调函数返回了\",{\"1\":{\"262\":1}}],[\"除非手动修改它\",{\"1\":{\"128\":1}}],[\"除外的所有错误和警告信息\",{\"1\":{\"262\":1}}],[\"除此之外\",{\"1\":{\"42\":1}}],[\"除了持有数据的ele字段\",{\"1\":{\"297\":1}}],[\"除了字典本身的实现外\",{\"1\":{\"296\":1}}],[\"除了基本的链表定义外\",{\"1\":{\"295\":1}}],[\"除了上述两个标准异常之外\",{\"1\":{\"262\":1}}],[\"除了上面介绍的g\",{\"1\":{\"29\":1}}],[\"除了数据表占用数据空间之外\",{\"1\":{\"142\":1}}],[\"除了使用in\",{\"1\":{\"112\":1}}],[\"除了分库分表\",{\"1\":{\"110\":1}}],[\"除了参数name\",{\"1\":{\"43\":1}}],[\"除了实例有值类型和指针类型的区别\",{\"1\":{\"43\":1}}],[\"除了reflect包\",{\"1\":{\"42\":1}}],[\"除了往里塞之外\",{\"1\":{\"21\":1}}],[\"构造struct实例\",{\"1\":{\"42\":1}}],[\"构建server\",{\"1\":{\"12\":1}}],[\"构建servemux\",{\"0\":{\"12\":1}}],[\"遍历操作的重点是\",{\"1\":{\"296\":1}}],[\"遍历map\",{\"1\":{\"41\":1}}],[\"遍历时是随机的\",{\"1\":{\"41\":1}}],[\"更没有重载\",{\"1\":{\"408\":1}}],[\"更多详解继续查看下文\",{\"1\":{\"305\":1}}],[\"更快\",{\"1\":{\"229\":1}}],[\"更快的系统响应速度\",{\"1\":{\"124\":1}}],[\"更不成立故进入最后一轮发现\",{\"1\":{\"219\":1}}],[\"更换字符集utf8\",{\"1\":{\"204\":1}}],[\"更改数据格式和表示\",{\"1\":{\"165\":1}}],[\"更新数据时\",{\"1\":{\"288\":1}}],[\"更新数据源由缓存系统操作\",{\"1\":{\"288\":2}}],[\"更新数据源+失效缓存\",{\"1\":{\"288\":1}}],[\"更新数据源\",{\"1\":{\"287\":1,\"288\":1}}],[\"更新缓存为内存操作\",{\"1\":{\"288\":1}}],[\"更新缓存\",{\"1\":{\"288\":2}}],[\"更新时间\",{\"1\":{\"278\":1}}],[\"更新前和更新后都有\",{\"1\":{\"244\":1}}],[\"更新操作创建了一个新的版本并且新版本的回滚指针指向了旧的版本\",{\"1\":{\"218\":1}}],[\"更新\",{\"1\":{\"214\":1,\"215\":1}}],[\"更新比较频繁的也不适合加索引\",{\"1\":{\"79\":1}}],[\"更新一个key\",{\"1\":{\"41\":1}}],[\"更通俗地说\",{\"1\":{\"4\":1}}],[\"数字打印完成后通过\",{\"1\":{\"366\":1}}],[\"数值存储在紧邻的后八个字节中\",{\"1\":{\"299\":1}}],[\"数值存储在紧邻的后四个字节中\",{\"1\":{\"299\":1}}],[\"数值存储在紧邻的后三个字节中\",{\"1\":{\"299\":1}}],[\"数值存储在紧邻的后两个字节中\",{\"1\":{\"299\":1}}],[\"数值存储在紧邻的下一个字节\",{\"1\":{\"299\":1}}],[\"数值如何存储\",{\"1\":{\"299\":1}}],[\"数量大的表\",{\"1\":{\"129\":1}}],[\"数组只能与相同纬度长度以及类型的其他数组比较\",{\"1\":{\"440\":1}}],[\"数组的长度比当前表中所有结点的level\",{\"1\":{\"297\":1}}],[\"数组的长度\",{\"1\":{\"297\":1}}],[\"数组长度的随机算法\",{\"1\":{\"297\":1}}],[\"数组最长的长度\",{\"1\":{\"297\":1}}],[\"数组\",{\"1\":{\"41\":1}}],[\"数据的备份\",{\"1\":{\"357\":1}}],[\"数据的查找效率也会比平衡二叉树高很多\",{\"1\":{\"69\":1}}],[\"数据导入以后\",{\"1\":{\"341\":1}}],[\"数据类型\",{\"1\":{\"339\":1}}],[\"数据不一致问题\",{\"0\":{\"328\":1}}],[\"数据不会被破坏\",{\"1\":{\"106\":1}}],[\"数据同步阶段过程\",{\"0\":{\"316\":1}}],[\"数据同步过程\",{\"1\":{\"314\":1}}],[\"数据是只能master往slave同步单向\",{\"1\":{\"305\":1}}],[\"数据稳定\",{\"1\":{\"298\":1}}],[\"数据区\",{\"1\":{\"294\":3}}],[\"数据源的差异\",{\"1\":{\"288\":1}}],[\"数据源为新数据\",{\"1\":{\"287\":1}}],[\"数据删除问题\",{\"0\":{\"255\":1}}],[\"数据页不在内存中\",{\"1\":{\"250\":1}}],[\"数据页在内存中直接插入值\",{\"1\":{\"250\":1}}],[\"数据插入时针对于这两个索引\",{\"1\":{\"250\":1}}],[\"数据存储方式不一样\",{\"1\":{\"223\":1}}],[\"数据存储空间小\",{\"1\":{\"183\":1}}],[\"数据\",{\"1\":{\"182\":1,\"294\":1}}],[\"数据安全性\",{\"1\":{\"166\":1}}],[\"数据列不允许重复\",{\"1\":{\"143\":2}}],[\"数据表中的每一列\",{\"1\":{\"138\":1}}],[\"数据库并发控制\",{\"0\":{\"212\":1,\"213\":1}}],[\"数据库进程拿到请求sql\",{\"1\":{\"179\":1}}],[\"数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合\",{\"1\":{\"172\":1}}],[\"数据库中有六种触发器\",{\"1\":{\"171\":1}}],[\"数据库中间件了解过吗\",{\"0\":{\"116\":1}}],[\"数据库锁有哪些呢\",{\"0\":{\"156\":1}}],[\"数据库事务\",{\"1\":{\"154\":1}}],[\"数据库为什么使用b+树而不是b树\",{\"0\":{\"148\":1}}],[\"数据库主从分离\",{\"1\":{\"129\":1}}],[\"数据库存储日期格式时\",{\"0\":{\"128\":1}}],[\"数据库连接池好处\",{\"0\":{\"124\":1}}],[\"数据库连接池原理\",{\"1\":{\"122\":1}}],[\"数据库\",{\"1\":{\"116\":1,\"339\":1}}],[\"数据库自增主键可能遇到什么问题\",{\"0\":{\"113\":1}}],[\"数据库自增长序列或字段\",{\"1\":{\"94\":1}}],[\"数据库最费劲的就是跟程序链接释放\",{\"1\":{\"112\":1}}],[\"数据库的乐观锁和悲观锁\",{\"0\":{\"100\":1}}],[\"数据库索引的原理\",{\"0\":{\"88\":1}}],[\"数据库被切分后\",{\"1\":{\"86\":1}}],[\"数据和索引\",{\"1\":{\"87\":1}}],[\"数据迁移\",{\"1\":{\"86\":1}}],[\"数据量是否太大\",{\"1\":{\"190\":1}}],[\"数据量少的不适合加索引\",{\"1\":{\"79\":1}}],[\"数据量大了索引才显得有意义\",{\"1\":{\"66\":1}}],[\"数据即索引\",{\"1\":{\"71\":1,\"73\":1}}],[\"数据查询的效率也会更快\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"数据对应user表中的行数据\",{\"1\":{\"67\":1}}],[\"数据级并行\",{\"1\":{\"16\":1}}],[\"数据未读就表示未send成功\",{\"1\":{\"3\":1}}],[\"如均为设置过期时间\",{\"1\":{\"345\":1}}],[\"如oom\",{\"1\":{\"345\":1}}],[\"如命中缓存\",{\"1\":{\"288\":1}}],[\"如缓存失效\",{\"1\":{\"288\":2}}],[\"如缓存数据为批量写入\",{\"1\":{\"284\":1}}],[\"如有效用户id等\",{\"1\":{\"286\":1}}],[\"如之前项目中使用的三级缓存方案\",{\"1\":{\"285\":1}}],[\"如不同缓存数据访问无规律或相对离散\",{\"1\":{\"284\":1}}],[\"如用户信息\",{\"1\":{\"275\":1}}],[\"如数字\",{\"1\":{\"274\":1}}],[\"如连接\",{\"1\":{\"187\":1}}],[\"如交易流水表\",{\"1\":{\"129\":1}}],[\"如去除冗余字段\",{\"1\":{\"129\":1}}],[\"如图所示\",{\"1\":{\"218\":1}}],[\"如图\",{\"1\":{\"117\":1}}],[\"如何从持久化中恢复数据\",{\"1\":{\"350\":1}}],[\"如何同步数据呢\",{\"1\":{\"306\":1}}],[\"如何编码\",{\"1\":{\"299\":1}}],[\"如何避免应考虑\",{\"1\":{\"284\":1}}],[\"如何避免\",{\"0\":{\"252\":1}}],[\"如何操作\",{\"0\":{\"204\":1}}],[\"如何考虑时区转换问题\",{\"0\":{\"128\":1}}],[\"如何写sql能够有效的使用到复合索引\",{\"0\":{\"111\":1}}],[\"如何优化长难的查询语句\",{\"0\":{\"188\":1}}],[\"如何优化\",{\"0\":{\"108\":1}}],[\"如何理解其中各个字段的含义\",{\"0\":{\"103\":1}}],[\"如何做到安全的修改同一行数据\",{\"0\":{\"97\":1}}],[\"如何选择合适的分布式主键方案呢\",{\"0\":{\"94\":1}}],[\"如何字段类型是字符串\",{\"1\":{\"78\":1}}],[\"如性别\",{\"1\":{\"79\":1,\"144\":1}}],[\"如\",{\"1\":{\"78\":1,\"109\":1,\"111\":1,\"147\":1,\"175\":1,\"191\":1,\"275\":1}}],[\"如此一来我们查找数据进行磁盘的io次数有会再次减少\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"如下图所示\",{\"1\":{\"192\":1}}],[\"如下\",{\"1\":{\"44\":1,\"112\":1,\"159\":1,\"192\":1,\"297\":1}}],[\"如animal\",{\"1\":{\"42\":1}}],[\"如interface和指针可以\",{\"1\":{\"41\":1}}],[\"如int\",{\"1\":{\"41\":1}}],[\"如果执行\",{\"1\":{\"502\":2}}],[\"如果泄漏\",{\"1\":{\"500\":1}}],[\"如果切片背后的存储要基于运行时的数据进行扩充\",{\"1\":{\"489\":1}}],[\"如果切片中存在\",{\"1\":{\"473\":1}}],[\"如果变量通过了这些校验\",{\"1\":{\"489\":1}}],[\"如果接收值的地址\",{\"1\":{\"484\":1}}],[\"如果接受之的地址不空\",{\"1\":{\"484\":1}}],[\"如果waitgroup自然结束返回false\",{\"1\":{\"431\":2}}],[\"如果timeout到了超时时间返回true\",{\"1\":{\"431\":2}}],[\"如果key不存在阻塞\",{\"1\":{\"421\":1}}],[\"如果为\",{\"1\":{\"401\":1}}],[\"如果类型实现了这个接口\",{\"1\":{\"394\":1}}],[\"如果允许其他额外储存结构\",{\"1\":{\"370\":1}}],[\"如果丢失数据可以通过其它途径补回\",{\"1\":{\"358\":1}}],[\"如果redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据\",{\"1\":{\"358\":1}}],[\"如果runid或offset检验通过\",{\"1\":{\"318\":1}}],[\"如果runid或offset校验通过\",{\"1\":{\"318\":1}}],[\"如果一台服务器上有既有rdb文件\",{\"1\":{\"357\":1}}],[\"如果一个\",{\"1\":{\"401\":1}}],[\"如果一个sds实例中的数据被变更了\",{\"1\":{\"294\":1}}],[\"如果一个索引包含所有要查询字段的值\",{\"1\":{\"230\":1}}],[\"如果一个查询中有范围查询\",{\"1\":{\"228\":1}}],[\"如果重写失败\",{\"1\":{\"356\":1}}],[\"如果实时写入磁盘会带来非常高的磁盘io\",{\"1\":{\"356\":1}}],[\"如果设置为\",{\"1\":{\"353\":1}}],[\"如果自己的业务有完善的监控系统\",{\"1\":{\"352\":1}}],[\"如果持久化出错\",{\"1\":{\"352\":1}}],[\"如果从节点的延迟过大\",{\"1\":{\"328\":1}}],[\"如果这个缓冲区大小设置不合理那么很大可能会造成死循环\",{\"1\":{\"322\":1}}],[\"如果master判断偏移量是在复制缓冲区范围内\",{\"1\":{\"317\":1}}],[\"如果项目是跟￥占关系的\",{\"1\":{\"306\":1}}],[\"如果长度小于254\",{\"1\":{\"301\":1}}],[\"如果键值对的个数大于254的话\",{\"1\":{\"301\":1}}],[\"如果该key读取的goroutine挂起\",{\"1\":{\"421\":1}}],[\"如果该配置启用\",{\"1\":{\"353\":1}}],[\"如果该字段为1即代表之前被解压过\",{\"1\":{\"300\":1}}],[\"如果该错误由\",{\"1\":{\"262\":1}}],[\"如果说ziplist是整个redis中为了节省内存\",{\"1\":{\"300\":1}}],[\"如果ziplist中entry的数目小于65535\",{\"1\":{\"299\":1}}],[\"如果正在扩容过程中\",{\"1\":{\"296\":1}}],[\"如果需要\",{\"1\":{\"296\":1}}],[\"如果需要扩容\",{\"1\":{\"296\":1}}],[\"如果需要抢占调度\",{\"1\":{\"33\":1}}],[\"如果插入时\",{\"1\":{\"296\":1}}],[\"如果插入的记录所在页不在内存中\",{\"1\":{\"250\":1}}],[\"如果订单在一定时间内不付款就把此订单状态改为失败然后redis里的\",{\"1\":{\"268\":1}}],[\"如果后端服务器down掉\",{\"1\":{\"266\":1}}],[\"如果还没有错误则返回\",{\"1\":{\"262\":1}}],[\"如果存储在共享空间之中即使表删除了空间也不会释放\",{\"1\":{\"255\":1}}],[\"如果存在default且其它case都不满足条件\",{\"1\":{\"7\":1}}],[\"如果查询条件使用的是普通索引\",{\"1\":{\"246\":1}}],[\"如果查询语句的字段全部命中了索引\",{\"1\":{\"152\":1}}],[\"如果通过调整顺序\",{\"1\":{\"246\":1}}],[\"如果非要使用的话不要设置太大的内存占用\",{\"1\":{\"236\":1}}],[\"如果表中没有定义主键\",{\"1\":{\"230\":1}}],[\"如果表数据量太大\",{\"1\":{\"182\":1}}],[\"如果索引类型为index\",{\"1\":{\"229\":1}}],[\"如果可见则会知道前面的删除标志是已经删除\",{\"1\":{\"219\":1}}],[\"如果此条记录对于该事务不可见且\",{\"1\":{\"215\":1}}],[\"如果大于等于则说明此事务无法看见该条记录\",{\"1\":{\"215\":1}}],[\"如果大于则进入下一轮判断\",{\"1\":{\"215\":1}}],[\"如果满足\",{\"1\":{\"215\":1}}],[\"如果操作完成后通过版本号进行判断在该线程操作过程中是否有其他线程已经对该共享资源进行操作了\",{\"1\":{\"212\":1}}],[\"如果a表的tid不是连续的\",{\"1\":{\"206\":1}}],[\"如果a表tid是自增长\",{\"1\":{\"206\":1}}],[\"如果要存储用户的密码散列\",{\"0\":{\"186\":1}}],[\"如果标识了主键\",{\"1\":{\"184\":1}}],[\"如果slave保存的runid与master现在的runid不同\",{\"1\":{\"321\":1}}],[\"如果slave保存的runid与master现在的runid相同\",{\"1\":{\"321\":1}}],[\"如果sql很复杂\",{\"1\":{\"182\":1}}],[\"如果select不在循环中或循环次数结束\",{\"1\":{\"7\":1}}],[\"如果select在循环中\",{\"1\":{\"7\":1}}],[\"如果业务处理不好可以用分布式事务锁或者使用乐观锁\",{\"1\":{\"159\":1}}],[\"如果不允许的话\",{\"1\":{\"370\":1}}],[\"如果不存在就尝试加载rdb\",{\"1\":{\"357\":1}}],[\"如果不存储数据\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"如果不在则说明已经提交\",{\"1\":{\"215\":1}}],[\"如果不是很理解可以参考着我后面的实践结合着去理解\",{\"1\":{\"215\":1}}],[\"如果不了解的可以去学习一下\",{\"1\":{\"212\":1}}],[\"如果不支持\",{\"0\":{\"204\":1}}],[\"如果不同程序会并发存取多个表\",{\"1\":{\"159\":1}}],[\"如果\",{\"1\":{\"158\":1,\"199\":1,\"478\":2}}],[\"如果按锁粒度划分\",{\"1\":{\"133\":1}}],[\"如果b的数据量大于a\",{\"1\":{\"112\":1}}],[\"如果b的数据量小于a\",{\"1\":{\"112\":1}}],[\"如果某个表有近千万数据\",{\"0\":{\"108\":1}}],[\"如果某类型实现接口的方法的receiver是\",{\"1\":{\"46\":2}}],[\"如果事务执行过程中出错或者用户执行了rollback\",{\"1\":{\"107\":1,\"194\":1}}],[\"如果别的线程修改过\",{\"1\":{\"99\":1}}],[\"如果看到别的线程没修改过\",{\"1\":{\"99\":1}}],[\"如果id是连续的\",{\"1\":{\"93\":1}}],[\"如果ins保存的是指针类型的\",{\"1\":{\"48\":1}}],[\"如果ins保存的是值类型的type\",{\"1\":{\"48\":1}}],[\"如果树这种数据结构作为索引\",{\"1\":{\"90\":1}}],[\"如果二叉树特殊化为一个链表\",{\"1\":{\"89\":1}}],[\"如果有则通知操作失败\",{\"1\":{\"212\":1}}],[\"如果有\",{\"0\":{\"203\":1},\"1\":{\"199\":1}}],[\"如果有权限就会调用数据库引擎接口\",{\"1\":{\"126\":1}}],[\"如果有权限\",{\"1\":{\"126\":1}}],[\"如果有这种感觉\",{\"1\":{\"72\":1}}],[\"如果有修改操作\",{\"1\":{\"43\":2}}],[\"如果上面的二叉查找树是这样的构造\",{\"1\":{\"68\":1}}],[\"如果我想要在\",{\"1\":{\"66\":1}}],[\"如果我们要找到幸运数字为33的用户信息\",{\"1\":{\"72\":1}}],[\"如果我们的b+树一个节点可以存储1000个键值\",{\"1\":{\"70\":1}}],[\"如果我们用树这种数据结构作为索引的数据结构\",{\"1\":{\"69\":1}}],[\"如果我们能把尽量多的数据放进磁盘块中\",{\"1\":{\"69\":1}}],[\"如果我们需要查找id=17的用户信息\",{\"1\":{\"68\":1}}],[\"如果我们需要查找id=12的用户信息\",{\"1\":{\"67\":1}}],[\"如果我们多协程对同一个key进行操作\",{\"1\":{\"53\":1}}],[\"如果我们被迫无奈\",{\"1\":{\"44\":1}}],[\"如果追加元素\",{\"1\":{\"63\":1}}],[\"如果在超时时间未查到目标值程序\",{\"1\":{\"473\":1}}],[\"如果在则说明这条记录还未提交对于当前操作的事务是不可见的\",{\"1\":{\"215\":1}}],[\"如果在表中一条条的查找的话\",{\"1\":{\"67\":1}}],[\"如果在添加写锁之前已经有其他的读锁和写锁\",{\"1\":{\"58\":1}}],[\"如果在一个地方lock\",{\"1\":{\"57\":1}}],[\"如果在select中执行send操作\",{\"1\":{\"7\":1}}],[\"如果杠精面试官说我就想要多协程对同一个key进行操作\",{\"1\":{\"53\":1}}],[\"如果是多核可能会暴涨\",{\"1\":{\"461\":1}}],[\"如果是多个不同的域名呢\",{\"1\":{\"265\":1}}],[\"如果是case\",{\"1\":{\"392\":1}}],[\"如果是重复指令\",{\"1\":{\"386\":1}}],[\"如果是二进制数据\",{\"1\":{\"299\":1}}],[\"如果是数值\",{\"1\":{\"299\":1}}],[\"如果是\",{\"1\":{\"296\":1,\"356\":1}}],[\"如果是这两个域名\",{\"1\":{\"265\":1}}],[\"如果是生产模式下就要进行优雅的错误处理\",{\"1\":{\"262\":2}}],[\"如果是mysqld导致的\",{\"1\":{\"190\":1}}],[\"如果是分布式系统\",{\"1\":{\"183\":1}}],[\"如果是单机的话\",{\"1\":{\"183\":1}}],[\"如果是b树\",{\"1\":{\"90\":1}}],[\"如果是b类型\",{\"1\":{\"48\":1}}],[\"如果是nil则使用默认的defaultservemux\",{\"1\":{\"12\":1}}],[\"如果只有一个工作线程\",{\"1\":{\"29\":1}}],[\"如果栈太大了过于浪费它还能自动收缩\",{\"1\":{\"27\":1}}],[\"如果没有开启aof\",{\"1\":{\"355\":1}}],[\"如果没有符合条件的\",{\"1\":{\"230\":1}}],[\"如果没有则操作成功\",{\"1\":{\"212\":1}}],[\"如果没有\",{\"0\":{\"203\":1}}],[\"如果没有唯一键\",{\"1\":{\"150\":1}}],[\"如果没有主键\",{\"1\":{\"150\":1}}],[\"如果没有缓存\",{\"1\":{\"126\":1}}],[\"如果没有权限就直接返回错误信息\",{\"1\":{\"126\":1}}],[\"如果没有权限\",{\"1\":{\"126\":1}}],[\"如果没有进行写锁定\",{\"1\":{\"58\":2}}],[\"如果没有空闲的处理器了\",{\"1\":{\"22\":1}}],[\"如果没有default\",{\"1\":{\"7\":1}}],[\"如果g进行了系统调用syscall\",{\"1\":{\"22\":1}}],[\"如果哪里都没找到要执行的g呢\",{\"1\":{\"21\":1}}],[\"如果全局队列里也没有的话\",{\"1\":{\"21\":1}}],[\"如果取完的话就去全局队列取\",{\"1\":{\"21\":1}}],[\"如果多个case同时满足条件\",{\"1\":{\"7\":1}}],[\"如果所有的case语句块评估时都被阻塞\",{\"1\":{\"7\":1}}],[\"如果使用close\",{\"1\":{\"2\":1}}],[\"空间固定会用完\",{\"1\":{\"244\":1}}],[\"空接口是一种接口\",{\"1\":{\"47\":1}}],[\"空接口是指没有定义任何接口方法的接口\",{\"1\":{\"47\":1}}],[\"空interface\",{\"0\":{\"47\":1}}],[\"空map\",{\"1\":{\"41\":1}}],[\"空闲的p结构体对象的数量\",{\"1\":{\"36\":1}}],[\"空闲的工作线程的数量\",{\"1\":{\"36\":1}}],[\"函数本身是阻塞的\",{\"1\":{\"431\":1}}],[\"函数里启动的\",{\"1\":{\"401\":1}}],[\"函数不需要循环调用\",{\"1\":{\"396\":1}}],[\"函数不能加数字\",{\"1\":{\"391\":1}}],[\"函数判断\",{\"1\":{\"370\":1}}],[\"函数将错误信息托管至errorexception\",{\"1\":{\"262\":1}}],[\"函数所在文件中产生的大多数\",{\"1\":{\"262\":1}}],[\"函数来帮助开发者自定义异常处理行为\",{\"1\":{\"262\":1}}],[\"函数来注册这个方法\",{\"1\":{\"262\":1}}],[\"函数来设置错误级别\",{\"1\":{\"262\":1}}],[\"函数实现\",{\"1\":{\"262\":1}}],[\"函数的读者的数量\",{\"1\":{\"58\":1}}],[\"函数并且还没调用\",{\"1\":{\"58\":1}}],[\"函数或\",{\"1\":{\"42\":1}}],[\"函数\",{\"1\":{\"42\":1,\"428\":1}}],[\"函数用于获取map中元素的个数\",{\"1\":{\"41\":1}}],[\"函数外的map也会被修改\",{\"1\":{\"41\":1}}],[\"函数式编程\",{\"1\":{\"16\":1}}],[\"若这个配置项是开启的\",{\"1\":{\"300\":1}}],[\"若数值取值均不在上述范围\",{\"1\":{\"299\":1}}],[\"若数值取值范围位于\",{\"1\":{\"299\":5}}],[\"若数据是整数值\",{\"1\":{\"299\":1}}],[\"若数据是二进制数据\",{\"1\":{\"299\":3}}],[\"若前一个entry占用的字节数等于或大于\",{\"1\":{\"299\":1}}],[\"若前一个entry占用的字节数小于\",{\"1\":{\"299\":1}}],[\"若等于或超过65535\",{\"1\":{\"299\":1}}],[\"若生成的新结点的level\",{\"1\":{\"297\":1}}],[\"若当前zskiplistlevel实例在level\",{\"1\":{\"297\":1}}],[\"若当前不在平滑扩容过程中\",{\"1\":{\"296\":1}}],[\"若是新字典初始化\",{\"1\":{\"296\":1}}],[\"若字典上还运行着安全迭代器\",{\"1\":{\"296\":1}}],[\"若字典中元素的个数与bucket数组长度比值大于1\",{\"1\":{\"296\":1}}],[\"若字典中本无元素\",{\"1\":{\"296\":1}}],[\"若字典正处于平滑扩容过程\",{\"1\":{\"296\":1}}],[\"若在平滑扩容过程中\",{\"1\":{\"296\":1}}],[\"若该数目不为0\",{\"1\":{\"296\":1}}],[\"若扩容是一次性的\",{\"1\":{\"296\":1}}],[\"若值是整数值的话\",{\"1\":{\"296\":1}}],[\"若总体空间已经超过了阈值\",{\"1\":{\"294\":1}}],[\"若剩余空间不足\",{\"1\":{\"294\":1}}],[\"若切片发生拷贝\",{\"1\":{\"63\":1}}],[\"若强行比较\",{\"1\":{\"44\":1}}],[\"若对象实例中数据比较复杂\",{\"1\":{\"42\":1}}],[\"若函数内部对map做了相关修改\",{\"1\":{\"41\":1}}],[\"若没有此操作\",{\"1\":{\"6\":1}}],[\"若没有缓冲数据\",{\"1\":{\"2\":1}}],[\"关键定义如下\",{\"1\":{\"295\":1,\"298\":1}}],[\"关键字的实现跟go关键字很类似\",{\"1\":{\"405\":1}}],[\"关键字无法初始化\",{\"1\":{\"391\":1}}],[\"关键字\",{\"1\":{\"212\":1}}],[\"关于自动触发的规则请看上面配置部分\",{\"1\":{\"356\":1}}],[\"关于原理部分\",{\"1\":{\"354\":1}}],[\"关于压缩的配置\",{\"1\":{\"352\":1}}],[\"关于性能与实践建议\",{\"1\":{\"350\":1}}],[\"关于这个问题给出俩个解决方案\",{\"1\":{\"328\":1}}],[\"关于新创建的结点\",{\"1\":{\"297\":1}}],[\"关于超卖问题\",{\"1\":{\"269\":1}}],[\"关于nginx轮询算法的解释可以看这篇文章\",{\"1\":{\"266\":1}}],[\"关于nginx负责均衡算法策略的选择\",{\"1\":{\"266\":1}}],[\"关于单点登录\",{\"1\":{\"265\":1}}],[\"关于session相关知识可以阅读php官方手册\",{\"1\":{\"264\":1}}],[\"关联字段\",{\"1\":{\"238\":1}}],[\"关联数组\",{\"1\":{\"41\":1}}],[\"关心过业务系统里面的sql耗时吗\",{\"0\":{\"182\":1}}],[\"关掉连接\",{\"1\":{\"179\":1}}],[\"关闭时执行\",{\"1\":{\"502\":1}}],[\"关闭时会报错\",{\"1\":{\"463\":1}}],[\"关闭前\",{\"1\":{\"478\":2}}],[\"关闭索引\",{\"0\":{\"226\":1}}],[\"关闭等\",{\"1\":{\"187\":1}}],[\"关闭通道是没有意义的\",{\"1\":{\"6\":1}}],[\"关闭channel\",{\"1\":{\"2\":1}}],[\"关闭channel后\",{\"1\":{\"2\":2}}],[\"qx9lfw2s2zzgvhzg3mtzkwzc0000gn\",{\"1\":{\"490\":1}}],[\"qcount\",{\"1\":{\"484\":2}}],[\"q为整个跳跃表中\",{\"1\":{\"297\":1}}],[\"q\",{\"1\":{\"297\":4}}],[\"quicklist在两者之间做了一个平衡\",{\"1\":{\"300\":1}}],[\"quicklist有自己的优点\",{\"1\":{\"300\":1}}],[\"quicklist的具体实现代码篇幅很长\",{\"1\":{\"300\":1}}],[\"quicklist的内存布局图如下所示\",{\"1\":{\"300\":1}}],[\"quicklist作为一个封装良好的数据结构\",{\"1\":{\"300\":1}}],[\"quicklistentry是对ziplist中的entry概念的封装\",{\"1\":{\"300\":1}}],[\"quicklistentry\",{\"1\":{\"300\":2}}],[\"quicklistiter是一个迭代器\",{\"1\":{\"300\":1}}],[\"quicklistiter\",{\"1\":{\"300\":2}}],[\"quicklistlzf\",{\"1\":{\"300\":5}}],[\"quicklistnodes\",{\"1\":{\"300\":2}}],[\"quicklistnode\",{\"1\":{\"300\":16}}],[\"quicklist是一个链表\",{\"1\":{\"300\":2}}],[\"quicklist\",{\"0\":{\"300\":1},\"1\":{\"292\":1,\"300\":17}}],[\"queries\",{\"1\":{\"224\":1}}],[\"query\",{\"1\":{\"224\":1,\"236\":2,\"237\":2,\"400\":2,\"437\":2}}],[\"queue\",{\"1\":{\"35\":2,\"36\":1,\"276\":1,\"407\":1}}],[\"qihoo\",{\"1\":{\"85\":1}}],[\"qq\",{\"1\":{\"37\":1,\"266\":1,\"473\":1,\"490\":1}}],[\"原来是咔咔\",{\"1\":{\"329\":1}}],[\"原子性\",{\"1\":{\"106\":1,\"107\":1,\"194\":1,\"223\":1,\"245\":1}}],[\"原\",{\"1\":{\"63\":1}}],[\"原文地址\",{\"1\":{\"291\":1}}],[\"原文链接\",{\"1\":{\"288\":1}}],[\"原文\",{\"1\":{\"37\":1,\"73\":1,\"347\":1,\"469\":1,\"490\":1}}],[\"原因是内部有协程\",{\"1\":{\"15\":1}}],[\"原因在于\",{\"1\":{\"8\":1}}],[\"指通道已经关闭\",{\"1\":{\"484\":1}}],[\"指令\",{\"1\":{\"318\":1,\"319\":2}}],[\"指是的这种场景\",{\"1\":{\"296\":1}}],[\"指值本身又是一种键值对结构\",{\"1\":{\"275\":1}}],[\"指定轮询几率\",{\"1\":{\"266\":1}}],[\"指一段代码\",{\"1\":{\"170\":1}}],[\"指在事务开始之前和事务结束以后\",{\"1\":{\"106\":1}}],[\"指针字段会耗费大量内存\",{\"1\":{\"300\":1}}],[\"指针的形式间接持有\",{\"1\":{\"295\":1}}],[\"指针来间接的指向数据\",{\"1\":{\"295\":1}}],[\"指针类型比较的是指针地址\",{\"1\":{\"439\":1}}],[\"指针类型别名的原因\",{\"1\":{\"294\":1}}],[\"指针类型的实例的method\",{\"1\":{\"46\":1}}],[\"指针类型的实例是另一个method\",{\"1\":{\"46\":1}}],[\"指针不会被重新分配\",{\"1\":{\"63\":2}}],[\"指针\",{\"1\":{\"41\":1}}],[\"指针会被初始化为nil指针\",{\"1\":{\"37\":1}}],[\"指向null\",{\"1\":{\"296\":1}}],[\"指向的旧表会被释放\",{\"1\":{\"296\":1}}],[\"指向的哈希表中\",{\"1\":{\"296\":1}}],[\"指向扩容后的新哈希表\",{\"1\":{\"296\":1}}],[\"指向旧哈希表\",{\"1\":{\"296\":1}}],[\"指向同索引的下一个dictentry结构\",{\"1\":{\"296\":1}}],[\"指向这条记录的上一个版本\",{\"1\":{\"215\":1}}],[\"指向工作线程正在运行的goroutine的g结构体对象\",{\"1\":{\"34\":1}}],[\"指向内存高地址\",{\"1\":{\"31\":1}}],[\"指向内存低地址\",{\"1\":{\"31\":1}}],[\"由子进程负责持久化过程\",{\"1\":{\"355\":1}}],[\"由冲突而链起来的多个结点\",{\"1\":{\"296\":1}}],[\"由使用者自行调用\",{\"1\":{\"294\":1}}],[\"由缓存系统更新数据源\",{\"1\":{\"288\":1}}],[\"由等待下次读取来回写缓存\",{\"1\":{\"288\":1}}],[\"由参数innodb\",{\"1\":{\"255\":1}}],[\"由一个有限的数据库操作序列构成\",{\"1\":{\"154\":1}}],[\"由mysql\",{\"1\":{\"139\":1}}],[\"由平衡二叉树的构造我们可以发现第一张图中的二叉树其实就是一棵平衡二叉树\",{\"1\":{\"68\":1}}],[\"由于执行了6遍\",{\"1\":{\"501\":1}}],[\"由于主进程依然在响应命令\",{\"1\":{\"356\":1}}],[\"由于主节点的cpu占用过高\",{\"1\":{\"327\":1}}],[\"由于\",{\"1\":{\"355\":1}}],[\"由于网络因素\",{\"1\":{\"328\":1}}],[\"由于网络环境不佳\",{\"1\":{\"326\":1}}],[\"由于len\",{\"1\":{\"301\":1}}],[\"由于list中的链表结点本身并不直接持有数据\",{\"1\":{\"295\":1}}],[\"由于每个结点持有的ziplist是有上限长度的\",{\"1\":{\"300\":1}}],[\"由于该字段仅占16位\",{\"1\":{\"300\":1}}],[\"由于其头部额外存储了数据区的长度信息\",{\"1\":{\"294\":1}}],[\"由于无论其中存储的是用户的二进制数据\",{\"1\":{\"294\":1}}],[\"由于索引唯一性\",{\"1\":{\"250\":1}}],[\"由于sql的执行是有上下文的\",{\"1\":{\"140\":1}}],[\"由于add和read操作都会使用到锁\",{\"1\":{\"57\":1}}],[\"由于近来go语言的兴起\",{\"1\":{\"17\":1}}],[\"由空闲的p结构体对象组成的链表\",{\"1\":{\"36\":1}}],[\"由空闲的工作线程组成链表\",{\"1\":{\"36\":1}}],[\"kv\",{\"1\":{\"441\":3}}],[\"kick\",{\"1\":{\"407\":1}}],[\"kill\",{\"1\":{\"190\":1}}],[\"kaka时\",{\"1\":{\"322\":1}}],[\"kaka\",{\"1\":{\"309\":1}}],[\"k通过指针间接持有键\",{\"1\":{\"296\":1}}],[\"k3=d\",{\"1\":{\"111\":1}}],[\"k3\",{\"1\":{\"111\":2,\"147\":2}}],[\"k2=b\",{\"1\":{\"111\":1}}],[\"k2\",{\"1\":{\"111\":3,\"147\":3}}],[\"k1=a\",{\"1\":{\"111\":1}}],[\"k1\",{\"1\":{\"111\":4,\"147\":4}}],[\"kl\",{\"1\":{\"72\":2}}],[\"keyobj\",{\"1\":{\"346\":5}}],[\"key==he\",{\"1\":{\"296\":1}}],[\"keydestructor\",{\"1\":{\"296\":1}}],[\"keydup\",{\"1\":{\"296\":1}}],[\"key2\",{\"1\":{\"296\":1}}],[\"key1\",{\"1\":{\"296\":1}}],[\"keycompare\",{\"1\":{\"296\":1}}],[\"key键名为\",{\"1\":{\"268\":1}}],[\"key分区\",{\"1\":{\"234\":1}}],[\"keys\",{\"1\":{\"195\":1,\"226\":1,\"227\":1,\"296\":2,\"346\":1}}],[\"key是string类型\",{\"1\":{\"52\":1}}],[\"key\",{\"1\":{\"52\":10,\"53\":11,\"58\":13,\"67\":1,\"69\":1,\"145\":2,\"173\":2,\"195\":2,\"229\":1,\"230\":1,\"234\":2,\"268\":1,\"269\":3,\"295\":1,\"296\":13,\"301\":3,\"339\":3,\"341\":2,\"342\":1,\"346\":5,\"421\":5,\"508\":1}}],[\"keep\",{\"1\":{\"36\":1,\"300\":1}}],[\"k\",{\"1\":{\"41\":1,\"53\":2,\"346\":7,\"370\":2,\"424\":2,\"469\":1}}],[\"known\",{\"1\":{\"32\":1,\"33\":4}}],[\"队列\",{\"1\":{\"276\":1}}],[\"队列尾\",{\"1\":{\"35\":1}}],[\"队列头\",{\"1\":{\"35\":1}}],[\"队列中存储的是待执行的goroutine列表\",{\"1\":{\"20\":1}}],[\"本身\",{\"1\":{\"414\":1}}],[\"本文将通过下面内容的介绍\",{\"1\":{\"350\":1}}],[\"本文主要讲解了什么是主从复制\",{\"1\":{\"329\":1}}],[\"本文主要讨论分布式缓存系统设计与使用中面临的问题\",{\"1\":{\"282\":1}}],[\"本文实现所需环境\",{\"1\":{\"304\":1}}],[\"本文就来从头到尾介绍下数据库的索引\",{\"1\":{\"66\":1}}],[\"本地缓存\",{\"1\":{\"282\":1}}],[\"本地goroutine运行队列\",{\"1\":{\"35\":1}}],[\"本次事务提交之前\",{\"1\":{\"98\":1}}],[\"本次select就不会出现阻塞的情况\",{\"1\":{\"7\":1}}],[\"本篇文从二叉查找树\",{\"1\":{\"73\":1}}],[\"6版本后\",{\"1\":{\"246\":1}}],[\"6版本之前\",{\"1\":{\"246\":1}}],[\"6版本以上会根据后续条件的值判断索引值是否符合\",{\"1\":{\"246\":1}}],[\"6版本innodb开始支持全文索引\",{\"1\":{\"235\":1}}],[\"6及以上可以放心大胆的去用子查询\",{\"1\":{\"232\":1}}],[\"69\",{\"0\":{\"173\":1}}],[\"6896993332019822605\",{\"1\":{\"503\":2}}],[\"68\",{\"0\":{\"172\":1}}],[\"67\",{\"0\":{\"171\":1}}],[\"66\",{\"0\":{\"170\":1}}],[\"666\",{\"1\":{\"158\":1}}],[\"65k\",{\"1\":{\"300\":1}}],[\"65536\",{\"1\":{\"300\":1}}],[\"65\",{\"0\":{\"169\":1},\"1\":{\"200\":1,\"473\":1}}],[\"6379\",{\"1\":{\"309\":1}}],[\"6380连接\",{\"1\":{\"308\":1}}],[\"63254901\",{\"1\":{\"235\":1}}],[\"63\",{\"0\":{\"167\":1}}],[\"62\",{\"0\":{\"166\":1}}],[\"6113927\",{\"1\":{\"265\":1}}],[\"61\",{\"0\":{\"163\":1}}],[\"60\",{\"0\":{\"160\":1},\"1\":{\"352\":1}}],[\"6\",{\"0\":{\"88\":1,\"299\":1,\"396\":1,\"410\":1,\"450\":1,\"461\":1},\"1\":{\"34\":1,\"127\":1,\"198\":1,\"219\":1,\"469\":1,\"490\":3,\"500\":1,\"503\":1}}],[\"64mb\",{\"1\":{\"353\":1}}],[\"6443332\",{\"1\":{\"266\":1}}],[\"64kb\",{\"1\":{\"200\":1,\"300\":1}}],[\"64\",{\"0\":{\"168\":1},\"1\":{\"12\":1,\"300\":1,\"370\":6}}],[\"前后赋值\",{\"1\":{\"374\":1}}],[\"前后翻转\",{\"1\":{\"374\":1}}],[\"前者称之为主节点\",{\"1\":{\"305\":1}}],[\"前一个entry所占用的字节数\",{\"1\":{\"299\":1}}],[\"前置数据加载\",{\"1\":{\"282\":1}}],[\"前缀的语句发生错误时\",{\"1\":{\"262\":1}}],[\"前缀索引更小\",{\"1\":{\"229\":1}}],[\"前缀索引主要是对字符串类型的列取公共前缀进行索引\",{\"1\":{\"229\":1}}],[\"前缀索引\",{\"0\":{\"229\":1}}],[\"前提是客户端有安装\",{\"1\":{\"201\":1}}],[\"前滚到该事务完成时并提交掉\",{\"1\":{\"199\":1}}],[\"前文所说的g结构体\",{\"1\":{\"33\":1}}],[\"前面我们讲解b+树索引的时候并没有去说怎么在b+树中进行数据的查找\",{\"1\":{\"72\":1}}],[\"前面我们说每个工作线程都有一个m结构体对象与之对应\",{\"1\":{\"29\":1}}],[\"前面说了\",{\"1\":{\"43\":1}}],[\"前面都是在for无限循环中读取channel中的数据\",{\"1\":{\"6\":1}}],[\"栈\",{\"1\":{\"276\":1}}],[\"栈底\",{\"1\":{\"31\":1}}],[\"栈顶\",{\"1\":{\"31\":1}}],[\"栈内存空间一旦创建和初始化完成之后其大小就不能再有变化\",{\"1\":{\"27\":1}}],[\"栈内存\",{\"1\":{\"19\":1}}],[\"另外一个从\",{\"1\":{\"418\":1}}],[\"另外一个\",{\"1\":{\"366\":1}}],[\"另外四个字节\",{\"1\":{\"299\":1}}],[\"另外注意\",{\"1\":{\"294\":1}}],[\"另外\",{\"1\":{\"30\":1,\"69\":1,\"70\":1,\"297\":1}}],[\"另一个事务才能继续操作\",{\"1\":{\"245\":1}}],[\"另一个并发事务b往这个范围中插入\",{\"1\":{\"96\":1}}],[\"另一方面它还拥有一个用来保存goroutine的运行队列\",{\"1\":{\"29\":1}}],[\"另一方面\",{\"1\":{\"27\":1}}],[\"另一端正好在期待本端的操作时\",{\"1\":{\"4\":1}}],[\"看这里\",{\"1\":{\"502\":1}}],[\"看到阻塞协程第一个想到的就是channel\",{\"1\":{\"421\":1}}],[\"看到有很多博客上写的是通过\",{\"1\":{\"215\":1}}],[\"看下列代码\",{\"1\":{\"265\":1}}],[\"看下这个结构的定义\",{\"1\":{\"58\":1}}],[\"看看执行计划是否准确\",{\"1\":{\"190\":1}}],[\"看图形象一点\",{\"1\":{\"159\":1}}],[\"看是否可以适当添加索引\",{\"1\":{\"129\":1}}],[\"看不懂记不住都没有关系\",{\"1\":{\"30\":1}}],[\"看上面的案例\",{\"1\":{\"8\":1}}],[\"光是看这些结构体的定义我们没有必要也无法真正理解它们的用途\",{\"1\":{\"30\":1}}],[\"牵涉到的细节也很庞杂\",{\"1\":{\"30\":1}}],[\"三\",{\"0\":{\"307\":1}}],[\"三个\",{\"1\":{\"219\":1}}],[\"三个隐藏字段\",{\"1\":{\"215\":1}}],[\"三个索引\",{\"1\":{\"111\":1,\"147\":1}}],[\"三角形代表m结构体的实例对象\",{\"1\":{\"29\":1}}],[\"三者的关系\",{\"0\":{\"21\":1}}],[\"通道输入的是\",{\"1\":{\"502\":4}}],[\"通知字母打印\",{\"1\":{\"366\":1}}],[\"通常情况下不应当由sds的使用者直接调用\",{\"1\":{\"294\":1}}],[\"通常错误会被转化为异常进行统一处理\",{\"1\":{\"262\":1}}],[\"通常我们在web模式下都会有个入口文件\",{\"1\":{\"260\":1}}],[\"通过fmt\",{\"1\":{\"490\":1}}],[\"通过一个例子加深理解\",{\"1\":{\"490\":1}}],[\"通过key获取到的实际上是两个值\",{\"1\":{\"441\":1}}],[\"通过位运算判断\",{\"1\":{\"370\":1}}],[\"通过strings\",{\"1\":{\"370\":2}}],[\"通过socket接收到信息后\",{\"1\":{\"318\":1}}],[\"通过socket接收rdb文件\",{\"1\":{\"318\":1}}],[\"通过socket发送复制缓冲区中从节点offset到主节点offset的数据\",{\"1\":{\"318\":1}}],[\"通过socket发送rdb文件给从节点\",{\"1\":{\"318\":1}}],[\"通过上面的分析\",{\"1\":{\"358\":1}}],[\"通过上面的分析我们知道aof基本上最多损失1s的数据\",{\"1\":{\"357\":1}}],[\"通过上图可以看到\",{\"1\":{\"70\":1}}],[\"通过少量访问\",{\"1\":{\"347\":1}}],[\"通过记录键使用频率来定位最可能淘汰的键\",{\"1\":{\"347\":1}}],[\"通过图4和图2对比\",{\"1\":{\"346\":1}}],[\"通过图4和图3对比\",{\"1\":{\"346\":1}}],[\"通过使用\",{\"1\":{\"342\":1}}],[\"通过\",{\"1\":{\"318\":1}}],[\"通过多个从节点分担读负载\",{\"1\":{\"307\":1}}],[\"通过自定义各种函数实现\",{\"1\":{\"296\":1}}],[\"通过判断flag低三位的值\",{\"1\":{\"294\":1}}],[\"通过这个指针\",{\"1\":{\"294\":1}}],[\"通过负载均衡把请求分发到不同的节点\",{\"1\":{\"268\":1}}],[\"通过索引访问数据\",{\"1\":{\"231\":1}}],[\"通过undolog来查找可见的记录版本\",{\"1\":{\"215\":1}}],[\"通过外间tid关联\",{\"0\":{\"206\":1}}],[\"通过步骤一的连接\",{\"1\":{\"179\":1}}],[\"通过表级锁定来减少死锁产生的概率\",{\"1\":{\"159\":1}}],[\"通过tcp协议的三次握手和数据库服务器建立连接\",{\"1\":{\"123\":1}}],[\"通过tls实现m结构体对象与工作线程之间的绑定\",{\"1\":{\"34\":1}}],[\"通过回滚\",{\"1\":{\"107\":1,\"194\":1}}],[\"通过锁以及mvcc\",{\"1\":{\"107\":1,\"194\":1}}],[\"通过慢查询日志定位那些执行效率较低的\",{\"1\":{\"103\":1}}],[\"通过空接口类型\",{\"1\":{\"47\":1}}],[\"通过下面的示例对map进行声明和创建\",{\"1\":{\"41\":1}}],[\"通过m既可以找到与之对应的工作线程正在运行的goroutine\",{\"1\":{\"29\":1}}],[\"通讯顺序进程\",{\"1\":{\"16\":1}}],[\"加上main函数本身也是一个goroutine\",{\"1\":{\"501\":1}}],[\"加上undo\",{\"1\":{\"219\":1}}],[\"加载aof时如果有错如何处理\",{\"1\":{\"353\":1}}],[\"加载很慢的话\",{\"0\":{\"93\":1}}],[\"加写锁\",{\"1\":{\"212\":1}}],[\"加读锁\",{\"1\":{\"212\":1}}],[\"加锁后复制变量\",{\"1\":{\"460\":1}}],[\"加锁是一种非常简单粗暴的方法\",{\"1\":{\"212\":1}}],[\"加锁慢\",{\"1\":{\"133\":1}}],[\"加锁快\",{\"1\":{\"133\":1}}],[\"加锁会导致严重的性能问题\",{\"1\":{\"29\":1}}],[\"加索引\",{\"1\":{\"82\":1}}],[\"加持\",{\"1\":{\"15\":1}}],[\"该函数可每秒钟往chan中放一个time\",{\"1\":{\"428\":1}}],[\"该问题主要考察了并发情况下map的读写问题\",{\"1\":{\"424\":1}}],[\"该接口定义在fmt\",{\"1\":{\"394\":1}}],[\"该接口没有间接的被任何sds其它接口调用\",{\"1\":{\"294\":1}}],[\"该加载谁呢\",{\"1\":{\"357\":1}}],[\"该触发方式会fork一个子进程\",{\"1\":{\"355\":1}}],[\"该值最大能够设置为\",{\"1\":{\"354\":1}}],[\"该指针指向结点的前一个紧邻结点\",{\"1\":{\"297\":1}}],[\"该指针指向该元素\",{\"1\":{\"63\":1}}],[\"该字段的值恒为2\",{\"1\":{\"300\":1}}],[\"该字段值为\",{\"1\":{\"296\":1}}],[\"该字段记录了运行于该字典上的安全迭代器的数目\",{\"1\":{\"296\":1}}],[\"该记录的事务id\",{\"1\":{\"215\":1}}],[\"该事务对数据库所作的操作更改\",{\"1\":{\"106\":1}}],[\"该实例对象在源代码中被定义成了一个共享的全局变量\",{\"1\":{\"29\":1}}],[\"该结构体保存了goroutine的所有信息\",{\"1\":{\"33\":1}}],[\"该结构体的每一个实例对象都代表了一个goroutine\",{\"1\":{\"29\":1}}],[\"该结构体非常复杂\",{\"1\":{\"19\":1}}],[\"于是\",{\"1\":{\"29\":2}}],[\"于是go调度器又引入了schedt结构体\",{\"1\":{\"29\":1}}],[\"于是sender被阻塞\",{\"1\":{\"3\":1}}],[\"便于工作线程寻找需要被调度起来运行的goroutine\",{\"1\":{\"29\":1}}],[\"可读的时候会公平的选中一个执行\",{\"1\":{\"409\":1}}],[\"可读性高可认为修改修复\",{\"1\":{\"356\":1}}],[\"可通过config\",{\"1\":{\"346\":1}}],[\"可把数据库中的库存数据转移到redis缓存中\",{\"1\":{\"268\":1}}],[\"可重写errorhandler方法\",{\"1\":{\"262\":1}}],[\"可重复性读\",{\"1\":{\"245\":1}}],[\"可重复读\",{\"1\":{\"95\":1,\"223\":1}}],[\"可在客户端执行\",{\"1\":{\"334\":1}}],[\"可在\",{\"1\":{\"262\":1}}],[\"可忽略\",{\"1\":{\"262\":1}}],[\"可复用\",{\"1\":{\"255\":1}}],[\"可见\",{\"1\":{\"219\":1}}],[\"可见性算法\",{\"1\":{\"213\":1,\"215\":3,\"219\":1}}],[\"可回滚\",{\"1\":{\"177\":1}}],[\"可移植性不灵活\",{\"1\":{\"169\":1}}],[\"可能导致写失败\",{\"1\":{\"395\":1}}],[\"可能导致索引失效\",{\"1\":{\"78\":3}}],[\"可能还未调用\",{\"1\":{\"395\":1}}],[\"可能会导致链式反应\",{\"1\":{\"299\":1}}],[\"可能会导致索引失效\",{\"1\":{\"78\":1}}],[\"可能会散布到新表的多个索引位上\",{\"1\":{\"296\":1}}],[\"可能会散布在多个新表索引中去\",{\"1\":{\"296\":1}}],[\"可能出现诸如主键重复等的问题\",{\"1\":{\"113\":1}}],[\"可是我们有多个工作线程和多个m需要一一对应\",{\"1\":{\"29\":1}}],[\"可运行\",{\"1\":{\"29\":1}}],[\"可以编译\",{\"1\":{\"448\":3,\"450\":3}}],[\"可以将map中的非指针类型value\",{\"1\":{\"399\":1}}],[\"可以输入重复指令n\",{\"1\":{\"386\":1}}],[\"可以用来判断在一个字符串中包含的另外一个字符串的数量\",{\"1\":{\"370\":1}}],[\"可以加入主从机器\",{\"1\":{\"358\":1}}],[\"可以加载读锁\",{\"1\":{\"58\":1}}],[\"可以关闭持久化\",{\"1\":{\"358\":1}}],[\"可以手动或者自动触发\",{\"1\":{\"356\":1}}],[\"可以禁止此项配置\",{\"1\":{\"352\":1}}],[\"可以理解为就进行一次备份\",{\"1\":{\"352\":1}}],[\"可以方便的对\",{\"1\":{\"342\":1}}],[\"可以大大提高redis服务器的并发量和负载\",{\"1\":{\"307\":1}}],[\"可以大大降低死锁机会\",{\"1\":{\"159\":1}}],[\"可以提高服务器的负载能力\",{\"1\":{\"307\":1}}],[\"可以由从节点来提供服务也就是slave\",{\"1\":{\"307\":1}}],[\"可以看到有一个slave0的一个信息\",{\"1\":{\"310\":1}}],[\"可以看到\",{\"1\":{\"294\":1}}],[\"可以重复\",{\"1\":{\"278\":1}}],[\"可以放到set中实现\",{\"1\":{\"277\":1}}],[\"可以取多个集合取交集\",{\"1\":{\"277\":1}}],[\"可以包含任何数据\",{\"1\":{\"274\":1}}],[\"可以极大可能的避免超卖\",{\"1\":{\"269\":1}}],[\"可以解决session的问题\",{\"1\":{\"266\":1}}],[\"可以自己动手实现下\",{\"1\":{\"265\":1}}],[\"可以参考这篇文章\",{\"1\":{\"265\":1,\"266\":1}}],[\"可以采用\",{\"1\":{\"252\":1}}],[\"可以少维护一个索引\",{\"1\":{\"246\":1}}],[\"可以减少资源占用\",{\"1\":{\"232\":1}}],[\"可以先关闭索引\",{\"1\":{\"225\":1}}],[\"可以先阐述四种隔离级别\",{\"1\":{\"155\":1}}],[\"可以分9种情况进行\",{\"1\":{\"207\":1}}],[\"可以使用单个过程变量\",{\"1\":{\"374\":1}}],[\"可以使用golang内置的方式实现\",{\"1\":{\"370\":1}}],[\"可以使用命令redis\",{\"1\":{\"325\":1}}],[\"可以使用info\",{\"1\":{\"319\":1}}],[\"可以使用set\",{\"1\":{\"262\":1}}],[\"可以使用select\",{\"1\":{\"98\":1}}],[\"可以使用索引\",{\"1\":{\"246\":1}}],[\"可以使用表连接代替\",{\"1\":{\"232\":1}}],[\"可以使用批量\",{\"1\":{\"201\":1}}],[\"可以把ssh底层结构体转成byte的切片的指针\",{\"1\":{\"496\":1}}],[\"可以把字符串a转成底层结构的形式\",{\"1\":{\"496\":1}}],[\"可以把数据页回滚到前镜像的\",{\"1\":{\"199\":1}}],[\"可以把内核对系统线程的调度简单的归纳为\",{\"1\":{\"29\":1}}],[\"可以通过下标取出对应的value值\",{\"1\":{\"276\":1}}],[\"可以通过\",{\"1\":{\"260\":1}}],[\"可以通过显示的命令开启事务\",{\"1\":{\"245\":1}}],[\"可以通过set\",{\"1\":{\"245\":1}}],[\"可以通过show\",{\"1\":{\"238\":1}}],[\"可以通过参数设置\",{\"1\":{\"238\":1}}],[\"可以通过如下语句来计算\",{\"1\":{\"229\":1}}],[\"可以通过不断比较公共前缀出现的次数和总记录的商来取前缀\",{\"1\":{\"229\":1}}],[\"可以通过伪哈希索引的手段来优化查询语句\",{\"1\":{\"228\":1}}],[\"可以通过long\",{\"1\":{\"224\":1}}],[\"可以通过设置\",{\"1\":{\"198\":1}}],[\"可以通过数据库中的相关表实现级联更改\",{\"1\":{\"170\":1}}],[\"可以一定程度上确保数据安全\",{\"1\":{\"169\":1}}],[\"可以降低网络通信量\",{\"1\":{\"169\":1}}],[\"可以尝试使用升级锁定颗粒度\",{\"1\":{\"159\":1}}],[\"可以根据条件来完成行锁锁定\",{\"1\":{\"158\":1}}],[\"可以获取到整行数据\",{\"1\":{\"150\":1}}],[\"可以在键盘上输入\",{\"1\":{\"370\":1}}],[\"可以在配置文件修改repl\",{\"1\":{\"322\":1}}],[\"可以在索引遍历过程中\",{\"1\":{\"127\":1}}],[\"可以在一个进程中启动成千上万个协程\",{\"1\":{\"15\":1}}],[\"可以考虑提前分库分表的\",{\"1\":{\"184\":1}}],[\"可以考虑进行分离\",{\"1\":{\"129\":1}}],[\"可以考虑加缓存\",{\"1\":{\"120\":1}}],[\"可以考虑优化表结构\",{\"1\":{\"109\":1}}],[\"可以抽象成这样一个循环\",{\"1\":{\"112\":1}}],[\"可以抽象成这样的一个循环\",{\"1\":{\"112\":1}}],[\"可以这样\",{\"1\":{\"93\":1}}],[\"可以存储更多的节点数据\",{\"1\":{\"90\":1}}],[\"可以直接读取\",{\"1\":{\"87\":1}}],[\"可以从几个维度去看这个问题\",{\"1\":{\"88\":1}}],[\"可以从这几个维度回答这个问题\",{\"1\":{\"82\":1}}],[\"可以从三个维度回答这个问题\",{\"1\":{\"77\":1}}],[\"可以想象到二叉树的节点将会非常多\",{\"1\":{\"69\":1}}],[\"可以同时申请多个读锁\",{\"1\":{\"58\":1}}],[\"可以定义一个空接口类型的array\",{\"1\":{\"47\":1}}],[\"可以是任意类型\",{\"1\":{\"42\":1}}],[\"可以轻易的创建成千上万甚至上百万的goroutine出来并发的执行任务而不用太担心性能和内存等问题\",{\"1\":{\"27\":1}}],[\"可以保证系统开销降到最低\",{\"1\":{\"19\":1}}],[\"要求sync\",{\"1\":{\"431\":2}}],[\"要求手写代码\",{\"1\":{\"431\":2}}],[\"要求程序不能退出\",{\"1\":{\"428\":2}}],[\"要求每秒钟调用一次proc函数\",{\"1\":{\"428\":2}}],[\"要求每秒钟调用一次proc并保证程序不退出\",{\"0\":{\"428\":1}}],[\"要求每个节点的左右子树的高度差不能超过1\",{\"1\":{\"68\":1}}],[\"要求能成功输出\",{\"1\":{\"424\":1}}],[\"要限制ip的频繁访问\",{\"1\":{\"424\":1}}],[\"要防止多个机器同时运行持久化\",{\"1\":{\"358\":1}}],[\"要根据业务场景来选择\",{\"1\":{\"266\":1}}],[\"要根据业务需求\",{\"1\":{\"147\":1}}],[\"要控制合适的分区的个数\",{\"1\":{\"234\":1}}],[\"要优化了\",{\"1\":{\"229\":1}}],[\"要是单独的列\",{\"1\":{\"228\":1}}],[\"要先记\",{\"1\":{\"199\":1}}],[\"要怎么处理呢\",{\"0\":{\"190\":1}}],[\"要么是辅助索引\",{\"1\":{\"206\":1}}],[\"要么全部不执行\",{\"1\":{\"154\":1}}],[\"要么都不执行\",{\"1\":{\"106\":1}}],[\"要安全的修改同一行数据\",{\"1\":{\"97\":1}}],[\"要从页3中查找数据\",{\"1\":{\"72\":1}}],[\"要查找这个id>=18\",{\"1\":{\"72\":1}}],[\"要实现这一点是很不容易的\",{\"1\":{\"70\":1}}],[\"要实现对goroutine的调度\",{\"1\":{\"29\":1}}],[\"要介绍b+树索引\",{\"1\":{\"66\":1}}],[\"要等待写锁完成释放后\",{\"1\":{\"58\":1}}],[\"要命的还在后头\",{\"1\":{\"8\":1}}],[\"实例的内存情况进行静态的分析\",{\"1\":{\"342\":1}}],[\"实例中数据的内存分布情况\",{\"1\":{\"333\":1}}],[\"实际工作中是需要配置在俩台不同的服务器的\",{\"1\":{\"308\":1}}],[\"实际数量在结点创建时\",{\"1\":{\"297\":1}}],[\"实际上代码执行后会启动\",{\"1\":{\"437\":1}}],[\"实际上\",{\"1\":{\"42\":1}}],[\"实战场景\",{\"1\":{\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1}}],[\"实践\",{\"0\":{\"216\":1}}],[\"实时监控某张表中的某个字段的更改而需要做出相应的处理\",{\"1\":{\"170\":1}}],[\"实表\",{\"1\":{\"164\":1}}],[\"实现一个调整单链表的函数\",{\"1\":{\"469\":1}}],[\"实现一一对应的关系\",{\"1\":{\"41\":1}}],[\"实现如下\",{\"1\":{\"421\":1}}],[\"实现阻塞读且并发安全的map\",{\"0\":{\"421\":1}}],[\"实现方法也有很多种\",{\"1\":{\"418\":1}}],[\"实现方式\",{\"1\":{\"99\":1,\"102\":1}}],[\"实现的\",{\"1\":{\"394\":1}}],[\"实现的非常苟\",{\"1\":{\"292\":1}}],[\"实现主节点和从节点连接保持在线\",{\"1\":{\"319\":1}}],[\"实现了\",{\"1\":{\"415\":1}}],[\"实现了快速恢复故障\",{\"1\":{\"307\":1}}],[\"实现了数据的热备份\",{\"1\":{\"307\":1}}],[\"实现了http\",{\"1\":{\"12\":1}}],[\"实现复杂\",{\"1\":{\"288\":1}}],[\"实现简单\",{\"1\":{\"286\":1,\"297\":1}}],[\"实现栈的自动伸缩\",{\"1\":{\"33\":1}}],[\"实质都是通过保存和修改cpu寄存器的值来达到切换线程\",{\"1\":{\"29\":1}}],[\"放在这里只是为了帮助我们从宏观上了解goroutine的两级调度模型\",{\"1\":{\"28\":1}}],[\"程序hang住\",{\"1\":{\"446\":1,\"447\":1}}],[\"程序会卡在\",{\"1\":{\"401\":1}}],[\"程序启动时由runtime代码初始化\",{\"1\":{\"37\":1}}],[\"程序启动时的初始化代码\",{\"1\":{\"28\":1,\"29\":1}}],[\"程序运行起来之后创建了n个由内核调度的操作系统线程\",{\"1\":{\"28\":1}}],[\"保证并发安全\",{\"1\":{\"421\":1}}],[\"保证两串的长度都小于等于5000\",{\"1\":{\"378\":1}}],[\"保证字符串的长度小于等于5000\",{\"1\":{\"374\":1}}],[\"保证字符串中的字符为\",{\"1\":{\"370\":1}}],[\"保证在迭代器遍历操作开始时\",{\"1\":{\"296\":1}}],[\"保证了字典有很大的调优空间\",{\"1\":{\"296\":1}}],[\"保证send不会被阻塞\",{\"1\":{\"7\":1}}],[\"保留了集合不能有重复成员的特性\",{\"1\":{\"278\":1}}],[\"保护数据\",{\"1\":{\"165\":1}}],[\"保护的\",{\"1\":{\"57\":1}}],[\"保存master的offset\",{\"1\":{\"318\":1}}],[\"保存master的信息\",{\"1\":{\"315\":1}}],[\"保存主节点的runid和offset\",{\"1\":{\"318\":1}}],[\"保存所有的p\",{\"1\":{\"37\":1}}],[\"保存所有的g\",{\"1\":{\"37\":1}}],[\"保存调度信息\",{\"1\":{\"33\":1}}],[\"保存系统调用的返回值\",{\"1\":{\"32\":1}}],[\"保存cpu的rip寄存器的值\",{\"1\":{\"32\":2}}],[\"保存cpu的rsp寄存器的值\",{\"1\":{\"32\":1}}],[\"保存goroutine的状态\",{\"1\":{\"28\":1,\"29\":1}}],[\"从另外一个角度说\",{\"1\":{\"503\":1}}],[\"从runtime的源码可以看到\",{\"1\":{\"407\":1}}],[\"从redis4\",{\"1\":{\"347\":1}}],[\"从relay\",{\"1\":{\"117\":1,\"192\":1}}],[\"从持久化中恢复数据\",{\"0\":{\"357\":1}}],[\"从db删除对象\",{\"1\":{\"346\":1}}],[\"从后向前逐一淘汰\",{\"1\":{\"346\":1}}],[\"从源码安装\",{\"0\":{\"338\":1}}],[\"从主节点获取到最新的数据变更命令\",{\"1\":{\"319\":1}}],[\"从节点全量复制时\",{\"1\":{\"355\":1}}],[\"从节点达到maxmemory时不会有任何异常日志信息\",{\"1\":{\"345\":1}}],[\"从节点故障\",{\"1\":{\"328\":1}}],[\"从节点执行了慢查询\",{\"1\":{\"327\":1}}],[\"从节点每秒会发送一个指令replconf\",{\"1\":{\"327\":1}}],[\"从节点网络中断\",{\"1\":{\"326\":1}}],[\"从节点网络中断偏移量越界导致全量复制\",{\"0\":{\"326\":1}}],[\"从节点是接收一次记录一次\",{\"1\":{\"323\":1}}],[\"从节点就会一直全量复制\",{\"1\":{\"322\":1}}],[\"从节点收到+continue\",{\"1\":{\"318\":1}}],[\"从节点的offset与offset不相同\",{\"1\":{\"318\":1}}],[\"从节点的offset和主节点的offset相同时则忽略\",{\"1\":{\"318\":1}}],[\"从节点已经获取到了主节点的runid和offset\",{\"1\":{\"318\":1}}],[\"从节点接收到+fullresync\",{\"1\":{\"318\":1}}],[\"从节点接收数据执行bgrewriteaof\",{\"1\":{\"317\":1}}],[\"从节点发送指令psync\",{\"1\":{\"318\":1}}],[\"从节点会继续尝试连接主机\",{\"1\":{\"317\":1}}],[\"从节点会保存master的地址和端口\",{\"1\":{\"315\":1}}],[\"从节点还是会自动同步的\",{\"1\":{\"310\":1}}],[\"从节点提供读服务\",{\"1\":{\"307\":1}}],[\"从内存布局上也能看出来\",{\"1\":{\"300\":1}}],[\"从内存中读取到页1\",{\"1\":{\"72\":1}}],[\"从牙缝里省内存\",{\"1\":{\"299\":1}}],[\"从旧表迁移到新表后\",{\"1\":{\"296\":1}}],[\"从这里也可以看出来\",{\"1\":{\"296\":1}}],[\"从这个层面上说\",{\"1\":{\"266\":1}}],[\"从入参指针init处开始\",{\"1\":{\"294\":1}}],[\"从命名上能看出来\",{\"1\":{\"294\":1}}],[\"从前端来讲可以这样搞\",{\"1\":{\"268\":1}}],[\"从性能和存储空间方面考量\",{\"1\":{\"246\":1}}],[\"从数据库的relay\",{\"1\":{\"192\":1}}],[\"从数据库把主数据库的bin\",{\"1\":{\"192\":1}}],[\"从数据库中删除表\",{\"1\":{\"177\":1}}],[\"从锁的类别上来讲\",{\"1\":{\"157\":1}}],[\"从锁的类别角度讲\",{\"0\":{\"157\":1}}],[\"从哪些方面入手\",{\"0\":{\"129\":1}}],[\"从exec\",{\"1\":{\"117\":1,\"192\":1}}],[\"从库启动复制\",{\"1\":{\"238\":1}}],[\"从库启动之后\",{\"1\":{\"117\":1,\"192\":1}}],[\"从库配置中继日志文件地址\",{\"1\":{\"238\":1}}],[\"从库发起连接\",{\"1\":{\"117\":1,\"192\":1}}],[\"从而影响主进程读写性能\",{\"1\":{\"354\":1}}],[\"从而影响数据库性能\",{\"1\":{\"212\":1}}],[\"从而出现这类异常持续存在的缓存\",{\"1\":{\"347\":1}}],[\"从而进行全量复制\",{\"1\":{\"322\":1}}],[\"从而绕过缓存\",{\"1\":{\"286\":1}}],[\"从而导致主节点和从节点的数据不一致\",{\"1\":{\"322\":1}}],[\"从而导致恶性循环的现象\",{\"1\":{\"159\":1}}],[\"从而导致查找效率的不稳定\",{\"1\":{\"68\":1}}],[\"从而降低服务器负载\",{\"1\":{\"119\":1}}],[\"从而提高并发性能的一种机制\",{\"1\":{\"114\":1}}],[\"从而引发问题\",{\"1\":{\"113\":1}}],[\"从而让性能更优\",{\"1\":{\"112\":1}}],[\"从而实现一致性\",{\"1\":{\"107\":1,\"194\":1}}],[\"从磁盘中读取页3后将页3放入内存中\",{\"1\":{\"72\":1}}],[\"从磁盘中读取数据时\",{\"1\":{\"69\":1}}],[\"从磁盘中读取数据的速度会慢上百倍千倍甚至万倍\",{\"1\":{\"69\":1}}],[\"从页1中我们可以找到键值18\",{\"1\":{\"72\":1}}],[\"从图中可以看到\",{\"1\":{\"67\":1}}],[\"从实现接口方法的角度上看\",{\"1\":{\"46\":1}}],[\"从表象来看是一个东西\",{\"1\":{\"44\":1}}],[\"从上面的代码我们可以看出\",{\"1\":{\"58\":1}}],[\"从上面的代码示例我们可以看到struct实例可以是一个值也可以是一个指针\",{\"1\":{\"42\":1}}],[\"从上面的案例中我们通过锁机制实现了并发安全的map\",{\"1\":{\"52\":1}}],[\"从上图可以看出\",{\"1\":{\"29\":1,\"69\":1}}],[\"从现在开始\",{\"1\":{\"27\":1}}],[\"从buffered\",{\"1\":{\"3\":1}}],[\"正确实现了单例\",{\"1\":{\"448\":1}}],[\"正确的话就在服务器端生成一个唯一sessionid\",{\"1\":{\"264\":1}}],[\"正常情况下我们的代码都会执行\",{\"1\":{\"503\":1}}],[\"正常退出\",{\"1\":{\"447\":1}}],[\"正常的程序中都无法使用这个tag属性\",{\"1\":{\"42\":1}}],[\"正好符合我们的要求\",{\"1\":{\"428\":1}}],[\"正在被执行的\",{\"1\":{\"401\":1}}],[\"正在运行代码的处理器\",{\"1\":{\"19\":1}}],[\"正方形代表p结构体的实例对象\",{\"1\":{\"29\":1}}],[\"正是因为go语言中实现了如此轻量级的线程\",{\"1\":{\"27\":1}}],[\"系统全局不可用\",{\"1\":{\"284\":1}}],[\"系统可以提交sql语句到数据库执行\",{\"1\":{\"123\":1}}],[\"系统通过undo\",{\"1\":{\"107\":1,\"194\":1}}],[\"系统也会帮你创建一个隐式的主键\",{\"1\":{\"71\":1}}],[\"系统中cpu核的数量\",{\"1\":{\"37\":1}}],[\"系统线程对goroutine的调度与内核对系统线程的调度原理是一样的\",{\"1\":{\"29\":1}}],[\"系统线程远远用不了这么多内存\",{\"1\":{\"27\":1}}],[\"系统调用\",{\"0\":{\"22\":1}}],[\"系统调用之前的线程的处理器\",{\"1\":{\"19\":1}}],[\"然而执行程序\",{\"1\":{\"501\":1}}],[\"然而在一个繁忙的系统中\",{\"1\":{\"29\":1}}],[\"然而在绝大多数情况下\",{\"1\":{\"27\":1}}],[\"然后执行\",{\"1\":{\"502\":1}}],[\"然后保证map的并发读写\",{\"1\":{\"424\":1}}],[\"然后根据定义的顺序倒序执行\",{\"1\":{\"410\":1}}],[\"然后根据主键索引查到行记录\",{\"1\":{\"246\":1}}],[\"然后就产生了循环调用\",{\"1\":{\"394\":1}}],[\"然后是全部不同\",{\"1\":{\"370\":1}}],[\"然后是事务a进行了select的操作\",{\"1\":{\"219\":1}}],[\"然后周而复始的工作\",{\"1\":{\"366\":1}}],[\"然后可以手动触发备份\",{\"1\":{\"358\":1}}],[\"然后从节点长时间没有相应\",{\"1\":{\"327\":1}}],[\"然后从节点就会执行bgrewriteaof恢复数据\",{\"1\":{\"316\":1}}],[\"然后发送给从节点\",{\"1\":{\"325\":1}}],[\"然后清空当前所有数据\",{\"1\":{\"318\":1}}],[\"然后使用简短的话语来描述上边的工作流程\",{\"1\":{\"315\":1}}],[\"然后使用redis\",{\"1\":{\"308\":1}}],[\"然后直接使用redis\",{\"1\":{\"308\":1}}],[\"然后分别开启俩个redis服务\",{\"1\":{\"308\":1}}],[\"然后把用户id加入到秒杀购买成功队列\",{\"1\":{\"268\":1}}],[\"然后去消费秒杀队列\",{\"1\":{\"268\":1}}],[\"然后去睡觉\",{\"1\":{\"21\":1}}],[\"然后在函数返回之前的地方\",{\"1\":{\"405\":1}}],[\"然后在发送给从节点\",{\"1\":{\"322\":1}}],[\"然后在slave6380端口是可以成功获取到的\",{\"1\":{\"309\":1}}],[\"然后在谈实现的原理\",{\"1\":{\"308\":1}}],[\"然后在每次请求的时候把cookie相关信息带上\",{\"1\":{\"265\":1}}],[\"然后在下次查询的时候把数据读入内存\",{\"1\":{\"250\":1}}],[\"然后将这个语句写到redolog里\",{\"1\":{\"251\":1}}],[\"然后insert失败\",{\"1\":{\"245\":1}}],[\"然后通过\",{\"1\":{\"356\":1}}],[\"然后通过http协议把这个sessionid放到cookie里返回给客户端\",{\"1\":{\"264\":1}}],[\"然后通过索引找到磁盘相应数据\",{\"1\":{\"231\":1}}],[\"然后通过主键找到具体的值\",{\"1\":{\"230\":1}}],[\"然后通过回滚指针判断\",{\"1\":{\"219\":1}}],[\"然后前面视图也没有进行更改\",{\"1\":{\"219\":1}}],[\"然后小亮的记录\",{\"1\":{\"219\":1}}],[\"然后对于小张这条记录\",{\"1\":{\"219\":1}}],[\"然后对于事务c的\",{\"1\":{\"219\":1}}],[\"然后此时所见和上面也是一样的\",{\"1\":{\"219\":1}}],[\"然后事务b进行了\",{\"1\":{\"219\":1}}],[\"然后事务b进行了插入\",{\"1\":{\"219\":1}}],[\"然后事务a进行了更新操作\",{\"1\":{\"218\":1}}],[\"然后事务a再次查询相同的范围\",{\"1\":{\"96\":1}}],[\"然后我们获取刚刚被修改的id为1的记录行\",{\"1\":{\"218\":1}}],[\"然后我们获取更改了的数据行\",{\"1\":{\"218\":1}}],[\"然后我们获取那两个没有被修改的记录\",{\"1\":{\"218\":1}}],[\"然后判断小张这条记录\",{\"1\":{\"219\":2}}],[\"然后判断这条记录的\",{\"1\":{\"215\":1}}],[\"然后判断sql\",{\"1\":{\"126\":1}}],[\"然后修改数据页\",{\"1\":{\"199\":1}}],[\"然后写到\",{\"1\":{\"198\":1}}],[\"然后给这些代码块取一个名字\",{\"1\":{\"169\":1}}],[\"然后批量删除其中无用数据\",{\"1\":{\"146\":1}}],[\"然后再进一步扩充\",{\"1\":{\"294\":1}}],[\"然后再通过后台进程把redis中的用户秒杀请求同步到数据库中\",{\"1\":{\"268\":1}}],[\"然后再同步到磁盘文件\",{\"1\":{\"198\":1}}],[\"然后再关联\",{\"1\":{\"93\":1}}],[\"然后再拿到页3中的指针p1\",{\"1\":{\"72\":1}}],[\"然后页8中就没有数据了\",{\"1\":{\"72\":1}}],[\"然后进行查找\",{\"1\":{\"72\":1}}],[\"然后映射到value\",{\"1\":{\"41\":1}}],[\"然后互相绑定\",{\"1\":{\"21\":1}}],[\"然后开一个goruntine处理这个连接\",{\"1\":{\"12\":1}}],[\"然后accept阻塞直到返回下一个链接\",{\"1\":{\"12\":1}}],[\"然后阻塞\",{\"1\":{\"3\":1}}],[\"内无值\",{\"1\":{\"478\":1}}],[\"内有元素已经被读完\",{\"1\":{\"478\":1}}],[\"内有元素还未读\",{\"1\":{\"478\":1}}],[\"内的值\",{\"1\":{\"478\":1}}],[\"内部发生函数调用的时候\",{\"1\":{\"401\":1}}],[\"内部优化\",{\"0\":{\"325\":1}}],[\"内部会探测该哈希表是否需要扩容\",{\"1\":{\"296\":1}}],[\"内部会探测哈希表是否需要扩容\",{\"1\":{\"296\":1}}],[\"内部会检查是否需要扩容\",{\"1\":{\"296\":1}}],[\"内部api也不会清除闲置内在空间\",{\"1\":{\"294\":1}}],[\"内部节点只存键\",{\"1\":{\"148\":1}}],[\"内置函数导致的\",{\"1\":{\"262\":1}}],[\"内连接\",{\"1\":{\"135\":1,\"137\":1,\"174\":1}}],[\"内核调度器按照一定的算法挑选出一个线程并把该线程保存在内存之中的寄存器的值放入cpu对应的寄存器从而恢复该线程的运行\",{\"1\":{\"29\":1}}],[\"内核负责对这n个操作系统线程进行调度\",{\"1\":{\"28\":1}}],[\"内核并不会一开始就分配这么多的物理内存\",{\"1\":{\"27\":1}}],[\"内核在创建操作系统线程时默认会为其分配一个较大的栈内存\",{\"1\":{\"27\":1}}],[\"内存可能会稳定在256mb\",{\"1\":{\"461\":1}}],[\"内存稳定\",{\"1\":{\"450\":1}}],[\"内存超限后写命令会返回错误\",{\"1\":{\"345\":1}}],[\"内存使用量是理论上的近似值\",{\"1\":{\"339\":1}}],[\"内存使用量包含\",{\"1\":{\"339\":1}}],[\"内存使用量\",{\"1\":{\"339\":1}}],[\"内存使用太重\",{\"1\":{\"27\":1}}],[\"内存地址都不会变化\",{\"1\":{\"296\":1}}],[\"内存级缓存优势在于本地内存i\",{\"1\":{\"282\":1}}],[\"内存级缓存\",{\"1\":{\"282\":1,\"285\":1}}],[\"内存里是没有这个物理页的\",{\"1\":{\"251\":1}}],[\"内存分配用到的缓存等等\",{\"1\":{\"35\":1}}],[\"内存分配等\",{\"1\":{\"19\":1}}],[\"创建备份\",{\"0\":{\"334\":1}}],[\"创建新结点\",{\"1\":{\"297\":1}}],[\"创建更加合理的索引\",{\"1\":{\"252\":1}}],[\"创建删除更新该记录的事务id\",{\"1\":{\"217\":1}}],[\"创建的真正的三个隐藏列吧\",{\"1\":{\"215\":1}}],[\"创建索引的三种方式\",{\"0\":{\"145\":1}}],[\"创建索引需要注意顺序\",{\"1\":{\"144\":1}}],[\"创建索引有什么原则呢\",{\"0\":{\"144\":1}}],[\"创建索引和维护索引要耗费时间\",{\"1\":{\"142\":1}}],[\"创建和初始化m结构体对象\",{\"1\":{\"29\":1}}],[\"创建和切换太重\",{\"1\":{\"27\":1}}],[\"创建n个操作系统线程执行schedule函数\",{\"1\":{\"28\":1,\"29\":1}}],[\"创建一个不含数据的sds\",{\"1\":{\"294\":1}}],[\"创建一个sds实例有三个接口\",{\"1\":{\"294\":1}}],[\"创建一个i\",{\"1\":{\"117\":1,\"192\":1}}],[\"创建一个map\",{\"1\":{\"41\":2}}],[\"创建一个操作系统线程执行schedule函数\",{\"1\":{\"28\":1,\"29\":1}}],[\"创建一个新的连接\",{\"1\":{\"12\":1}}],[\"创建一个无缓冲的chan\",{\"1\":{\"2\":1}}],[\"重写操作\",{\"1\":{\"358\":1}}],[\"重写数据\",{\"1\":{\"358\":1}}],[\"重写是直接把当前内存的数据生成对应命令\",{\"1\":{\"356\":1}}],[\"重写触发配置\",{\"1\":{\"353\":1}}],[\"重写方法\",{\"1\":{\"42\":1}}],[\"重新创建一个事务c并select\",{\"1\":{\"218\":1}}],[\"重新跑这些\",{\"1\":{\"190\":1}}],[\"重新编译问题\",{\"1\":{\"169\":1}}],[\"重用sql语句\",{\"1\":{\"165\":1}}],[\"重要的全局变量\",{\"0\":{\"37\":1}}],[\"重要的结构体\",{\"0\":{\"30\":1}}],[\"重\",{\"1\":{\"27\":1}}],[\"非指针类型比较的是每个属性的值\",{\"1\":{\"439\":1}}],[\"非常快\",{\"1\":{\"353\":1}}],[\"非安全迭代器\",{\"1\":{\"296\":1}}],[\"非致命错误\",{\"1\":{\"262\":1}}],[\"非主键索引的叶子节点存储的是主键\",{\"1\":{\"246\":1}}],[\"非主键索引\",{\"1\":{\"246\":1}}],[\"非聚簇索引一定会回表查询吗\",{\"0\":{\"152\":1}}],[\"非聚簇索引\",{\"1\":{\"71\":1}}],[\"非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据\",{\"1\":{\"71\":1}}],[\"非聚集索引\",{\"0\":{\"71\":1},\"1\":{\"71\":1,\"92\":2}}],[\"非商业转载请注明出处\",{\"1\":{\"23\":1,\"207\":1,\"219\":1,\"329\":1,\"358\":1,\"503\":2}}],[\"非阻塞\",{\"1\":{\"3\":1}}],[\"著作权归作者所有\",{\"1\":{\"23\":1,\"207\":1,\"219\":1,\"329\":1,\"358\":1,\"503\":2}}],[\"著名的c++专家herb\",{\"1\":{\"16\":1}}],[\"掘金\",{\"1\":{\"23\":1,\"207\":1,\"219\":1,\"329\":1,\"358\":1,\"503\":2}}],[\"来判断字符是否一致\",{\"1\":{\"378\":1}}],[\"来分别控制数字和字母的打印序列\",{\"1\":{\"366\":1}}],[\"来控制打印的进度\",{\"1\":{\"366\":1}}],[\"来控制实现的\",{\"1\":{\"215\":1}}],[\"来尽可能降低redis在fork时的事件消耗\",{\"1\":{\"355\":1}}],[\"来设置\",{\"1\":{\"354\":1}}],[\"来保证内存占用与实际效果的平衡\",{\"1\":{\"345\":1}}],[\"来进行静态分析\",{\"1\":{\"333\":1}}],[\"来查看从节点租后一次连接时间的间隔\",{\"1\":{\"319\":1}}],[\"来做负载均衡执行者\",{\"1\":{\"266\":1}}],[\"来做的\",{\"1\":{\"252\":1}}],[\"来实现\",{\"1\":{\"264\":1}}],[\"来实现版本并发控制\",{\"1\":{\"215\":1}}],[\"来实现数据库并发控制\",{\"1\":{\"213\":1}}],[\"来对需要重启的机器执行重启命令\",{\"1\":{\"201\":1}}],[\"来降低并发事务冲突\",{\"1\":{\"114\":1}}],[\"来决定主查询的数据结果是否得意保留\",{\"1\":{\"112\":1}}],[\"来源于到一个通道\",{\"1\":{\"502\":1}}],[\"来源\",{\"1\":{\"23\":1,\"207\":1,\"219\":1,\"329\":1,\"358\":1,\"503\":2}}],[\"来关闭channel\",{\"1\":{\"2\":1}}],[\"向前偏一个字节\",{\"1\":{\"294\":1}}],[\"向长时间运行的g发出抢占调度等等\",{\"1\":{\"23\":1}}],[\"向unbuffered\",{\"1\":{\"4\":1}}],[\"又存在for循环中启动goroutine时变量使用问题以及goroutine执行滞后问题\",{\"1\":{\"424\":1}}],[\"又有aof文件\",{\"1\":{\"357\":1}}],[\"又称write\",{\"1\":{\"288\":1}}],[\"又叫做写锁\",{\"1\":{\"157\":1}}],[\"又叫做读锁\",{\"1\":{\"157\":1}}],[\"又叫监控线程\",{\"1\":{\"23\":1}}],[\"又可以找到工作线程的局部运行队列等资源\",{\"1\":{\"29\":1}}],[\"又创建了一个g\",{\"1\":{\"21\":1}}],[\"哇\",{\"1\":{\"21\":1}}],[\"啥\",{\"1\":{\"21\":1}}],[\"默认使用\",{\"1\":{\"502\":1}}],[\"默认情况下\",{\"1\":{\"413\":1}}],[\"默认情况下gomaxprocs被设置为内核数\",{\"1\":{\"19\":1}}],[\"默认10秒进行一次\",{\"1\":{\"319\":1}}],[\"默认的实现是ziplist\",{\"1\":{\"300\":1}}],[\"默认\",{\"1\":{\"266\":1}}],[\"默认提供这两种算法\",{\"1\":{\"266\":1}}],[\"默认值为当前时间\",{\"1\":{\"193\":1}}],[\"默认等于ncpu\",{\"1\":{\"37\":1}}],[\"默认启动四个线程四个处理器\",{\"1\":{\"21\":1}}],[\"首先想到的就是\",{\"1\":{\"428\":1}}],[\"首先要保证启动的goroutine得到的参数是正确的\",{\"1\":{\"424\":1}}],[\"首先要保证字符串长度小于5000\",{\"1\":{\"378\":1}}],[\"首先要先找到主键索引\",{\"1\":{\"246\":1}}],[\"首先考虑秒杀的场景\",{\"1\":{\"268\":1}}],[\"首先二级索引先找到主键\",{\"1\":{\"230\":1}}],[\"首先此时视图还是这个样子\",{\"1\":{\"219\":1}}],[\"首先也是\",{\"1\":{\"219\":1}}],[\"首先对于前面两条小明和小方的记录是一样的\",{\"1\":{\"219\":2}}],[\"首先对共享资源进行加锁\",{\"1\":{\"212\":1}}],[\"首先事务a开启了事务\",{\"1\":{\"218\":1}}],[\"首先我们先配置俩个配置文件\",{\"1\":{\"308\":1}}],[\"首先我们要知道跨域\",{\"1\":{\"265\":1}}],[\"首先我们在事务a中删除一条记录\",{\"1\":{\"219\":1}}],[\"首先我们声明了一个长度为2\",{\"1\":{\"63\":1}}],[\"首先我创建了一个非常简单的表\",{\"1\":{\"217\":1}}],[\"首先比较这条记录的\",{\"1\":{\"215\":1}}],[\"首先去处理器的私有队列里取g执行\",{\"1\":{\"21\":1}}],[\"首先\",{\"1\":{\"21\":1,\"43\":1,\"67\":1,\"72\":1,\"218\":1,\"219\":1,\"299\":1,\"431\":1}}],[\"还要实现多个goroutine读的时候如果值不存在则阻塞\",{\"1\":{\"421\":1}}],[\"还要多一步\",{\"1\":{\"250\":1}}],[\"还做一件事情就是判断主节点是否在线\",{\"1\":{\"319\":1}}],[\"还额外增加了\",{\"1\":{\"295\":1}}],[\"还广泛用于redis的其它功能实现中\",{\"1\":{\"295\":1}}],[\"还是经过压缩包装后的quicklistlzf\",{\"1\":{\"300\":1}}],[\"还是数值\",{\"1\":{\"299\":1}}],[\"还是\",{\"1\":{\"296\":1}}],[\"还是字符串\",{\"1\":{\"294\":1}}],[\"还是那句话脱离具体业务的技术选型\",{\"1\":{\"253\":1}}],[\"还是这张b+树索引图\",{\"1\":{\"72\":1}}],[\"还请根据业务需求\",{\"1\":{\"246\":1}}],[\"还差点东西\",{\"1\":{\"215\":1}}],[\"还会创建一个sql线程\",{\"1\":{\"117\":1,\"192\":1}}],[\"还会加锁呢\",{\"1\":{\"105\":1}}],[\"还看不懂\",{\"1\":{\"72\":1}}],[\"还有rdb快照保存\",{\"1\":{\"312\":1}}],[\"还有一个字段score\",{\"1\":{\"297\":1}}],[\"还有\",{\"1\":{\"212\":1}}],[\"还有个map结构\",{\"1\":{\"58\":1}}],[\"还有玩大家很想获取的goroutine标识\",{\"1\":{\"19\":1}}],[\"还可以通过ins\",{\"1\":{\"48\":1}}],[\"还可以有一个tag属性\",{\"1\":{\"42\":1}}],[\"还可以使用new\",{\"1\":{\"42\":1}}],[\"还记得第一章我们讨论过的线程本地存储吗\",{\"1\":{\"29\":1}}],[\"还通过指针维持着与p结构体的实例对象之间的绑定关系\",{\"1\":{\"29\":1}}],[\"还存储了处理器的待运行队列\",{\"1\":{\"20\":1}}],[\"垃圾回收\",{\"1\":{\"20\":1}}],[\"刚才说p是负责m与g的关联\",{\"1\":{\"19\":1}}],[\"代码里\",{\"1\":{\"502\":1}}],[\"代码特别难写\",{\"1\":{\"299\":1}}],[\"代码如下\",{\"1\":{\"12\":4}}],[\"代表两串是否重新排列后可相同\",{\"1\":{\"378\":1}}],[\"代表以entry数目限制单个ziplist的长度\",{\"1\":{\"300\":1}}],[\"代表以字节数限制单个ziplist的最大长度\",{\"1\":{\"300\":1}}],[\"代表将被用于存储小数点后的位数\",{\"1\":{\"132\":1}}],[\"代表将被用于存储值的总的小数位数\",{\"1\":{\"132\":1}}],[\"代表进程的主线程\",{\"1\":{\"37\":1}}],[\"代表当前正在线程上执行的goroutine\",{\"1\":{\"19\":1}}],[\"会泄露\",{\"1\":{\"502\":1}}],[\"会泄漏呢\",{\"1\":{\"502\":1}}],[\"会泄漏两个goroutine的来源\",{\"1\":{\"502\":1}}],[\"会是\",{\"1\":{\"502\":1}}],[\"会产生拷贝\",{\"1\":{\"495\":1}}],[\"会产生死锁panic\",{\"1\":{\"456\":1,\"457\":1}}],[\"会发生内存拷贝吗\",{\"0\":{\"493\":1},\"1\":{\"494\":1}}],[\"会使得\",{\"1\":{\"489\":1}}],[\"会根据类型清理相应地址的内存\",{\"1\":{\"484\":1}}],[\"会根据类型清理响应的内存\",{\"1\":{\"484\":1}}],[\"会一直能读到值\",{\"0\":{\"484\":1}}],[\"会\",{\"1\":{\"478\":1}}],[\"会正确读到\",{\"1\":{\"478\":1}}],[\"会怎么样\",{\"0\":{\"476\":1},\"1\":{\"477\":1}}],[\"会阻塞依赖于\",{\"1\":{\"465\":1}}],[\"会阻塞当前redis服务器\",{\"1\":{\"355\":1}}],[\"会将锁的状态也复制\",{\"1\":{\"460\":1}}],[\"会将旧表ht\",{\"1\":{\"296\":1}}],[\"会报错误信息\",{\"1\":{\"412\":1}}],[\"会优先放入到下一个调度的runnext字段上作为下一次优先调度的g\",{\"1\":{\"407\":1}}],[\"会在方法结束时被回收\",{\"1\":{\"490\":1}}],[\"会在\",{\"1\":{\"489\":1}}],[\"会在其\",{\"1\":{\"401\":1}}],[\"会在下文的常见问题里详细说明这几个点\",{\"1\":{\"316\":1}}],[\"会直接调用\",{\"1\":{\"394\":1}}],[\"会对redis造成阻塞\",{\"1\":{\"358\":1}}],[\"会对匹配的数据进行回表查询\",{\"1\":{\"246\":1}}],[\"会有1s损耗\",{\"1\":{\"356\":1}}],[\"会向客户端写入一个log\",{\"1\":{\"353\":1}}],[\"会每隔一秒发送perlconf\",{\"1\":{\"319\":1}}],[\"会调用sdsmakeroomfor函数用于扩容空间\",{\"1\":{\"294\":1}}],[\"会退化为轮询策略\",{\"1\":{\"266\":1}}],[\"会话跨域和单点登录\",{\"0\":{\"265\":1}}],[\"会话安全方面php官方手册进行了说明\",{\"1\":{\"264\":1}}],[\"会话是由客户端发起请求\",{\"1\":{\"264\":1}}],[\"会话管理主要有两个部分组成\",{\"1\":{\"264\":1}}],[\"会话管理\",{\"0\":{\"263\":1,\"264\":1}}],[\"会以该函数名开头\",{\"1\":{\"262\":1}}],[\"会导致底层数组扩容\",{\"1\":{\"438\":1}}],[\"会导致最后m中的map中储存的都是stus最后一个student的值\",{\"1\":{\"406\":1}}],[\"会导致所有的从节点进行全量复制\",{\"1\":{\"325\":1}}],[\"会导致整个ziplist表中的后续所有结点的entry\",{\"1\":{\"299\":1}}],[\"会导致此问题\",{\"1\":{\"284\":1}}],[\"会导致脚本终止运行\",{\"1\":{\"262\":1}}],[\"会导致大量行的改动\",{\"1\":{\"140\":1}}],[\"会拖垮整个库\",{\"1\":{\"245\":1}}],[\"会自行创建一个隐式主键\",{\"1\":{\"230\":1}}],[\"会超出自增长的值范围\",{\"1\":{\"183\":1}}],[\"会忽略列值为空\",{\"1\":{\"167\":1}}],[\"会返回对应类型的零值\",{\"1\":{\"484\":2}}],[\"会返回右表所有的行\",{\"1\":{\"135\":1}}],[\"会返回左表所有的行\",{\"1\":{\"135\":1}}],[\"会出现死锁\",{\"1\":{\"133\":2}}],[\"会锁表还是锁行还是其他\",{\"0\":{\"104\":1}}],[\"会大大降低sql导致的线上事故\",{\"1\":{\"103\":1}}],[\"会影响外部原始实例\",{\"1\":{\"43\":1}}],[\"会如何\",{\"1\":{\"42\":1}}],[\"会深度参与运行时的调度过程\",{\"1\":{\"19\":1}}],[\"会先主动检查这个标志\",{\"1\":{\"401\":1}}],[\"会先过滤掉age<10的数据\",{\"1\":{\"246\":1}}],[\"会先查询缓存\",{\"1\":{\"126\":1}}],[\"会先输入数据\",{\"1\":{\"1\":1}}],[\"会先获取到数据\",{\"1\":{\"1\":1}}],[\"为翻转后的字符串\",{\"1\":{\"374\":1}}],[\"为闲置空间\",{\"1\":{\"301\":1}}],[\"为值的数据\",{\"1\":{\"301\":1}}],[\"为ht\",{\"1\":{\"296\":1}}],[\"为解决一个问题\",{\"1\":{\"285\":1}}],[\"为数组的键\",{\"1\":{\"262\":1}}],[\"为1\",{\"1\":{\"218\":1}}],[\"为什么上面要特意强调是同一个域名呢\",{\"1\":{\"503\":1}}],[\"为什么呢\",{\"1\":{\"501\":1}}],[\"为什么读已关闭的\",{\"0\":{\"484\":1}}],[\"为什么写已经关闭的\",{\"0\":{\"483\":1}}],[\"为什么会出现主节点资源被严重占用\",{\"1\":{\"327\":1}}],[\"为什么forward指针总是画的水平的原因\",{\"1\":{\"297\":1}}],[\"为什么事务a未提交的修改对于事务b是不可见的\",{\"1\":{\"218\":1}}],[\"为什么\",{\"0\":{\"183\":1,\"391\":1,\"414\":1,\"476\":1},\"1\":{\"477\":1}}],[\"为什么要使用视图\",{\"0\":{\"160\":1,\"161\":1}}],[\"为什么要用\",{\"0\":{\"88\":1}}],[\"为什么需要redis主从复制\",{\"0\":{\"306\":1}}],[\"为什么需要注意组合索引中的顺序\",{\"0\":{\"153\":1}}],[\"为什么需要数据库连接池呢\",{\"0\":{\"121\":1}}],[\"为什么不是一般二叉树\",{\"0\":{\"89\":1}}],[\"为什么不是b树\",{\"1\":{\"88\":1}}],[\"为什么不是平衡二叉树呢\",{\"0\":{\"90\":1}}],[\"为什么不是平衡二叉树\",{\"1\":{\"88\":1}}],[\"为什么不是二叉树\",{\"1\":{\"88\":1}}],[\"为什么不用二叉树\",{\"0\":{\"88\":1}}],[\"为什么是幸运数字\",{\"1\":{\"72\":1}}],[\"为什么mysql使用b+树做索引\",{\"0\":{\"66\":1}}],[\"为确保该锁最终可用\",{\"1\":{\"58\":1}}],[\"为各个字段做好默认的赋0初始化\",{\"1\":{\"42\":1}}],[\"为了把重写期间响应的写入信息也写入到新的文件中\",{\"1\":{\"356\":1}}],[\"为了保证最终备份的完整性\",{\"1\":{\"356\":1}}],[\"为了平衡性能与数据安全\",{\"1\":{\"352\":1}}],[\"为了使用持久化的功能\",{\"1\":{\"351\":1}}],[\"为了不影响线上实例的使用\",{\"1\":{\"333\":1}}],[\"为了查看方便在把日志文件和持久化文件的名字都用各自的端口来做标识\",{\"1\":{\"308\":1}}],[\"为了加速将散列值转化为bucket中的数组索引\",{\"1\":{\"296\":1}}],[\"为了加深理解\",{\"1\":{\"219\":1}}],[\"为了识别当前用户而创建的一种技术手段\",{\"1\":{\"264\":1}}],[\"为了你再次深入理解这个算法\",{\"1\":{\"219\":1}}],[\"为了提高复杂sql语句的复用性和表操作的安全性\",{\"1\":{\"161\":1}}],[\"为了解决平衡二叉树的这个弊端\",{\"1\":{\"69\":1}}],[\"为了解决这个问题\",{\"1\":{\"68\":1}}],[\"为了节省篇幅\",{\"1\":{\"30\":1}}],[\"为了实现对goroutine的调度\",{\"1\":{\"29\":1}}],[\"为了方便描述\",{\"1\":{\"28\":1}}],[\"为了避免混淆\",{\"1\":{\"27\":1}}],[\"为了尽量避免极端情况下操作系统线程栈的溢出\",{\"1\":{\"27\":1}}],[\"为了让代码运行的更快\",{\"1\":{\"16\":1}}],[\"为\",{\"0\":{\"431\":1},\"1\":{\"19\":1,\"218\":2,\"219\":6,\"478\":1}}],[\"唤醒时候传递的参数\",{\"1\":{\"19\":1}}],[\"期望\",{\"1\":{\"19\":1}}],[\"期待另一端的\",{\"1\":{\"4\":1}}],[\"调整后\",{\"1\":{\"469\":1}}],[\"调试麻烦\",{\"1\":{\"169\":1}}],[\"调用runtime\",{\"1\":{\"405\":1}}],[\"调用dictaddraw\",{\"1\":{\"296\":1}}],[\"调用方\",{\"1\":{\"288\":1}}],[\"调用\",{\"1\":{\"58\":1,\"262\":1,\"489\":1}}],[\"调用会从获得的锁中排除新的读取器\",{\"1\":{\"58\":1}}],[\"调用servemux的servehttp方法来处理请求\",{\"1\":{\"12\":1}}],[\"调度时会发生栈的切换\",{\"1\":{\"34\":1}}],[\"调度器结构体对象\",{\"1\":{\"37\":1}}],[\"调度器又为每个工作线程引入了一个私有的局部goroutine运行队列\",{\"1\":{\"29\":1}}],[\"调度器代码又负责把g对象的成员变量所保存的寄存器的值恢复到cpu的寄存器\",{\"1\":{\"29\":1}}],[\"调度器代码负责把cpu寄存器的值保存在g对象的成员变量之中\",{\"1\":{\"29\":1}}],[\"调度器代码可以通过g对象来对goroutine进行调度\",{\"1\":{\"29\":1}}],[\"调度器数据结构概述\",{\"0\":{\"29\":1}}],[\"调度循环\",{\"1\":{\"28\":1,\"29\":1}}],[\"调度相关的数据\",{\"1\":{\"19\":1}}],[\"状态的\",{\"1\":{\"224\":1}}],[\"状态\",{\"1\":{\"19\":1,\"199\":1}}],[\"上接收数据\",{\"1\":{\"489\":1}}],[\"上了\",{\"1\":{\"401\":1}}],[\"上个例子中已经采用了原子操作\",{\"1\":{\"269\":1}}],[\"上图是一个完整主从复制建立连接工作流程\",{\"1\":{\"315\":1}}],[\"上图主从复制分了五个步骤进行\",{\"1\":{\"192\":1}}],[\"上图中圆形图案代表g结构体的实例对象\",{\"1\":{\"29\":1}}],[\"上述图中的b树为3阶b树\",{\"1\":{\"69\":1}}],[\"上述代码中我们定义了一个结构体\",{\"1\":{\"58\":1}}],[\"上面这个其实就是我们比较收悉的读取\",{\"1\":{\"502\":1}}],[\"上面这个其实就是我们比较收悉的\",{\"1\":{\"502\":1}}],[\"上面这道题在不执行resp\",{\"1\":{\"500\":1}}],[\"上面例子中\",{\"1\":{\"260\":1}}],[\"上面讲了\",{\"1\":{\"215\":1}}],[\"上面我们讲解了利用二叉查找树可以快速的找到数据\",{\"1\":{\"68\":1}}],[\"上面的例子中\",{\"1\":{\"262\":1}}],[\"上面的错误级别可以参考php官方文档\",{\"1\":{\"262\":1}}],[\"上面的列子很简单\",{\"1\":{\"260\":1}}],[\"上面的示例中\",{\"1\":{\"268\":1}}],[\"上面的示例\",{\"1\":{\"45\":1}}],[\"上面的horse中有两个匿名段inter和animal\",{\"1\":{\"42\":1}}],[\"上面的代码有严重的内存泄漏问题\",{\"1\":{\"437\":1}}],[\"上面的代码监听了8080端口来提供http服务\",{\"1\":{\"12\":1}}],[\"上面的代码表示必须f1函数执行完成才能执行f2函数\",{\"1\":{\"5\":1}}],[\"上面的代码我们看到首先声明了一个chan\",{\"1\":{\"2\":1}}],[\"上下文切换不需要经过内核态\",{\"1\":{\"19\":1}}],[\"之所以说这是一个蛋疼问题\",{\"1\":{\"299\":1}}],[\"之所以这么做是因为在数据库中页的大小是固定的\",{\"1\":{\"70\":1}}],[\"之后被第一个协程重新赋值\",{\"1\":{\"462\":1}}],[\"之后是不能再调用\",{\"1\":{\"458\":1}}],[\"之后是事务c进行\",{\"1\":{\"219\":1}}],[\"之后使用strings\",{\"1\":{\"382\":1}}],[\"之后只需要一次循环遍历s1中的字符在s2是否都存在即可\",{\"1\":{\"378\":1}}],[\"之后即可\",{\"1\":{\"342\":1}}],[\"之后会将新表的持有权转交给ht\",{\"1\":{\"296\":1}}],[\"之后基于行\",{\"1\":{\"238\":1}}],[\"之后\",{\"1\":{\"198\":1}}],[\"之前的版本只有myisam支持\",{\"1\":{\"235\":1}}],[\"之前要记\",{\"1\":{\"199\":1}}],[\"之前\",{\"1\":{\"198\":1}}],[\"之类的设置等\",{\"1\":{\"119\":1}}],[\"之间的代码段称为资源的临界区\",{\"1\":{\"57\":1}}],[\"之间没有引用关系了\",{\"1\":{\"8\":1}}],[\"之称的协程\",{\"1\":{\"19\":1}}],[\"轻量级线程\",{\"1\":{\"19\":1}}],[\"也知道是因为没有执行close\",{\"1\":{\"502\":1}}],[\"也不能跟\",{\"1\":{\"435\":1}}],[\"也不会影响用户的使用\",{\"1\":{\"306\":1}}],[\"也不会造成栈内存空间的大量浪费\",{\"1\":{\"27\":1}}],[\"也没有虚方法\",{\"1\":{\"408\":1}}],[\"也即是\",{\"1\":{\"401\":1}}],[\"也即类型检测\",{\"1\":{\"48\":1}}],[\"也有缺点\",{\"1\":{\"300\":1}}],[\"也有可能是每个\",{\"1\":{\"190\":1}}],[\"也有可能有问题\",{\"1\":{\"183\":1}}],[\"也底层数据结构中最简单的一个\",{\"1\":{\"298\":1}}],[\"也被大量使用在redis内部\",{\"1\":{\"294\":1}}],[\"也被称为\",{\"1\":{\"137\":1}}],[\"也在活跃事务数组中故不可见\",{\"1\":{\"219\":1}}],[\"也在指针类型的实例t方法集中\",{\"1\":{\"46\":1}}],[\"也可能先执行\",{\"1\":{\"400\":1}}],[\"也可能存储了当前的key值以及整行的数据\",{\"1\":{\"150\":1}}],[\"也可以携带从节点的延迟时间和从节点的数量\",{\"1\":{\"319\":1}}],[\"也可以全局保存有效资源摘要\",{\"1\":{\"286\":1}}],[\"也可以单独存储在一个以\",{\"1\":{\"255\":1}}],[\"也可以认为是一种逻辑删除\",{\"1\":{\"255\":1}}],[\"也可以是字符串索引的最左\",{\"1\":{\"246\":2}}],[\"也可以使用\",{\"1\":{\"201\":1}}],[\"也能防止非法数据插入外键\",{\"1\":{\"173\":1}}],[\"也能分配g到它应该去的线程上执行\",{\"1\":{\"20\":1}}],[\"也叫组合索引\",{\"1\":{\"111\":1}}],[\"也会是\",{\"1\":{\"502\":3}}],[\"也会触发\",{\"1\":{\"355\":1}}],[\"也会被写入到磁盘上\",{\"1\":{\"250\":1}}],[\"也会存储数据\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"也会拷贝\",{\"1\":{\"43\":1}}],[\"也就解释了为什么读关闭的chan会一直返回false\",{\"1\":{\"484\":1}}],[\"也就说明我们的主从复制就已经配置完成了\",{\"1\":{\"309\":1}}],[\"也就相当于全表扫描了\",{\"1\":{\"68\":1}}],[\"也就是此时\",{\"1\":{\"502\":2}}],[\"也就是之前说的连接会复用\",{\"1\":{\"502\":1}}],[\"也就是在迭代写时会阻塞\",{\"1\":{\"413\":1}}],[\"也就是9\",{\"1\":{\"407\":1}}],[\"也就是m的类型\",{\"1\":{\"392\":1}}],[\"也就是m0\",{\"1\":{\"37\":1}}],[\"也就是字符串中的字符没有重复的\",{\"1\":{\"370\":1}}],[\"也就是每100ms触发一次定时任务\",{\"1\":{\"354\":1}}],[\"也就是slave\",{\"1\":{\"309\":1}}],[\"也就是服务冗余\",{\"1\":{\"307\":1}}],[\"也就是单机状态\",{\"1\":{\"306\":1}}],[\"也就是o\",{\"1\":{\"299\":1}}],[\"也就是把字段值倒序过来存储\",{\"1\":{\"253\":1}}],[\"也就是把索引和列的值存在一起\",{\"1\":{\"231\":1}}],[\"也就是多版本并发控制\",{\"1\":{\"223\":1,\"245\":1}}],[\"也就是主从延迟\",{\"1\":{\"118\":1}}],[\"也就是\",{\"1\":{\"112\":1,\"401\":1}}],[\"也就是我们接下来要说的b树\",{\"1\":{\"69\":1}}],[\"也就是我们说的一个磁盘块\",{\"1\":{\"69\":1,\"90\":1}}],[\"也就是高度太高了\",{\"1\":{\"68\":1}}],[\"也就是说写操作的行为需完全发生在读操作两步之间\",{\"1\":{\"288\":1}}],[\"也就是说这会给其他事务造成堵塞\",{\"1\":{\"212\":1}}],[\"也就是说页1已经在内存中了\",{\"1\":{\"72\":1}}],[\"也就是说上图中的b+树索引就是innodb中b+树索引真正的实现方式\",{\"1\":{\"70\":1}}],[\"也就是说\",{\"1\":{\"43\":2,\"252\":1}}],[\"也就是说两端都因为对方而使得自己当前处于阻塞状态\",{\"1\":{\"4\":1}}],[\"也就是拷贝完整的person数据结构\",{\"1\":{\"43\":1}}],[\"也就是拷贝一个副本\",{\"1\":{\"43\":1}}],[\"也是这里会对主进程产生阻塞\",{\"1\":{\"356\":1}}],[\"也是非常容易的\",{\"1\":{\"352\":1}}],[\"也是slave的主节点\",{\"1\":{\"305\":1}}],[\"也是立即缩容\",{\"1\":{\"299\":1}}],[\"也是无法保证操作顺序的\",{\"1\":{\"57\":1}}],[\"也是大家熟知的有\",{\"1\":{\"19\":1}}],[\"霍尔提出\",{\"1\":{\"17\":1}}],[\"而a的读锁又要求c调用完成\",{\"1\":{\"457\":1}}],[\"而其他三个协程会一直在后台等待写入\",{\"1\":{\"437\":1}}],[\"而给出的初始代码\",{\"1\":{\"424\":1}}],[\"而在a和c中同一个调用链中间需要让出读锁\",{\"1\":{\"457\":1}}],[\"而在调用runtime\",{\"1\":{\"405\":1}}],[\"而在具体实现上\",{\"1\":{\"292\":1}}],[\"而题目中打印\",{\"1\":{\"394\":1}}],[\"而自动触发的场景主要是有以下几点\",{\"1\":{\"355\":1}}],[\"而lfu中\",{\"1\":{\"347\":1}}],[\"而近似lru则用较小内存支出实现近似效果\",{\"1\":{\"346\":1}}],[\"而仅持有数据的指针\",{\"1\":{\"301\":1}}],[\"而写的最苟的数据结构\",{\"1\":{\"300\":1}}],[\"而若在遍历过程中\",{\"1\":{\"296\":1}}],[\"而对于变更数据区的api\",{\"1\":{\"294\":1}}],[\"而衔接\",{\"1\":{\"292\":1}}],[\"而无视缓存\",{\"1\":{\"288\":1}}],[\"而cache\",{\"1\":{\"288\":1}}],[\"而一个索引上不同的值的个数\",{\"1\":{\"252\":1}}],[\"而你只要记住\",{\"1\":{\"214\":1}}],[\"而我认为\",{\"1\":{\"213\":1}}],[\"而不是复合结构或复杂结构\",{\"1\":{\"301\":1}}],[\"而不是间接持有\",{\"1\":{\"296\":1}}],[\"而不是根据redolog\",{\"1\":{\"251\":1}}],[\"而不是一次\",{\"1\":{\"230\":1}}],[\"而不是count\",{\"1\":{\"189\":1}}],[\"而不是新建索引\",{\"1\":{\"144\":1}}],[\"而不是作为二进制浮点数\",{\"1\":{\"132\":1}}],[\"而不依赖于其他非主键\",{\"1\":{\"138\":1}}],[\"而不能是依赖于主键的一部分\",{\"1\":{\"138\":1}}],[\"而不提供查询\",{\"1\":{\"119\":1}}],[\"而2\",{\"1\":{\"132\":1}}],[\"而text用于存储大字符串\",{\"1\":{\"131\":1}}],[\"而\",{\"1\":{\"116\":1,\"215\":1,\"251\":1,\"297\":1,\"401\":1,\"438\":1}}],[\"而非聚簇索引的叶节点仍然是索引节点\",{\"1\":{\"92\":1}}],[\"而非聚集索引一个表可以存在多个\",{\"1\":{\"92\":1}}],[\"而偏偏是b+树呢\",{\"1\":{\"88\":1}}],[\"而myisam可被压缩\",{\"1\":{\"87\":1}}],[\"而myisam可以没有主键\",{\"1\":{\"87\":1}}],[\"而myisam支持表级锁\",{\"1\":{\"87\":1}}],[\"而myisam支持全文索引\",{\"1\":{\"87\":1}}],[\"而b+树的键值就是主键\",{\"1\":{\"71\":1}}],[\"而b树的叶子节点各自独立的\",{\"1\":{\"148\":1}}],[\"而b树因为数据分散在各个节点\",{\"1\":{\"70\":1}}],[\"而b树节点中不仅存储键值\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"而切片是对数组的抽象\",{\"1\":{\"63\":1}}],[\"而指针引用\",{\"1\":{\"44\":1}}],[\"而且每次都没有执行\",{\"1\":{\"503\":1}}],[\"而且缓存为空时\",{\"1\":{\"484\":1}}],[\"而且\",{\"1\":{\"393\":1}}],[\"而且能够帮助用户排除业务中潜在的风险点\",{\"1\":{\"342\":1}}],[\"而且它是悲观锁哦\",{\"1\":{\"105\":1}}],[\"而且它明确了要拷贝的对象是值类型的实例\",{\"1\":{\"43\":1}}],[\"而且此时所有的数据又都存在叶子节点\",{\"1\":{\"72\":1}}],[\"而且键值是按照顺序存放的\",{\"1\":{\"72\":1}}],[\"而且数据是按照顺序排列的\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"而且可以重写字段\",{\"1\":{\"42\":1}}],[\"而灰色的g表示处于运行队列之中正在等待被调度起来运行的goroutine\",{\"1\":{\"29\":1}}],[\"而schedule函数在一个调度循环中反复从m个goroutine中挑选出一个需要运行的goroutine并跳转到该goroutine去运行\",{\"1\":{\"28\":1}}],[\"而这n个系统线程又负责对这m个goroutine进行调度和运行\",{\"1\":{\"28\":1}}],[\"而goroutine我们不再称之为什么什么线程而是直接使用goroutine这个词\",{\"1\":{\"27\":1}}],[\"而相对的\",{\"1\":{\"27\":1}}],[\"而进入内核所消耗的性能代价比较高\",{\"1\":{\"27\":1}}],[\"而会去找其他比较闲的m执行其他的g\",{\"1\":{\"22\":1}}],[\"而会转身去找别的g执行\",{\"1\":{\"21\":1}}],[\"而今天\",{\"1\":{\"16\":1}}],[\"而并发模型的目的就是来告诉你不同执行实体之间是如何协作的\",{\"1\":{\"16\":1}}],[\"而是通过从小部分采样后的样本中淘汰局部lru键\",{\"1\":{\"346\":1}}],[\"而是通过value字段\",{\"1\":{\"295\":1}}],[\"而是通过void\",{\"1\":{\"295\":1}}],[\"而是一个压缩后的quicklistlzf实例\",{\"1\":{\"300\":1}}],[\"而是在操作完成之后进行判断\",{\"1\":{\"212\":1}}],[\"而是表示null\",{\"1\":{\"167\":1}}],[\"而是存储该列对应的主键\",{\"1\":{\"71\":1}}],[\"而是存储数据的文件地址\",{\"1\":{\"70\":1}}],[\"而是直接修改或访问共享数据\",{\"1\":{\"57\":1}}],[\"而是对不同的key进行操作\",{\"1\":{\"53\":1}}],[\"而是把它塞到全局队列里\",{\"1\":{\"21\":1}}],[\"而是处理完被选中的case后进入下一轮select\",{\"1\":{\"7\":1}}],[\"而是等到receiver准备接收channel数据了\",{\"1\":{\"3\":1}}],[\"那\",{\"1\":{\"502\":4}}],[\"那接收值将获得是一个该类型的零值\",{\"1\":{\"484\":1}}],[\"那接收值将获得一个该值类型的零值\",{\"1\":{\"484\":1}}],[\"那v的类型还是多对应接口的类型\",{\"1\":{\"392\":1}}],[\"那为什么不执行\",{\"1\":{\"502\":1}}],[\"那为什么不是b树而是b+树呢\",{\"0\":{\"91\":1}}],[\"那为什么会说复制缓冲积压区有可能会导致全量复制呢\",{\"1\":{\"322\":1}}],[\"那造成的后果就可想而知\",{\"1\":{\"306\":1}}],[\"那应该怎么办呢\",{\"1\":{\"265\":1}}],[\"那这个索引就被称之为覆盖索引\",{\"1\":{\"230\":1}}],[\"那边他的负载下来了\",{\"1\":{\"119\":1}}],[\"那我再来解释下吧\",{\"1\":{\"72\":1}}],[\"那我们每查找一次数据就需要从磁盘中读取一个节点\",{\"1\":{\"69\":1,\"90\":1}}],[\"那我们查找数据的时间也会大幅度降低\",{\"1\":{\"69\":1}}],[\"那我们还有其他的方式来实现吗\",{\"1\":{\"52\":1}}],[\"那什么是聚集索引呢\",{\"1\":{\"71\":1}}],[\"那如果我们要存储海量的数据呢\",{\"1\":{\"69\":1}}],[\"那如果两个goroutine正在通过channel做一些恩恩爱爱的事阻塞住了怎么办\",{\"1\":{\"21\":1}}],[\"那说明什么\",{\"1\":{\"69\":1}}],[\"那一次磁盘读取操作就会读取更多数据\",{\"1\":{\"69\":1}}],[\"那多个读锁就都会阻塞\",{\"1\":{\"58\":1}}],[\"那咋办呢\",{\"1\":{\"53\":1}}],[\"那他到底想从你这面获取什么呢\",{\"1\":{\"52\":1}}],[\"那面试官要使用原生map\",{\"1\":{\"52\":1}}],[\"那m就会因为太失望和p断开关系\",{\"1\":{\"21\":1}}],[\"那就会喧杂一个唯一的非空索引替代\",{\"1\":{\"230\":1}}],[\"那就是使用锁机制实现的线程安全的map\",{\"1\":{\"57\":1}}],[\"那就是通过channel机制来实现\",{\"1\":{\"52\":1}}],[\"那就是标准包里的sync\",{\"1\":{\"52\":1}}],[\"那就只能把g放回全局队列当中等待分配\",{\"1\":{\"22\":1}}],[\"那就不把g塞到处理器的私有队列里了\",{\"1\":{\"21\":1}}],[\"那就轮流往其他p里面放呗\",{\"1\":{\"21\":1}}],[\"那就需要先了解什么是并发模型\",{\"1\":{\"15\":1}}],[\"那么问题又来了\",{\"1\":{\"502\":1,\"503\":1}}],[\"那么问题来了\",{\"1\":{\"495\":1}}],[\"那么go有个很强的包叫\",{\"1\":{\"496\":1}}],[\"那么如果想要在底层转换二者\",{\"1\":{\"496\":1}}],[\"那么如何通过这三个字段来实现\",{\"1\":{\"215\":1}}],[\"那么每个键值需要有一个阻塞goroutine\",{\"1\":{\"421\":1}}],[\"那么必须用锁\",{\"1\":{\"421\":1}}],[\"那么v\",{\"1\":{\"392\":1}}],[\"那么将重复次数和重复的指令存起来递归调用即可\",{\"1\":{\"386\":1}}],[\"那么为什么会优先加载aof呢\",{\"1\":{\"357\":1}}],[\"那么为什么需要配置这么多条规则呢\",{\"1\":{\"352\":1}}],[\"那么这里为什么要先写入buf在同步到磁盘呢\",{\"1\":{\"356\":1}}],[\"那么这个通道的值是从哪里过来的呢\",{\"1\":{\"502\":1}}],[\"那么这个字节的值就是固定值254\",{\"1\":{\"301\":1}}],[\"那么这个顺序往往就是需要优先考虑采用的\",{\"1\":{\"246\":1}}],[\"那么这个gorutine将会被阻塞\",{\"1\":{\"57\":1}}],[\"那么这个p留在这里就浪费了\",{\"1\":{\"22\":1}}],[\"那么复制积压缓冲区就是存储的aof持久化的数据\",{\"1\":{\"322\":1}}],[\"那么主节点是如何知道从节点挂掉的数量和延迟时间呢\",{\"1\":{\"319\":1}}],[\"那么主从复制的作用就是针对为什么使用它来讲了\",{\"1\":{\"307\":1}}],[\"那么下来我们对每一步进程简单的介绍\",{\"1\":{\"318\":1}}],[\"那么quicklistnode\",{\"1\":{\"300\":1}}],[\"那么称quicklist就是在最苟的基础上\",{\"1\":{\"300\":1}}],[\"那么encoding占用两个字节\",{\"1\":{\"299\":1}}],[\"那么encoding占一字节\",{\"1\":{\"299\":1}}],[\"那么该字段的值固定为65535\",{\"1\":{\"299\":1}}],[\"那么该字段中存储的就是实际entry的值\",{\"1\":{\"299\":1}}],[\"那么头结点中需要新增几个指向该结点的指针\",{\"1\":{\"297\":1}}],[\"那么无论本次插入是否成功\",{\"1\":{\"296\":1}}],[\"那么很有可能会在后续发生多次变更\",{\"1\":{\"294\":1}}],[\"那么命令模式下是不是也可以有个入口文件呢\",{\"1\":{\"260\":1}}],[\"那么索引应该这样加\",{\"1\":{\"230\":1}}],[\"那么只会泄漏一个\",{\"1\":{\"503\":1}}],[\"那么只能用到范围查询之前的列\",{\"1\":{\"228\":1}}],[\"那么只有指针类型的实例t才算是实现了这个接口\",{\"1\":{\"46\":1}}],[\"那么此时返回的列表应该就是这样了\",{\"1\":{\"219\":1}}],[\"那么说明当前事务能看到这条记录\",{\"1\":{\"215\":1}}],[\"那么需要用\",{\"1\":{\"199\":1}}],[\"那么当进行select\",{\"1\":{\"152\":1}}],[\"那么查找到此终止\",{\"1\":{\"72\":1}}],[\"那么我们会对这三个过程进行谈论\",{\"1\":{\"314\":1}}],[\"那么我们在从节点执行一个命令为\",{\"1\":{\"309\":1}}],[\"那么我们在上图b树中查找的流程如下\",{\"1\":{\"69\":1}}],[\"那么我们就可以对页8中的键值依次进行遍历查找并匹配满足条件的数据\",{\"1\":{\"72\":1}}],[\"那么b+树使得范围查找\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"那么3层b+树可以存储1000×1000×1000=10亿个数据\",{\"1\":{\"70\":1}}],[\"那么就可能会导致这个结点在遍历过程中被遗漏\",{\"1\":{\"296\":1}}],[\"那么就是可见的\",{\"1\":{\"215\":1}}],[\"那么就需要使用覆盖索引\",{\"1\":{\"206\":1}}],[\"那么就不必再进行回表查询\",{\"1\":{\"152\":1}}],[\"那么就会存储更多的键值\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"那么就只会有一个m结构体对象\",{\"1\":{\"29\":1}}],[\"那么值类型的实例t和指针类型的实例t都算实现了这个接口\",{\"1\":{\"46\":1}}],[\"那么选择值类型的receiver还是指针类型的receiver\",{\"1\":{\"43\":1}}],[\"那么默认就创建四个线程\",{\"1\":{\"19\":1}}],[\"那么csp与go语言有什么关系呢\",{\"1\":{\"17\":1}}],[\"那么\",{\"1\":{\"15\":1,\"112\":1,\"469\":1,\"502\":2}}],[\"那么具体是怎么执行一个http请求的呢\",{\"1\":{\"12\":1}}],[\"处理业务逻辑有很大的帮助\",{\"1\":{\"262\":1}}],[\"处理\",{\"1\":{\"190\":1}}],[\"处理器的数量也是默认按照gomaxprocs来设置的\",{\"1\":{\"20\":1}}],[\"处理并相应\",{\"1\":{\"12\":1}}],[\"处理监听serve\",{\"1\":{\"12\":1}}],[\"mb\",{\"1\":{\"342\":1}}],[\"msgchan\",{\"1\":{\"397\":4}}],[\"msg\",{\"1\":{\"392\":2,\"397\":3}}],[\"msb\",{\"1\":{\"294\":1}}],[\"mstartfn\",{\"1\":{\"34\":1}}],[\"mliudong\",{\"1\":{\"234\":1}}],[\"mcc\",{\"1\":{\"212\":1}}],[\"move\",{\"1\":{\"296\":1,\"299\":2,\"386\":3}}],[\"more\",{\"1\":{\"296\":4,\"299\":2,\"300\":1}}],[\"morestackc\",{\"1\":{\"33\":1}}],[\"moxigandashu\",{\"1\":{\"235\":1}}],[\"mode\",{\"1\":{\"214\":1,\"237\":1,\"341\":1,\"342\":1}}],[\"mongodb的objectid\",{\"1\":{\"94\":1}}],[\"mti来储存表定义\",{\"1\":{\"87\":1}}],[\"mvcc需要关注这几个知识点\",{\"0\":{\"115\":1}}],[\"mvcc熟悉吗\",{\"0\":{\"114\":1}}],[\"mvcc\",{\"0\":{\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1},\"1\":{\"87\":1,\"114\":1,\"212\":1,\"213\":2,\"214\":2,\"215\":3,\"218\":1,\"219\":1,\"245\":1}}],[\"mystruct\",{\"1\":{\"481\":3}}],[\"mysql做持久化层\",{\"1\":{\"274\":1}}],[\"mysql在fsync操作时执行查询或更新语句很慢\",{\"0\":{\"254\":1}}],[\"mysql里是采用采样统计的方式来拼比基数的\",{\"1\":{\"252\":1}}],[\"mysql里记录货币用什么字段类型比较好\",{\"0\":{\"132\":1}}],[\"mysql为何有的时候选择的索引不是理想中的\",{\"0\":{\"252\":1}}],[\"mysql笔记之实践篇\",{\"0\":{\"249\":1}}],[\"mysql笔记之基础篇\",{\"0\":{\"241\":1}}],[\"mysql架构\",{\"0\":{\"242\":1}}],[\"mysql高级特性\",{\"0\":{\"233\":1}}],[\"mysql版本5\",{\"1\":{\"232\":1}}],[\"mysql修改表相关\",{\"0\":{\"225\":1}}],[\"mysql优化相关\",{\"0\":{\"224\":1}}],[\"mysql相关知识点浅析\",{\"0\":{\"222\":1}}],[\"mysql一条sql加锁分析\",{\"0\":{\"207\":1}}],[\"mysql如何获取当前日期\",{\"0\":{\"205\":1}}],[\"mysqldiff\",{\"1\":{\"203\":1}}],[\"mysql5\",{\"1\":{\"198\":1,\"235\":1,\"246\":1}}],[\"mysql服务端进行通信\",{\"1\":{\"187\":1}}],[\"mysql服务器通过权限表来控制用户对数据库的访问\",{\"1\":{\"139\":1}}],[\"mysql驱动程序主要帮助编程语言与\",{\"1\":{\"187\":1}}],[\"mysql驱动程序是什么\",{\"0\":{\"187\":1}}],[\"mysql自增主键用完了怎么办\",{\"0\":{\"184\":1}}],[\"mysql都有哪些锁呢\",{\"0\":{\"157\":1}}],[\"mysql有关权限的表有哪几个呢\",{\"0\":{\"139\":1}}],[\"mysql逻辑架构图主要分三层\",{\"1\":{\"136\":1}}],[\"mysql中text数据类型的最大长度\",{\"0\":{\"200\":1}}],[\"mysql中datetime和timestamp的区别\",{\"0\":{\"193\":1}}],[\"mysql中都有哪些触发器\",{\"0\":{\"171\":1}}],[\"mysql中有哪几种锁\",{\"0\":{\"133\":1}}],[\"mysql中int\",{\"0\":{\"176\":1}}],[\"mysql中innodb引擎的行锁是怎么实现的\",{\"0\":{\"158\":1}}],[\"mysql中in\",{\"0\":{\"112\":1}}],[\"mysql数据库cpu飙升的话\",{\"0\":{\"190\":1}}],[\"mysql数据库管理系统提供了视图特性\",{\"1\":{\"161\":1}}],[\"mysql数据库服务器性能分析的方法命令有哪些\",{\"0\":{\"130\":1}}],[\"mysql数据库经典面试题解析\",{\"0\":{\"76\":1}}],[\"mysql8\",{\"1\":{\"126\":1}}],[\"mysql的数据恢复相较于innodb较差\",{\"1\":{\"223\":1}}],[\"mysql的复制原理以及流程\",{\"0\":{\"192\":1}}],[\"mysql的binlog有几种录入格式\",{\"0\":{\"140\":1}}],[\"mysql的主从延迟\",{\"0\":{\"117\":1}}],[\"mysql的默认隔离级别是什么\",{\"0\":{\"95\":1}}],[\"mysql事务得四大特性以及实现原理\",{\"0\":{\"106\":1}}],[\"mysql默认的事务隔离级别是可重复读\",{\"1\":{\"95\":1}}],[\"mysql估计使用全表扫描要比使用索引快\",{\"1\":{\"78\":1}}],[\"mysql\",{\"0\":{\"77\":1,\"81\":1,\"135\":1,\"210\":1,\"512\":1},\"1\":{\"116\":2,\"127\":1,\"171\":1,\"181\":1,\"187\":1,\"191\":1,\"215\":1,\"218\":1,\"238\":3},\"2\":{\"74\":1,\"75\":1,\"208\":1,\"209\":1,\"220\":1,\"221\":1,\"239\":1,\"240\":1,\"247\":1,\"248\":1,\"257\":1,\"258\":1}}],[\"mymutex\",{\"1\":{\"449\":2}}],[\"mymap\",{\"1\":{\"52\":6,\"53\":6,\"58\":5}}],[\"myd\",{\"1\":{\"87\":1}}],[\"myisam里如果未指定条件就会取自身维护的总数\",{\"1\":{\"256\":1}}],[\"myisam通过key\",{\"1\":{\"231\":1}}],[\"myisam却不同\",{\"1\":{\"231\":1}}],[\"myisam和innodb的索引总结\",{\"0\":{\"231\":1}}],[\"myisam和innodb的区别\",{\"0\":{\"223\":1}}],[\"myisam采用索引和列的值分离的方式存储数据\",{\"1\":{\"223\":1}}],[\"myisam崩溃的概率比innodb要大很多\",{\"1\":{\"223\":1}}],[\"myisam支持延迟更新索引键\",{\"1\":{\"223\":1}}],[\"myisam支持全文索引\",{\"1\":{\"223\":1}}],[\"myisam的锁不支持行级锁\",{\"1\":{\"223\":1}}],[\"myisam用\",{\"1\":{\"87\":1}}],[\"myisam记录插入顺序是\",{\"1\":{\"87\":1}}],[\"myisam更快\",{\"1\":{\"87\":1}}],[\"myisam\",{\"1\":{\"87\":2,\"242\":1}}],[\"myisam不支持外键\",{\"1\":{\"87\":1}}],[\"myisam不支持事务\",{\"1\":{\"87\":1}}],[\"myisam中的b+树索引实现与innodb中的略有不同\",{\"1\":{\"70\":1}}],[\"mycat\",{\"0\":{\"116\":1},\"1\":{\"85\":1,\"109\":1,\"116\":2}}],[\"mfor\",{\"1\":{\"58\":1}}],[\"mfind方法通过互斥锁去读map数据\",{\"1\":{\"58\":1}}],[\"mfind\",{\"1\":{\"58\":3}}],[\"m定义map类型\",{\"1\":{\"53\":1}}],[\"m代表的是一个map类型\",{\"1\":{\"52\":1}}],[\"mp\",{\"1\":{\"37\":1,\"473\":1,\"490\":1}}],[\"m和p\",{\"1\":{\"37\":1}}],[\"m和schedt之间的关系图\",{\"1\":{\"29\":1}}],[\"m0的g0\",{\"1\":{\"37\":1}}],[\"m0\",{\"1\":{\"37\":1}}],[\"mnext\",{\"1\":{\"36\":1}}],[\"millisecond\",{\"1\":{\"447\":1,\"450\":2}}],[\"mic\",{\"1\":{\"401\":1}}],[\"minute\",{\"1\":{\"424\":3}}],[\"min\",{\"1\":{\"319\":2,\"353\":1}}],[\"misuse\",{\"1\":{\"296\":1}}],[\"mixed|row|statement\",{\"1\":{\"238\":1}}],[\"mixed\",{\"1\":{\"140\":1,\"238\":1}}],[\"mid=2247483761\",{\"1\":{\"37\":1}}],[\"midle\",{\"1\":{\"36\":1}}],[\"might\",{\"1\":{\"12\":1,\"502\":1}}],[\"menglu\",{\"1\":{\"436\":1,\"439\":4,\"441\":2}}],[\"message\",{\"1\":{\"262\":4}}],[\"mediumtext\",{\"1\":{\"200\":1}}],[\"merge则说明表的索引策略很糟糕\",{\"1\":{\"229\":1}}],[\"merge\",{\"1\":{\"195\":1}}],[\"memstats\",{\"1\":{\"450\":1}}],[\"mem\",{\"1\":{\"346\":3}}],[\"memcpy\",{\"1\":{\"299\":1}}],[\"memcached\",{\"1\":{\"120\":1,\"282\":1}}],[\"memmove\",{\"1\":{\"299\":2,\"346\":1}}],[\"memory\",{\"1\":{\"33\":1,\"242\":1,\"296\":1,\"299\":1,\"339\":4,\"341\":9,\"342\":7,\"346\":2}}],[\"means\",{\"1\":{\"32\":1,\"296\":1}}],[\"method\",{\"1\":{\"12\":3,\"266\":1}}],[\"m对应的线程从本地和全局goroutine队列中获取goroutine并运行之\",{\"1\":{\"29\":1}}],[\"m也会跟着进入系统调用状态\",{\"1\":{\"22\":1}}],[\"m并不稀罕这对go男女\",{\"1\":{\"21\":1}}],[\"m这边还要疯狂往外取\",{\"1\":{\"21\":1}}],[\"mu2\",{\"1\":{\"449\":5}}],[\"mu\",{\"1\":{\"445\":5,\"446\":7,\"449\":6,\"502\":2}}],[\"multiversion\",{\"1\":{\"212\":1}}],[\"multiple\",{\"1\":{\"12\":1}}],[\"must\",{\"1\":{\"57\":1}}],[\"mutual\",{\"1\":{\"57\":1}}],[\"mutex做写锁\",{\"1\":{\"412\":1}}],[\"mutex和rwmutex都不关联goroutine\",{\"1\":{\"59\":1}}],[\"mutex和sync\",{\"0\":{\"56\":1,\"59\":1}}],[\"mutex类型来说是允许的\",{\"1\":{\"57\":1}}],[\"mutex类型实现mutex\",{\"1\":{\"57\":1}}],[\"mutex保证了每个资源临界区的安全\",{\"1\":{\"57\":1}}],[\"mutex提供两个方法\",{\"1\":{\"57\":1}}],[\"mutex互斥锁\",{\"0\":{\"57\":1}}],[\"mutex\",{\"0\":{\"445\":1,\"449\":1},\"1\":{\"35\":1,\"36\":2,\"57\":6,\"58\":2,\"412\":1,\"424\":1,\"445\":1,\"448\":1,\"449\":1},\"2\":{\"61\":1}}],[\"muintptr\",{\"1\":{\"20\":1,\"34\":1,\"35\":1,\"36\":1}}],[\"m里面存了两个比较重要的东西\",{\"1\":{\"19\":1}}],[\"m结构体用来代表工作线程\",{\"1\":{\"34\":1}}],[\"m结构体对象除了记录着工作线程的诸如栈的起止位置\",{\"1\":{\"29\":1}}],[\"m结构体\",{\"0\":{\"34\":1},\"1\":{\"19\":1}}],[\"m就是对应操作系统的线程\",{\"1\":{\"19\":1}}],[\"m\",{\"1\":{\"19\":5,\"20\":1,\"28\":3,\"29\":1,\"33\":3,\"34\":5,\"35\":2,\"36\":8,\"37\":2,\"41\":10,\"52\":21,\"53\":21,\"57\":5,\"58\":19,\"246\":2,\"355\":1,\"392\":1,\"397\":2,\"399\":2,\"406\":2,\"407\":1,\"421\":5,\"448\":3,\"453\":4,\"490\":3,\"502\":1,\"507\":4,\"508\":1}}],[\"m的联系\",{\"1\":{\"18\":1}}],[\"mark\",{\"1\":{\"370\":8}}],[\"mark4\",{\"1\":{\"370\":2}}],[\"mark3\",{\"1\":{\"370\":2}}],[\"mark2\",{\"1\":{\"370\":2}}],[\"mark1\",{\"1\":{\"370\":2}}],[\"match字段\",{\"1\":{\"295\":1}}],[\"match\",{\"1\":{\"295\":1}}],[\"mac\",{\"1\":{\"294\":2}}],[\"machine\",{\"1\":{\"18\":2}}],[\"management\",{\"1\":{\"264\":1}}],[\"manual\",{\"1\":{\"262\":9,\"264\":3}}],[\"master会尝试使用部分复制\",{\"1\":{\"321\":1}}],[\"master会把自己的runid发送给slave\",{\"1\":{\"321\":1}}],[\"master会将接收到的数据变更命令发送给slave\",{\"1\":{\"317\":1}}],[\"master心跳\",{\"1\":{\"319\":1}}],[\"master服务器主要是写\",{\"1\":{\"307\":1}}],[\"master跟slave怎么连接呢\",{\"1\":{\"306\":1}}],[\"masteruser\",{\"1\":{\"238\":1}}],[\"master\",{\"1\":{\"117\":1,\"192\":1,\"238\":8,\"305\":2,\"309\":1,\"317\":1}}],[\"map属于引用类型\",{\"1\":{\"412\":1}}],[\"map我想大家心中已经有了答案\",{\"1\":{\"53\":1}}],[\"map类型\",{\"1\":{\"52\":1}}],[\"map同slice一样都是线程不安全的数据类型\",{\"1\":{\"41\":1}}],[\"map的value本身是不可寻址的\",{\"1\":{\"399\":1}}],[\"map的相关知识大家可以读这篇文章\",{\"1\":{\"53\":1}}],[\"map的值可以是任意对象\",{\"1\":{\"41\":1}}],[\"map的key可以是任意内置的数据类型\",{\"1\":{\"41\":1}}],[\"map是一个指针\",{\"1\":{\"41\":1}}],[\"map\",{\"0\":{\"41\":1,\"453\":1,\"506\":1},\"1\":{\"41\":7,\"44\":1,\"47\":1,\"52\":2,\"53\":2,\"58\":2,\"296\":1,\"391\":1,\"399\":1,\"406\":1,\"412\":3,\"421\":3,\"424\":4,\"441\":1,\"453\":1,\"464\":1,\"507\":2,\"508\":2},\"2\":{\"50\":1,\"55\":1,\"364\":1,\"368\":1,\"372\":1,\"376\":1,\"380\":1,\"384\":1,\"388\":1,\"403\":1,\"417\":1,\"420\":1,\"423\":1,\"426\":1,\"430\":1,\"433\":1,\"443\":1,\"467\":1,\"471\":1,\"475\":1,\"486\":1,\"492\":1,\"498\":1,\"505\":1,\"510\":1}}],[\"maxmemory\",{\"1\":{\"345\":1,\"346\":17}}],[\"maxmcount\",{\"1\":{\"36\":1}}],[\"maxlevel\",{\"1\":{\"297\":3}}],[\"max\",{\"1\":{\"237\":1,\"294\":2,\"296\":1,\"300\":3,\"319\":1}}],[\"maxvalue\",{\"1\":{\"234\":1}}],[\"maximum\",{\"1\":{\"36\":1}}],[\"may\",{\"1\":{\"32\":1,\"299\":1}}],[\"mainstarted\",{\"1\":{\"407\":1}}],[\"main1\",{\"1\":{\"391\":1}}],[\"main函数中我们利用for语句生成了9个goruntine\",{\"1\":{\"52\":1}}],[\"main\",{\"1\":{\"3\":2,\"4\":3,\"5\":1,\"6\":2,\"7\":1,\"8\":2,\"41\":1,\"44\":1,\"52\":1,\"53\":1,\"57\":1,\"58\":2,\"63\":2,\"386\":2,\"391\":1,\"393\":1,\"394\":1,\"395\":1,\"397\":3,\"398\":1,\"399\":1,\"400\":1,\"401\":3,\"405\":2,\"407\":1,\"408\":1,\"409\":1,\"410\":1,\"411\":1,\"414\":2,\"415\":2,\"418\":1,\"424\":4,\"428\":4,\"431\":4,\"435\":2,\"436\":2,\"437\":2,\"438\":2,\"439\":2,\"440\":2,\"441\":2,\"445\":5,\"446\":2,\"447\":2,\"449\":2,\"450\":2,\"451\":2,\"452\":2,\"453\":2,\"454\":2,\"480\":3,\"481\":2,\"490\":22,\"496\":2,\"500\":2,\"507\":2}}],[\"make创建\",{\"1\":{\"63\":1}}],[\"make\",{\"1\":{\"2\":1,\"3\":4,\"4\":3,\"5\":1,\"6\":2,\"7\":2,\"8\":2,\"12\":1,\"41\":2,\"47\":1,\"52\":1,\"53\":3,\"58\":1,\"63\":2,\"299\":1,\"366\":2,\"395\":1,\"397\":1,\"398\":1,\"400\":1,\"406\":1,\"409\":2,\"411\":2,\"413\":2,\"418\":1,\"424\":2,\"431\":3,\"437\":1,\"451\":1,\"454\":1,\"480\":1,\"481\":2}}],[\"x表示x坐标\",{\"1\":{\"386\":1}}],[\"x0\",{\"1\":{\"386\":2}}],[\"xianid就不是覆盖索引\",{\"1\":{\"230\":1}}],[\"xianid就是cityid的覆盖索引\",{\"1\":{\"230\":1}}],[\"xianid\",{\"1\":{\"230\":4}}],[\"xxxxxx是低六位\",{\"1\":{\"299\":1}}],[\"xxx\",{\"1\":{\"214\":8,\"255\":2}}],[\"x86\",{\"1\":{\"34\":1}}],[\"x\",{\"1\":{\"12\":1,\"48\":2,\"230\":1,\"296\":1,\"297\":1,\"386\":8,\"435\":4,\"438\":1}}],[\"即访问共享变量\",{\"1\":{\"412\":1}}],[\"即将str\",{\"1\":{\"374\":1}}],[\"即可\",{\"1\":{\"311\":1}}],[\"即可通过redo\",{\"1\":{\"107\":1,\"194\":1}}],[\"即为zipmap\",{\"1\":{\"301\":1}}],[\"即为1111\",{\"1\":{\"299\":1}}],[\"即为平衡树的意思\",{\"1\":{\"69\":1}}],[\"即0xfe\",{\"1\":{\"299\":1}}],[\"即0xff\",{\"1\":{\"299\":1}}],[\"即每一次插入操作都会调用zrealloc接口重新分配内存\",{\"1\":{\"298\":1}}],[\"即每次一个http请求都会建立一个连接\",{\"1\":{\"12\":1}}],[\"即所有的数值都需要以int64\",{\"1\":{\"298\":1}}],[\"即是现在要介绍的zskiplist结构\",{\"1\":{\"297\":1}}],[\"即是valuetype\",{\"1\":{\"292\":1}}],[\"即bucket数组\",{\"1\":{\"296\":1}}],[\"即dict\",{\"1\":{\"296\":1}}],[\"即在扩容时\",{\"1\":{\"296\":1}}],[\"即整个字典由一个bucket实现\",{\"1\":{\"296\":1}}],[\"即便是在操作数据区的时候导致数据区占用内存减少时\",{\"1\":{\"294\":1}}],[\"即默认情况下\",{\"1\":{\"294\":1}}],[\"即图中\",{\"1\":{\"294\":1}}],[\"即自定义异常来捕获\",{\"1\":{\"262\":1}}],[\"即基于行和基于语句一起使用\",{\"1\":{\"238\":1}}],[\"即不能为空值\",{\"1\":{\"172\":1}}],[\"即没有冗余元素的超键\",{\"1\":{\"172\":1}}],[\"即某个字段值为null时\",{\"1\":{\"167\":1}}],[\"即适合选择exists\",{\"1\":{\"112\":1}}],[\"即mysql优化原则\",{\"1\":{\"112\":1}}],[\"即一个事务不影响其它事务运行效果\",{\"1\":{\"106\":1}}],[\"即使已经执行很长时间\",{\"1\":{\"401\":1}}],[\"即使有一个服务器宕机了\",{\"1\":{\"306\":1}}],[\"即使在迭代过程中对字典有插入操作\",{\"1\":{\"296\":1}}],[\"即使在左表中没有匹配的记录\",{\"1\":{\"135\":1}}],[\"即使在右表中没有匹配的记录\",{\"1\":{\"135\":1}}],[\"即使你不创建主键\",{\"1\":{\"71\":1}}],[\"即使不够用\",{\"1\":{\"27\":1}}],[\"即id=12\",{\"1\":{\"67\":1}}],[\"即底层数组的长度\",{\"1\":{\"63\":1}}],[\"即减少一次读锁的引用计数\",{\"1\":{\"58\":1}}],[\"即写锁权限高于读锁\",{\"1\":{\"58\":1}}],[\"即\",{\"1\":{\"46\":1,\"292\":1,\"297\":1,\"299\":2}}],[\"即元素个数\",{\"1\":{\"41\":1}}],[\"即有多个少key\",{\"1\":{\"41\":1}}],[\"即交由gin来处理请求\",{\"1\":{\"12\":1}}],[\"即先执行读取的\",{\"1\":{\"1\":1}}],[\"lf\",{\"1\":{\"386\":2}}],[\"lfu提供明确参数来指定计数更新频率\",{\"1\":{\"347\":1}}],[\"lfu使用morris\",{\"1\":{\"347\":1}}],[\"lfu\",{\"1\":{\"347\":5}}],[\"l左转\",{\"1\":{\"386\":1}}],[\"lzf\",{\"1\":{\"300\":2}}],[\"lzf==2\",{\"1\":{\"300\":1}}],[\"lzf=2\",{\"1\":{\"300\":1}}],[\"lgn\",{\"1\":{\"298\":1}}],[\"lpush+brpop=message\",{\"1\":{\"276\":1}}],[\"lpush+ltrim=capped\",{\"1\":{\"276\":1}}],[\"lpush+lpop=stack\",{\"1\":{\"276\":1}}],[\"lpush+rpop=queue\",{\"1\":{\"276\":1}}],[\"lucknum=33\",{\"1\":{\"72\":1}}],[\"luckynum\",{\"1\":{\"72\":1}}],[\"lsb\",{\"1\":{\"294\":5}}],[\"ls\",{\"1\":{\"72\":1}}],[\"l代表锁\",{\"1\":{\"52\":1}}],[\"lag\",{\"1\":{\"319\":1}}],[\"lag为0或者为1就是正常状态\",{\"1\":{\"319\":1}}],[\"layout\",{\"1\":{\"294\":1}}],[\"latencyremovenestedevent\",{\"1\":{\"346\":1}}],[\"latencyaddsampleifneeded\",{\"1\":{\"346\":1}}],[\"latencyendmonitor\",{\"1\":{\"346\":1}}],[\"latencystartmonitor\",{\"1\":{\"346\":1}}],[\"latency\",{\"1\":{\"35\":1,\"346\":5}}],[\"largest\",{\"1\":{\"339\":1,\"341\":1,\"342\":1}}],[\"large\",{\"1\":{\"35\":1}}],[\"lastindex\",{\"1\":{\"370\":1}}],[\"lastindex函数判断\",{\"1\":{\"370\":1}}],[\"lastpoll\",{\"1\":{\"36\":1}}],[\"last\",{\"1\":{\"35\":1,\"262\":2}}],[\"lambda架构\",{\"1\":{\"16\":1}}],[\"lru符合预期\",{\"1\":{\"346\":1}}],[\"lru\",{\"1\":{\"345\":4,\"346\":8,\"347\":1}}],[\"lr\",{\"1\":{\"32\":1}}],[\"literal\",{\"1\":{\"490\":1}}],[\"li\",{\"1\":{\"406\":1}}],[\"likely\",{\"1\":{\"296\":1}}],[\"like\",{\"1\":{\"246\":1}}],[\"like后面\",{\"1\":{\"134\":1}}],[\"like通配符可能导致索引失效\",{\"1\":{\"78\":1}}],[\"list作为最传统的双链表\",{\"1\":{\"300\":1}}],[\"list在redis除了作为一些value\",{\"1\":{\"295\":1}}],[\"listiter\",{\"1\":{\"295\":2}}],[\"listnode\",{\"1\":{\"295\":7}}],[\"list分区\",{\"1\":{\"234\":1}}],[\"list\",{\"0\":{\"295\":1},\"1\":{\"215\":2,\"218\":3,\"219\":5,\"260\":2,\"273\":1,\"276\":2,\"292\":2,\"295\":4,\"341\":2,\"342\":1,\"502\":1}}],[\"list<>\",{\"1\":{\"112\":2}}],[\"listener\",{\"1\":{\"12\":1}}],[\"listen\",{\"1\":{\"12\":1}}],[\"listenandserve\",{\"1\":{\"12\":3}}],[\"limit\",{\"0\":{\"93\":1},\"1\":{\"93\":3,\"206\":2,\"215\":4,\"218\":10,\"219\":18,\"341\":1}}],[\"line\",{\"1\":{\"262\":3,\"490\":1}}],[\"link\",{\"1\":{\"35\":2}}],[\"linux平台thread的值就是操作系统线程id\",{\"1\":{\"34\":1}}],[\"libexec\",{\"1\":{\"502\":4}}],[\"lib\",{\"1\":{\"238\":2}}],[\"liblink\",{\"1\":{\"33\":3}}],[\"libmach\",{\"1\":{\"32\":1}}],[\"live\",{\"1\":{\"32\":1,\"415\":2}}],[\"leaking\",{\"1\":{\"490\":1}}],[\"least\",{\"1\":{\"347\":1}}],[\"leave\",{\"1\":{\"300\":1}}],[\"level<zskiplist\",{\"1\":{\"297\":1}}],[\"level\",{\"1\":{\"297\":21}}],[\"less\",{\"1\":{\"234\":3,\"345\":1}}],[\"lepus\",{\"1\":{\"202\":1}}],[\"left\",{\"1\":{\"35\":1,\"135\":1,\"229\":1,\"294\":1,\"346\":2,\"386\":3}}],[\"len代表链表中的结点\",{\"1\":{\"300\":1}}],[\"len+addlen\",{\"1\":{\"294\":1}}],[\"len分别以uint8\",{\"1\":{\"294\":1}}],[\"length代表其中存储的整数的个数\",{\"1\":{\"298\":1}}],[\"length\",{\"1\":{\"112\":4,\"294\":1,\"297\":1,\"298\":1,\"299\":9,\"300\":3}}],[\"len\",{\"1\":{\"12\":2,\"37\":1,\"41\":2,\"63\":1,\"195\":1,\"294\":5,\"295\":1,\"299\":2,\"300\":2,\"301\":3,\"339\":1,\"341\":1,\"342\":1,\"370\":2,\"374\":3,\"378\":2,\"382\":1,\"453\":1,\"464\":1,\"496\":2}}],[\"letter负责通知打印字母的goroutine来打印字母\",{\"1\":{\"366\":1}}],[\"letter\",{\"1\":{\"366\":3}}],[\"let\",{\"1\":{\"12\":1}}],[\"looping\",{\"1\":{\"502\":1}}],[\"looking\",{\"1\":{\"34\":1}}],[\"loadorstore\",{\"1\":{\"453\":1}}],[\"load\",{\"1\":{\"353\":2,\"507\":1}}],[\"lost\",{\"1\":{\"317\":1}}],[\"low\",{\"1\":{\"215\":2,\"218\":3,\"219\":7}}],[\"lock保证了在一个时间点只有其中一个goruntine可以访问其中一个临界区\",{\"1\":{\"57\":1}}],[\"locked\",{\"1\":{\"35\":1,\"36\":1}}],[\"lock\",{\"1\":{\"35\":2,\"36\":2,\"52\":2,\"57\":4,\"58\":4,\"214\":1,\"412\":1,\"421\":1,\"424\":7,\"445\":2,\"446\":1,\"448\":1,\"449\":2,\"483\":1,\"484\":3,\"502\":1}}],[\"local\",{\"1\":{\"29\":1,\"34\":1,\"308\":2}}],[\"localaddr\",{\"1\":{\"12\":1}}],[\"localaddrcontextkey\",{\"1\":{\"12\":1}}],[\"lo+stackguard\",{\"1\":{\"33\":2}}],[\"lo\",{\"1\":{\"19\":2,\"31\":2,\"33\":1}}],[\"longer\",{\"1\":{\"502\":1}}],[\"longval\",{\"1\":{\"300\":1}}],[\"longtext\",{\"1\":{\"200\":1}}],[\"long\",{\"1\":{\"12\":1,\"237\":1,\"295\":1,\"296\":14,\"297\":1,\"299\":2,\"300\":5,\"346\":4}}],[\"log`\",{\"1\":{\"234\":1}}],[\"log和可见性算法来实现的版本并发控制\",{\"1\":{\"219\":1}}],[\"log其实存放的是逻辑日志\",{\"1\":{\"218\":1}}],[\"log无法删除\",{\"1\":{\"215\":1}}],[\"log重做日志文件中再执行一次这些sql语句\",{\"1\":{\"192\":1}}],[\"log文件的sql语句复制过来\",{\"1\":{\"192\":1}}],[\"log二进制文件\",{\"1\":{\"192\":1}}],[\"log里面读取内容\",{\"1\":{\"117\":1,\"192\":1}}],[\"log把数据恢复\",{\"1\":{\"107\":1,\"194\":1}}],[\"log日志持久化了\",{\"1\":{\"107\":1,\"194\":1}}],[\"log日志返回事务开始的状态\",{\"1\":{\"107\":1,\"194\":1}}],[\"log来实现\",{\"1\":{\"107\":1,\"194\":1}}],[\"log来实现的\",{\"1\":{\"107\":1,\"194\":1}}],[\"logf\",{\"1\":{\"12\":1}}],[\"log\",{\"0\":{\"251\":1},\"1\":{\"6\":1,\"8\":4,\"52\":1,\"53\":3,\"57\":2,\"58\":6,\"115\":1,\"117\":2,\"119\":2,\"192\":2,\"198\":3,\"199\":1,\"215\":4,\"234\":1,\"237\":2,\"238\":6,\"244\":3,\"251\":1,\"298\":1,\"347\":1}}],[\"l\",{\"1\":{\"12\":2,\"41\":1,\"52\":7,\"374\":5,\"386\":2}}],[\"ln\",{\"1\":{\"12\":2}}],[\"初始化的地方在编译时是可以知道的\",{\"1\":{\"489\":1}}],[\"初始化的\",{\"1\":{\"413\":1}}],[\"初始化dictht下的table\",{\"1\":{\"296\":1}}],[\"初始化时的bucket数组长度为4\",{\"1\":{\"296\":1}}],[\"初始化一个实例\",{\"1\":{\"42\":1}}],[\"初始化一个map\",{\"1\":{\"41\":1}}],[\"初始化\",{\"1\":{\"41\":2}}],[\"初始化全局中间件\",{\"1\":{\"12\":1}}],[\"初始化gin\",{\"1\":{\"12\":1}}],[\"ua\",{\"1\":{\"412\":6}}],[\"u64\",{\"1\":{\"296\":1}}],[\"uid\",{\"1\":{\"268\":1}}],[\"uint16\",{\"1\":{\"294\":4}}],[\"uint8\",{\"1\":{\"294\":2,\"401\":1}}],[\"uint64表示整个sds\",{\"1\":{\"294\":1}}],[\"uint64表示用户数据的长度\",{\"1\":{\"294\":1}}],[\"uint64\",{\"1\":{\"36\":2,\"294\":2,\"296\":4,\"370\":4}}],[\"uintreg\",{\"1\":{\"19\":1,\"32\":1}}],[\"uint32\",{\"1\":{\"19\":1,\"20\":2,\"35\":5,\"36\":3,\"57\":1,\"58\":2,\"294\":4,\"298\":2,\"448\":1}}],[\"uintptr\",{\"1\":{\"19\":7,\"31\":2,\"32\":4,\"33\":2,\"34\":2,\"63\":1,\"483\":1,\"496\":2}}],[\"uri\",{\"1\":{\"266\":1}}],[\"url\",{\"1\":{\"266\":1}}],[\"ucenter\",{\"1\":{\"265\":1}}],[\"upstream\",{\"1\":{\"266\":5}}],[\"up\",{\"1\":{\"215\":2,\"218\":7,\"219\":11}}],[\"update除了有查询的作用外\",{\"1\":{\"105\":1}}],[\"update有什么含义\",{\"0\":{\"104\":1}}],[\"update\",{\"0\":{\"105\":1},\"1\":{\"98\":2,\"117\":1,\"158\":2,\"171\":2,\"192\":1,\"214\":2,\"215\":2,\"297\":2,\"299\":4}}],[\"updated\",{\"1\":{\"36\":1}}],[\"usr\",{\"1\":{\"308\":2}}],[\"usage\",{\"1\":{\"300\":2}}],[\"using\",{\"1\":{\"145\":1,\"299\":1}}],[\"useful\",{\"1\":{\"296\":1}}],[\"used++\",{\"1\":{\"296\":1}}],[\"used\",{\"1\":{\"294\":5,\"296\":10,\"300\":2,\"345\":1,\"346\":1,\"347\":1}}],[\"userages\",{\"1\":{\"412\":3}}],[\"user=\",{\"1\":{\"238\":1}}],[\"user权限表\",{\"1\":{\"139\":1}}],[\"users\",{\"1\":{\"63\":3}}],[\"user\",{\"1\":{\"42\":6,\"45\":2,\"63\":1,\"72\":2,\"98\":1,\"262\":5,\"300\":1}}],[\"use\",{\"1\":{\"12\":1,\"57\":1,\"297\":1,\"299\":2,\"300\":2,\"502\":1}}],[\"uuid\",{\"1\":{\"94\":1,\"183\":1}}],[\"u\",{\"1\":{\"42\":3,\"43\":4,\"45\":4}}],[\"unmarshal\",{\"1\":{\"393\":1}}],[\"uncompressed\",{\"1\":{\"300\":2}}],[\"uncommitted\",{\"1\":{\"95\":1}}],[\"untouched\",{\"1\":{\"299\":1}}],[\"until\",{\"1\":{\"12\":1}}],[\"unordered\",{\"1\":{\"296\":1}}],[\"unused\",{\"1\":{\"294\":4}}],[\"unusual\",{\"1\":{\"32\":1}}],[\"unsigned\",{\"1\":{\"294\":5,\"295\":1,\"296\":8,\"297\":2,\"299\":12,\"300\":16}}],[\"unsafe\",{\"1\":{\"19\":1,\"32\":1,\"296\":1,\"407\":2,\"483\":1,\"484\":1,\"496\":7}}],[\"undefined\",{\"1\":{\"262\":1}}],[\"undolog\",{\"1\":{\"215\":2,\"245\":1}}],[\"undo把该事务的修改回滚到事务开始之前\",{\"1\":{\"199\":1}}],[\"undo\",{\"1\":{\"107\":1,\"115\":1,\"194\":1,\"198\":4,\"199\":5,\"215\":3,\"218\":1}}],[\"unicode\",{\"1\":{\"382\":1,\"386\":2}}],[\"uninitialized\",{\"1\":{\"299\":1}}],[\"union的效率高于\",{\"1\":{\"178\":1}}],[\"union\",{\"1\":{\"178\":3,\"296\":1}}],[\"union与union\",{\"0\":{\"178\":1}}],[\"unique\",{\"1\":{\"173\":2,\"195\":1,\"234\":1}}],[\"unit\",{\"1\":{\"35\":1}}],[\"unlocked\",{\"1\":{\"57\":1}}],[\"unlock\",{\"1\":{\"52\":2,\"57\":3,\"58\":3,\"412\":1,\"421\":1,\"424\":2,\"445\":2,\"446\":1,\"448\":1,\"449\":2,\"483\":1,\"484\":1,\"502\":1}}],[\"unexpected\",{\"1\":{\"48\":1}}],[\"unescape\",{\"1\":{\"12\":1}}],[\"unparking\",{\"1\":{\"36\":1}}],[\"unbuffered\",{\"1\":{\"3\":3}}],[\"plainerror\",{\"1\":{\"483\":1}}],[\"py\",{\"1\":{\"338\":1}}],[\"pypi\",{\"0\":{\"337\":1}}],[\"python\",{\"1\":{\"335\":1,\"338\":1}}],[\"p+rawlen\",{\"1\":{\"299\":4}}],[\"p+reqlen\",{\"1\":{\"299\":5}}],[\"php默认会把session存储在服务器的临时目录中\",{\"1\":{\"264\":1}}],[\"phpsessid=q0fm8up72q58ne1b6khf37dlos\",{\"1\":{\"264\":1}}],[\"php官方提供了\",{\"1\":{\"262\":1}}],[\"php提供了很简单两个全局变量来操作cookie和session\",{\"1\":{\"264\":1}}],[\"php提供了\",{\"1\":{\"262\":1}}],[\"php的异常处理基类是\",{\"1\":{\"262\":1}}],[\"php的错误和异常处理\",{\"0\":{\"261\":1}}],[\"php的命令模式也就是cli模式\",{\"1\":{\"260\":1}}],[\"php的命令模式实现\",{\"0\":{\"260\":1}}],[\"php\",{\"0\":{\"513\":1},\"1\":{\"260\":4,\"262\":24,\"264\":7,\"265\":1},\"2\":{\"271\":1}}],[\"php面试总结\",{\"0\":{\"259\":1},\"2\":{\"271\":1}}],[\"p0\",{\"1\":{\"234\":1}}],[\"psync\",{\"1\":{\"318\":2}}],[\"ps\",{\"1\":{\"215\":1,\"345\":1}}],[\"pssh\",{\"1\":{\"201\":1}}],[\"ptail\",{\"1\":{\"299\":3}}],[\"ptrsize\",{\"1\":{\"407\":1}}],[\"ptr\",{\"1\":{\"215\":4,\"217\":2,\"295\":3,\"407\":2}}],[\"pt\",{\"1\":{\"203\":1}}],[\"peeking\",{\"1\":{\"502\":1}}],[\"peo\",{\"1\":{\"414\":2}}],[\"people类型\",{\"1\":{\"414\":1}}],[\"people\",{\"1\":{\"393\":3,\"394\":3,\"399\":2,\"408\":5,\"414\":2,\"415\":3}}],[\"persistent\",{\"1\":{\"502\":1}}],[\"persistconn\",{\"1\":{\"502\":3}}],[\"person实例实现了user接口\",{\"1\":{\"45\":1}}],[\"person\",{\"1\":{\"43\":6,\"45\":4}}],[\"percentage\",{\"1\":{\"353\":1}}],[\"period决定的\",{\"1\":{\"319\":1}}],[\"per\",{\"1\":{\"255\":1,\"326\":1}}],[\"pending\",{\"1\":{\"58\":1}}],[\"p2\",{\"1\":{\"43\":1}}],[\"p1\",{\"1\":{\"43\":1,\"234\":1}}],[\"p的最大值\",{\"1\":{\"37\":1}}],[\"pick\",{\"1\":{\"346\":1}}],[\"pip\",{\"1\":{\"337\":1}}],[\"pipelining\",{\"1\":{\"12\":2}}],[\"ping\",{\"1\":{\"319\":2}}],[\"pidle\",{\"1\":{\"35\":1,\"36\":1}}],[\"p结构体用于保存工作线程执行go代码时所必需的资源\",{\"1\":{\"35\":1}}],[\"p结构体\",{\"0\":{\"35\":1}}],[\"p不会傻傻的等待g和m系统调用完成\",{\"1\":{\"22\":1}}],[\"public\",{\"1\":{\"262\":4,\"264\":8}}],[\"puintptr\",{\"1\":{\"19\":3,\"34\":3,\"35\":1,\"36\":1}}],[\"putorcloseidleconn\",{\"1\":{\"502\":1}}],[\"put\",{\"1\":{\"12\":2,\"450\":1}}],[\"p\",{\"1\":{\"19\":2,\"20\":1,\"29\":2,\"34\":3,\"35\":1,\"36\":1,\"37\":1,\"43\":4,\"45\":6,\"234\":1,\"235\":1,\"238\":1,\"265\":1,\"297\":6,\"299\":26,\"308\":1,\"393\":3,\"394\":6,\"397\":10,\"407\":5,\"408\":3,\"502\":2}}],[\"pconn\",{\"1\":{\"502\":8}}],[\"pc\",{\"1\":{\"19\":1,\"32\":2,\"407\":2,\"502\":11}}],[\"policy\",{\"1\":{\"345\":1,\"346\":11}}],[\"policy启动淘汰策略\",{\"1\":{\"345\":1}}],[\"points\",{\"1\":{\"300\":1}}],[\"pointers\",{\"1\":{\"296\":1}}],[\"pointer\",{\"1\":{\"19\":1,\"32\":2,\"33\":2,\"299\":1,\"407\":2,\"483\":1,\"484\":1,\"496\":5}}],[\"port\",{\"1\":{\"264\":1,\"311\":1}}],[\"position\",{\"1\":{\"299\":1,\"346\":1}}],[\"pos设置为0表示从日志开头读起\",{\"1\":{\"238\":1}}],[\"pos=0\",{\"1\":{\"238\":1}}],[\"possible\",{\"1\":{\"195\":1}}],[\"pos位置开始执行读取到的更新事件\",{\"1\":{\"117\":1,\"192\":1}}],[\"post\",{\"1\":{\"23\":1,\"207\":1,\"219\":1,\"329\":1,\"358\":1,\"469\":1,\"503\":2}}],[\"potentially\",{\"1\":{\"35\":1}}],[\"pool+k+1\",{\"1\":{\"346\":1}}],[\"pool+k\",{\"1\":{\"346\":1}}],[\"pool\",{\"0\":{\"450\":1},\"1\":{\"12\":4,\"237\":1,\"251\":1,\"346\":13,\"450\":4,\"502\":1}}],[\"primary\",{\"1\":{\"145\":1,\"173\":1,\"234\":1}}],[\"privdata字段\",{\"1\":{\"296\":1}}],[\"privdata是用于存储用户自定义数据\",{\"1\":{\"296\":1}}],[\"privdata\",{\"1\":{\"296\":6}}],[\"private\",{\"1\":{\"264\":2}}],[\"priv权限表\",{\"1\":{\"139\":2}}],[\"priv和host\",{\"1\":{\"139\":1}}],[\"priv\",{\"1\":{\"139\":1}}],[\"print\",{\"1\":{\"366\":4,\"394\":2,\"454\":1}}],[\"printf\",{\"1\":{\"6\":1,\"48\":5,\"450\":1,\"451\":1,\"481\":9,\"496\":1,\"500\":1}}],[\"println\",{\"1\":{\"3\":5,\"4\":5,\"5\":2,\"6\":1,\"7\":4,\"8\":4,\"44\":2,\"45\":1,\"47\":1,\"48\":2,\"52\":1,\"53\":3,\"57\":2,\"58\":5,\"63\":8,\"386\":1,\"393\":2,\"395\":3,\"397\":2,\"398\":2,\"400\":1,\"401\":2,\"405\":3,\"407\":2,\"408\":3,\"409\":1,\"410\":1,\"411\":1,\"414\":1,\"415\":2,\"418\":1,\"424\":2,\"428\":1,\"431\":4,\"435\":1,\"436\":4,\"437\":1,\"438\":2,\"439\":2,\"440\":2,\"441\":1,\"445\":1,\"446\":1,\"449\":1,\"452\":1,\"453\":1,\"481\":3,\"490\":3,\"507\":1,\"508\":1}}],[\"prevrawlensize\",{\"1\":{\"299\":5}}],[\"prevrawlen\",{\"1\":{\"299\":1}}],[\"previous\",{\"1\":{\"299\":1,\"300\":1}}],[\"prevlen\",{\"1\":{\"299\":11}}],[\"prevlensize\",{\"1\":{\"299\":2}}],[\"prevlen字段扩容\",{\"1\":{\"299\":1}}],[\"prevlen需要从一字节扩容至五字节\",{\"1\":{\"299\":1}}],[\"prevlen即是\",{\"1\":{\"299\":1}}],[\"prev\",{\"1\":{\"295\":1,\"300\":1}}],[\"prealloc时\",{\"1\":{\"294\":1}}],[\"prealloc\",{\"1\":{\"294\":3}}],[\"prepare\",{\"1\":{\"244\":1,\"296\":1}}],[\"precision\",{\"1\":{\"132\":1}}],[\"preemption\",{\"1\":{\"33\":2}}],[\"preempt\",{\"1\":{\"19\":1,\"33\":1,\"401\":2}}],[\"prunning\",{\"1\":{\"35\":1}}],[\"province\",{\"1\":{\"507\":3,\"508\":2}}],[\"project\",{\"1\":{\"397\":6}}],[\"propagateexpire\",{\"1\":{\"346\":1}}],[\"progress\",{\"1\":{\"296\":2}}],[\"protected\",{\"1\":{\"262\":2}}],[\"protoatleast\",{\"1\":{\"12\":1}}],[\"profiles\",{\"1\":{\"130\":1}}],[\"proxy\",{\"1\":{\"116\":1,\"191\":1}}],[\"prologue\",{\"1\":{\"33\":2}}],[\"proc\",{\"1\":{\"36\":1,\"428\":3}}],[\"proccessor负责machine与goroutine的连接\",{\"1\":{\"20\":1}}],[\"processrequest\",{\"1\":{\"450\":3}}],[\"processlist\",{\"1\":{\"190\":1,\"224\":1}}],[\"processor\",{\"0\":{\"20\":1},\"1\":{\"18\":2}}],[\"processes\",{\"1\":{\"17\":1}}],[\"process\",{\"1\":{\"12\":1}}],[\"pase\",{\"1\":{\"406\":1}}],[\"password=\",{\"1\":{\"238\":1}}],[\"password\",{\"1\":{\"215\":4,\"238\":1}}],[\"pay\",{\"1\":{\"339\":1}}],[\"payload\",{\"1\":{\"299\":1}}],[\"pads\",{\"1\":{\"300\":1}}],[\"packed\",{\"1\":{\"294\":5}}],[\"package\",{\"1\":{\"58\":1,\"386\":1,\"401\":1,\"405\":1,\"414\":1,\"415\":1,\"424\":2,\"428\":2,\"431\":2,\"435\":1,\"436\":1,\"437\":1,\"438\":1,\"439\":1,\"440\":1,\"441\":1,\"445\":1,\"446\":1,\"447\":1,\"448\":1,\"449\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"454\":1,\"481\":1,\"490\":1,\"496\":1,\"500\":1,\"507\":1}}],[\"paulma\",{\"1\":{\"235\":1}}],[\"pall\",{\"1\":{\"234\":1}}],[\"pattern方案\",{\"1\":{\"288\":1}}],[\"pattern\",{\"1\":{\"35\":1,\"288\":4}}],[\"path\",{\"1\":{\"12\":1}}],[\"parse\",{\"1\":{\"262\":3}}],[\"partition\",{\"1\":{\"234\":4}}],[\"partitions\",{\"1\":{\"195\":1,\"234\":1}}],[\"parking\",{\"1\":{\"36\":1}}],[\"park\",{\"1\":{\"34\":1}}],[\"parameters\",{\"1\":{\"33\":1}}],[\"param\",{\"1\":{\"19\":1,\"391\":5,\"490\":1}}],[\"params\",{\"1\":{\"12\":3}}],[\"parallel\",{\"1\":{\"12\":1}}],[\"panic\",{\"0\":{\"483\":1},\"1\":{\"12\":3,\"19\":2,\"395\":1,\"397\":1,\"405\":2,\"409\":1,\"428\":4,\"445\":1,\"446\":1,\"447\":1,\"449\":1,\"451\":1,\"452\":1,\"453\":1,\"454\":1,\"478\":1,\"480\":1,\"483\":2}}],[\"接着上面的代码堆栈往下翻\",{\"1\":{\"502\":1}}],[\"接着我们使用go内置的append函数对ints进行追加\",{\"1\":{\"63\":1}}],[\"接着我们使用go内置的append函数对int1进行追加\",{\"1\":{\"63\":1}}],[\"接着我们通过下标截取的方式声明了一个int类型的切片\",{\"1\":{\"63\":1}}],[\"接下来尝试下怎么通过\",{\"1\":{\"490\":1}}],[\"接下来所有接收的值都会非阻塞直接成功\",{\"1\":{\"478\":1}}],[\"接下来想怎么分析就怎么分析了\",{\"1\":{\"341\":1}}],[\"接下来我们把当前节点>的右子节点作为当前节点\",{\"1\":{\"67\":1}}],[\"接下来我们来看go语言对csp并发模型的实现\",{\"1\":{\"17\":1}}],[\"接口不为\",{\"1\":{\"415\":1}}],[\"接口返回的sds可以直接传入libc中的字符串输出函数中进行操作\",{\"1\":{\"294\":1}}],[\"接口的扩展\",{\"1\":{\"116\":1}}],[\"接口转回int类型的实例i\",{\"1\":{\"48\":1}}],[\"接口实例中存放的是什么类型\",{\"1\":{\"48\":1}}],[\"接口实例中可以存放各种实现了接口的类型实例\",{\"1\":{\"48\":1}}],[\"接口实例转回时\",{\"1\":{\"48\":1}}],[\"接口实例ins中保存的是int类型\",{\"1\":{\"48\":1}}],[\"接口类型的数据结构是2个指针\",{\"1\":{\"45\":1}}],[\"接口类型是指针类型\",{\"1\":{\"45\":1}}],[\"接口\",{\"1\":{\"42\":1,\"45\":1,\"415\":1}}],[\"接口只包含一个方法\",{\"1\":{\"12\":1}}],[\"接收\",{\"1\":{\"2\":1}}],[\"hchan\",{\"1\":{\"483\":1,\"484\":1}}],[\"hz\",{\"1\":{\"354\":1}}],[\"h中\",{\"1\":{\"297\":1}}],[\"h\",{\"1\":{\"296\":5}}],[\"h与src\",{\"1\":{\"294\":1,\"295\":1,\"298\":1,\"300\":1,\"301\":1}}],[\"ht\",{\"1\":{\"296\":12}}],[\"html\",{\"1\":{\"234\":1,\"235\":1,\"238\":1,\"265\":1,\"266\":1}}],[\"http包的内存泄漏\",{\"0\":{\"499\":1}}],[\"http包中server\",{\"1\":{\"12\":1}}],[\"http包中有默认的defaultservemux\",{\"1\":{\"12\":1}}],[\"https\",{\"1\":{\"23\":1,\"37\":1,\"207\":1,\"219\":1,\"234\":1,\"235\":2,\"238\":3,\"265\":1,\"266\":3,\"329\":1,\"338\":1,\"358\":1,\"392\":1,\"469\":1,\"473\":1,\"490\":1,\"500\":1,\"503\":2}}],[\"httpmethod\",{\"1\":{\"12\":1}}],[\"http服务的底层走的是tcp协议\",{\"1\":{\"12\":1}}],[\"http\",{\"1\":{\"12\":17,\"238\":1,\"262\":9,\"264\":3,\"288\":1,\"347\":1,\"500\":2,\"502\":7}}],[\"huaxiao\",{\"1\":{\"207\":1}}],[\"hj\",{\"1\":{\"72\":1}}],[\"home\",{\"1\":{\"352\":1}}],[\"holding\",{\"1\":{\"300\":1}}],[\"hold\",{\"1\":{\"299\":2}}],[\"host\",{\"1\":{\"311\":1}}],[\"hostip\",{\"1\":{\"238\":1}}],[\"host=\",{\"1\":{\"238\":1}}],[\"host权限表\",{\"1\":{\"139\":1}}],[\"horse称为外部struct\",{\"1\":{\"42\":1}}],[\"horse\",{\"1\":{\"42\":1}}],[\"however\",{\"1\":{\"32\":1,\"294\":1,\"299\":1}}],[\"how\",{\"1\":{\"12\":1,\"299\":1}}],[\"hi\",{\"1\":{\"19\":2,\"31\":2,\"33\":1,\"414\":1}}],[\"hijacked\",{\"1\":{\"12\":2}}],[\"haha\",{\"1\":{\"481\":2}}],[\"happens\",{\"0\":{\"454\":1}}],[\"has\",{\"1\":{\"296\":1,\"299\":3}}],[\"hashfunction\",{\"1\":{\"296\":1}}],[\"hash也可以看成是轮询的升级版\",{\"1\":{\"266\":1}}],[\"hash失效时\",{\"1\":{\"266\":1}}],[\"hash分区\",{\"1\":{\"234\":1}}],[\"hash\",{\"0\":{\"275\":1},\"1\":{\"84\":2,\"266\":6,\"273\":1,\"292\":1,\"296\":15}}],[\"hash索引根本无法进行模糊查询\",{\"1\":{\"134\":1}}],[\"hash索引在等值查询上比b+树效率更高\",{\"1\":{\"134\":1}}],[\"hash索引不支持\",{\"1\":{\"134\":2}}],[\"hash索引不能\",{\"1\":{\"134\":1}}],[\"hash索引和b+树区别是什么\",{\"0\":{\"134\":1}}],[\"hash索引\",{\"1\":{\"66\":1}}],[\"hard\",{\"1\":{\"32\":1}}],[\"have\",{\"1\":{\"12\":1,\"32\":1,\"36\":1,\"299\":1}}],[\"handleexceptions\",{\"1\":{\"262\":2}}],[\"handle\",{\"1\":{\"34\":1}}],[\"handles\",{\"1\":{\"12\":1}}],[\"handlehttprequest\",{\"1\":{\"12\":3}}],[\"handlershutdown\",{\"1\":{\"262\":2}}],[\"handlers\",{\"1\":{\"12\":6}}],[\"handlerfunc函数\",{\"1\":{\"12\":1}}],[\"handler\",{\"1\":{\"12\":10,\"130\":1,\"262\":14,\"264\":1}}],[\"handler接口的实现者\",{\"1\":{\"12\":1}}],[\"handler接口\",{\"1\":{\"12\":2}}],[\"he\",{\"1\":{\"296\":7}}],[\"held\",{\"1\":{\"58\":1}}],[\"hello这个key\",{\"1\":{\"292\":1}}],[\"hello\",{\"1\":{\"47\":1,\"246\":1,\"292\":1,\"409\":1,\"490\":1}}],[\"hence\",{\"1\":{\"32\":1}}],[\"head\",{\"1\":{\"295\":1,\"300\":2,\"469\":1}}],[\"headersize\",{\"1\":{\"299\":1}}],[\"headersize+tail\",{\"1\":{\"299\":1}}],[\"header\",{\"1\":{\"12\":1,\"294\":4,\"297\":1}}],[\"heap\",{\"1\":{\"32\":1,\"490\":6}}],[\"here\",{\"1\":{\"12\":1,\"294\":1,\"299\":1}}],[\"面试官听到这个锁的实现方法之后双眼冒光\",{\"1\":{\"56\":1}}],[\"面试总结\",{\"2\":{\"10\":1,\"14\":1,\"25\":1,\"39\":1,\"50\":1,\"55\":1,\"61\":1,\"65\":1,\"75\":1,\"209\":1,\"221\":1,\"240\":1,\"248\":1,\"258\":1,\"271\":1,\"280\":1,\"290\":1,\"303\":1,\"331\":1,\"344\":1,\"349\":1,\"360\":1,\"364\":1,\"368\":1,\"372\":1,\"376\":1,\"380\":1,\"384\":1,\"388\":1,\"403\":1,\"417\":1,\"420\":1,\"423\":1,\"426\":1,\"430\":1,\"433\":1,\"443\":1,\"467\":1,\"471\":1,\"475\":1,\"486\":1,\"492\":1,\"498\":1,\"505\":1,\"510\":1}}],[\"面试\",{\"2\":{\"10\":1,\"14\":1,\"25\":1,\"39\":1,\"50\":1,\"55\":1,\"61\":1,\"65\":1,\"75\":1,\"209\":1,\"221\":1,\"240\":1,\"248\":1,\"258\":1,\"271\":1,\"280\":1,\"290\":1,\"303\":1,\"331\":1,\"344\":1,\"349\":1,\"360\":1,\"364\":1,\"368\":1,\"372\":1,\"376\":1,\"380\":1,\"384\":1,\"388\":1,\"403\":1,\"417\":1,\"420\":1,\"423\":1,\"426\":1,\"430\":1,\"433\":1,\"443\":1,\"467\":1,\"471\":1,\"475\":1,\"486\":1,\"492\":1,\"498\":1,\"505\":1,\"510\":1}}],[\"源码提示直接\",{\"1\":{\"483\":1}}],[\"源码参考\",{\"1\":{\"366\":1,\"370\":1,\"374\":1,\"378\":1,\"382\":1,\"386\":1}}],[\"源码解析\",{\"1\":{\"346\":1,\"366\":1,\"370\":1,\"374\":1,\"378\":1,\"382\":1,\"386\":1}}],[\"源码\",{\"2\":{\"10\":1,\"14\":1,\"25\":1,\"39\":1,\"50\":1,\"55\":1,\"61\":1,\"65\":1,\"344\":1,\"364\":1,\"368\":1,\"372\":1,\"376\":1,\"380\":1,\"384\":1,\"388\":1,\"403\":1,\"417\":1,\"420\":1,\"423\":1,\"426\":1,\"430\":1,\"433\":1,\"443\":1,\"467\":1,\"471\":1,\"475\":1,\"486\":1,\"492\":1,\"498\":1,\"505\":1,\"510\":1}}],[\"了解过吗\",{\"0\":{\"127\":1,\"141\":1,\"149\":1}}],[\"了\",{\"1\":{\"8\":1,\"21\":1,\"489\":1}}],[\"我提供一些自己的实践经验\",{\"1\":{\"358\":1}}],[\"我就是个技术混子\",{\"1\":{\"259\":1}}],[\"我就是要使用go提供的原生map\",{\"1\":{\"52\":1}}],[\"我自我感觉回答的很渣\",{\"1\":{\"259\":1}}],[\"我自己取的\",{\"1\":{\"215\":1}}],[\"我再把这张图挂上来\",{\"1\":{\"219\":1}}],[\"我来说一下三个步骤\",{\"1\":{\"215\":1}}],[\"我来解释一下\",{\"1\":{\"212\":1}}],[\"我查了很多资料\",{\"1\":{\"215\":1}}],[\"我觉很有必要先去了解一下\",{\"1\":{\"214\":1}}],[\"我觉得它俩主要是概念的理解\",{\"1\":{\"212\":1}}],[\"我这里用的是lepus\",{\"1\":{\"202\":1}}],[\"我排查死锁的一般步骤是酱紫的\",{\"1\":{\"81\":1}}],[\"我个人建议是使用锁进行实现\",{\"1\":{\"53\":1}}],[\"我看下这个serverhandler\",{\"1\":{\"12\":1}}],[\"我\",{\"1\":{\"8\":1,\"44\":2}}],[\"我们直接看源码\",{\"1\":{\"502\":1}}],[\"我们还是通过图来了解这个流程\",{\"1\":{\"357\":1}}],[\"我们如何从这些持久化文件中恢复数据呢\",{\"1\":{\"357\":1}}],[\"我们重点看看\",{\"1\":{\"355\":1}}],[\"我们重点关注的是type\",{\"1\":{\"195\":1}}],[\"我们主要来看rdb与aof是如何完成持久化的\",{\"1\":{\"354\":1}}],[\"我们主要用它生成内存快照\",{\"1\":{\"335\":1}}],[\"我们主要看serve\",{\"1\":{\"12\":1}}],[\"我们继续使用这个图来谈论\",{\"1\":{\"307\":1}}],[\"我们的slave3既是master的从节点\",{\"1\":{\"305\":1}}],[\"我们以插入操作引起的扩容为例\",{\"1\":{\"296\":1}}],[\"我们定义了几个key\",{\"1\":{\"268\":1}}],[\"我们使用\",{\"1\":{\"268\":1}}],[\"我们在创建秒杀活动的时候就要把商品相关信息写入到缓存中\",{\"1\":{\"268\":1}}],[\"我们在应用中应该尽量使用主键查询\",{\"1\":{\"246\":1}}],[\"我们一般会采用\",{\"1\":{\"333\":1}}],[\"我们一一分析下\",{\"1\":{\"268\":1}}],[\"我们一定要记住这句话\",{\"1\":{\"73\":1}}],[\"我们自定义了一个处理类\",{\"1\":{\"262\":1}}],[\"我们同样可以使用前缀索引中的方法来比较\",{\"1\":{\"230\":1}}],[\"我们同样是通过for循环开了9个协程来对map进行增删改查\",{\"1\":{\"53\":1}}],[\"我们再使用一个相对来说比较复杂的示例来验证\",{\"1\":{\"219\":1}}],[\"我们再来验证一下\",{\"1\":{\"218\":1}}],[\"我们预期的结果应该是这样的\",{\"1\":{\"218\":1}}],[\"我们进行判断\",{\"1\":{\"218\":1}}],[\"我们先看一下这个run\",{\"1\":{\"321\":1}}],[\"我们先测试一下看是否实现主从复制\",{\"1\":{\"309\":1}}],[\"我们先得有一个概念\",{\"1\":{\"309\":1}}],[\"我们先简单的配置一个主从复制案例\",{\"1\":{\"308\":1}}],[\"我们先判断\",{\"1\":{\"218\":1}}],[\"我们先来看一看\",{\"1\":{\"215\":1}}],[\"我们获取到\",{\"1\":{\"218\":1}}],[\"我们假设事务a的事务id为2\",{\"1\":{\"218\":1}}],[\"我们用刚刚的可见性算法来实验一下\",{\"1\":{\"218\":1}}],[\"我们平时写sql时\",{\"1\":{\"182\":1}}],[\"我们想要删除百万数据的时候可以先删除索引\",{\"1\":{\"146\":1}}],[\"我们要选择最外层循环小的\",{\"1\":{\"112\":1}}],[\"我们也可以用exists实现一样的查询功能\",{\"1\":{\"112\":1}}],[\"我们也必将会对这些结构体有越来越清晰的认识\",{\"1\":{\"30\":1}}],[\"我们知道并发控制常用的是锁\",{\"1\":{\"212\":1}}],[\"我们知道\",{\"1\":{\"90\":1}}],[\"我们最终会找到主键值47\",{\"1\":{\"72\":1}}],[\"我们可以控制单个redis实例的最大内存\",{\"1\":{\"355\":1}}],[\"我们可以自由定制什么情况下触发备份\",{\"1\":{\"352\":1}}],[\"我们可以将前面生成的\",{\"1\":{\"340\":1}}],[\"我们可以查看持久化文件查看\",{\"1\":{\"322\":1}}],[\"我们可以使用info命令查看\",{\"1\":{\"321\":1}}],[\"我们可以讲\",{\"1\":{\"300\":1}}],[\"我们可以采用redis\",{\"1\":{\"268\":1}}],[\"我们可以通过set\",{\"1\":{\"262\":1}}],[\"我们可以得知现在的\",{\"1\":{\"219\":1}}],[\"我们可以判断此时\",{\"1\":{\"219\":2}}],[\"我们可以发现\",{\"1\":{\"219\":1}}],[\"我们可以这么理解聚簇索引\",{\"1\":{\"92\":1}}],[\"我们可以一直找到键值为22的数据\",{\"1\":{\"72\":1}}],[\"我们可以找到键值18\",{\"1\":{\"72\":1}}],[\"我们可以把前面的调度伪代码写得更丰满一点\",{\"1\":{\"29\":1}}],[\"我们可以把它理解为线程\",{\"1\":{\"1\":1}}],[\"我们就多准备几台服务器\",{\"1\":{\"306\":1}}],[\"我们就需要拿着p2指针去磁盘中进行读取页3\",{\"1\":{\"72\":1}}],[\"我们就能在不同的工作线程中使用相同的全局变量名来访问不同的m结构体对象\",{\"1\":{\"29\":1}}],[\"我们首先判断小明和小方的记录\",{\"1\":{\"219\":1}}],[\"我们首先获取\",{\"1\":{\"218\":1}}],[\"我们首先需要找到id=18的键值\",{\"1\":{\"72\":1}}],[\"我们首先想到的是使用互斥锁或读写锁\",{\"1\":{\"52\":1}}],[\"我们称为回表\",{\"1\":{\"71\":1}}],[\"我们称之为\",{\"1\":{\"252\":1}}],[\"我们称之为非聚集索引\",{\"1\":{\"71\":1}}],[\"我们称之为聚集索引\",{\"1\":{\"71\":1}}],[\"我们称这个运行队列为全局运行队列\",{\"1\":{\"29\":1}}],[\"我们称这些系统线程为工作线程\",{\"1\":{\"28\":1}}],[\"我们提到了图中的索引其实是聚集索引的实现方式\",{\"1\":{\"71\":1}}],[\"我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据\",{\"1\":{\"70\":1}}],[\"我们通过代码可以看到\",{\"1\":{\"12\":1}}],[\"我们根据页3中的指针p2找到页8\",{\"1\":{\"69\":1}}],[\"我们那么我们根据页1中的指针p2找到页3\",{\"1\":{\"69\":1}}],[\"我们应该明白这样一句话\",{\"1\":{\"71\":1}}],[\"我们应该寻找一种单个节点可以存储多个键值和数据的平衡树\",{\"1\":{\"69\":1}}],[\"我们应当尽量减少从磁盘中读取数据的次数\",{\"1\":{\"69\":1}}],[\"我们查找数据的效率将会极低\",{\"1\":{\"69\":1}}],[\"我们查找数据时也会进行很多次磁盘io\",{\"1\":{\"69\":1}}],[\"我们都知道rdb的快照\",{\"1\":{\"358\":1}}],[\"我们都知道平衡二叉树可是每个节点只存储一个键值和数据的\",{\"1\":{\"69\":1}}],[\"我们都会选择将user表中的数据和索引存储在磁盘这种外围设备中\",{\"1\":{\"69\":1}}],[\"我们需要尽可能降低阻塞\",{\"1\":{\"358\":1}}],[\"我们需要先知道该如何开启持久化的功能\",{\"1\":{\"351\":1}}],[\"我们需要关注查询sql条件的顺序\",{\"1\":{\"111\":1}}],[\"我们需要再去磁盘中将页8读取到内存中\",{\"1\":{\"72\":1}}],[\"我们需要保证二叉查找树一直保持平衡\",{\"1\":{\"68\":1}}],[\"我们需要查找7次\",{\"1\":{\"68\":1}}],[\"我们需要6次才能找到\",{\"1\":{\"67\":1}}],[\"我们需要利用多核来挖掘并行的价值\",{\"1\":{\"16\":1}}],[\"我们从当前节点中取出data\",{\"1\":{\"67\":1}}],[\"我们为user表\",{\"1\":{\"67\":1}}],[\"我们今天要介绍的是工作开发中最常接触到innodb存储引擎中的的b+树索引\",{\"1\":{\"66\":1}}],[\"我们对int1进行下标修改\",{\"1\":{\"63\":1}}],[\"我们来总结一下吧\",{\"1\":{\"219\":1}}],[\"我们来看一下现在的表格\",{\"1\":{\"215\":1}}],[\"我们来关注下面的代码\",{\"1\":{\"63\":1}}],[\"我们来思考这个问题\",{\"1\":{\"52\":1}}],[\"我们发现读数据和写数据互不冲突\",{\"1\":{\"58\":1}}],[\"我们输出的结果和我们预想的将大相径庭\",{\"1\":{\"53\":1}}],[\"我们开启了一个go协程用来读取ch中的方法并执行\",{\"1\":{\"53\":1}}],[\"我们完全不需要线程私有全局变量\",{\"1\":{\"29\":1}}],[\"我们只讲与go语言相关的并发模型csp\",{\"1\":{\"16\":1}}],[\"我们看到在代码案例中我们对共享的变量i进行加和读操作\",{\"1\":{\"57\":1}}],[\"我们看到在这三个操作中都使用到了锁机制\",{\"1\":{\"52\":1}}],[\"我们看到代码里serverhandler中的\",{\"1\":{\"12\":1}}],[\"我们看到实例化了一个serverhandler并调用了其servehttp方法来处理\",{\"1\":{\"12\":1}}],[\"我们看到这个方法中做了哪些事\",{\"1\":{\"12\":1}}],[\"我们看到这个方法的参数是一个连接的上下文\",{\"1\":{\"12\":1}}],[\"我们看到这个方法两个步骤\",{\"1\":{\"12\":1}}],[\"我们看下gin中怎么实现的\",{\"1\":{\"12\":1}}],[\"我们这个计时器\",{\"1\":{\"8\":1}}],[\"我们本意是在3秒之后停止main\",{\"1\":{\"8\":1}}],[\"ghc2wdw3vhp91drrfvcnag\",{\"1\":{\"473\":1}}],[\"ghost\",{\"1\":{\"346\":2}}],[\"gp\",{\"1\":{\"407\":4}}],[\"gpm代表了三个角色\",{\"1\":{\"18\":1}}],[\"gpm调度模型\",{\"0\":{\"18\":1},\"1\":{\"17\":1}}],[\"gb\",{\"1\":{\"342\":1}}],[\"guavacache\",{\"1\":{\"282\":1}}],[\"guintptr\",{\"1\":{\"19\":1,\"20\":2,\"32\":1,\"33\":1,\"35\":2,\"407\":1}}],[\"grow\",{\"1\":{\"450\":1}}],[\"growth\",{\"1\":{\"33\":2}}],[\"group\",{\"1\":{\"86\":1}}],[\"gs\",{\"1\":{\"36\":2}}],[\"gsignal\",{\"1\":{\"33\":1}}],[\"gqueue\",{\"1\":{\"36\":1}}],[\"glist\",{\"1\":{\"35\":1,\"36\":2}}],[\"global\",{\"1\":{\"29\":1,\"36\":2,\"224\":1,\"296\":1}}],[\"globaloptionshandler\",{\"1\":{\"12\":1}}],[\"gfree是所有已经退出的goroutine对应的g结构体对象组成的链表\",{\"1\":{\"36\":1}}],[\"gfree\",{\"1\":{\"35\":1,\"36\":1}}],[\"gdead\",{\"1\":{\"35\":1}}],[\"g结构体用于代表一个goroutine\",{\"1\":{\"33\":1}}],[\"g结构体\",{\"0\":{\"33\":1}}],[\"g保存刚刚正在运行的goroutine的状态然后再次去寻找下一个goroutine\",{\"1\":{\"28\":1}}],[\"g0主要用来记录工作线程使用的栈信息\",{\"1\":{\"34\":1}}],[\"g0\",{\"1\":{\"19\":2,\"33\":1,\"34\":1,\"37\":3}}],[\"g\",{\"1\":{\"19\":4,\"28\":5,\"29\":6,\"32\":2,\"33\":1,\"34\":2,\"35\":4,\"36\":1,\"37\":2,\"401\":1}}],[\"git\",{\"1\":{\"338\":1}}],[\"github\",{\"1\":{\"288\":1,\"338\":1,\"347\":1}}],[\"given\",{\"1\":{\"12\":1,\"296\":1}}],[\"gin中主要通过context\",{\"1\":{\"12\":1}}],[\"gin\",{\"1\":{\"12\":2},\"2\":{\"14\":1}}],[\"gin框架构建servemux流程如下\",{\"1\":{\"12\":1}}],[\"gin框架也实现了这个\",{\"1\":{\"12\":1}}],[\"getconn\",{\"1\":{\"502\":1}}],[\"getcallerpc\",{\"1\":{\"407\":1}}],[\"get操作等待\",{\"1\":{\"421\":1}}],[\"get方法时可能被thorw\",{\"1\":{\"412\":1}}],[\"getg\",{\"1\":{\"407\":2}}],[\"getname\",{\"1\":{\"45\":3}}],[\"getvalue\",{\"1\":{\"12\":1}}],[\"get\",{\"1\":{\"12\":4,\"32\":1,\"262\":2,\"296\":2,\"412\":2,\"450\":1,\"500\":1,\"502\":4}}],[\"gcflags=\",{\"1\":{\"490\":3}}],[\"gc\",{\"1\":{\"8\":2,\"32\":2,\"264\":1,\"401\":3,\"450\":1}}],[\"gomod\",{\"1\":{\"490\":1}}],[\"gomaxprocs\",{\"1\":{\"37\":2,\"407\":1,\"409\":1}}],[\"go并发编程小测验\",{\"1\":{\"444\":1}}],[\"go里面map如何实现key不存在\",{\"1\":{\"421\":1}}],[\"go里的map用于存放key\",{\"1\":{\"41\":1}}],[\"goto\",{\"1\":{\"407\":1}}],[\"gosched\",{\"1\":{\"401\":1}}],[\"good\",{\"1\":{\"414\":1,\"502\":1}}],[\"goods\",{\"1\":{\"268\":5}}],[\"goodat\",{\"1\":{\"44\":2}}],[\"go也能像其它动态语言一样\",{\"1\":{\"47\":1}}],[\"go会自动解除引用\",{\"1\":{\"43\":1}}],[\"go中的读写锁是基于互斥锁的\",{\"1\":{\"58\":1}}],[\"go中的参数传递其本质都是以复制的方式传递的\",{\"1\":{\"42\":1}}],[\"go中标准包提供sync\",{\"1\":{\"57\":1}}],[\"go中所有需要传值的时候\",{\"1\":{\"43\":1}}],[\"go面试之slice\",{\"0\":{\"62\":1}}],[\"go面试之sync\",{\"0\":{\"56\":1}}],[\"go面试之并发安全的map\",{\"0\":{\"51\":1}}],[\"go面试之map\",{\"0\":{\"40\":1}}],[\"go面试之channel的使用\",{\"0\":{\"0\":1}}],[\"goexperiment=framepointer\",{\"1\":{\"32\":1}}],[\"go文件之中\",{\"1\":{\"30\":1}}],[\"go调度器源代码中还有一个用来代表工作线程的m结构体\",{\"1\":{\"29\":1}}],[\"goidgen\",{\"1\":{\"36\":1}}],[\"goid\",{\"1\":{\"19\":1}}],[\"going\",{\"1\":{\"12\":1}}],[\"gobuf结构体和其它的一些状态信息\",{\"1\":{\"33\":1}}],[\"gobuf结构体用于保存goroutine的调度信息\",{\"1\":{\"32\":1}}],[\"gobuf结构体\",{\"0\":{\"32\":1}}],[\"gobuf\",{\"1\":{\"19\":2,\"32\":2,\"33\":1}}],[\"go的结构体表示\",{\"1\":{\"19\":1}}],[\"go语言的gpm调度器是什么\",{\"0\":{\"15\":1}}],[\"golang程序变量会携带有一组校验数据\",{\"1\":{\"489\":1}}],[\"golang中的map\",{\"1\":{\"441\":1}}],[\"golang中有规定\",{\"1\":{\"392\":1}}],[\"golang提供了switch\",{\"1\":{\"48\":1}}],[\"golang将直接以panic的方式终止程序\",{\"1\":{\"48\":1}}],[\"golang通过gin框架创建http服务源码剖析\",{\"0\":{\"11\":1}}],[\"golang\",{\"0\":{\"361\":1,\"362\":1,\"418\":1,\"444\":1,\"511\":1},\"1\":{\"392\":1,\"393\":1,\"395\":1,\"401\":2,\"406\":1,\"408\":1,\"409\":1,\"414\":1,\"418\":1,\"428\":1,\"435\":1,\"438\":1,\"502\":1},\"2\":{\"9\":1,\"10\":1,\"13\":1,\"24\":1,\"38\":1,\"49\":1,\"50\":1,\"54\":1,\"55\":1,\"60\":1,\"61\":1,\"64\":1,\"65\":1,\"270\":1,\"363\":1,\"364\":1,\"367\":1,\"368\":1,\"371\":1,\"372\":1,\"375\":1,\"376\":1,\"379\":1,\"380\":1,\"383\":1,\"384\":1,\"387\":1,\"388\":1,\"402\":1,\"403\":1,\"416\":1,\"417\":1,\"419\":1,\"420\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"429\":1,\"430\":1,\"432\":1,\"433\":1,\"442\":1,\"443\":1,\"466\":1,\"467\":1,\"470\":1,\"471\":1,\"474\":1,\"475\":1,\"485\":1,\"486\":1,\"491\":1,\"492\":1,\"497\":1,\"498\":1,\"504\":1,\"505\":1,\"509\":1,\"510\":1}}],[\"goruntine\",{\"1\":{\"8\":2}}],[\"goroutine全局运行队列\",{\"1\":{\"36\":1}}],[\"goroutine的控制结构中\",{\"1\":{\"405\":1}}],[\"goroutine的容器\",{\"1\":{\"29\":1}}],[\"goroutine的目的\",{\"1\":{\"29\":1}}],[\"goroutine的栈也会自动扩大\",{\"1\":{\"27\":1}}],[\"goroutine建立在操作系统线程基础之上\",{\"1\":{\"28\":1}}],[\"goroutine启动时默认栈大小只有2k\",{\"1\":{\"27\":1}}],[\"goroutine是用户态线程\",{\"1\":{\"27\":1}}],[\"goroutine是go语言实现的用户态线程\",{\"1\":{\"27\":1}}],[\"goroutine简介\",{\"0\":{\"27\":1}}],[\"goroutine调度器概述\",{\"0\":{\"26\":1}}],[\"goroutine调度相关的数据存储在sched\",{\"1\":{\"19\":1}}],[\"goroutine由一个名为runtime\",{\"1\":{\"19\":1}}],[\"goroutine就是代码中使用go关键词创建的执行单元\",{\"1\":{\"19\":1}}],[\"goroutines\",{\"1\":{\"4\":1,\"6\":1,\"28\":1,\"35\":3,\"36\":1,\"401\":1,\"451\":3}}],[\"goroutine中进行的\",{\"1\":{\"4\":2}}],[\"goroutine\",{\"0\":{\"19\":1},\"1\":{\"1\":6,\"4\":2,\"6\":1,\"12\":1,\"15\":1,\"18\":1,\"28\":1,\"29\":2,\"33\":1,\"34\":2,\"366\":3,\"395\":2,\"401\":7,\"418\":2,\"480\":1,\"489\":1,\"502\":7,\"503\":1},\"2\":{\"25\":1,\"39\":1}}],[\"go提供了一个select语句块\",{\"1\":{\"7\":1}}],[\"go将探测到此问题\",{\"1\":{\"4\":1}}],[\"go\",{\"1\":{\"3\":4,\"4\":1,\"5\":2,\"6\":2,\"7\":3,\"8\":2,\"12\":1,\"19\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"36\":1,\"44\":2,\"52\":1,\"53\":2,\"57\":1,\"58\":3,\"366\":2,\"394\":1,\"395\":2,\"397\":3,\"398\":1,\"400\":1,\"401\":2,\"407\":2,\"413\":1,\"418\":3,\"424\":3,\"428\":3,\"431\":4,\"437\":2,\"446\":1,\"447\":1,\"450\":2,\"451\":2,\"452\":2,\"454\":1,\"457\":1,\"483\":1,\"490\":20,\"502\":8},\"2\":{\"10\":1,\"14\":1,\"25\":1,\"39\":1,\"50\":1,\"55\":1,\"61\":1,\"65\":1,\"364\":1,\"368\":1,\"372\":1,\"376\":1,\"380\":1,\"384\":1,\"388\":1,\"403\":1,\"417\":1,\"420\":1,\"423\":1,\"426\":1,\"430\":1,\"433\":1,\"443\":1,\"467\":1,\"471\":1,\"475\":1,\"486\":1,\"492\":1,\"498\":1,\"505\":1,\"510\":1}}],[\"时的\",{\"1\":{\"502\":1}}],[\"时可能会超出其容量\",{\"1\":{\"489\":1}}],[\"时刻都可以立即执行并返回\",{\"1\":{\"421\":1}}],[\"时间复杂度为o\",{\"1\":{\"370\":1}}],[\"时间策略\",{\"1\":{\"352\":1}}],[\"时长要小于写操作\",{\"1\":{\"288\":1}}],[\"时\",{\"1\":{\"8\":1,\"44\":1,\"78\":1,\"296\":1,\"355\":1}}],[\"因此只泄漏了一个读goroutine和一个写goroutine\",{\"1\":{\"503\":1}}],[\"因此其生命周期大于栈\",{\"1\":{\"489\":1}}],[\"因此死锁\",{\"1\":{\"457\":1}}],[\"因此追加数据后的\",{\"1\":{\"438\":1}}],[\"因此需要原子性的修改int值\",{\"1\":{\"424\":1}}],[\"因此为了不影响redis主进程响应\",{\"1\":{\"358\":1}}],[\"因此也会为子进程保留一个buf\",{\"1\":{\"356\":1}}],[\"因此也无需关注proxy本身的高可用\",{\"1\":{\"116\":1}}],[\"因此它依然会写入旧的aof\",{\"1\":{\"356\":1}}],[\"因此阻塞只会发生在fork子进程的时候\",{\"1\":{\"355\":1}}],[\"因此我们在配置redis时\",{\"1\":{\"354\":1}}],[\"因此我们可以说主从复制是高可用的基石\",{\"1\":{\"307\":1}}],[\"因此redis又实现了一个轻量级的字典\",{\"1\":{\"301\":1}}],[\"因此不能直接通过key来赋值对象\",{\"1\":{\"441\":1}}],[\"因此不会有丢失流量的情况\",{\"1\":{\"266\":1}}],[\"因此不用再次进行回表查询\",{\"1\":{\"150\":1}}],[\"因此这种模式的文件保存的信息太多\",{\"1\":{\"140\":1}}],[\"因此在保存的时候需要保存相关的信息\",{\"1\":{\"140\":1}}],[\"因此在每次进行\",{\"1\":{\"8\":1}}],[\"因此读取磁盘的次数就降下来啦\",{\"1\":{\"90\":1}}],[\"因此访问它需要加锁\",{\"1\":{\"29\":1}}],[\"因此\",{\"1\":{\"29\":1,\"102\":1,\"112\":1,\"246\":1,\"401\":1,\"405\":1,\"406\":1,\"407\":1,\"408\":1,\"412\":1,\"424\":1}}],[\"因此很合理的也就被\",{\"1\":{\"8\":1}}],[\"因为它只在方法内存在\",{\"1\":{\"490\":1}}],[\"因为它有一个变量保存了整个表的总行数\",{\"1\":{\"87\":1}}],[\"因为不够一组\",{\"1\":{\"469\":1}}],[\"因为cpu缓存会导致多个核心中变量值不同步\",{\"1\":{\"459\":1}}],[\"因为aof保存的数据更完整\",{\"1\":{\"357\":1}}],[\"因为值越大说明执行频率越频繁越高\",{\"1\":{\"354\":1}}],[\"因为zipmap的内存布局就是一块连续的内存空间\",{\"1\":{\"301\":1}}],[\"因为读起来真的费劲\",{\"1\":{\"299\":1}}],[\"因为读写锁可以多次获取读锁\",{\"1\":{\"58\":1}}],[\"因为链式扩容只能一步一步的计算\",{\"1\":{\"299\":1}}],[\"因为内部api无法判断这样做的合适时机\",{\"1\":{\"294\":1}}],[\"因为内存的易失性\",{\"1\":{\"69\":1}}],[\"因为多数字符串在程序运行期间是不变的\",{\"1\":{\"294\":1}}],[\"因为他们不同源\",{\"1\":{\"265\":1}}],[\"因为mutex\",{\"1\":{\"456\":1}}],[\"因为mutex不会和goroutine进行关联\",{\"1\":{\"57\":1}}],[\"因为map中的值会在内存中移动\",{\"1\":{\"399\":1}}],[\"因为myisam的索引和数据是分开存储存储的\",{\"1\":{\"231\":1}}],[\"因为在\",{\"1\":{\"219\":1}}],[\"因为前面\",{\"1\":{\"219\":1}}],[\"因为隔离性\",{\"1\":{\"218\":1}}],[\"因为有\",{\"1\":{\"199\":1}}],[\"因为事务在修改页时\",{\"1\":{\"199\":1}}],[\"因为事务a读取到事务b未提交的数据\",{\"1\":{\"96\":1}}],[\"因为这里只是读\",{\"1\":{\"412\":1}}],[\"因为这会让\",{\"1\":{\"181\":1}}],[\"因为这个方法既在值类型的实例t方法集中\",{\"1\":{\"46\":1}}],[\"因为这个方法不在值类型的实例t方法集中\",{\"1\":{\"46\":1}}],[\"因为innodb是顺序插入的\",{\"1\":{\"230\":1}}],[\"因为innodb引擎中的索引策略的最左原则\",{\"1\":{\"153\":1}}],[\"因为ints的长度为2\",{\"1\":{\"63\":1}}],[\"因为exists查询的理解就是\",{\"1\":{\"112\":1}}],[\"因为绝大多数用户都不会往后翻太多页\",{\"1\":{\"93\":1}}],[\"因为页9不在内存中\",{\"1\":{\"72\":1}}],[\"因为页中的数据是链表进行连接的\",{\"1\":{\"72\":1}}],[\"因为是范围查找\",{\"1\":{\"72\":1}}],[\"因为是互斥锁\",{\"1\":{\"58\":1}}],[\"因为b+树索引的所有数据均存储在叶子节点\",{\"1\":{\"70\":1}}],[\"因为图的美观性\",{\"1\":{\"69\":1}}],[\"因为redis每个时段的读写请求肯定不是均衡的\",{\"1\":{\"352\":1}}],[\"因为redis的默认端口就是6379所以我们启动另外一台redis服务器直接使用redis\",{\"1\":{\"308\":1}}],[\"因为receiver严格规定p是一个值类型的实例\",{\"1\":{\"43\":1}}],[\"因为rwmutex的多个读可以并存\",{\"1\":{\"59\":1}}],[\"因为竞争的存在\",{\"1\":{\"57\":1}}],[\"因为任意类型都实现了空接口\",{\"1\":{\"47\":1}}],[\"因为没方法需要实现\",{\"1\":{\"47\":1}}],[\"因为没有人需要\",{\"1\":{\"8\":1}}],[\"因为从系统调用返回之后如果p被其它工作线程抢占\",{\"1\":{\"32\":1}}],[\"因为全局运行队列是每个工作线程都可以读写的\",{\"1\":{\"29\":1}}],[\"因为每个go程序只有一个调度器\",{\"1\":{\"29\":1}}],[\"因为要继续往下执行\",{\"1\":{\"22\":1}}],[\"因为\",{\"1\":{\"8\":1,\"219\":1,\"401\":1,\"462\":1,\"489\":1,\"508\":1}}],[\"因为关闭通道是针对发送数据而言的\",{\"1\":{\"6\":1}}],[\"因为关闭通道意味着没有数据再需要发送\",{\"1\":{\"2\":1}}],[\"因为容量为1的channel\",{\"1\":{\"3\":1}}],[\"达到终止循环的效果\",{\"1\":{\"7\":1}}],[\"执行go\",{\"1\":{\"490\":1}}],[\"执行时间太长\",{\"1\":{\"401\":1}}],[\"执行时为什么会报错\",{\"0\":{\"399\":1}}],[\"执行info命令即可看到\",{\"1\":{\"321\":1}}],[\"执行bgrewriteaof\",{\"1\":{\"318\":1}}],[\"执行命令\",{\"1\":{\"311\":1}}],[\"执行命令redis\",{\"1\":{\"308\":1}}],[\"执行完就代表我们连接上了\",{\"1\":{\"309\":1}}],[\"执行插入操作\",{\"1\":{\"297\":1}}],[\"执行的操作类似于dict\",{\"1\":{\"296\":1}}],[\"执行响应的逻辑\",{\"1\":{\"260\":1}}],[\"执行过delete语句之后建议执行重建表语句\",{\"1\":{\"255\":1}}],[\"执行数据页中相关的操作\",{\"1\":{\"250\":1}}],[\"执行器sql更改流程\",{\"1\":{\"244\":1}}],[\"执行器调用事务提交接口\",{\"1\":{\"244\":1}}],[\"执行器调用存储引擎进行数据更改\",{\"1\":{\"244\":1}}],[\"执行器生成操作的binlog日志\",{\"1\":{\"244\":1}}],[\"执行器操作存储引擎获取要执行的记录\",{\"1\":{\"244\":1}}],[\"执行器\",{\"1\":{\"242\":1}}],[\"执行速度快\",{\"1\":{\"238\":1}}],[\"执行计划包含字段信息如下\",{\"1\":{\"195\":1}}],[\"执行\",{\"1\":{\"179\":1,\"355\":2,\"401\":1}}],[\"执行效率比较高\",{\"1\":{\"169\":1}}],[\"执行relay\",{\"1\":{\"119\":1}}],[\"执行用户goroutine代码时\",{\"1\":{\"34\":1}}],[\"执行具体的handlerfunc\",{\"1\":{\"12\":1}}],[\"执行这段代码\",{\"1\":{\"7\":1}}],[\"执行default\",{\"1\":{\"7\":1}}],[\"一次建立连接\",{\"1\":{\"502\":1}}],[\"一次runlock\",{\"1\":{\"58\":1}}],[\"一段时间后总是输出\",{\"1\":{\"451\":2}}],[\"一定成立\",{\"1\":{\"401\":1}}],[\"一定要整体考虑一些会触发定时任务的配置\",{\"1\":{\"354\":1}}],[\"一定要比数据页先持久化到磁盘\",{\"1\":{\"199\":1}}],[\"一步是命令的实时写入\",{\"1\":{\"356\":1}}],[\"一视同仁\",{\"1\":{\"345\":1}}],[\"一台为6379\",{\"1\":{\"308\":1}}],[\"一台为6380\",{\"1\":{\"308\":1}}],[\"一点一点解决你的问题\",{\"1\":{\"306\":1}}],[\"一\",{\"0\":{\"305\":1,\"390\":1}}],[\"一字节或五字节\",{\"1\":{\"301\":2}}],[\"一句话总结\",{\"1\":{\"288\":1}}],[\"一句老话\",{\"1\":{\"285\":1}}],[\"一行一行进行累加\",{\"1\":{\"256\":1}}],[\"一种用于在小规模场合使用的轻量级字典结构\",{\"1\":{\"292\":1}}],[\"一种以ziplist作为结点的双链表结构\",{\"1\":{\"292\":1}}],[\"一种实现上类似于tlv\",{\"1\":{\"292\":1}}],[\"一种常见缓存更新策略\",{\"1\":{\"287\":1}}],[\"一种记录changebuffer的改动\",{\"1\":{\"251\":1}}],[\"一种记录普通数据页的改动\",{\"1\":{\"251\":1}}],[\"一种\",{\"1\":{\"213\":1}}],[\"一种折中的方案\",{\"1\":{\"140\":1}}],[\"一直都是最大值\",{\"1\":{\"184\":1}}],[\"一直轮询channel的可读事件\",{\"1\":{\"7\":1}}],[\"一些值得监控的变量值\",{\"1\":{\"130\":1}}],[\"一条sql加锁\",{\"1\":{\"207\":1}}],[\"一条sql的执行顺序\",{\"0\":{\"180\":1}}],[\"一条sql执行过长的时间\",{\"0\":{\"129\":1}}],[\"一条sql语句在mysql中如何执行的\",{\"0\":{\"125\":1}}],[\"一致性问题\",{\"0\":{\"281\":1}}],[\"一致性\",{\"1\":{\"106\":1,\"107\":1,\"194\":1,\"223\":1,\"245\":1,\"266\":1}}],[\"一时兴起想起来的\",{\"1\":{\"72\":1}}],[\"一旦被锁住\",{\"1\":{\"57\":1}}],[\"一方面用来保存调度器自身的状态信息\",{\"1\":{\"29\":1}}],[\"一方面\",{\"1\":{\"27\":1}}],[\"一个典型的例子就是\",{\"1\":{\"489\":1}}],[\"一个\",{\"1\":{\"342\":1,\"366\":1}}],[\"一个端口为6380\",{\"1\":{\"308\":1}}],[\"一个端口为6379\",{\"1\":{\"308\":1}}],[\"一个entry的首字节都不会是255\",{\"1\":{\"299\":1}}],[\"一个未遍历的结点\",{\"1\":{\"296\":1}}],[\"一个命令执行完才会执行下一个\",{\"1\":{\"274\":1}}],[\"一个key对应一个value\",{\"1\":{\"274\":1}}],[\"一个索引上不同的值越多\",{\"1\":{\"252\":1}}],[\"一个页里面可以存多个行\",{\"1\":{\"246\":1}}],[\"一个事务结束\",{\"1\":{\"245\":1}}],[\"一个创建事务id字段和一个删除事务id字段\",{\"1\":{\"215\":1}}],[\"一个3亿的表b\",{\"0\":{\"206\":1}}],[\"一个6亿的表a\",{\"0\":{\"206\":1}}],[\"一个复杂查询可以考虑拆成多个简单查询\",{\"1\":{\"188\":1}}],[\"一个数据列只能有一个主键\",{\"1\":{\"172\":1}}],[\"一个存储过程替代大量t\",{\"1\":{\"169\":1}}],[\"一个或极少不同值\",{\"1\":{\"151\":1}}],[\"一个表只允许存在一个\",{\"1\":{\"173\":1}}],[\"一个表只能有一个主键\",{\"1\":{\"143\":1}}],[\"一个表允许有多个\",{\"1\":{\"173\":1}}],[\"一个表允许多个列创建唯一索引\",{\"1\":{\"143\":1}}],[\"一个表中只能拥有一个聚集索引\",{\"1\":{\"92\":1}}],[\"一个服务器开放ｎ个链接给客户端来连接的\",{\"1\":{\"118\":1}}],[\"一个返回值的探测\",{\"1\":{\"48\":1}}],[\"一个goroutine结构体被创建\",{\"1\":{\"21\":1}}],[\"一个是读写锁\",{\"1\":{\"58\":1}}],[\"一个是对象的值\",{\"1\":{\"47\":1}}],[\"一个是对象的类型\",{\"1\":{\"47\":1}}],[\"一个是指针\",{\"1\":{\"42\":1}}],[\"一个是curg\",{\"1\":{\"19\":1}}],[\"一个是g0\",{\"1\":{\"19\":1}}],[\"一般会用到\",{\"1\":{\"428\":1}}],[\"一般想答让面试官满意的答案还是有几点注意的地方\",{\"1\":{\"418\":1}}],[\"一般而言\",{\"1\":{\"288\":1}}],[\"一般而言读操作\",{\"1\":{\"288\":1}}],[\"一般这个中间层就是我们上文提到的负载均衡\",{\"1\":{\"268\":1}}],[\"一般面试的时候问这个问题主要是考察候选人的综合能力\",{\"1\":{\"267\":1}}],[\"一般做程序开发都会遇到这种业务需求\",{\"1\":{\"267\":1}}],[\"一般选择的标准可以参考这三个指标\",{\"1\":{\"266\":1}}],[\"一般单点登录的使用场景是多系统之间\",{\"1\":{\"265\":1}}],[\"一般客户端指的是cookie\",{\"1\":{\"264\":1}}],[\"一般处理错误的时候需要进行\",{\"1\":{\"262\":1}}],[\"一般处理错误的时候需要进行以下几点\",{\"1\":{\"262\":1}}],[\"一般在框架中都会封装一套属于框架自身的错误和异常处理模块\",{\"1\":{\"262\":1}}],[\"一般在做错误处理的时候这个函数会被register\",{\"1\":{\"262\":1}}],[\"一般php常见的错误级别有这几种\",{\"1\":{\"262\":1}}],[\"一般编程语言都有自己的错误处理机制\",{\"1\":{\"262\":1}}],[\"一般的框架都会实现命令的注册\",{\"1\":{\"260\":1}}],[\"一般最简单的实现就是如下\",{\"1\":{\"260\":1}}],[\"一般最多12个表\",{\"1\":{\"224\":1}}],[\"一般是由优化器在对sql语句进行分析时造成的\",{\"1\":{\"252\":1}}],[\"一般是机器ip32位的后八位\",{\"1\":{\"238\":1}}],[\"一般适用于更新频繁但查询比较少的表\",{\"1\":{\"250\":1}}],[\"一般建议搞一个\",{\"1\":{\"246\":1}}],[\"一般都是在并发下\",{\"1\":{\"269\":1}}],[\"一般都是在实际应用中采用混合模式复制\",{\"1\":{\"238\":1}}],[\"一般都是通过\",{\"1\":{\"8\":1}}],[\"一般达不到最大值\",{\"1\":{\"184\":1}}],[\"一般就是切断环路\",{\"1\":{\"159\":1}}],[\"一般有悲观锁和乐观锁两种方案~\",{\"1\":{\"97\":1}}],[\"一般根节点都是常驻内存的\",{\"1\":{\"72\":1}}],[\"一般根节点是常驻内存的\",{\"1\":{\"70\":1}}],[\"一般情况下都采用\",{\"1\":{\"353\":1}}],[\"一般情况下链式扩容能连锁反映五六次就很不幸了\",{\"1\":{\"299\":1}}],[\"一般情况下\",{\"1\":{\"69\":1,\"296\":1}}],[\"一般cap是切片长度的两倍\",{\"1\":{\"63\":1}}],[\"一般来说选择指针类型的receiver\",{\"1\":{\"43\":1}}],[\"一般来说\",{\"1\":{\"7\":1}}],[\"就行\",{\"1\":{\"496\":1}}],[\"就产生快照\",{\"1\":{\"352\":1}}],[\"就触发产生一次快照\",{\"1\":{\"352\":1}}],[\"就空了四个字节的闲置空间\",{\"1\":{\"301\":1}}],[\"就使字典进入平滑扩容过程\",{\"1\":{\"296\":1}}],[\"就需要扩容\",{\"1\":{\"296\":1}}],[\"就需要list的使用者将相关的函数指针赋值于list\",{\"1\":{\"295\":1}}],[\"就需要用到平衡二叉树了\",{\"1\":{\"68\":1}}],[\"就能取到flag\",{\"1\":{\"294\":1}}],[\"就和一个班里的同学学号不能重复\",{\"1\":{\"278\":1}}],[\"就把错误全面的展现出来\",{\"1\":{\"262\":2}}],[\"就把这篇文章发给她\",{\"1\":{\"73\":1}}],[\"就一定会记录2中前一种redolog\",{\"1\":{\"251\":1}}],[\"就像书的目录一样\",{\"1\":{\"246\":1}}],[\"就变成了这样\",{\"1\":{\"217\":1}}],[\"就用\",{\"1\":{\"199\":1}}],[\"就三步曲\",{\"1\":{\"192\":1}}],[\"就本质而言\",{\"1\":{\"168\":1}}],[\"就叫做回表\",{\"1\":{\"149\":1}}],[\"就修改失败或者重试\",{\"1\":{\"99\":1}}],[\"就可以利用\",{\"1\":{\"340\":1}}],[\"就可以包装成一个quicklistlzf结构\",{\"1\":{\"300\":1}}],[\"就可以了\",{\"1\":{\"299\":1}}],[\"就可以实现会话的跨域了\",{\"1\":{\"265\":1}}],[\"就可以修改成功\",{\"1\":{\"99\":1}}],[\"就可以直接从接口上调用它所保存的实例的方法\",{\"1\":{\"45\":1}}],[\"就要保证一个线程在修改时其它线程无法更新这行记录\",{\"1\":{\"97\":1}}],[\"就又会加载页9到内存中\",{\"1\":{\"72\":1}}],[\"就是因为执行了ioutil\",{\"1\":{\"503\":1}}],[\"就是12个goroutine\",{\"1\":{\"501\":1}}],[\"就是根据配置规则来触发\",{\"1\":{\"356\":1}}],[\"就是这里出现了问题\",{\"1\":{\"322\":1}}],[\"就是在配置主从复制时\",{\"1\":{\"309\":1}}],[\"就是把php文件当做脚本执行的一种方式\",{\"1\":{\"260\":1}}],[\"就是一块连续的内存空间\",{\"1\":{\"299\":1}}],[\"就是一种\",{\"1\":{\"213\":1}}],[\"就是一些编译好了的sql语句\",{\"1\":{\"169\":1}}],[\"就是最左优先\",{\"1\":{\"147\":1}}],[\"就是小表驱动大表\",{\"1\":{\"112\":1}}],[\"就是事务之间是进水不犯河水的\",{\"1\":{\"106\":1}}],[\"就是键值18对应的数据\",{\"1\":{\"72\":1}}],[\"就是咱们常用的用go关键字创建的执行体\",{\"1\":{\"18\":1}}],[\"就不会退出\",{\"1\":{\"502\":2}}],[\"就不得不提二叉查找树\",{\"1\":{\"66\":1}}],[\"就不难理解只有所有case都不满足条件时\",{\"1\":{\"7\":1}}],[\"就执行b类型里的特有方法\",{\"1\":{\"48\":1}}],[\"就执行a类型里的特有方法\",{\"1\":{\"48\":1}}],[\"就去其他处理器队列里偷\",{\"1\":{\"21\":1}}],[\"就会退出\",{\"1\":{\"502\":2}}],[\"就会启动一个读goroutine和写goroutine\",{\"1\":{\"502\":1}}],[\"就会在堆上分配\",{\"1\":{\"489\":1}}],[\"就会在返回到步骤2继续执行全量复制\",{\"1\":{\"318\":1}}],[\"就会\",{\"0\":{\"483\":1}}],[\"就会有一部分数据会被挤出去\",{\"1\":{\"322\":1}}],[\"就会返回continue命令\",{\"1\":{\"317\":1}}],[\"就会更大\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"就会导致出现例子中的直接报错的情况\",{\"1\":{\"44\":1}}],[\"就会调用都\",{\"1\":{\"8\":1}}],[\"就会出现死锁\",{\"1\":{\"4\":1}}],[\"其使用体验类似于线性数据结构\",{\"1\":{\"300\":1}}],[\"其余结点的zl字段指向的是经过压缩后的quicklistlzf\",{\"1\":{\"300\":2}}],[\"其余都有\",{\"1\":{\"245\":1}}],[\"其后一个结点的entry\",{\"1\":{\"299\":1}}],[\"其苟的程序到达了字节级别\",{\"1\":{\"299\":1}}],[\"其encoding都仅占用一个字节\",{\"1\":{\"299\":1}}],[\"其值为全f\",{\"1\":{\"299\":1}}],[\"其值为五个ascii字符组成的二进制数据\",{\"1\":{\"292\":1}}],[\"其定义与实现均未定义任何struct结构体\",{\"1\":{\"301\":1}}],[\"其定义与实现在src\",{\"1\":{\"298\":1}}],[\"其定义在src\",{\"1\":{\"297\":1}}],[\"其level\",{\"1\":{\"297\":2}}],[\"其标示着结点的得分\",{\"1\":{\"297\":1}}],[\"其最大的特点就是\",{\"1\":{\"297\":1}}],[\"其在内部实现时\",{\"1\":{\"296\":1}}],[\"其用意是这样的\",{\"1\":{\"296\":1}}],[\"其通过table字段间接的持有顺序表形式的bucket\",{\"1\":{\"296\":1}}],[\"其功能类似于c++标准库中的std\",{\"1\":{\"296\":1}}],[\"其内存占用如上图\",{\"1\":{\"301\":1}}],[\"其内存布局如下图\",{\"1\":{\"297\":1}}],[\"其内存布局如下图所示\",{\"1\":{\"295\":1,\"298\":1}}],[\"其内存布局如下所示\",{\"1\":{\"296\":1,\"301\":1}}],[\"其内部则是调用了\",{\"1\":{\"294\":1}}],[\"其末尾都带一个\",{\"1\":{\"294\":1}}],[\"其关键定义如下\",{\"1\":{\"294\":1,\"296\":1}}],[\"其底层至少支持两种不同的底层数据结构来实现\",{\"1\":{\"292\":1}}],[\"其底层实现的数据结构有8种\",{\"1\":{\"292\":1}}],[\"其value有多种类型\",{\"1\":{\"292\":1}}],[\"其他协程是不能获得读锁的\",{\"1\":{\"457\":1}}],[\"其他可能被访问的键会被淘汰\",{\"1\":{\"347\":1}}],[\"其他的错误进行了忽略\",{\"1\":{\"262\":1}}],[\"其他的lock将会竞争互斥锁\",{\"1\":{\"57\":1}}],[\"其他的lock操作将无法进行\",{\"1\":{\"57\":1}}],[\"其他线程对该资源进行操作的时候会被\",{\"1\":{\"212\":1}}],[\"其他情况\",{\"1\":{\"190\":1}}],[\"其他任何事务都不能对数据进行修改啦\",{\"1\":{\"101\":1}}],[\"其拷贝时间都是大差不差的\",{\"1\":{\"63\":1}}],[\"其虽然都是\",{\"1\":{\"44\":1}}],[\"其中包括正常情况下\",{\"1\":{\"502\":1}}],[\"其中包括但不限于缓冲区\",{\"1\":{\"327\":1}}],[\"其中第一个\",{\"1\":{\"502\":1}}],[\"其中一个产生随机数并写入到\",{\"1\":{\"418\":1}}],[\"其中128个是常用字符\",{\"1\":{\"370\":1}}],[\"其中lru\",{\"1\":{\"345\":1}}],[\"其中有连接主节点信息\",{\"1\":{\"312\":1}}],[\"其中关键定义如下\",{\"1\":{\"300\":1}}],[\"其中yyyyyyyy是高八位\",{\"1\":{\"299\":1}}],[\"其中低六位bitxxxxxx是用二进制保存的数据长度\",{\"1\":{\"299\":1}}],[\"其中还顺带实现了一个迭代器\",{\"1\":{\"296\":1}}],[\"其中type字段中存储的是本字典使用到的各种函数指针\",{\"1\":{\"296\":1}}],[\"其中sdshdr5实际并未使用到\",{\"1\":{\"294\":1}}],[\"其中sdshdr是头部\",{\"1\":{\"294\":1}}],[\"其中\",{\"1\":{\"230\":1,\"469\":1}}],[\"其中id为主键\",{\"1\":{\"72\":1}}],[\"其中最常用的是make创建和下标截取\",{\"1\":{\"63\":1}}],[\"其中animal称为内部struct\",{\"1\":{\"42\":1}}],[\"其中红色的g表示m对应的工作线程正在运行的goroutine\",{\"1\":{\"29\":1}}],[\"其它机器正常响应客户端的命令\",{\"1\":{\"358\":1}}],[\"其它自定义的struct类型\",{\"1\":{\"42\":1}}],[\"其它线程通过这个park唤醒该工作线程\",{\"1\":{\"34\":1}}],[\"其它线程需要知道系统调用的返回值\",{\"1\":{\"32\":1}}],[\"其它很多地方还需要访问它\",{\"1\":{\"29\":1}}],[\"其它的case都不会被阻塞\",{\"1\":{\"7\":1}}],[\"其创建和切换都在用户代码中完成而无需进入操作系统内核\",{\"1\":{\"27\":1}}],[\"其实就是\",{\"1\":{\"502\":1}}],[\"其实是已经加锁状态\",{\"1\":{\"460\":1}}],[\"其实是一个没有\",{\"1\":{\"401\":1}}],[\"其实被\",{\"1\":{\"401\":1}}],[\"其实想要从这些文件中恢复数据\",{\"1\":{\"357\":1}}],[\"其实时间复杂度并不高\",{\"1\":{\"299\":1}}],[\"其实现位于\",{\"1\":{\"295\":1,\"296\":1}}],[\"其实现位于src\",{\"1\":{\"294\":1}}],[\"其实现中核心的几行如下\",{\"1\":{\"294\":1}}],[\"其实\",{\"1\":{\"219\":1}}],[\"其实你也发现了这是一个链表\",{\"1\":{\"218\":1}}],[\"其实主要思路就是\",{\"1\":{\"215\":1}}],[\"其实只是三个字段\",{\"1\":{\"215\":1}}],[\"其实还有一个删除的flag字段\",{\"1\":{\"215\":1}}],[\"其实这些不是它们之前的区别\",{\"1\":{\"70\":1}}],[\"其实上面的b树我们也可以对各个节点加上链表\",{\"1\":{\"70\":1}}],[\"其实质是对当前三个属性的拷贝\",{\"1\":{\"63\":1}}],[\"其实csp概念早在1978年就被东尼\",{\"1\":{\"17\":1}}],[\"其实如果注意到select语句是在某一个goroutine中评估的\",{\"1\":{\"7\":1}}],[\"当\",{\"1\":{\"483\":1}}],[\"当管道关闭后\",{\"1\":{\"418\":1}}],[\"当next是true时总会将新进来的g放入下一次调度字段中\",{\"1\":{\"407\":1}}],[\"当创建一个g时\",{\"1\":{\"407\":1}}],[\"当这个\",{\"1\":{\"401\":1}}],[\"当服务器重启的时候会重新执行这些命令来恢复原始的数据\",{\"1\":{\"350\":1}}],[\"当内存达到maxmemory后\",{\"1\":{\"345\":1}}],[\"当slave断联时恢复数据使用\",{\"1\":{\"323\":1}}],[\"当select中的case都在禁用状态\",{\"1\":{\"7\":1}}],[\"当select未在循环中时\",{\"1\":{\"7\":1}}],[\"当主节点重启后\",{\"1\":{\"325\":1}}],[\"当主节点数据量在一瞬间特别大的时候\",{\"1\":{\"322\":1}}],[\"当主节点也就是master出现问题时\",{\"1\":{\"307\":1}}],[\"当执行一个命令为set\",{\"1\":{\"322\":1}}],[\"当断线重连时\",{\"1\":{\"321\":1}}],[\"当从节点故障时\",{\"1\":{\"328\":1}}],[\"当从节点挂掉的数量或者延迟过高时\",{\"1\":{\"319\":1}}],[\"当从节点第一次连接的时候根本就不知道主节点的runid\",{\"1\":{\"318\":1}}],[\"当从节点第一次连接主节点时\",{\"1\":{\"316\":1}}],[\"当从节点把自己的runid和复制偏移量发送给主节点\",{\"1\":{\"317\":1}}],[\"当master数据库被修改后\",{\"1\":{\"317\":1}}],[\"当在从节点重新启动后就可以在主节点直接查看到从节点的连接信息\",{\"1\":{\"310\":1}}],[\"当在程序中持有一个sds实例时\",{\"1\":{\"294\":1}}],[\"当只有一台服务器时内存肯定会到达峰值的\",{\"1\":{\"306\":1}}],[\"当只有读锁或者没有锁时\",{\"1\":{\"58\":1}}],[\"当数值为正数时\",{\"1\":{\"300\":1}}],[\"当数值为负数时\",{\"1\":{\"300\":1}}],[\"当数据更新导致的统计出错的时候可以使用\",{\"1\":{\"252\":1}}],[\"当encoding\",{\"1\":{\"298\":2}}],[\"当新旧bucket容量特别大时\",{\"1\":{\"296\":1}}],[\"当迁移完成后\",{\"1\":{\"296\":1}}],[\"当字典中存储的结点数目\",{\"1\":{\"296\":1}}],[\"当插入的秒杀请求数达到上限时\",{\"1\":{\"268\":1}}],[\"当部分后端机器挂掉时\",{\"1\":{\"266\":1}}],[\"当ip\",{\"1\":{\"266\":1}}],[\"当业务发展到一定程度之后\",{\"1\":{\"266\":1}}],[\"当命中了最左原则\",{\"1\":{\"246\":1}}],[\"当找到索引也就找到了数据\",{\"1\":{\"231\":1}}],[\"当需要访问数据时\",{\"1\":{\"231\":1}}],[\"当使用str1\",{\"1\":{\"438\":1}}],[\"当使用explain分析查询语句时\",{\"1\":{\"229\":1}}],[\"当使用mfind读取数据时\",{\"1\":{\"58\":1}}],[\"当值为0时\",{\"1\":{\"224\":1}}],[\"当生成read\",{\"1\":{\"215\":1}}],[\"当事务提交之后可以直接丢弃\",{\"1\":{\"215\":1}}],[\"当事务需要回滚时\",{\"1\":{\"199\":1}}],[\"当建表没有指定主键\",{\"1\":{\"215\":1}}],[\"当一个线程需要对一个共享资源进行操作的时候\",{\"1\":{\"212\":1}}],[\"当一个线程需要对共享资源进行操作的时候\",{\"1\":{\"212\":1}}],[\"当该线程持有该资源的锁的时候\",{\"1\":{\"212\":1}}],[\"当线程要对一个共享资源进行操作的时候\",{\"1\":{\"212\":1}}],[\"当触发某个事件时\",{\"1\":{\"170\":1}}],[\"当视图来自多个基本表时\",{\"1\":{\"164\":1}}],[\"当用户要进行数据的写入时\",{\"1\":{\"157\":1}}],[\"当用户要进行数据的读取时\",{\"1\":{\"157\":1}}],[\"当查询使用聚簇索引时\",{\"1\":{\"150\":1}}],[\"当无法使用statement的时候使用row\",{\"1\":{\"140\":1}}],[\"当某个sql在从服务器上执行的时间稍长\",{\"1\":{\"118\":1}}],[\"当我们创建一个组合索引的时候\",{\"1\":{\"111\":1,\"147\":1}}],[\"当我们插入或删除数据导致不满足平衡二叉树不平衡时\",{\"1\":{\"68\":1}}],[\"当系统崩溃\",{\"1\":{\"107\":1,\"194\":1}}],[\"当当\",{\"1\":{\"85\":1}}],[\"当原\",{\"1\":{\"63\":1}}],[\"当chan被关闭了\",{\"1\":{\"484\":1}}],[\"当channel的某一端\",{\"1\":{\"4\":1}}],[\"当cap不够时进行动态扩容\",{\"1\":{\"63\":1}}],[\"当有写锁时\",{\"1\":{\"58\":1}}],[\"当释放了释放了一个临界区\",{\"1\":{\"57\":1}}],[\"当接口实例中保存了自定义类型的实例后\",{\"1\":{\"45\":1}}],[\"当其基本类型包含\",{\"1\":{\"44\":1}}],[\"当时我们说过\",{\"1\":{\"29\":1}}],[\"当goroutine被调度起来运行时\",{\"1\":{\"29\":1}}],[\"当goroutine被调离cpu时\",{\"1\":{\"29\":1}}],[\"当g完成了系统调用\",{\"1\":{\"22\":1}}],[\"当前事务id\",{\"1\":{\"219\":1}}],[\"当前读\",{\"1\":{\"214\":1}}],[\"当前线程要进来修改数据时\",{\"1\":{\"98\":1}}],[\"当前struct类型本身\",{\"1\":{\"42\":1}}],[\"当前正在运行的goroutine以及与m绑定的p等信息\",{\"1\":{\"34\":1}}],[\"当前正在执行的goroutine以及是否空闲等等状态信息之外\",{\"1\":{\"29\":1}}],[\"当前的\",{\"1\":{\"19\":1}}],[\"当前占用的线程\",{\"1\":{\"19\":1}}],[\"当然自动触发的整体时间还跟redis的定时任务频率有关系\",{\"1\":{\"356\":1}}],[\"当然如果你想要禁用rdb配置\",{\"1\":{\"352\":1}}],[\"当然这不算开启\",{\"1\":{\"218\":1}}],[\"当然除了\",{\"1\":{\"212\":1}}],[\"当然还有所以索引优化等方案~\",{\"1\":{\"110\":1}}],[\"当然\",{\"1\":{\"16\":1,\"109\":1}}],[\"则溢出\",{\"1\":{\"489\":1}}],[\"则为通道关闭\",{\"1\":{\"483\":1}}],[\"则目标值输出\",{\"1\":{\"473\":1}}],[\"则唤醒\",{\"1\":{\"421\":1}}],[\"则会依次从defer表中出栈并执行\",{\"1\":{\"405\":1}}],[\"则会让出执行权\",{\"1\":{\"401\":1}}],[\"则会直接进行全量复制\",{\"1\":{\"321\":1}}],[\"则会发送\",{\"1\":{\"318\":1}}],[\"则会命中覆盖索引\",{\"1\":{\"246\":1}}],[\"则用1字节存储\",{\"1\":{\"301\":1}}],[\"则encoding\",{\"1\":{\"299\":5}}],[\"则encoding和data挤在同一个字节中\",{\"1\":{\"299\":1}}],[\"则encoding和data的规约如下\",{\"1\":{\"299\":1}}],[\"则encoding占用五个字节\",{\"1\":{\"299\":1}}],[\"则prevlen字段占五字节\",{\"1\":{\"299\":1}}],[\"则prevlen字段占一字节\",{\"1\":{\"299\":1}}],[\"则其forward字段指向的结点\",{\"1\":{\"297\":1}}],[\"则置先释放原旧bucket数组\",{\"1\":{\"296\":1}}],[\"则调用dictexpand进入平滑扩容状态\",{\"1\":{\"296\":1}}],[\"则初始化字典\",{\"1\":{\"296\":1}}],[\"则什么也不做\",{\"1\":{\"296\":1}}],[\"则开始扩容\",{\"1\":{\"296\":1}}],[\"则暂停结点迁移\",{\"1\":{\"296\":1}}],[\"则步进增长sds\",{\"1\":{\"294\":1}}],[\"则是redis实现的另外一种数据结构\",{\"1\":{\"292\":1}}],[\"则更新缓存\",{\"1\":{\"288\":1}}],[\"则直接更新数据源\",{\"1\":{\"288\":1}}],[\"则缓存服务取回源数据更新缓存\",{\"1\":{\"288\":1}}],[\"则整个缓存系统不可用\",{\"1\":{\"285\":1}}],[\"则不会淘汰\",{\"1\":{\"345\":1}}],[\"则不会存在这些缓存数据同时失效的情况\",{\"1\":{\"284\":1}}],[\"则不迁移结点\",{\"1\":{\"296\":1}}],[\"则不使用索引\",{\"1\":{\"78\":1}}],[\"则说明删除了返回空\",{\"1\":{\"219\":1}}],[\"则说明已被删除则返回空\",{\"1\":{\"219\":1}}],[\"则根据回滚指针找到上一个版本记录\",{\"1\":{\"219\":1}}],[\"则返回的是空\",{\"1\":{\"219\":1}}],[\"则返回\",{\"1\":{\"218\":2}}],[\"则可见\",{\"1\":{\"218\":1}}],[\"则可能会永远被send阻塞\",{\"1\":{\"7\":1}}],[\"则主键冲突\",{\"1\":{\"184\":1}}],[\"则隐式的生成一个键来建立聚簇索引\",{\"1\":{\"150\":1}}],[\"则挑选一个唯一键建立聚簇索引\",{\"1\":{\"150\":1}}],[\"则就会引起一个运行时错误\",{\"1\":{\"58\":2}}],[\"则lock就会阻塞直到该锁可用\",{\"1\":{\"58\":1}}],[\"则输出\",{\"1\":{\"48\":2,\"473\":1}}],[\"则这个goroutine会被放入全局运行队列被其它工作线程调度\",{\"1\":{\"32\":1}}],[\"则迟早会被send阻塞\",{\"1\":{\"7\":1}}],[\"则所有其它case都直接结束评估\",{\"1\":{\"7\":1}}],[\"则执行default\",{\"1\":{\"7\":1}}],[\"则随机选择一个进行处理\",{\"1\":{\"7\":1}}],[\"则阻塞直到某个语句块可以被处理\",{\"1\":{\"7\":1}}],[\"b001\",{\"1\":{\"490\":1}}],[\"bbbbbbb\",{\"1\":{\"415\":1}}],[\"bbc\",{\"1\":{\"238\":1}}],[\"b命令会改变值x\",{\"1\":{\"386\":1}}],[\"b后退一步\",{\"1\":{\"386\":1}}],[\"bgrewriteaof\",{\"1\":{\"356\":1}}],[\"bgsave\",{\"1\":{\"333\":1,\"334\":1,\"352\":2,\"355\":3}}],[\"b在使用时\",{\"1\":{\"246\":1}}],[\"b+\",{\"1\":{\"246\":1}}],[\"b+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据\",{\"0\":{\"150\":1}}],[\"b+树的叶子节点有一条链相连\",{\"1\":{\"148\":1}}],[\"b+树的阶数是等于键值的数量的\",{\"1\":{\"70\":1}}],[\"b+树使用like\",{\"1\":{\"134\":1}}],[\"b+树支持order\",{\"1\":{\"134\":1}}],[\"b+树支持联合索引的最左侧原则\",{\"1\":{\"134\":1}}],[\"b+树可以进行范围查询\",{\"1\":{\"134\":1}}],[\"b+树非叶子节点上是不存储数据的\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"b+树是对b树的进一步优化\",{\"1\":{\"70\":1}}],[\"b+树\",{\"0\":{\"70\":1,\"88\":1},\"1\":{\"80\":1}}],[\"b+树就是从他们仨演化来的\",{\"1\":{\"66\":1}}],[\"b+树索引的所有数据均存储在叶子节点\",{\"1\":{\"91\":1,\"148\":1}}],[\"b+树索引的叶子节点并不存储数据\",{\"1\":{\"70\":1}}],[\"b+树索引按照存储方式的不同分为聚集索引和非聚集索引\",{\"1\":{\"71\":1}}],[\"b+树索引\",{\"1\":{\"66\":1}}],[\"b表id也需要有索引\",{\"1\":{\"206\":1}}],[\"b表的id为索引\",{\"1\":{\"206\":1}}],[\"btree\",{\"1\":{\"145\":1}}],[\"block\",{\"1\":{\"483\":1,\"484\":1}}],[\"blocked\",{\"1\":{\"34\":2}}],[\"blog\",{\"1\":{\"235\":1,\"238\":2,\"266\":2}}],[\"blob值被视为二进制字符串\",{\"1\":{\"131\":1}}],[\"blob用于存储二进制数据\",{\"1\":{\"131\":1}}],[\"blob和text有什么区别\",{\"0\":{\"131\":1}}],[\"b交替执行\",{\"1\":{\"96\":1}}],[\"bv\",{\"1\":{\"69\":1}}],[\"b树和b+树的区别\",{\"0\":{\"148\":1}}],[\"b树查找数据读取磁盘的次数将会很少\",{\"1\":{\"69\":1}}],[\"b树相对于平衡二叉树\",{\"1\":{\"69\":1}}],[\"b树\",{\"0\":{\"69\":1},\"1\":{\"69\":1}}],[\"b\",{\"0\":{\"465\":1},\"1\":{\"41\":1,\"93\":1,\"112\":7,\"206\":4,\"218\":1,\"228\":1,\"246\":2,\"265\":3,\"386\":1,\"410\":7,\"436\":2,\"438\":1,\"445\":5,\"446\":3,\"447\":1,\"448\":1,\"449\":1,\"450\":4,\"451\":1,\"452\":1,\"453\":1,\"454\":1,\"489\":1,\"490\":5,\"496\":2,\"502\":5,\"507\":1}}],[\"bin\",{\"1\":{\"238\":3}}],[\"binlog有两种模式\",{\"1\":{\"244\":1}}],[\"binlog是server层的日志\",{\"1\":{\"244\":1}}],[\"binlogname\",{\"1\":{\"238\":1}}],[\"binlog\",{\"1\":{\"238\":2,\"244\":3}}],[\"binlog线程\",{\"1\":{\"192\":1}}],[\"binlog=1\",{\"1\":{\"119\":1}}],[\"biz=mzu1otg5ndkzoa==\",{\"1\":{\"37\":1}}],[\"bitch\",{\"1\":{\"414\":2}}],[\"bits\",{\"1\":{\"294\":4,\"300\":6}}],[\"bit\",{\"1\":{\"36\":1,\"300\":4}}],[\"by中无法使用\",{\"1\":{\"229\":1}}],[\"by语句中也会用到索引\",{\"1\":{\"228\":1}}],[\"by子句中\",{\"1\":{\"144\":1}}],[\"by或者group\",{\"1\":{\"144\":1}}],[\"by排序\",{\"1\":{\"134\":1}}],[\"by以及聚合函数问题\",{\"1\":{\"86\":1}}],[\"by\",{\"1\":{\"35\":2,\"86\":1,\"93\":2,\"228\":1,\"229\":1,\"234\":1,\"300\":1,\"341\":1,\"502\":2}}],[\"bytes\",{\"1\":{\"12\":1,\"130\":1,\"200\":4,\"299\":5,\"300\":4,\"339\":1,\"341\":3,\"342\":1,\"450\":3,\"502\":1}}],[\"byte\",{\"1\":{\"12\":1,\"294\":1,\"300\":4,\"339\":1,\"393\":1,\"401\":2,\"496\":2,\"502\":1}}],[\"bp\",{\"1\":{\"32\":1}}],[\"boy\",{\"1\":{\"414\":1}}],[\"bottom\",{\"1\":{\"386\":3}}],[\"both\",{\"1\":{\"299\":1}}],[\"bounds\",{\"1\":{\"31\":1}}],[\"boolean\",{\"1\":{\"300\":1}}],[\"bool\",{\"1\":{\"19\":1,\"33\":1,\"34\":2,\"52\":1,\"53\":1,\"300\":1,\"366\":2,\"370\":3,\"374\":1,\"378\":1,\"382\":1,\"421\":1,\"424\":2,\"431\":3,\"478\":2,\"483\":2,\"484\":2}}],[\"bodyeofsignal\",{\"1\":{\"502\":5}}],[\"bodyeof\",{\"1\":{\"502\":5}}],[\"body\",{\"1\":{\"12\":5,\"500\":2,\"501\":1,\"502\":12,\"503\":2}}],[\"build409982591\",{\"1\":{\"490\":1}}],[\"build\",{\"1\":{\"490\":3}}],[\"bucket\",{\"1\":{\"296\":1}}],[\"buckets\",{\"1\":{\"296\":3}}],[\"bucket中出现冲突的概率会越来越大\",{\"1\":{\"296\":1}}],[\"bucket的容量适宜于为2的幂次\",{\"1\":{\"296\":1}}],[\"bucket的容量存储在size字段中\",{\"1\":{\"296\":1}}],[\"but\",{\"1\":{\"12\":1,\"32\":1,\"33\":1,\"296\":1,\"346\":1}}],[\"bufio\",{\"1\":{\"502\":1}}],[\"buf是真实存储用户数据的地方\",{\"1\":{\"294\":1}}],[\"buffer反而会增加维护成本\",{\"1\":{\"250\":1}}],[\"buffer类似于缓冲\",{\"1\":{\"250\":1}}],[\"buffer是可以持久化的数据\",{\"1\":{\"250\":1}}],[\"buffer中\",{\"1\":{\"250\":1}}],[\"buffer命中时\",{\"1\":{\"231\":1}}],[\"buffer把索引先缓存到内存中\",{\"1\":{\"231\":1}}],[\"buffer\",{\"0\":{\"251\":1},\"1\":{\"141\":1,\"198\":1,\"237\":1,\"250\":1,\"251\":3,\"450\":2,\"478\":2,\"502\":3}}],[\"buffered\",{\"1\":{\"3\":1}}],[\"bufw\",{\"1\":{\"12\":1}}],[\"bufr\",{\"1\":{\"12\":1}}],[\"buf\",{\"1\":{\"12\":5,\"294\":5,\"356\":1,\"502\":2}}],[\"bestkey\",{\"1\":{\"346\":4}}],[\"behind\",{\"1\":{\"288\":1}}],[\"been\",{\"1\":{\"36\":1}}],[\"between\",{\"1\":{\"32\":1,\"234\":1,\"296\":1}}],[\"because\",{\"1\":{\"12\":1,\"296\":1,\"299\":2}}],[\"be\",{\"1\":{\"12\":1,\"32\":2,\"33\":1,\"35\":1,\"36\":1,\"57\":1,\"296\":1,\"299\":2,\"502\":1}}],[\"before\",{\"0\":{\"454\":1},\"1\":{\"12\":1,\"34\":1,\"171\":3,\"502\":2}}],[\"baidu\",{\"1\":{\"500\":1}}],[\"ban\",{\"1\":{\"424\":12}}],[\"balance\",{\"1\":{\"69\":1}}],[\"backlog\",{\"1\":{\"322\":1,\"326\":1}}],[\"backward\",{\"1\":{\"297\":1}}],[\"backserver\",{\"1\":{\"266\":5}}],[\"back\",{\"1\":{\"35\":1,\"288\":1,\"299\":1,\"502\":1}}],[\"background\",{\"1\":{\"12\":1,\"424\":1}}],[\"barriers\",{\"1\":{\"32\":3}}],[\"basecontext\",{\"1\":{\"12\":3}}],[\"basectx\",{\"1\":{\"12\":4}}],[\"break\",{\"1\":{\"12\":1,\"112\":2,\"296\":1,\"299\":3,\"346\":1,\"396\":1}}],[\"break是退出当前select\",{\"1\":{\"7\":1}}],[\"break关键字中断\",{\"1\":{\"7\":1}}],[\"但如果你调用的域名一直是同一个的话\",{\"1\":{\"503\":1}}],[\"但如果此时忘了\",{\"1\":{\"503\":1}}],[\"但a会逃逸到堆\",{\"1\":{\"490\":1}}],[\"但在go则ok\",{\"1\":{\"490\":1}}],[\"但在刚刚被访问后其被淘汰概率很低\",{\"1\":{\"347\":1}}],[\"但其引用的值一定是在堆上\",{\"1\":{\"489\":1}}],[\"但其他的111func\",{\"1\":{\"400\":1}}],[\"但其具体返回的地址是不一样的\",{\"1\":{\"44\":1}}],[\"但与lru不同\",{\"1\":{\"347\":1}}],[\"但与此同时\",{\"1\":{\"295\":1}}],[\"但现象为增量数据无法同步至从节点\",{\"1\":{\"345\":1}}],[\"但zipmap是直接持有数据的\",{\"1\":{\"301\":1}}],[\"但对于字典中的键值均为二进制数据\",{\"1\":{\"301\":1}}],[\"但引入了新的问题\",{\"1\":{\"300\":1}}],[\"但这种情况的概率十分的小\",{\"1\":{\"299\":1}}],[\"但代码中的时间复杂度是o\",{\"1\":{\"299\":1}}],[\"但它的缺点也十分明显\",{\"1\":{\"299\":1}}],[\"但它确实保存了两个指针\",{\"1\":{\"47\":1}}],[\"但位于int64\",{\"1\":{\"299\":1}}],[\"但小于2^32\",{\"1\":{\"299\":1}}],[\"但小于16384\",{\"1\":{\"299\":1}}],[\"但实际数量需要一个个entry的去遍历所有entry才能得到\",{\"1\":{\"299\":1}}],[\"但实例有两种类型\",{\"1\":{\"43\":1}}],[\"但区域划分比较复杂\",{\"1\":{\"299\":1}}],[\"但为了从牙缝里节省内存\",{\"1\":{\"299\":1}}],[\"但内存操作的时间开销上升了\",{\"1\":{\"298\":1}}],[\"但凡有一个数值元素的值超过了int32\",{\"1\":{\"298\":1}}],[\"但至少保证在迭代起始时\",{\"1\":{\"296\":1}}],[\"但比tlv复杂的\",{\"1\":{\"292\":1}}],[\"但具体在底层实现上\",{\"1\":{\"292\":1}}],[\"但读操作更新缓存比写操作失效缓存慢\",{\"1\":{\"288\":1}}],[\"但不可避免一次网络i\",{\"1\":{\"282\":1}}],[\"但同样也增加额外技术考虑因素\",{\"1\":{\"281\":1}}],[\"但同时也是不可以比较的\",{\"1\":{\"44\":1}}],[\"但考试成绩可以相同\",{\"1\":{\"278\":1}}],[\"但和列表不同的是集合中\",{\"1\":{\"277\":1}}],[\"但脚本仍会结束\",{\"1\":{\"262\":1}}],[\"但磁盘文件的大小是不会变的\",{\"1\":{\"255\":1}}],[\"但会增加查询扫描次数\",{\"1\":{\"253\":1}}],[\"但drop普通索引不会\",{\"1\":{\"246\":1}}],[\"但此时的\",{\"1\":{\"219\":1}}],[\"但多多益善嘛\",{\"1\":{\"219\":1}}],[\"但后来发现并不是很正确\",{\"1\":{\"215\":1}}],[\"但还是最好自己公司有一套分布式唯一id生产方案吧\",{\"1\":{\"183\":1}}],[\"但rwmutex显然更适用于读多写少的场景\",{\"1\":{\"59\":1}}],[\"但也因此而出现了随机性\",{\"1\":{\"57\":1}}],[\"但也可以用来向channel发送数据\",{\"1\":{\"7\":1}}],[\"但也可以使用range来迭代channel\",{\"1\":{\"6\":1}}],[\"但达不到我们预想的要求\",{\"1\":{\"53\":1}}],[\"但可以处理转换失败时的panic\",{\"1\":{\"48\":1}}],[\"但可以通过gomaxprocs修改\",{\"1\":{\"37\":1}}],[\"但真实的调度代码错综复杂\",{\"1\":{\"29\":1}}],[\"但并未详细说明它们之间是如何对应起来的\",{\"1\":{\"29\":1}}],[\"但是泄漏的goroutine个数就让我迷糊了\",{\"1\":{\"501\":1}}],[\"但是由于返回时被外部引用\",{\"1\":{\"489\":1}}],[\"但是第二个\",{\"1\":{\"478\":1}}],[\"但是读到的内容根据通道内关闭前是否有元素而不同\",{\"1\":{\"478\":1}}],[\"但是过一会会回收掉\",{\"1\":{\"450\":1}}],[\"但是程序运行会panic\",{\"1\":{\"448\":1}}],[\"但是为什么对\",{\"1\":{\"438\":1}}],[\"但是因为\",{\"1\":{\"437\":1}}],[\"但是map是并发读写不安全的\",{\"1\":{\"412\":1}}],[\"但是不建议超过\",{\"1\":{\"354\":1}}],[\"但是会继续执行\",{\"1\":{\"353\":1}}],[\"但是会导致少卖\",{\"1\":{\"269\":1}}],[\"但是也最不安全\",{\"1\":{\"353\":1}}],[\"但是这里可以考虑一下\",{\"1\":{\"318\":1}}],[\"但是这个问题不是那么简单的\",{\"1\":{\"260\":1}}],[\"但是对于redis主从复制的工作流程和常见问题很多都没有深入的了解\",{\"1\":{\"304\":1}}],[\"但是score\",{\"1\":{\"278\":1}}],[\"但是select\",{\"1\":{\"105\":1}}],[\"但是你在淘宝上登录之后在天猫上也可以访问自己的个人中心\",{\"1\":{\"265\":1}}],[\"但是脚本不会终止运行\",{\"1\":{\"262\":1}}],[\"但是在实现生产环境可不是就这样完事了\",{\"1\":{\"309\":1}}],[\"但是在实际过程中是不可能只有俩台redis服务器来做主从复制的\",{\"1\":{\"305\":1}}],[\"但是在可以正常运行的脚本里面也可能会有类似的通知\",{\"1\":{\"262\":1}}],[\"但是在更新数据时效率太低\",{\"1\":{\"246\":1}}],[\"但是在数据更改比较大的情况下\",{\"1\":{\"238\":1}}],[\"但是很安全\",{\"1\":{\"353\":1}}],[\"但是很多情况下无法正确复制数据\",{\"1\":{\"238\":1}}],[\"但是很抱歉\",{\"1\":{\"19\":1}}],[\"但是特消耗存储空间\",{\"1\":{\"230\":1}}],[\"但是突然之间\",{\"1\":{\"190\":1}}],[\"但是它无序的\",{\"1\":{\"183\":1}}],[\"但是它到底存放了什么东西\",{\"1\":{\"45\":1}}],[\"但是如果数据量过大\",{\"1\":{\"183\":1}}],[\"但是从服务器的里面读取binlog的线程仅有一个\",{\"1\":{\"118\":1}}],[\"但是平衡二叉树可是每个节点只存储一个键值和数据的\",{\"1\":{\"90\":1}}],[\"但是和内存相比\",{\"1\":{\"69\":1}}],[\"但是和上个锁的案例有个不同的地方是多个协程之间不再是对同一个key进行操作\",{\"1\":{\"53\":1}}],[\"但是\",{\"1\":{\"68\":1,\"415\":1}}],[\"但是要问到为什么用b+树\",{\"1\":{\"66\":1}}],[\"但是追加数据会影响int1\",{\"1\":{\"63\":1}}],[\"但是追加数据不会影响ints\",{\"1\":{\"63\":1}}],[\"但是若一个写锁在占用锁\",{\"1\":{\"58\":1}}],[\"但是我们代码运行下来发现是一直输出数据\",{\"1\":{\"8\":1}}],[\"但重点在于计时器激活后\",{\"1\":{\"8\":1}}],[\"但允许case语句块为空块\",{\"1\":{\"7\":1}}],[\"不知道\",{\"1\":{\"507\":1}}],[\"不进行resp\",{\"1\":{\"501\":1}}],[\"不进行排序\",{\"1\":{\"178\":1}}],[\"不为空\",{\"1\":{\"484\":1}}],[\"不为空那么就会指向回滚指针的地址\",{\"1\":{\"215\":1}}],[\"不准使用额外的储存结构\",{\"1\":{\"370\":1}}],[\"不淘汰\",{\"1\":{\"345\":1}}],[\"不匹配就是复制积压缓冲区溢出了\",{\"1\":{\"318\":1}}],[\"不超过\",{\"1\":{\"300\":4}}],[\"不超过4kb\",{\"1\":{\"300\":1}}],[\"不超过32\",{\"1\":{\"297\":1}}],[\"不希望使用者感知到其内部的实现\",{\"1\":{\"300\":1}}],[\"不预留空间\",{\"1\":{\"298\":1}}],[\"不涉及用户数据的拷贝\",{\"1\":{\"296\":1}}],[\"不分配额外的预留空间\",{\"1\":{\"294\":1}}],[\"不包括16384\",{\"1\":{\"299\":1}}],[\"不包括64\",{\"1\":{\"299\":1}}],[\"不包括末尾\",{\"1\":{\"294\":1}}],[\"不包括末尾的\",{\"1\":{\"294\":1}}],[\"不包括重复行\",{\"1\":{\"178\":1}}],[\"不更新数据源\",{\"1\":{\"288\":1}}],[\"不做任何缓存操作\",{\"1\":{\"288\":1}}],[\"不存在资源访问时\",{\"1\":{\"286\":1}}],[\"不存在脏页\",{\"1\":{\"251\":1}}],[\"不错\",{\"1\":{\"259\":1}}],[\"不用回表操作\",{\"1\":{\"246\":1}}],[\"不用加锁\",{\"1\":{\"214\":1}}],[\"不过限于篇幅\",{\"1\":{\"296\":1}}],[\"不过你仍然可以获取\",{\"1\":{\"262\":1}}],[\"不过这次我们不是比较前缀出现的次数而是整个列的记录不重复的次数\",{\"1\":{\"230\":1}}],[\"不过在order\",{\"1\":{\"229\":1}}],[\"不容易吧\",{\"1\":{\"219\":1}}],[\"不解释了\",{\"1\":{\"219\":1}}],[\"不成立的话就把秒杀用户id加入到秒杀队列中\",{\"1\":{\"268\":1}}],[\"不成立的话就对商品库存进行\",{\"1\":{\"268\":1}}],[\"不成立进入最后一步发现在活跃事务数组中故不可见且此条记录回滚指针为null所以返回空\",{\"1\":{\"219\":1}}],[\"不成立进入下一步判断\",{\"1\":{\"219\":1}}],[\"不成立再进入最后一轮判断是否在活跃事务列表中\",{\"1\":{\"219\":1}}],[\"不成立故进入下一轮发现\",{\"1\":{\"219\":1}}],[\"不成立故进入下一轮\",{\"1\":{\"219\":1}}],[\"不符合\",{\"1\":{\"218\":2}}],[\"不然就进入下一轮判断\",{\"1\":{\"215\":1}}],[\"不对它进行加锁\",{\"1\":{\"212\":1}}],[\"不可能对一台服务器进行无限升级的\",{\"1\":{\"306\":1}}],[\"不可见\",{\"1\":{\"218\":1}}],[\"不可回滚\",{\"1\":{\"177\":2}}],[\"不可重复\",{\"1\":{\"173\":1}}],[\"不可重复读呢\",{\"0\":{\"96\":1}}],[\"不统计\",{\"1\":{\"167\":1}}],[\"不剥夺条件\",{\"1\":{\"159\":1}}],[\"不是索引键那么innodb将实行表锁\",{\"1\":{\"158\":1}}],[\"不是容量为1的buffered\",{\"1\":{\"3\":1}}],[\"不一定是紧邻的\",{\"1\":{\"297\":1}}],[\"不一定\",{\"1\":{\"152\":1}}],[\"不应\",{\"1\":{\"151\":7}}],[\"不必从数据表中读取\",{\"1\":{\"149\":1}}],[\"不必读取数据行\",{\"1\":{\"143\":1}}],[\"不允许使用额外的存储结构\",{\"1\":{\"370\":1}}],[\"不允许有重复的元素\",{\"1\":{\"277\":1}}],[\"不允许添加和删除数据\",{\"1\":{\"164\":1}}],[\"不允许为null\",{\"1\":{\"143\":1}}],[\"不允许fall\",{\"1\":{\"7\":1}}],[\"不记录sql语句上下文相关信息\",{\"1\":{\"140\":1}}],[\"不需要记录每一行的变化\",{\"1\":{\"140\":1}}],[\"不需要p就可以独立运行\",{\"1\":{\"23\":1}}],[\"不管成功与否\",{\"1\":{\"106\":1}}],[\"不管当前slice具体有多少个元素\",{\"1\":{\"63\":1}}],[\"不支持\",{\"1\":{\"87\":1}}],[\"不能使用队列或者栈作为辅助\",{\"1\":{\"469\":1}}],[\"不能编译\",{\"1\":{\"445\":1,\"446\":1,\"447\":1,\"448\":1,\"449\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"454\":1}}],[\"不能定义为\",{\"1\":{\"414\":1}}],[\"不能是rdb还是aof都是先写入一个临时文件\",{\"1\":{\"356\":1}}],[\"不能通过索引下标获取元素\",{\"1\":{\"277\":1}}],[\"不能访问\",{\"1\":{\"265\":1}}],[\"不能有函数操作\",{\"1\":{\"144\":1}}],[\"不能再依赖数据库自身的主键生成机制啦\",{\"1\":{\"86\":1}}],[\"不能动态扩容的\",{\"1\":{\"63\":1}}],[\"不在存储所有的数据了\",{\"1\":{\"72\":1}}],[\"不同方案在不同场景下是有各自优劣的\",{\"1\":{\"288\":1}}],[\"不同应用场景下对缓存数据的一致性要求不同\",{\"1\":{\"284\":1}}],[\"不同的是\",{\"1\":{\"415\":1}}],[\"不同的是它调用的是runtime\",{\"1\":{\"405\":1}}],[\"不同的是两者实现的存储方式不一样\",{\"1\":{\"231\":1}}],[\"不同的并发模型的协作方式也不尽相同\",{\"1\":{\"16\":1}}],[\"不同类型的联接执行计划\",{\"1\":{\"130\":1}}],[\"不同类型更不能互转\",{\"1\":{\"48\":1}}],[\"不会泄露\",{\"1\":{\"502\":1}}],[\"不会影响\",{\"1\":{\"438\":1}}],[\"不会影响外部原始实例\",{\"1\":{\"43\":1}}],[\"不会覆写被组合的\",{\"1\":{\"408\":1}}],[\"不会再降级\",{\"1\":{\"298\":1}}],[\"不会再次进行回表查询\",{\"1\":{\"152\":1}}],[\"不会使用索引\",{\"1\":{\"246\":1}}],[\"不会忽略列值为null\",{\"1\":{\"167\":2}}],[\"不会出现死锁\",{\"1\":{\"133\":1}}],[\"不会指向任何数据结构\",{\"1\":{\"41\":1}}],[\"不光是这个schedule函数会需要访问m\",{\"1\":{\"29\":1}}],[\"不给你调用😏\",{\"1\":{\"19\":1}}],[\"所谓会话管理指的是因为http协议是无状态的一种协议\",{\"1\":{\"264\":1}}],[\"所谓的类型\",{\"1\":{\"299\":1}}],[\"所谓的\",{\"1\":{\"296\":1}}],[\"所谓的安全与否\",{\"1\":{\"296\":1}}],[\"所谓的对goroutine的调度\",{\"1\":{\"28\":1}}],[\"所谓的太重\",{\"1\":{\"27\":1}}],[\"所有键按lfu淘汰\",{\"1\":{\"347\":1}}],[\"所有key随机淘汰\",{\"1\":{\"345\":1}}],[\"所有key中按照最近最少使用lru原则剔除key\",{\"1\":{\"345\":1}}],[\"所有key的lru机制\",{\"1\":{\"345\":1}}],[\"所有存储数值的entry\",{\"1\":{\"299\":1}}],[\"所有数据都位于一个稳定的取值范围中\",{\"1\":{\"298\":1}}],[\"所有结点的实际数据\",{\"1\":{\"296\":1}}],[\"所有创建sds实例的接口\",{\"1\":{\"294\":1}}],[\"所有减库存操作都在redis中进行\",{\"1\":{\"268\":1}}],[\"所有引擎都可以使用\",{\"1\":{\"244\":1}}],[\"所有位于全局运行队列中的g形成一个链表\",{\"1\":{\"33\":1}}],[\"所有的操作都是在从节点来操作\",{\"1\":{\"309\":1}}],[\"所有的一切都是基于统一浏览器上\",{\"1\":{\"265\":1}}],[\"所有的错误和异常都在这里进行处理\",{\"1\":{\"262\":1}}],[\"所有的异常处理类都继承它\",{\"1\":{\"262\":1}}],[\"所有的数据行\",{\"1\":{\"177\":1}}],[\"所有的m构成的一个链表\",{\"1\":{\"37\":1}}],[\"所有的消息都通过channel传输\",{\"1\":{\"17\":1}}],[\"所有的case块都是按源代码书写顺序进行评估的\",{\"1\":{\"7\":1}}],[\"所有case都不满足条件时\",{\"1\":{\"7\":1}}],[\"所以答案就是3个goroutine\",{\"1\":{\"503\":1}}],[\"所以答案是13\",{\"1\":{\"501\":1}}],[\"所以结论呼之欲出了\",{\"1\":{\"503\":1}}],[\"所以会在堆上分配\",{\"1\":{\"489\":1}}],[\"所以会优先输出10\",{\"1\":{\"410\":1}}],[\"所以编译器没法知道变量什么时候才会被释放\",{\"1\":{\"489\":1}}],[\"所以追加数据时会从len\",{\"1\":{\"411\":1}}],[\"所以上面的代码其实可以等价于这样\",{\"1\":{\"401\":1}}],[\"所以上面的\",{\"1\":{\"401\":1}}],[\"所以上面的赋值过程是让空接口any保存各个数据对象的类型和对象的值\",{\"1\":{\"47\":1}}],[\"所以他没有name这个字段\",{\"1\":{\"392\":1}}],[\"所以直接对\",{\"1\":{\"391\":1}}],[\"所以第一次发送的指令是psync\",{\"1\":{\"318\":1}}],[\"所以针对以上俩个问题\",{\"1\":{\"306\":1}}],[\"所以如果值的变更导致闲置空间大于254的话\",{\"1\":{\"301\":1}}],[\"所以实际上\",{\"1\":{\"300\":1}}],[\"所以实际上有四种不同的头部\",{\"1\":{\"294\":1}}],[\"所以以entry数目限制ziplist的容量时\",{\"1\":{\"300\":1}}],[\"所以蛋疼的地方就来了\",{\"1\":{\"299\":1}}],[\"所以数据的生命周期并不完全与链表及其结点一致\",{\"1\":{\"295\":1}}],[\"所以字符串的求长操作时间复杂度为o\",{\"1\":{\"294\":1}}],[\"所以默认的创建sds实例接口\",{\"1\":{\"294\":1}}],[\"所以至少调用libc中的字符串输出函数是安全的\",{\"1\":{\"294\":1}}],[\"所以认为这种并发问题概率较低\",{\"1\":{\"288\":1}}],[\"所以可以读写分离\",{\"1\":{\"268\":1}}],[\"所以可见并返回\",{\"1\":{\"218\":1,\"219\":1}}],[\"所以把页面进行静态化处理是一种很好的方法\",{\"1\":{\"268\":1}}],[\"所以物理空间没有实际释放\",{\"1\":{\"255\":1}}],[\"所以使用覆盖索引是一个常用的性能优化手段\",{\"1\":{\"246\":1}}],[\"所以此时即使前面事务a\",{\"1\":{\"219\":1}}],[\"所以此时\",{\"1\":{\"219\":1}}],[\"所以这里msg的类型还是interface\",{\"1\":{\"392\":1}}],[\"所以这里就是根据自身redis写入情况来进行合理配置\",{\"1\":{\"352\":1}}],[\"所以这次的\",{\"1\":{\"219\":1}}],[\"所以这种结构也称为type\",{\"1\":{\"48\":1}}],[\"所以事务c\",{\"1\":{\"219\":1}}],[\"所以事务a不在活跃事务数组中\",{\"1\":{\"218\":1}}],[\"所以最终返回的就是\",{\"1\":{\"218\":1}}],[\"所以最终返回的是\",{\"1\":{\"218\":1}}],[\"所以只能说明该行记录还未提交\",{\"1\":{\"218\":1}}],[\"所以长事务会产生很多老的视图导致undo\",{\"1\":{\"215\":1}}],[\"所以不能直接删除\",{\"1\":{\"215\":1}}],[\"所以需要把ziplist\",{\"1\":{\"300\":1}}],[\"所以需要注意组合索引中的顺序\",{\"1\":{\"153\":1}}],[\"所以需要使用全局变量来方便其它地方对m的以及与m相关的g和p的访问\",{\"1\":{\"29\":1}}],[\"所以通过二级索引查询到聚簇索引后\",{\"1\":{\"149\":1}}],[\"所以有些设置参数可以修改\",{\"1\":{\"119\":1}}],[\"所以有着非常大的发展潜力\",{\"1\":{\"19\":1}}],[\"所以一个事务拥有\",{\"1\":{\"101\":1}}],[\"所以一般我们查找10亿数据\",{\"1\":{\"70\":1}}],[\"所以我们这里叫做页更符合mysql中索引的底层数据结构\",{\"1\":{\"69\":1}}],[\"所以适用于\",{\"1\":{\"58\":1}}],[\"所以是无序的\",{\"1\":{\"57\":1}}],[\"所以20个goruntine将会产生40个资源临界区\",{\"1\":{\"57\":1}}],[\"所以p2\",{\"1\":{\"43\":1}}],[\"所以p1\",{\"1\":{\"43\":1}}],[\"所以无论是指针类型的p1实例还是值类型的p2实例\",{\"1\":{\"43\":1}}],[\"所以方法体中的p\",{\"1\":{\"43\":1}}],[\"所以mu1\",{\"1\":{\"460\":1}}],[\"所以map是引用类型\",{\"1\":{\"41\":1}}],[\"所以m里面还要存储与p相关的数据\",{\"1\":{\"19\":1}}],[\"所以程序刚启动时allgs\",{\"1\":{\"37\":1}}],[\"所以在与操作时要考虑的分支情况比较多\",{\"1\":{\"300\":1}}],[\"所以在buf中\",{\"1\":{\"294\":1}}],[\"所以在这里我们只需要大概了解一下就行了\",{\"1\":{\"30\":1}}],[\"所以在每个go程序中schedt结构体只有一个实例对象\",{\"1\":{\"29\":1}}],[\"所以其开销要远远小于系统线程的创建和切换\",{\"1\":{\"27\":1}}],[\"所以必须要再找一个空闲的处理器发车\",{\"1\":{\"22\":1}}],[\"所以\",{\"1\":{\"7\":1,\"43\":2,\"69\":1,\"296\":1,\"415\":1,\"508\":1}}],[\"所以default必须要可执行而不能阻塞\",{\"1\":{\"7\":1}}],[\"所以对已经关闭的chan进行send操作会引发panic\",{\"1\":{\"3\":1}}],[\"所以每发送一个数据就被阻塞\",{\"1\":{\"3\":1}}],[\"v类型是\",{\"1\":{\"508\":1}}],[\"v+delta\",{\"1\":{\"396\":1}}],[\"volatile\",{\"1\":{\"345\":6,\"346\":6,\"347\":1}}],[\"void\",{\"1\":{\"294\":2,\"295\":7,\"296\":24,\"297\":1,\"346\":1}}],[\"verifying\",{\"1\":{\"300\":1}}],[\"version\",{\"1\":{\"212\":1,\"297\":1}}],[\"v通过指针间接持有值\",{\"1\":{\"296\":1}}],[\"visitips\",{\"1\":{\"424\":10}}],[\"visit\",{\"1\":{\"296\":1,\"424\":4}}],[\"visits\",{\"1\":{\"296\":2}}],[\"view是不会更改的\",{\"1\":{\"219\":1}}],[\"view发生了变化\",{\"1\":{\"219\":1}}],[\"view的是在进行第一次进行快照读的时候\",{\"1\":{\"218\":1}}],[\"view的时候如何去拿获取的\",{\"1\":{\"215\":1}}],[\"view生成时刻\",{\"1\":{\"215\":1}}],[\"view生成时刻系统中正在活跃的事务id\",{\"1\":{\"215\":1}}],[\"view了的时候才能删除\",{\"1\":{\"215\":1}}],[\"view\",{\"1\":{\"115\":1,\"215\":5,\"218\":4,\"219\":4}}],[\"vitess\",{\"1\":{\"85\":1}}],[\"vg\",{\"1\":{\"72\":1}}],[\"vs\",{\"0\":{\"71\":1},\"1\":{\"347\":1,\"400\":3,\"437\":3}}],[\"v20180824\",{\"0\":{\"259\":1}}],[\"v2\",{\"1\":{\"44\":2}}],[\"v1\",{\"1\":{\"44\":2}}],[\"v\",{\"1\":{\"7\":5,\"8\":4,\"12\":2,\"41\":1,\"48\":7,\"63\":3,\"296\":1,\"370\":6,\"378\":3,\"382\":3,\"392\":2,\"394\":1,\"396\":2,\"424\":2,\"481\":18,\"496\":1,\"507\":3,\"508\":2}}],[\"valdestructor\",{\"1\":{\"296\":1}}],[\"valdup\",{\"1\":{\"296\":1}}],[\"val是int类型\",{\"1\":{\"52\":1}}],[\"value的type\",{\"1\":{\"292\":1}}],[\"value存储数据的方式\",{\"1\":{\"292\":1}}],[\"value型的内存数据库\",{\"1\":{\"292\":1}}],[\"value可以重复\",{\"1\":{\"276\":1}}],[\"valuen\",{\"1\":{\"275\":1}}],[\"value1\",{\"1\":{\"275\":1}}],[\"value=\",{\"1\":{\"275\":1}}],[\"value插入秒杀请求\",{\"1\":{\"268\":1}}],[\"value数据结构\",{\"1\":{\"268\":1}}],[\"values\",{\"1\":{\"214\":1,\"234\":3}}],[\"value值\",{\"1\":{\"41\":1}}],[\"value对\",{\"1\":{\"41\":1}}],[\"value\",{\"0\":{\"292\":1},\"1\":{\"12\":5,\"44\":2,\"47\":2,\"48\":1,\"57\":1,\"292\":2,\"295\":1,\"299\":4,\"300\":1,\"339\":1,\"342\":1,\"396\":3,\"409\":4,\"421\":3,\"508\":1}}],[\"val\",{\"1\":{\"3\":2,\"52\":6,\"53\":8,\"58\":3,\"296\":3,\"301\":2,\"421\":5,\"484\":2}}],[\"variable\",{\"1\":{\"262\":1}}],[\"varchar\",{\"0\":{\"175\":1},\"1\":{\"145\":1,\"175\":2,\"176\":1,\"234\":1,\"341\":4,\"342\":4}}],[\"var\",{\"1\":{\"2\":1,\"12\":1,\"41\":2,\"42\":2,\"45\":1,\"47\":1,\"48\":2,\"57\":3,\"63\":1,\"238\":2,\"370\":2,\"393\":1,\"396\":1,\"401\":1,\"414\":1,\"415\":1,\"435\":1,\"445\":2,\"446\":2,\"447\":1,\"449\":2,\"450\":2,\"451\":1,\"452\":2,\"453\":1,\"454\":2,\"490\":1,\"507\":1}}],[\"用lz4算法压缩后\",{\"1\":{\"300\":1}}],[\"用lpush加入时间轴\",{\"1\":{\"276\":1}}],[\"用以记录所有结点\",{\"1\":{\"297\":1}}],[\"用sds替代c\",{\"1\":{\"294\":1}}],[\"用一个原子类型的变量值\",{\"1\":{\"268\":1}}],[\"用1代表代码行\",{\"1\":{\"167\":1}}],[\"用户存储master收集数据的命令记录\",{\"1\":{\"322\":1}}],[\"用户可以自行选择更高效更特定化的散列函数\",{\"1\":{\"296\":1}}],[\"用户可以在多个列上建立索引\",{\"1\":{\"111\":1,\"153\":1}}],[\"用户数据均是以指针形式间接由dictentry结构持有\",{\"1\":{\"296\":1}}],[\"用户数据后总跟着一个\",{\"1\":{\"294\":1}}],[\"用户在对订单付完款之后减商品数据库库存\",{\"1\":{\"268\":1}}],[\"用户限流\",{\"1\":{\"268\":1}}],[\"用户发起登录请求\",{\"1\":{\"264\":1}}],[\"用户级别的错误有\",{\"1\":{\"262\":1}}],[\"用户身份证号等固定长度的字符串\",{\"1\":{\"186\":1}}],[\"用户信息表\",{\"1\":{\"67\":1}}],[\"用户态的goroutine则轻量得多\",{\"1\":{\"27\":1}}],[\"用来证明它的整个生命周期是否在运行时完全可知\",{\"1\":{\"489\":1}}],[\"用来唯一识别一个redis节点\",{\"1\":{\"321\":1}}],[\"用来判断指定字符串在另外一个字符串的索引未知\",{\"1\":{\"370\":1}}],[\"用来判断该行记录是否已经被删除\",{\"1\":{\"215\":1}}],[\"用来判断key是否存在\",{\"1\":{\"41\":1}}],[\"用来记录在获取写锁之前\",{\"1\":{\"58\":1}}],[\"用来定义行为\",{\"1\":{\"45\":1}}],[\"用来轮询每个case语句块的send或recv情况\",{\"1\":{\"7\":1}}],[\"用极度简化了的伪代码来描述goroutine调度器的工作流程大概是下面这个样子\",{\"1\":{\"28\":1}}],[\"用于同步信息\",{\"1\":{\"323\":1}}],[\"用于快速定位最后一个entry\",{\"1\":{\"299\":1}}],[\"用于替代c\",{\"1\":{\"294\":1}}],[\"用于存储任意数据的有序序列的数据结构\",{\"1\":{\"292\":1}}],[\"用于存储整数数值集合的自有结构\",{\"1\":{\"292\":1}}],[\"用于后端服务器性能不均的情况\",{\"1\":{\"266\":1}}],[\"用于控制字段的值范围\",{\"1\":{\"173\":1}}],[\"用于预防破坏表之间连接的动作\",{\"1\":{\"173\":1}}],[\"用于组合搜索\",{\"1\":{\"143\":1}}],[\"用于帮助我们在大量数据中快速定位到我们想要查找的数据\",{\"1\":{\"66\":1}}],[\"用于删除map中的某个key\",{\"1\":{\"41\":1}}],[\"用于缓存g结构体对象\",{\"1\":{\"36\":1}}],[\"用于记录goroutine使用的栈的起始和结束位置\",{\"1\":{\"31\":1}}],[\"用于回溯检查\",{\"1\":{\"19\":1}}],[\"用于端到端的数据传输\",{\"1\":{\"1\":1}}],[\"用法示例\",{\"1\":{\"7\":1}}],[\"它最开始会在栈上分配\",{\"1\":{\"489\":1}}],[\"它就可以在栈上分配\",{\"1\":{\"489\":1}}],[\"它就要进到一个处理器的队列等待发车\",{\"1\":{\"21\":1}}],[\"它无法主动让出自己的执行权\",{\"1\":{\"401\":1}}],[\"它其实有三种模式\",{\"1\":{\"353\":1}}],[\"它一般是由于键值对中的值被替换发生的\",{\"1\":{\"301\":1}}],[\"它描述了一个ziplist实例\",{\"1\":{\"300\":1}}],[\"它通过zl字段持有底层的ziplist\",{\"1\":{\"300\":1}}],[\"它本身是一个变长字段\",{\"1\":{\"299\":1}}],[\"它指的是整个ziplit中entry的数量\",{\"1\":{\"299\":1}}],[\"它指的是ziplist中最后一个entry的偏移量\",{\"1\":{\"299\":1}}],[\"它给每个元素设置一个分数\",{\"1\":{\"278\":1}}],[\"它复写了\",{\"1\":{\"116\":1}}],[\"它允许多个事务同时对数据进行变动\",{\"1\":{\"102\":1}}],[\"它认为数据的变动不会太频繁\",{\"1\":{\"102\":1}}],[\"它们有一个字符集\",{\"1\":{\"131\":1}}],[\"它们没有字符集\",{\"1\":{\"131\":1}}],[\"它们的锁申请行为可以在一个goroutine中操作\",{\"1\":{\"59\":1}}],[\"它们是有区别的\",{\"1\":{\"43\":1}}],[\"它们是等价的\",{\"1\":{\"42\":1}}],[\"它们都是数据对象的实例\",{\"1\":{\"42\":1}}],[\"它们都用于将key经过hash函数处理\",{\"1\":{\"41\":1}}],[\"它会定时去调用一些命令完成定时任务\",{\"1\":{\"354\":1}}],[\"它会为struct分配内存\",{\"1\":{\"42\":1}}],[\"它会返回每次迭代过程中所读取的数据\",{\"1\":{\"6\":1}}],[\"它将索引和列的值存储在一起\",{\"1\":{\"230\":1}}],[\"它将不会做任何初始化\",{\"1\":{\"41\":1}}],[\"它将只对所有case评估一次\",{\"1\":{\"7\":1}}],[\"它保存了m自身使用的栈信息\",{\"1\":{\"34\":1}}],[\"它保存了goroutine的所有信息\",{\"1\":{\"29\":1}}],[\"它代表了一个goroutine\",{\"1\":{\"33\":1}}],[\"它与操作系统线程之间实现了一个多对多\",{\"1\":{\"28\":1}}],[\"它是通过\",{\"1\":{\"213\":1}}],[\"它是通过读取历史版本的数据\",{\"1\":{\"114\":1}}],[\"它是数据库管理系统一种常见的并发控制\",{\"1\":{\"212\":1}}],[\"它是一种指针类型的数据类型\",{\"1\":{\"47\":1}}],[\"它是一个m\",{\"1\":{\"23\":1}}],[\"它是七大并发模型中的一种\",{\"1\":{\"17\":1}}],[\"它能提供线程需要的上下文环境\",{\"1\":{\"20\":1}}],[\"它由编程语言层面实现\",{\"1\":{\"19\":1}}],[\"它对应一个结构体g\",{\"1\":{\"18\":1}}],[\"它的定义与实现分别在src\",{\"1\":{\"300\":1}}],[\"它的设计宗旨就是\",{\"1\":{\"299\":1}}],[\"它的属性排序如下\",{\"1\":{\"195\":1}}],[\"它的底层原理\",{\"0\":{\"114\":1}}],[\"它的名称和类型都是inter和animal\",{\"1\":{\"42\":1}}],[\"它的核心观念是将两个并发执行的实体通过通道channel连接起来\",{\"1\":{\"17\":1}}],[\"它的行为如下\",{\"1\":{\"7\":1}}],[\"它凭什么做到如此高的并发呢\",{\"1\":{\"15\":1}}],[\"它像switch一样工作\",{\"1\":{\"7\":1}}],[\"rc\",{\"1\":{\"502\":6}}],[\"rc隔离级别\",{\"1\":{\"207\":4}}],[\"rmx\",{\"1\":{\"421\":3}}],[\"rmb\",{\"1\":{\"391\":1}}],[\"rd\",{\"1\":{\"421\":1}}],[\"rdb持久化与aof持久化可以同时存在\",{\"1\":{\"358\":1}}],[\"rdb的原理\",{\"0\":{\"355\":1}}],[\"rdb的持久化配置\",{\"0\":{\"352\":1}}],[\"rdbchecksum\",{\"1\":{\"352\":1}}],[\"rdbcompression\",{\"1\":{\"352\":2}}],[\"rdb与aof持久化的工作原理\",{\"1\":{\"350\":1}}],[\"rdbtools\",{\"1\":{\"337\":1}}],[\"rdb\",{\"0\":{\"336\":1,\"339\":1},\"1\":{\"333\":2,\"334\":2,\"335\":2,\"336\":1,\"338\":2,\"339\":2,\"342\":4,\"350\":1,\"352\":1}}],[\"rdb查看该信息\",{\"1\":{\"325\":1}}],[\"rlflf\",{\"1\":{\"386\":1}}],[\"rlock\",{\"1\":{\"52\":1,\"58\":4,\"413\":1,\"446\":2}}],[\"r2\",{\"1\":{\"386\":2}}],[\"r右转\",{\"1\":{\"386\":1}}],[\"raceaddr\",{\"1\":{\"484\":1}}],[\"raceacquire\",{\"1\":{\"484\":1}}],[\"raw==1\",{\"1\":{\"300\":1}}],[\"raw=1\",{\"1\":{\"300\":1}}],[\"rawlensize\",{\"1\":{\"299\":5}}],[\"rawlen\",{\"1\":{\"299\":10}}],[\"raw\",{\"1\":{\"299\":4}}],[\"rand\",{\"1\":{\"418\":1}}],[\"random\",{\"1\":{\"297\":1,\"345\":4,\"346\":5}}],[\"rank\",{\"1\":{\"297\":1}}],[\"range等\",{\"1\":{\"84\":2}}],[\"range遍历切片有什么要注意的\",{\"1\":{\"63\":1}}],[\"range迭代channel就会一直被阻塞\",{\"1\":{\"6\":1}}],[\"range\",{\"1\":{\"6\":1,\"41\":1,\"47\":1,\"63\":1,\"195\":1,\"234\":2,\"370\":3,\"378\":1,\"382\":1,\"386\":1,\"397\":1,\"398\":1,\"400\":1,\"406\":2,\"413\":1,\"418\":1,\"424\":1,\"437\":1,\"451\":1}}],[\"ratio\",{\"1\":{\"296\":3}}],[\"raid优化方案\",{\"1\":{\"282\":1}}],[\"rpush\",{\"1\":{\"268\":1}}],[\"rpath\",{\"1\":{\"12\":1}}],[\"rr\",{\"1\":{\"219\":1}}],[\"rr隔离级别\",{\"1\":{\"207\":4}}],[\"right\",{\"1\":{\"135\":1,\"346\":2,\"386\":3}}],[\"rt\",{\"1\":{\"72\":3,\"502\":3}}],[\"roundtrip\",{\"1\":{\"502\":3}}],[\"roundtripper\",{\"1\":{\"502\":3}}],[\"route\",{\"1\":{\"12\":1}}],[\"robj\",{\"1\":{\"346\":1}}],[\"roll\",{\"1\":{\"215\":4,\"217\":2}}],[\"row格式会记录行的内容\",{\"1\":{\"244\":1}}],[\"rowid\",{\"1\":{\"215\":2}}],[\"rows\",{\"1\":{\"195\":1,\"243\":1}}],[\"row\",{\"1\":{\"140\":1,\"238\":1}}],[\"row和mixed\",{\"1\":{\"140\":1}}],[\"root\",{\"1\":{\"12\":4,\"32\":1}}],[\"r\",{\"1\":{\"12\":5,\"53\":2,\"370\":2,\"386\":2,\"489\":3,\"502\":5}}],[\"rune\",{\"1\":{\"374\":1,\"378\":2,\"382\":1}}],[\"runid长度是40位\",{\"1\":{\"325\":1}}],[\"runid的值将发生变化\",{\"1\":{\"325\":1}}],[\"runid\",{\"1\":{\"318\":3}}],[\"runlock\",{\"1\":{\"52\":1,\"58\":4,\"413\":1,\"446\":2}}],[\"running\",{\"1\":{\"34\":1,\"35\":1,\"224\":1,\"296\":1,\"480\":1}}],[\"runnable\",{\"1\":{\"28\":1,\"29\":2,\"35\":2,\"36\":1}}],[\"runnext\",{\"1\":{\"20\":1,\"35\":2,\"407\":3}}],[\"runqput\",{\"1\":{\"407\":1}}],[\"runqsize\",{\"1\":{\"36\":1}}],[\"runqueue\",{\"1\":{\"29\":3}}],[\"runq\",{\"1\":{\"20\":1,\"35\":2,\"36\":1}}],[\"runqtail\",{\"1\":{\"20\":1,\"35\":1}}],[\"runqhead\",{\"1\":{\"20\":1,\"35\":1}}],[\"run\",{\"0\":{\"321\":1},\"1\":{\"12\":1,\"28\":1,\"29\":1,\"35\":2,\"397\":2,\"407\":1}}],[\"runtime2\",{\"1\":{\"30\":1}}],[\"runtime\",{\"1\":{\"12\":1,\"33\":1,\"401\":4,\"405\":2,\"407\":1,\"409\":1,\"450\":4,\"451\":2,\"483\":1,\"500\":2}}],[\"runhooks\",{\"1\":{\"12\":3}}],[\"rwfor\",{\"1\":{\"58\":1}}],[\"rwfind方法通过读写锁去读取数据\",{\"1\":{\"58\":1}}],[\"rwfind\",{\"1\":{\"58\":3}}],[\"rwmutex要高于mutex\",{\"1\":{\"59\":1}}],[\"rwmutex如何选择\",{\"0\":{\"59\":1}}],[\"rwmutex读写锁\",{\"0\":{\"58\":1}}],[\"rwmutex\",{\"0\":{\"56\":1,\"446\":1},\"1\":{\"52\":1,\"58\":6,\"412\":1,\"421\":1,\"446\":1,\"457\":1}}],[\"rwc\",{\"1\":{\"12\":6}}],[\"rw\",{\"1\":{\"12\":5,\"58\":9}}],[\"rerr\",{\"1\":{\"502\":1}}],[\"reuse\",{\"1\":{\"502\":1}}],[\"regular\",{\"1\":{\"407\":1}}],[\"registered\",{\"1\":{\"502\":1}}],[\"register\",{\"1\":{\"32\":2,\"34\":1,\"262\":2,\"264\":1}}],[\"registeronhiteof\",{\"1\":{\"12\":1}}],[\"reverstring\",{\"1\":{\"374\":1}}],[\"rename\",{\"1\":{\"356\":1}}],[\"reload\",{\"1\":{\"355\":1}}],[\"relay\",{\"1\":{\"238\":3}}],[\"rewrite\",{\"1\":{\"353\":4}}],[\"rehash\",{\"1\":{\"296\":1}}],[\"rehashed\",{\"1\":{\"296\":1}}],[\"rehashindex\",{\"1\":{\"296\":2}}],[\"rehashing\",{\"1\":{\"296\":6}}],[\"rehashidx\",{\"1\":{\"296\":3}}],[\"ref\",{\"1\":{\"195\":4,\"392\":1}}],[\"reflect\",{\"1\":{\"44\":2,\"496\":3}}],[\"redolog有两种\",{\"1\":{\"251\":1}}],[\"redolog是引擎层的日志\",{\"1\":{\"244\":1}}],[\"redolog和binlog的区别\",{\"1\":{\"244\":1}}],[\"redo\",{\"0\":{\"251\":1},\"1\":{\"107\":1,\"194\":1,\"198\":3,\"199\":5,\"244\":3,\"251\":1}}],[\"redis不处理交给os来处理\",{\"1\":{\"353\":1}}],[\"redis为持久化提供了两种方式\",{\"1\":{\"350\":1}}],[\"redis持久化的原理及优化\",{\"0\":{\"350\":1}}],[\"redis会按照maxmemory\",{\"1\":{\"345\":1}}],[\"redis中lru是近似lru实现\",{\"1\":{\"346\":1}}],[\"redis中内存淘汰算法实现\",{\"0\":{\"345\":1}}],[\"redis中的key与value在表层都是一个redisobject实例\",{\"1\":{\"292\":1}}],[\"redis中的数据结构\",{\"0\":{\"291\":1},\"1\":{\"291\":1}}],[\"redis内存分析\",{\"0\":{\"332\":1}}],[\"redis在启动时会自动生成一个随机的id\",{\"1\":{\"321\":1}}],[\"redis6379\",{\"1\":{\"308\":1}}],[\"redis6380\",{\"1\":{\"308\":2,\"310\":1}}],[\"redis存储路径为\",{\"1\":{\"308\":1}}],[\"redis主从复制的作用\",{\"0\":{\"307\":1}}],[\"redis主从复制原理\",{\"0\":{\"304\":1}}],[\"redis可以继续实现高可用\",{\"1\":{\"306\":1}}],[\"redis4\",{\"1\":{\"304\":1}}],[\"redis的maxmemory支持的内存淘汰机制使得其成为一种有效的缓存方案\",{\"1\":{\"345\":1}}],[\"redis的运行效率\",{\"1\":{\"292\":1}}],[\"redis的用户认为的\",{\"1\":{\"292\":1}}],[\"redisobject\",{\"1\":{\"292\":1}}],[\"redis对使用者暴露了五种value\",{\"1\":{\"292\":1}}],[\"redis作为key\",{\"1\":{\"292\":1}}],[\"redis作为缓存层\",{\"1\":{\"274\":1}}],[\"redis等\",{\"1\":{\"282\":1}}],[\"redis实现session共享\",{\"1\":{\"274\":1}}],[\"redis是单线程模型\",{\"1\":{\"274\":1}}],[\"redis常见的数据结构\",{\"0\":{\"273\":1}}],[\"redis\",{\"0\":{\"272\":1,\"336\":1,\"339\":1,\"346\":1,\"347\":1,\"514\":1},\"1\":{\"120\":1,\"264\":2,\"269\":1,\"274\":1,\"276\":1,\"308\":2,\"310\":1,\"311\":1,\"333\":3,\"334\":2,\"335\":1,\"336\":1,\"338\":2,\"340\":1,\"342\":2,\"345\":1,\"346\":20,\"347\":2,\"352\":1},\"2\":{\"279\":1,\"280\":1,\"289\":1,\"290\":1,\"302\":1,\"303\":1,\"330\":1,\"331\":1,\"343\":1,\"344\":1,\"348\":1,\"349\":1,\"359\":1,\"360\":1}}],[\"redis生成id\",{\"1\":{\"94\":1}}],[\"redirect\",{\"1\":{\"37\":1}}],[\"repeatcmd\",{\"1\":{\"386\":5}}],[\"repeat\",{\"1\":{\"386\":6}}],[\"repeatable\",{\"1\":{\"95\":2}}],[\"replace来替换空格\",{\"1\":{\"382\":1}}],[\"replace\",{\"1\":{\"382\":1}}],[\"replaceblank\",{\"1\":{\"382\":1}}],[\"repl\",{\"1\":{\"326\":1,\"327\":1}}],[\"replconf\",{\"1\":{\"319\":1}}],[\"replid变量\",{\"1\":{\"325\":1}}],[\"replication\",{\"1\":{\"319\":1}}],[\"replies\",{\"1\":{\"12\":2}}],[\"reporting\",{\"1\":{\"262\":5}}],[\"reason\",{\"1\":{\"299\":1}}],[\"reached\",{\"1\":{\"296\":1}}],[\"realloc\",{\"1\":{\"299\":1}}],[\"really\",{\"1\":{\"32\":1,\"296\":1}}],[\"realsize\",{\"1\":{\"296\":5}}],[\"real\",{\"1\":{\"32\":1}}],[\"readfrom\",{\"1\":{\"502\":2}}],[\"reading\",{\"1\":{\"502\":1}}],[\"readloop\",{\"1\":{\"502\":9}}],[\"readall\",{\"1\":{\"500\":1,\"502\":4,\"503\":2}}],[\"readmemstats\",{\"1\":{\"450\":1}}],[\"ready\",{\"1\":{\"35\":2}}],[\"readcloser\",{\"1\":{\"12\":1}}],[\"readerwait\",{\"1\":{\"58\":1}}],[\"readercount\",{\"1\":{\"58\":1}}],[\"readersem\",{\"1\":{\"58\":1}}],[\"reader\",{\"1\":{\"12\":1,\"489\":1,\"502\":5}}],[\"read\",{\"1\":{\"12\":2,\"57\":2,\"95\":4,\"115\":1,\"141\":1,\"215\":6,\"218\":4,\"219\":6,\"237\":1,\"264\":1,\"288\":1,\"412\":1,\"489\":1,\"502\":3}}],[\"readrequest\",{\"1\":{\"12\":1}}],[\"retrynext\",{\"1\":{\"407\":2}}],[\"ret\",{\"1\":{\"19\":1,\"32\":1,\"400\":2,\"410\":3,\"437\":2}}],[\"returns\",{\"1\":{\"502\":1}}],[\"returned\",{\"1\":{\"12\":2}}],[\"return是退出整个函数\",{\"1\":{\"7\":1}}],[\"return\",{\"1\":{\"3\":1,\"8\":2,\"12\":9,\"44\":1,\"45\":1,\"52\":2,\"53\":2,\"57\":2,\"58\":2,\"262\":2,\"264\":6,\"268\":2,\"269\":1,\"294\":2,\"296\":20,\"297\":2,\"299\":2,\"346\":1,\"366\":1,\"370\":11,\"374\":2,\"378\":3,\"382\":3,\"386\":1,\"393\":1,\"394\":1,\"395\":1,\"400\":5,\"407\":1,\"410\":1,\"412\":2,\"413\":1,\"414\":1,\"415\":1,\"421\":2,\"424\":7,\"431\":1,\"437\":5,\"448\":1,\"450\":1,\"484\":1,\"490\":1,\"502\":13}}],[\"re\",{\"1\":{\"12\":2}}],[\"remove\",{\"1\":{\"346\":1}}],[\"remoteaddr\",{\"1\":{\"12\":3}}],[\"remainder\",{\"1\":{\"300\":1}}],[\"remaining\",{\"1\":{\"35\":1}}],[\"remain\",{\"1\":{\"12\":1}}],[\"result\",{\"1\":{\"299\":1}}],[\"resultset\",{\"1\":{\"112\":4}}],[\"resize\",{\"1\":{\"296\":4}}],[\"restores\",{\"1\":{\"32\":1}}],[\"respect\",{\"1\":{\"32\":1}}],[\"response\",{\"1\":{\"502\":1}}],[\"responses\",{\"1\":{\"12\":1}}],[\"responsewriter\",{\"1\":{\"12\":4}}],[\"resp\",{\"1\":{\"12\":1,\"500\":2,\"502\":5,\"503\":1}}],[\"reset\",{\"1\":{\"12\":4,\"424\":1}}],[\"reqlen+tail\",{\"1\":{\"299\":1}}],[\"reqlen\",{\"1\":{\"299\":9}}],[\"req\",{\"1\":{\"12\":20,\"502\":11}}],[\"requested\",{\"1\":{\"300\":1}}],[\"requesturi\",{\"1\":{\"12\":1}}],[\"requests\",{\"1\":{\"12\":2}}],[\"requestbodyremains\",{\"1\":{\"12\":1}}],[\"request\",{\"1\":{\"12\":7,\"234\":3,\"502\":6}}],[\"recompress字段指示的是当前结点所持有的ziplist是否经过了解压\",{\"1\":{\"300\":1}}],[\"recompress\",{\"1\":{\"300\":2}}],[\"recover\",{\"1\":{\"12\":1,\"397\":2,\"428\":2}}],[\"receenabled\",{\"1\":{\"484\":1}}],[\"recently\",{\"1\":{\"296\":1,\"345\":1}}],[\"received\",{\"1\":{\"484\":2}}],[\"received和bytes\",{\"1\":{\"130\":1}}],[\"receiver部分\",{\"1\":{\"43\":2}}],[\"receiver\",{\"1\":{\"4\":2}}],[\"receiver被阻塞\",{\"1\":{\"3\":1}}],[\"receiver每次请求channel时\",{\"1\":{\"3\":1}}],[\"receiver端按照队列的方式\",{\"1\":{\"3\":1}}],[\"receiver端一直阻塞\",{\"1\":{\"3\":1}}],[\"receive\",{\"1\":{\"2\":1,\"6\":1}}],[\"receive和close\",{\"1\":{\"2\":1}}],[\"recv操作将返回对应类型的0值以及一个状态码false\",{\"1\":{\"2\":1}}],[\"recv\",{\"1\":{\"2\":1,\"4\":3}}],[\"overflow\",{\"1\":{\"296\":1}}],[\"over\",{\"1\":{\"296\":1}}],[\"override\",{\"1\":{\"42\":1}}],[\"our\",{\"1\":{\"296\":1,\"346\":1}}],[\"outer\",{\"1\":{\"137\":1}}],[\"out通道只用于发送数据\",{\"1\":{\"6\":1}}],[\"out\",{\"1\":{\"6\":1,\"34\":1,\"299\":2,\"300\":1,\"407\":1,\"418\":4,\"421\":2}}],[\"obj\",{\"1\":{\"296\":2}}],[\"observed\",{\"1\":{\"35\":1}}],[\"oldnext\",{\"1\":{\"407\":4}}],[\"old\",{\"1\":{\"296\":2,\"407\":1}}],[\"oldtype\",{\"1\":{\"294\":1}}],[\"oldp\",{\"1\":{\"19\":2,\"34\":1}}],[\"o非常高\",{\"1\":{\"288\":1}}],[\"o请求\",{\"1\":{\"282\":1}}],[\"o实现缓存作用\",{\"1\":{\"282\":1}}],[\"operation\",{\"1\":{\"508\":1}}],[\"operator\",{\"1\":{\"262\":1}}],[\"open\",{\"1\":{\"264\":1}}],[\"optimize\",{\"1\":{\"255\":1}}],[\"options\",{\"1\":{\"12\":2}}],[\"o\",{\"1\":{\"228\":1,\"282\":1,\"424\":14,\"448\":6}}],[\"o变为顺序i\",{\"1\":{\"228\":1}}],[\"o线程\",{\"1\":{\"117\":1,\"192\":1}}],[\"oceanus\",{\"1\":{\"85\":1}}],[\"otherwise\",{\"1\":{\"35\":1,\"296\":1,\"299\":1,\"300\":1,\"346\":1}}],[\"other\",{\"1\":{\"32\":1,\"33\":1,\"296\":1,\"401\":1}}],[\"os\",{\"1\":{\"28\":1,\"29\":1,\"490\":2}}],[\"of\",{\"1\":{\"12\":1,\"28\":2,\"29\":1,\"31\":1,\"32\":1,\"34\":1,\"35\":5,\"36\":8,\"294\":7,\"296\":6,\"297\":1,\"299\":9,\"300\":10,\"301\":5,\"502\":3}}],[\"offset加载到内存中\",{\"1\":{\"325\":1}}],[\"offset保存到rdb文件中\",{\"1\":{\"325\":1}}],[\"offset\",{\"0\":{\"323\":1},\"1\":{\"33\":4,\"299\":20,\"300\":3,\"318\":7,\"322\":1}}],[\"offsets\",{\"1\":{\"32\":1}}],[\"off\",{\"1\":{\"12\":1,\"288\":1}}],[\"org\",{\"1\":{\"392\":1}}],[\"orderat\",{\"1\":{\"339\":3}}],[\"order\",{\"1\":{\"86\":1,\"93\":2,\"341\":1}}],[\"or\",{\"1\":{\"12\":1,\"36\":2,\"195\":1,\"212\":1,\"296\":2,\"300\":3,\"502\":3}}],[\"origlistener\",{\"1\":{\"12\":1}}],[\"once\",{\"1\":{\"448\":2}}],[\"only\",{\"1\":{\"32\":1,\"237\":1,\"296\":1,\"300\":1}}],[\"one即可断开主从复制\",{\"1\":{\"310\":1}}],[\"one\",{\"1\":{\"12\":1,\"35\":1,\"299\":2,\"310\":1,\"346\":1}}],[\"on\",{\"1\":{\"12\":3,\"31\":1,\"33\":2,\"34\":3,\"35\":2,\"36\":1,\"145\":1,\"299\":1,\"300\":1,\"346\":2,\"352\":2,\"353\":1,\"480\":2,\"483\":2,\"502\":1}}],[\"ok2\",{\"1\":{\"481\":6}}],[\"ok1\",{\"1\":{\"481\":6}}],[\"ok=false\",{\"1\":{\"481\":6}}],[\"ok=true\",{\"1\":{\"481\":3}}],[\"ok=\",{\"1\":{\"481\":9}}],[\"ok是一个bool值\",{\"1\":{\"41\":1}}],[\"ok\",{\"1\":{\"3\":2,\"7\":4,\"41\":1,\"48\":6,\"52\":4,\"53\":5,\"296\":5,\"395\":3,\"412\":2,\"421\":2,\"424\":4,\"428\":2,\"481\":6,\"484\":3}}],[\"表中元素即是结点\",{\"1\":{\"296\":1}}],[\"表中的非主键只依赖于主键\",{\"1\":{\"138\":1}}],[\"表中的数据存储在其中\",{\"1\":{\"72\":1}}],[\"表中的数据都会有一个主键\",{\"1\":{\"71\":1}}],[\"表数据信息可能较小也可能巨大无比\",{\"1\":{\"255\":1}}],[\"表\",{\"1\":{\"230\":1}}],[\"表压缩\",{\"1\":{\"223\":1}}],[\"表结构还在\",{\"1\":{\"177\":2}}],[\"表锁\",{\"1\":{\"133\":1,\"156\":1}}],[\"表的隐藏列\",{\"1\":{\"115\":1}}],[\"表b表示部门表\",{\"1\":{\"112\":1}}],[\"表明这个chan参数只能进行读取操作\",{\"1\":{\"6\":1}}],[\"表示300s内有10条写入\",{\"1\":{\"352\":1}}],[\"表示900s内如果有1条是写入命令\",{\"1\":{\"352\":1}}],[\"表示quicklist的链表头两个\",{\"1\":{\"300\":1}}],[\"表示quicklist的链表头尾结点不压缩\",{\"1\":{\"300\":1}}],[\"表示不压缩\",{\"1\":{\"300\":1}}],[\"表示脚本遇到可能会表现为错误的情况\",{\"1\":{\"262\":1}}],[\"表示这个语句执行过程中扫描了多少行\",{\"1\":{\"243\":1}}],[\"表示这个slice目前最多能扩展到这么长\",{\"1\":{\"63\":1}}],[\"表示字段是可变长度字符串\",{\"1\":{\"176\":1}}],[\"表示字段是固定长度字符串\",{\"1\":{\"176\":1}}],[\"表示字段是int类型\",{\"1\":{\"176\":1}}],[\"表示事务完成以后\",{\"1\":{\"106\":1}}],[\"表示slice当前的长度\",{\"1\":{\"63\":1}}],[\"表示sender端的goroutine向channel中投放数据\",{\"1\":{\"2\":1}}],[\"表示该slice结构从底层数组的哪一个元素开始\",{\"1\":{\"63\":1}}],[\"表示当前启用的读者数量\",{\"1\":{\"58\":1}}],[\"表示当前工作线程正在试图从其它工作线程的本地运行队列偷取goroutine\",{\"1\":{\"34\":1}}],[\"表示处理器\",{\"1\":{\"18\":1}}],[\"表示操作系统的线程\",{\"1\":{\"18\":1}}],[\"表示无数据再需发送\",{\"1\":{\"6\":1}}],[\"表示channel\",{\"1\":{\"6\":2}}],[\"表示关闭channel\",{\"1\":{\"2\":1}}],[\"表示receiver端的goroutine从channel中读取数据\",{\"1\":{\"2\":1}}],[\"同步方式\",{\"1\":{\"353\":1}}],[\"同步模式\",{\"1\":{\"3\":1}}],[\"同样\",{\"1\":{\"393\":1}}],[\"同样php有个比较好的项目叫做\",{\"1\":{\"265\":1}}],[\"同样的页8页不在内存中\",{\"1\":{\"72\":1}}],[\"同样的\",{\"1\":{\"20\":1}}],[\"同一个key的请求\",{\"1\":{\"266\":1}}],[\"同一个字段\",{\"1\":{\"250\":1}}],[\"同一个记录在系统中存在多个版本\",{\"1\":{\"245\":1}}],[\"同理\",{\"1\":{\"112\":1}}],[\"同类型的值类型实例和指针类型实例不能互转\",{\"1\":{\"48\":1}}],[\"同级别的struct出现同名字段\",{\"1\":{\"42\":1}}],[\"同名方法\",{\"1\":{\"42\":1}}],[\"同时立即取消仍在执行的查找任务的goroutine\",{\"1\":{\"473\":1}}],[\"同时阻塞的两个对象肯定要每个启动一个协程\",{\"1\":{\"431\":1}}],[\"同时保证字符串由\",{\"1\":{\"382\":1}}],[\"同时理解这种保存数据的思路\",{\"1\":{\"350\":1}}],[\"同时实现数据的冗余备份\",{\"1\":{\"306\":1}}],[\"同时next指针用于指向\",{\"1\":{\"296\":1}}],[\"同时数据可以一步落地到其他的数据源\",{\"1\":{\"274\":1}}],[\"同时可以根据需求的变化\",{\"1\":{\"307\":1}}],[\"同时可以使用js异步请求服务端\",{\"1\":{\"268\":1}}],[\"同时可以删除不必要的冗余索引\",{\"1\":{\"111\":1}}],[\"同时也必然引入新的问题\",{\"1\":{\"285\":1}}],[\"同时也可以增加锁机制解决此低概率并发问题\",{\"1\":{\"288\":1}}],[\"同时也可以使用redis的乐观锁和事务实现\",{\"1\":{\"269\":1}}],[\"同时也可以指定权重\",{\"1\":{\"266\":1}}],[\"同时也支持第三方的算法\",{\"1\":{\"266\":1}}],[\"同时也支持索引间隙锁\",{\"1\":{\"223\":1}}],[\"同时还顺便执行了\",{\"1\":{\"502\":1}}],[\"同时还用\",{\"1\":{\"266\":1}}],[\"同时还有别的分区\",{\"1\":{\"234\":1}}],[\"同时还有一些使用了函数之类的语句无法被记录复制\",{\"1\":{\"140\":1}}],[\"同时你也可以通过自定义会话管理器来管理会话\",{\"1\":{\"264\":1}}],[\"同时php也提供了\",{\"1\":{\"262\":1}}],[\"同时用户也可以设置自身的错误级别\",{\"1\":{\"262\":1}}],[\"同时在备库上也建议指定中继日志\",{\"1\":{\"238\":1}}],[\"同时观察\",{\"1\":{\"190\":1}}],[\"同时增加了引擎的复杂度\",{\"1\":{\"181\":1}}],[\"同时进行默认规则的排序\",{\"1\":{\"178\":1}}],[\"同时ints对应的元素值也会修改\",{\"1\":{\"63\":1}}],[\"同时\",{\"1\":{\"27\":1,\"431\":1}}],[\"同时达到了3秒程序结束的效果\",{\"1\":{\"8\":1}}],[\"同时我们在检测到chan关闭时\",{\"1\":{\"7\":1}}],[\"同时上面的案例中\",{\"1\":{\"6\":1}}],[\"使\",{\"1\":{\"438\":1}}],[\"使每个url定向到同一个后端服务器\",{\"1\":{\"266\":1}}],[\"使之可以使用到覆盖索引\",{\"1\":{\"232\":1}}],[\"使之长度发生了改变\",{\"1\":{\"63\":2}}],[\"使数据访问更快\",{\"1\":{\"230\":1}}],[\"使事务相互隔离开\",{\"1\":{\"107\":1,\"194\":1}}],[\"使用多个goroutine查找切片中是否存在给定的值\",{\"1\":{\"473\":1}}],[\"使用两个\",{\"1\":{\"366\":2}}],[\"使用更牛逼的硬件\",{\"1\":{\"358\":1}}],[\"使用标准的\",{\"1\":{\"335\":1}}],[\"使用心跳机制进行维护\",{\"1\":{\"319\":1}}],[\"使用配置文件启用\",{\"0\":{\"310\":1}}],[\"使用客户端命令行启动\",{\"0\":{\"309\":1}}],[\"使用双哈希表实现的\",{\"1\":{\"292\":1}}],[\"使用双端链表实现的\",{\"1\":{\"276\":1}}],[\"使用下面的命令创建一个key\",{\"1\":{\"292\":1}}],[\"使用列表的技巧\",{\"1\":{\"276\":1}}],[\"使用示例\",{\"1\":{\"264\":1}}],[\"使用drop\",{\"1\":{\"255\":1}}],[\"使用索引\",{\"1\":{\"224\":1}}],[\"使用show\",{\"1\":{\"224\":1}}],[\"使用过\",{\"1\":{\"218\":1}}],[\"使用的是其中的\",{\"1\":{\"215\":1}}],[\"使用了\",{\"1\":{\"215\":1}}],[\"使用了有缓冲的chan\",{\"1\":{\"6\":1}}],[\"使用率是否下降\",{\"1\":{\"190\":1}}],[\"使用top\",{\"1\":{\"190\":1}}],[\"使用缓存\",{\"1\":{\"189\":1}}],[\"使用count\",{\"1\":{\"189\":1}}],[\"使用create\",{\"1\":{\"145\":1}}],[\"使用场景\",{\"0\":{\"174\":1},\"1\":{\"170\":1}}],[\"使用表的组成部分而不是整个表\",{\"1\":{\"165\":1}}],[\"使用非聚集索引\",{\"1\":{\"151\":1}}],[\"使用聚集索引\",{\"1\":{\"151\":1}}],[\"使用alter\",{\"1\":{\"145\":1}}],[\"使用自增主键对数据库做分库分表\",{\"1\":{\"113\":1}}],[\"使用\",{\"0\":{\"337\":1,\"339\":1},\"1\":{\"107\":1,\"194\":1,\"224\":1,\"246\":1,\"262\":1,\"366\":1}}],[\"使用乐观锁\",{\"0\":{\"99\":1}}],[\"使用悲观锁\",{\"0\":{\"98\":1}}],[\"使用共享表空间和多表空间储存数据\",{\"1\":{\"87\":1}}],[\"使用range遍历切片users\",{\"1\":{\"63\":1}}],[\"使用range读取ch将会发生panic\",{\"1\":{\"6\":1}}],[\"使用rwfind读取数据\",{\"1\":{\"58\":1}}],[\"使用数组实现的循环队列\",{\"1\":{\"35\":1}}],[\"使用用户goroutine自己的栈\",{\"1\":{\"34\":1}}],[\"使得每k个节点之间为一组进行逆序\",{\"1\":{\"469\":1}}],[\"使得recv操作无法被执行\",{\"1\":{\"4\":1}}],[\"使得sender不会阻塞\",{\"1\":{\"3\":1}}],[\"每秒同步一次\",{\"1\":{\"353\":1}}],[\"每秒执行一次\",{\"1\":{\"319\":1}}],[\"每条记录在更新的时候都会记录一条回滚操作\",{\"1\":{\"245\":1}}],[\"每一段都有自己的内部工作流程\",{\"1\":{\"314\":1}}],[\"每一次删除也会调用zrealloc接口缩减占用的内存\",{\"1\":{\"298\":1}}],[\"每一次插入\",{\"1\":{\"296\":1}}],[\"每一次扩充空间\",{\"1\":{\"294\":1}}],[\"每一条会修改数据的sql都会记录在binlog中\",{\"1\":{\"140\":1}}],[\"每一个索引在\",{\"1\":{\"246\":1}}],[\"每一个索引还要占用一定的物理空间\",{\"1\":{\"142\":1}}],[\"每一个运行着go代码的工作线程都会与一个p结构体的实例对象关联在一起\",{\"1\":{\"29\":1}}],[\"每一个线程对应一个runtime\",{\"1\":{\"19\":1}}],[\"每次泄漏一个读和写goroutine\",{\"1\":{\"501\":1}}],[\"每次循环会将集合中的值复制给这个变量\",{\"1\":{\"406\":1}}],[\"每次写操作整个ziplist的内存都需要重分配\",{\"1\":{\"300\":1}}],[\"每次做上百万次的数据集查询\",{\"1\":{\"112\":1}}],[\"每次最多并发执行10个\",{\"1\":{\"6\":1}}],[\"每时每刻都担心着它心爱的数据可能被别的事务修改\",{\"1\":{\"101\":1}}],[\"每20us~10ms会被唤醒一次出来打扫卫生\",{\"1\":{\"23\":1}}],[\"每个协程去处理一个阻塞\",{\"1\":{\"431\":1}}],[\"每个ip三分钟之内只能访问一次\",{\"1\":{\"424\":1}}],[\"每个ip要重复访问1000次\",{\"1\":{\"424\":1}}],[\"每个entry用单独的一块区域\",{\"1\":{\"299\":1}}],[\"每个entry中存储了它前一个entry所占用的字节数\",{\"1\":{\"299\":1}}],[\"每个zskiplistlevel中有两个字段\",{\"1\":{\"297\":1}}],[\"每个结点中最多持有32个zskiplistlevel结构\",{\"1\":{\"297\":1}}],[\"每个结点持有一个backward指针\",{\"1\":{\"297\":1}}],[\"每个结点\",{\"1\":{\"297\":1}}],[\"每个请求按访问ip的hash结果分配\",{\"1\":{\"266\":1}}],[\"每个请求按时间顺序逐一分配到不同的后端服务器\",{\"1\":{\"266\":1}}],[\"每个模块都有一个域名\",{\"1\":{\"265\":1}}],[\"每个框架的处理机制不一样\",{\"1\":{\"260\":1}}],[\"每个节点的左儿子小于父节点\",{\"1\":{\"246\":1}}],[\"每个节点存储了更多的键值\",{\"1\":{\"69\":1}}],[\"每个类型都分两个method\",{\"1\":{\"46\":1}}],[\"每个字段\",{\"1\":{\"138\":1}}],[\"每个字段都有类型\",{\"1\":{\"42\":1}}],[\"每个字段名都必须唯一\",{\"1\":{\"42\":1}}],[\"每个field都有所属数据类型\",{\"1\":{\"42\":1}}],[\"每个工作线程在刚刚被创建出来进入调度循环之前就利用线程本地存储机制为该工作线程实现了一个指向m结构体实例对象的私有全局变量\",{\"1\":{\"29\":1}}],[\"每个工作线程都有唯一的一个m结构体的实例对象与之对应\",{\"1\":{\"29\":1}}],[\"每个p都有一个私有的本地goroutine队列\",{\"1\":{\"29\":1}}],[\"每个m都绑定了一个p\",{\"1\":{\"29\":1}}],[\"每个线程都不再浑水摸鱼\",{\"1\":{\"20\":1}}],[\"每个线程分配到一个cpu上就不至于出现线程的上下文切换\",{\"1\":{\"19\":1}}],[\"每个g都能得到合理的调用\",{\"1\":{\"20\":1}}],[\"每个连接中都会被赋予server的信息\",{\"1\":{\"12\":1}}],[\"每个channel都有3种操作\",{\"1\":{\"2\":1}}],[\"np+next\",{\"1\":{\"299\":1}}],[\"np+rawlensize\",{\"1\":{\"299\":1}}],[\"np\",{\"1\":{\"299\":5}}],[\"npidle\",{\"1\":{\"36\":1}}],[\"nginx默认采用轮询算法\",{\"1\":{\"266\":1}}],[\"nginx\",{\"1\":{\"266\":2}}],[\"nginx或者\",{\"1\":{\"266\":1}}],[\"ngsys\",{\"1\":{\"36\":1}}],[\"num2\",{\"1\":{\"481\":2}}],[\"num1\",{\"1\":{\"481\":2}}],[\"num=0\",{\"1\":{\"481\":2}}],[\"num=1\",{\"1\":{\"481\":1}}],[\"num=\",{\"1\":{\"481\":3}}],[\"numgoroutine\",{\"1\":{\"451\":1,\"500\":1}}],[\"num\",{\"1\":{\"339\":1,\"341\":2,\"342\":1,\"431\":4,\"481\":2,\"500\":2}}],[\"number用来通知打印数字的goroutine打印数字\",{\"1\":{\"366\":1}}],[\"number<\",{\"1\":{\"366\":1}}],[\"number\",{\"1\":{\"36\":7,\"296\":4,\"300\":4,\"366\":3}}],[\"null值会占用更多的字节\",{\"1\":{\"185\":1}}],[\"null\",{\"0\":{\"185\":1},\"1\":{\"78\":2,\"145\":5,\"172\":1,\"173\":1,\"193\":2,\"195\":1,\"217\":3,\"224\":1,\"234\":4,\"262\":3,\"294\":4,\"296\":7,\"299\":3,\"346\":3,\"484\":1}}],[\"name`\",{\"1\":{\"145\":1}}],[\"name=\",{\"1\":{\"98\":2,\"246\":1}}],[\"name=xm\",{\"1\":{\"67\":1}}],[\"name\",{\"1\":{\"42\":3,\"43\":4,\"44\":2,\"45\":6,\"72\":1,\"93\":2,\"145\":4,\"215\":4,\"217\":3,\"218\":4,\"219\":5,\"226\":1,\"227\":1,\"246\":1,\"322\":1,\"392\":2,\"393\":3,\"394\":1,\"399\":2,\"400\":2,\"406\":5,\"412\":4,\"436\":1,\"437\":2,\"439\":5,\"481\":2}}],[\"ncpu\",{\"1\":{\"37\":1}}],[\"nmspinning\",{\"1\":{\"36\":1}}],[\"nmsys\",{\"1\":{\"36\":2}}],[\"nmfreed\",{\"1\":{\"36\":2}}],[\"nmidlelocked\",{\"1\":{\"36\":2}}],[\"nmidle\",{\"1\":{\"36\":2}}],[\"now\",{\"1\":{\"424\":3}}],[\"noeviction\",{\"1\":{\"345\":2}}],[\"nodes\",{\"1\":{\"300\":3}}],[\"node\",{\"1\":{\"300\":6}}],[\"noffset\",{\"1\":{\"299\":3}}],[\"nolock\",{\"1\":{\"57\":1}}],[\"nolockread\",{\"1\":{\"57\":2}}],[\"nostack\",{\"1\":{\"36\":1}}],[\"none==1\",{\"1\":{\"300\":1}}],[\"none=1\",{\"1\":{\"300\":1}}],[\"non\",{\"1\":{\"35\":1,\"296\":1}}],[\"normally\",{\"1\":{\"33\":1}}],[\"no\",{\"1\":{\"31\":1,\"44\":1,\"299\":1,\"310\":2,\"346\":1,\"353\":4,\"502\":1}}],[\"notify\",{\"1\":{\"346\":1}}],[\"notifykeyspaceevent\",{\"1\":{\"346\":1}}],[\"notice\",{\"1\":{\"262\":3}}],[\"nothing\",{\"1\":{\"48\":1}}],[\"note\",{\"1\":{\"34\":2,\"294\":1,\"296\":1,\"300\":1}}],[\"not\",{\"1\":{\"12\":2,\"34\":1,\"36\":1,\"57\":1,\"78\":2,\"145\":1,\"173\":1,\"193\":1,\"234\":3,\"296\":4,\"299\":4,\"300\":1,\"473\":1,\"490\":5,\"502\":2,\"508\":1}}],[\"necessary\",{\"1\":{\"299\":1}}],[\"nextdiff\",{\"1\":{\"299\":8}}],[\"nextde\",{\"1\":{\"296\":3}}],[\"nextentry\",{\"1\":{\"296\":1}}],[\"nextp\",{\"1\":{\"19\":2,\"34\":1}}],[\"next\",{\"1\":{\"12\":3,\"35\":1,\"36\":1,\"295\":2,\"296\":1,\"299\":15,\"300\":1,\"346\":1,\"407\":1}}],[\"never\",{\"1\":{\"12\":1,\"294\":1}}],[\"needed\",{\"1\":{\"296\":2,\"502\":2}}],[\"needs\",{\"1\":{\"32\":2,\"299\":1}}],[\"need\",{\"1\":{\"12\":1,\"32\":1,\"299\":4,\"346\":2}}],[\"newticker\",{\"1\":{\"428\":1}}],[\"newtimer\",{\"1\":{\"424\":1}}],[\"newban\",{\"1\":{\"424\":4}}],[\"newbufiowritersize\",{\"1\":{\"12\":1}}],[\"newbufioreader\",{\"1\":{\"12\":1}}],[\"newg\",{\"1\":{\"407\":2}}],[\"newproc1\",{\"1\":{\"407\":1}}],[\"newproc\",{\"1\":{\"405\":1,\"407\":1}}],[\"newlen\",{\"1\":{\"294\":4}}],[\"new一个\",{\"1\":{\"63\":1}}],[\"newmymap\",{\"1\":{\"52\":2,\"53\":2}}],[\"newconn\",{\"1\":{\"12\":1}}],[\"new\",{\"1\":{\"12\":1,\"44\":1,\"63\":1,\"262\":3,\"264\":2,\"296\":7,\"299\":1,\"391\":2,\"397\":1,\"438\":2,\"450\":2,\"490\":5,\"502\":1}}],[\"network\",{\"1\":{\"502\":1}}],[\"net\",{\"1\":{\"12\":4,\"235\":1,\"238\":2,\"262\":9,\"264\":3,\"266\":2,\"500\":1,\"502\":3}}],[\"nil的\",{\"1\":{\"415\":1}}],[\"nil\",{\"1\":{\"7\":2,\"12\":12,\"34\":1,\"35\":2,\"41\":1,\"48\":2,\"393\":1,\"397\":1,\"415\":2,\"421\":2,\"428\":1,\"435\":4,\"502\":11}}],[\"n\",{\"1\":{\"6\":1,\"12\":1,\"28\":3,\"29\":1,\"35\":1,\"36\":1,\"48\":4,\"246\":2,\"296\":10,\"298\":2,\"299\":2,\"355\":1,\"370\":8,\"400\":8,\"437\":8,\"450\":1,\"451\":1,\"481\":9,\"500\":1,\"502\":3}}],[\"t2\",{\"1\":{\"392\":1}}],[\"t1\",{\"1\":{\"392\":2}}],[\"ttl\",{\"1\":{\"345\":2,\"346\":2}}],[\"t类型存储着键的二进制长度\",{\"1\":{\"301\":1}}],[\"t所能表达的范围内\",{\"1\":{\"299\":1}}],[\"t形式编码\",{\"1\":{\"299\":4}}],[\"t存储着值\",{\"1\":{\"299\":1}}],[\"t或int32\",{\"1\":{\"298\":1}}],[\"t的形式存储着二进制数据的长度\",{\"1\":{\"299\":1}}],[\"t的形式存储着数值\",{\"1\":{\"298\":2}}],[\"t的形式存储\",{\"1\":{\"298\":1}}],[\"t的取值范围中\",{\"1\":{\"298\":1}}],[\"t的取值范围\",{\"1\":{\"298\":1}}],[\"two\",{\"1\":{\"296\":1}}],[\"twitter的snowflake算法\",{\"1\":{\"94\":1}}],[\"t命令对数据进行重新统计\",{\"1\":{\"252\":1}}],[\"tx\",{\"1\":{\"219\":23}}],[\"teacher\",{\"1\":{\"408\":5}}],[\"testing\",{\"1\":{\"300\":1}}],[\"testcookie\",{\"1\":{\"265\":1}}],[\"testcity\",{\"1\":{\"229\":2,\"230\":5}}],[\"temporarry\",{\"1\":{\"300\":1}}],[\"tempdelay\",{\"1\":{\"12\":2}}],[\"terminator\",{\"1\":{\"294\":4}}],[\"text\",{\"1\":{\"200\":1}}],[\"text值被视为非二进制字符串\",{\"1\":{\"131\":1}}],[\"tddl\",{\"1\":{\"85\":1}}],[\"ty\",{\"1\":{\"72\":1}}],[\"type的case\",{\"1\":{\"392\":1}}],[\"type的底层实现外\",{\"1\":{\"295\":1}}],[\"type的底层实现\",{\"1\":{\"294\":1}}],[\"type=\",{\"1\":{\"341\":1}}],[\"type类型的redisobject\",{\"1\":{\"292\":1}}],[\"type之间的关系\",{\"0\":{\"292\":1}}],[\"types\",{\"1\":{\"262\":2}}],[\"type是否开启缓存\",{\"1\":{\"236\":1}}],[\"typedmemclr\",{\"1\":{\"484\":3}}],[\"typedef\",{\"1\":{\"294\":1,\"295\":3,\"296\":5,\"297\":2,\"298\":1,\"300\":5}}],[\"typed\",{\"1\":{\"32\":1}}],[\"type\",{\"1\":{\"6\":1,\"12\":1,\"19\":4,\"20\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"42\":6,\"43\":1,\"45\":2,\"46\":5,\"47\":1,\"48\":12,\"52\":1,\"53\":1,\"57\":1,\"58\":2,\"63\":1,\"195\":2,\"262\":4,\"292\":2,\"294\":6,\"296\":1,\"339\":1,\"341\":1,\"342\":1,\"391\":2,\"392\":4,\"393\":1,\"394\":2,\"397\":1,\"399\":1,\"400\":1,\"406\":1,\"408\":2,\"412\":1,\"414\":2,\"415\":2,\"421\":3,\"424\":2,\"437\":1,\"439\":1,\"441\":1,\"448\":1,\"449\":1,\"481\":1,\"490\":1,\"496\":2,\"508\":1}}],[\"talk\",{\"1\":{\"414\":3}}],[\"take\",{\"1\":{\"299\":1}}],[\"tail分别指向头尾指针\",{\"1\":{\"300\":1}}],[\"tail\",{\"1\":{\"295\":1,\"297\":1,\"299\":20,\"300\":1}}],[\"tag\",{\"1\":{\"277\":1}}],[\"tag属性用于\",{\"1\":{\"42\":1}}],[\"table++\",{\"1\":{\"296\":1}}],[\"table中\",{\"1\":{\"296\":1}}],[\"table命令也能直接把对应的文件删除\",{\"1\":{\"255\":1}}],[\"table命令添加索引\",{\"1\":{\"145\":1}}],[\"table来控制\",{\"1\":{\"255\":1}}],[\"tablespaces\",{\"1\":{\"198\":1}}],[\"table\",{\"1\":{\"111\":1,\"139\":2,\"140\":1,\"145\":4,\"195\":1,\"203\":1,\"214\":6,\"225\":1,\"226\":2,\"227\":2,\"229\":1,\"230\":1,\"234\":1,\"237\":1,\"246\":1,\"252\":1,\"255\":2,\"296\":30,\"341\":1,\"342\":1}}],[\"table时创建索引\",{\"1\":{\"145\":1}}],[\"table时\",{\"1\":{\"87\":1}}],[\"taskid\",{\"1\":{\"6\":3}}],[\"task\",{\"1\":{\"6\":6}}],[\"tid要么是主键\",{\"1\":{\"206\":1}}],[\"tid>500000\",{\"1\":{\"206\":1}}],[\"tid\",{\"1\":{\"206\":3}}],[\"tinytext\",{\"1\":{\"200\":1}}],[\"ticker对象\",{\"1\":{\"428\":1}}],[\"tick\",{\"1\":{\"35\":1,\"451\":1}}],[\"timeevent\",{\"1\":{\"354\":1}}],[\"timeline\",{\"1\":{\"276\":1}}],[\"time`\",{\"1\":{\"234\":3}}],[\"time参数来设置日志记录行为\",{\"1\":{\"224\":1}}],[\"timestamp\",{\"1\":{\"193\":5}}],[\"timestamp字段的值都会被自动更新\",{\"1\":{\"128\":1}}],[\"timestamp类型适合用来记录数据的最后修改时间\",{\"1\":{\"128\":1}}],[\"timer\",{\"1\":{\"8\":3,\"19\":2,\"424\":3,\"431\":1}}],[\"timeout\",{\"1\":{\"8\":2,\"264\":1,\"327\":1,\"421\":1,\"431\":5,\"473\":1}}],[\"time\",{\"1\":{\"5\":2,\"6\":2,\"8\":6,\"12\":3,\"19\":1,\"35\":4,\"58\":6,\"234\":2,\"237\":1,\"265\":1,\"347\":1,\"395\":2,\"397\":7,\"398\":2,\"421\":1,\"424\":17,\"428\":4,\"431\":11,\"446\":5,\"447\":3,\"450\":7,\"451\":5,\"502\":4}}],[\"tls\",{\"1\":{\"34\":1}}],[\"tl\",{\"1\":{\"12\":2}}],[\"trace\",{\"1\":{\"502\":4}}],[\"track\",{\"1\":{\"32\":1}}],[\"transportrequest\",{\"1\":{\"502\":1}}],[\"transport\",{\"1\":{\"502\":10}}],[\"tryputidleconn\",{\"1\":{\"502\":9}}],[\"try\",{\"1\":{\"262\":1,\"346\":1}}],[\"truncated\",{\"1\":{\"353\":2}}],[\"truncate\",{\"1\":{\"177\":1}}],[\"true代表所有字符全都不同\",{\"1\":{\"370\":1}}],[\"true或者false\",{\"1\":{\"112\":1}}],[\"true\",{\"1\":{\"12\":1,\"215\":1,\"219\":1,\"264\":4,\"265\":1,\"300\":1,\"366\":3,\"370\":3,\"374\":1,\"378\":1,\"382\":1,\"401\":1,\"407\":1,\"421\":1,\"424\":2,\"431\":1,\"478\":1,\"484\":1,\"502\":7}}],[\"trx\",{\"1\":{\"119\":1,\"215\":9,\"217\":2,\"218\":13,\"219\":5}}],[\"trigger\",{\"1\":{\"33\":2,\"262\":2}}],[\"treq\",{\"1\":{\"502\":1}}],[\"treat\",{\"1\":{\"32\":1}}],[\"tree索引是有序的\",{\"1\":{\"228\":1}}],[\"tree索引\",{\"1\":{\"228\":1}}],[\"trees\",{\"1\":{\"12\":1}}],[\"tree\",{\"1\":{\"12\":2,\"69\":1}}],[\"tcp四次挥手告别\",{\"1\":{\"123\":1}}],[\"tcp协议监听端口\",{\"1\":{\"12\":1}}],[\"tcp\",{\"1\":{\"12\":1}}],[\"things\",{\"1\":{\"288\":1}}],[\"think\",{\"1\":{\"260\":2,\"414\":4}}],[\"this\",{\"1\":{\"12\":2,\"35\":1,\"296\":6,\"299\":4,\"300\":1,\"490\":1,\"502\":1}}],[\"than\",{\"1\":{\"234\":3,\"296\":1,\"299\":1}}],[\"that\",{\"1\":{\"12\":1,\"32\":2,\"34\":1,\"35\":3,\"36\":1,\"296\":5,\"299\":3,\"502\":1}}],[\"threshold\",{\"1\":{\"296\":1}}],[\"threadsafeset\",{\"1\":{\"413\":1}}],[\"threads\",{\"1\":{\"224\":2}}],[\"threadlocal\",{\"1\":{\"29\":1}}],[\"threadlocal用来定义线程私有全局变量\",{\"1\":{\"29\":1}}],[\"thread\",{\"1\":{\"28\":1,\"29\":1,\"34\":3,\"36\":1,\"117\":1,\"192\":1}}],[\"throughout\",{\"1\":{\"299\":1}}],[\"through中缓存失效策略来更新缓存\",{\"1\":{\"288\":1}}],[\"through\",{\"1\":{\"288\":2}}],[\"through行为\",{\"1\":{\"7\":1}}],[\"throwable\",{\"1\":{\"262\":1}}],[\"throw\",{\"1\":{\"262\":2}}],[\"throw关键字抛出异常\",{\"1\":{\"262\":1}}],[\"there\",{\"1\":{\"35\":1,\"58\":1,\"294\":1,\"296\":1,\"299\":1}}],[\"their\",{\"1\":{\"12\":1}}],[\"them\",{\"1\":{\"12\":1,\"502\":1}}],[\"the\",{\"1\":{\"12\":11,\"31\":2,\"32\":3,\"33\":5,\"34\":1,\"35\":8,\"57\":1,\"294\":6,\"296\":35,\"299\":31,\"300\":7,\"346\":7,\"407\":2,\"502\":7}}],[\"tofree\",{\"1\":{\"346\":1}}],[\"total\",{\"1\":{\"300\":3}}],[\"tools\",{\"0\":{\"336\":1,\"339\":1},\"1\":{\"333\":1,\"335\":1,\"336\":1,\"338\":2,\"342\":1}}],[\"too\",{\"1\":{\"300\":1}}],[\"top\",{\"1\":{\"36\":1,\"296\":1,\"386\":4,\"502\":1}}],[\"to\",{\"1\":{\"12\":6,\"32\":5,\"33\":7,\"35\":2,\"36\":2,\"48\":1,\"238\":1,\"294\":1,\"296\":9,\"299\":12,\"300\":4,\"317\":1,\"319\":1,\"346\":4,\"401\":1,\"407\":1,\"490\":8,\"502\":4}}],[\"t\",{\"1\":{\"6\":3,\"12\":5,\"32\":1,\"46\":5,\"48\":9,\"158\":1,\"246\":1,\"294\":10,\"296\":6,\"298\":6,\"299\":8,\"300\":1,\"408\":3,\"428\":2,\"490\":1,\"502\":9}}],[\"案例中我们定义了一个结构体\",{\"1\":{\"52\":1,\"53\":1}}],[\"案例中我们生成100个任务\",{\"1\":{\"6\":1}}],[\"案例\",{\"1\":{\"6\":2,\"7\":1,\"52\":1,\"53\":1,\"57\":1,\"58\":1}}],[\"两阶段提交\",{\"1\":{\"244\":1}}],[\"两种情况会导致此问题\",{\"1\":{\"283\":1}}],[\"两种\",{\"1\":{\"238\":1}}],[\"两者都支持\",{\"1\":{\"231\":1}}],[\"两者一直处于阻塞\",{\"1\":{\"3\":1}}],[\"两次索引查找\",{\"1\":{\"230\":1}}],[\"两次读取得到的结果集不一样了\",{\"1\":{\"96\":1}}],[\"两个参数\",{\"1\":{\"410\":1}}],[\"两个问题\",{\"1\":{\"382\":1}}],[\"两个相同的查询\",{\"1\":{\"96\":1}}],[\"两个字段\",{\"1\":{\"53\":1}}],[\"两个method\",{\"1\":{\"46\":1}}],[\"两个协程之间通过ch进行通信\",{\"1\":{\"5\":1}}],[\"eof的报错\",{\"1\":{\"502\":1}}],[\"eof\",{\"1\":{\"502\":3}}],[\"eofc\",{\"1\":{\"502\":4}}],[\"earlyclosefn\",{\"1\":{\"502\":7}}],[\"easy\",{\"1\":{\"299\":1}}],[\"es\",{\"1\":{\"502\":17}}],[\"establishes\",{\"1\":{\"502\":1}}],[\"escape\",{\"1\":{\"490\":5}}],[\"escapes\",{\"1\":{\"490\":6}}],[\"ep\",{\"1\":{\"483\":1,\"484\":5}}],[\"edis\",{\"1\":{\"346\":1}}],[\"evicted\",{\"1\":{\"346\":2}}],[\"evictedkeys++\",{\"1\":{\"346\":1}}],[\"evictionpoolpopulate\",{\"1\":{\"346\":2}}],[\"eviction\",{\"1\":{\"346\":9}}],[\"everysec\",{\"1\":{\"353\":4,\"356\":1}}],[\"every\",{\"1\":{\"35\":2,\"296\":1}}],[\"ever\",{\"1\":{\"32\":1}}],[\"even\",{\"1\":{\"12\":1,\"296\":1}}],[\"effect\",{\"1\":{\"299\":1}}],[\"echo\",{\"1\":{\"269\":1}}],[\"e\",{\"1\":{\"262\":35,\"502\":1}}],[\"equal\",{\"1\":{\"299\":1}}],[\"eq\",{\"1\":{\"195\":1,\"490\":1}}],[\"employee\",{\"1\":{\"93\":4}}],[\"empty\",{\"1\":{\"29\":1,\"47\":1,\"296\":4,\"346\":1}}],[\"elemtype\",{\"1\":{\"484\":1}}],[\"elem\",{\"1\":{\"413\":2}}],[\"elements\",{\"1\":{\"296\":3,\"339\":1,\"341\":2,\"342\":1,\"346\":1}}],[\"element\",{\"1\":{\"296\":3,\"299\":4,\"339\":1,\"341\":1,\"342\":1,\"346\":2}}],[\"ele\",{\"1\":{\"297\":3}}],[\"eliminates\",{\"1\":{\"35\":1}}],[\"else\",{\"1\":{\"12\":2,\"29\":1,\"53\":1,\"294\":1,\"297\":2,\"299\":7,\"346\":3,\"370\":3,\"414\":1,\"415\":1,\"502\":1}}],[\"exit\",{\"1\":{\"431\":2}}],[\"existing\",{\"1\":{\"296\":7}}],[\"exists\",{\"1\":{\"112\":1,\"296\":1,\"346\":1}}],[\"exec只会返回一条信息\",{\"1\":{\"400\":1}}],[\"exec\",{\"1\":{\"269\":1,\"397\":2,\"400\":2,\"437\":2}}],[\"executing\",{\"1\":{\"34\":3,\"401\":1}}],[\"execution\",{\"1\":{\"31\":1,\"401\":1}}],[\"examples\",{\"1\":{\"264\":1}}],[\"examined\",{\"1\":{\"243\":1}}],[\"exactly\",{\"1\":{\"31\":1}}],[\"extra\",{\"1\":{\"195\":1,\"299\":3,\"300\":2}}],[\"extern\",{\"1\":{\"34\":1}}],[\"expand\",{\"1\":{\"296\":3}}],[\"explame\",{\"1\":{\"265\":1}}],[\"explaining\",{\"1\":{\"502\":1}}],[\"explain分析sql语句\",{\"1\":{\"129\":1}}],[\"explain\",{\"0\":{\"103\":1},\"1\":{\"103\":1,\"189\":1,\"195\":1}}],[\"expectcontinuereader\",{\"1\":{\"12\":1}}],[\"expectscontinue\",{\"1\":{\"12\":1}}],[\"expect\",{\"1\":{\"12\":2}}],[\"excluding\",{\"1\":{\"294\":4}}],[\"exclusion\",{\"1\":{\"57\":1}}],[\"exceptionhandler\",{\"1\":{\"262\":3}}],[\"exceptions\",{\"1\":{\"262\":1}}],[\"exception\",{\"1\":{\"262\":11}}],[\"exchange\",{\"1\":{\"32\":1}}],[\"either\",{\"1\":{\"12\":1,\"31\":1}}],[\"erraborthandler\",{\"1\":{\"12\":1}}],[\"err\",{\"1\":{\"12\":12,\"296\":4,\"346\":1,\"393\":4,\"397\":3,\"428\":3,\"502\":21}}],[\"errserverclosed\",{\"1\":{\"12\":1}}],[\"error的错误可以交由set\",{\"1\":{\"262\":1}}],[\"errorhandler\",{\"1\":{\"262\":2}}],[\"errorexception\",{\"1\":{\"262\":5}}],[\"errorfunc\",{\"1\":{\"262\":1}}],[\"error\",{\"1\":{\"4\":1,\"6\":1,\"12\":2,\"262\":31,\"352\":2,\"412\":1,\"502\":11}}],[\"encode\",{\"1\":{\"299\":2}}],[\"encoded\",{\"1\":{\"299\":1}}],[\"encoding字段\",{\"1\":{\"300\":1}}],[\"encoding字段的规约就复杂了许多\",{\"1\":{\"299\":1}}],[\"encoding\",{\"1\":{\"298\":1,\"299\":10,\"300\":2,\"339\":1,\"341\":1,\"342\":1}}],[\"enc\",{\"1\":{\"298\":8}}],[\"entries\",{\"1\":{\"296\":1,\"300\":2}}],[\"entry的概念重新包装一下\",{\"1\":{\"300\":1}}],[\"entry的内存布局如下所示\",{\"1\":{\"299\":1}}],[\"entry\",{\"1\":{\"296\":13,\"299\":12,\"346\":1,\"421\":3}}],[\"enough\",{\"1\":{\"294\":1}}],[\"en\",{\"1\":{\"262\":2}}],[\"enable\",{\"1\":{\"227\":1}}],[\"ensure\",{\"1\":{\"36\":1}}],[\"engine=innodb\",{\"1\":{\"145\":1,\"234\":1,\"246\":1,\"255\":1}}],[\"engine\",{\"1\":{\"12\":18,\"81\":1,\"234\":3}}],[\"ends\",{\"1\":{\"300\":1}}],[\"end\",{\"1\":{\"5\":2,\"35\":1,\"299\":8,\"300\":1,\"502\":1}}],[\"3的概率为\",{\"1\":{\"297\":1}}],[\"3字节\",{\"1\":{\"294\":1}}],[\"38\",{\"0\":{\"138\":1}}],[\"3625522\",{\"1\":{\"234\":1}}],[\"36\",{\"0\":{\"136\":1}}],[\"3600\",{\"1\":{\"264\":1,\"265\":1}}],[\"360\",{\"1\":{\"85\":1}}],[\"39\",{\"0\":{\"139\":1},\"1\":{\"72\":1}}],[\"377671748\",{\"1\":{\"339\":1}}],[\"37\",{\"0\":{\"137\":1},\"1\":{\"72\":1}}],[\"35\",{\"0\":{\"135\":1},\"1\":{\"72\":1}}],[\"31的概率为\",{\"1\":{\"297\":1}}],[\"3128\",{\"1\":{\"266\":2}}],[\"31\",{\"0\":{\"131\":1},\"1\":{\"72\":1,\"297\":1}}],[\"345\",{\"1\":{\"473\":2}}],[\"34\",{\"0\":{\"134\":1},\"1\":{\"63\":2,\"72\":1}}],[\"3000\",{\"1\":{\"370\":4}}],[\"300\",{\"1\":{\"352\":2}}],[\"30\",{\"0\":{\"130\":1},\"1\":{\"48\":1,\"234\":1}}],[\"33\",{\"0\":{\"133\":1},\"1\":{\"47\":1,\"72\":1}}],[\"32kb\",{\"1\":{\"300\":1}}],[\"32k\",{\"1\":{\"300\":1}}],[\"32769\",{\"1\":{\"299\":1}}],[\"32767\",{\"1\":{\"299\":1}}],[\"32768\",{\"1\":{\"299\":2}}],[\"32的概率为\",{\"1\":{\"297\":1}}],[\"32\",{\"0\":{\"132\":1},\"1\":{\"36\":1,\"300\":3,\"473\":1}}],[\"3秒后才会被触发去执行某些事\",{\"1\":{\"8\":1}}],[\"3\",{\"0\":{\"82\":1,\"276\":1,\"296\":1,\"311\":1,\"316\":1,\"323\":1,\"327\":1,\"346\":1,\"393\":1,\"407\":1,\"447\":1,\"458\":1},\"1\":{\"5\":1,\"6\":1,\"8\":2,\"58\":2,\"63\":8,\"66\":1,\"217\":1,\"218\":11,\"219\":9,\"229\":2,\"238\":1,\"277\":1,\"294\":5,\"300\":1,\"345\":1,\"346\":6,\"410\":2,\"411\":2,\"428\":2,\"469\":2,\"480\":1,\"481\":3}}],[\"dynamic\",{\"0\":{\"294\":1}}],[\"dql\",{\"1\":{\"212\":1}}],[\"ddl\",{\"1\":{\"177\":2}}],[\"dddd\",{\"1\":{\"45\":1}}],[\"dml\",{\"1\":{\"177\":1,\"212\":1}}],[\"dropping\",{\"1\":{\"401\":1}}],[\"drop主键索引会导致其他索引失效\",{\"1\":{\"246\":1}}],[\"drop\",{\"0\":{\"177\":1},\"1\":{\"177\":1}}],[\"dbfilename\",{\"1\":{\"352\":1}}],[\"dbdelete\",{\"1\":{\"346\":1}}],[\"db权限表\",{\"1\":{\"139\":1}}],[\"db\",{\"1\":{\"139\":1,\"215\":10,\"217\":4,\"218\":10,\"219\":20,\"341\":1,\"342\":1,\"346\":7,\"450\":1}}],[\"db脚本初始化\",{\"1\":{\"139\":1}}],[\"date\",{\"1\":{\"205\":1}}],[\"datetime\",{\"1\":{\"145\":1,\"193\":4}}],[\"datetime字段的值不会改变\",{\"1\":{\"128\":1}}],[\"datetime类型适合用来记录数据的原始的创建时间\",{\"1\":{\"128\":1}}],[\"data为键的数据\",{\"1\":{\"301\":1}}],[\"database\",{\"1\":{\"296\":1,\"339\":1,\"341\":1,\"342\":1}}],[\"data\",{\"1\":{\"31\":1,\"58\":5,\"63\":1,\"67\":1,\"69\":1,\"300\":2,\"301\":1,\"308\":1,\"328\":1,\"352\":1,\"496\":2}}],[\"dialconn\",{\"1\":{\"502\":1}}],[\"didtimeout\",{\"1\":{\"502\":1}}],[\"dir\",{\"1\":{\"352\":1}}],[\"direction\",{\"1\":{\"295\":1,\"300\":1}}],[\"directly\",{\"1\":{\"294\":1}}],[\"diff\",{\"1\":{\"335\":1}}],[\"difficult\",{\"1\":{\"32\":1}}],[\"dictgetkey\",{\"1\":{\"346\":1}}],[\"dict支持各种嵌套\",{\"1\":{\"301\":1}}],[\"dict的中的一坨指针会浪费不少内存\",{\"1\":{\"301\":1}}],[\"dict的使用者是无感知的\",{\"1\":{\"296\":1}}],[\"dict作为字典结构\",{\"1\":{\"301\":1}}],[\"dict是最复杂的底层数据结构\",{\"1\":{\"300\":1}}],[\"dict是redis底层数据结构中实现最为复杂的一个数据结构\",{\"1\":{\"296\":1}}],[\"dictreset\",{\"1\":{\"296\":1}}],[\"dictrehash\",{\"1\":{\"296\":2}}],[\"dictrehashstep\",{\"1\":{\"296\":2}}],[\"dictcomparekeys\",{\"1\":{\"296\":1}}],[\"dictexpand\",{\"1\":{\"296\":3}}],[\"dictexpandifneeded\",{\"1\":{\"296\":2}}],[\"dictentry\",{\"1\":{\"296\":13}}],[\"dictsetkey\",{\"1\":{\"296\":1}}],[\"dictsetval\",{\"1\":{\"296\":1}}],[\"dicthashkey\",{\"1\":{\"296\":2}}],[\"dictht\",{\"1\":{\"296\":5}}],[\"dictkeyindex\",{\"1\":{\"296\":2}}],[\"dict即为字典\",{\"1\":{\"296\":1}}],[\"dict中存储的键值对\",{\"1\":{\"296\":1}}],[\"dictisrehashing\",{\"1\":{\"296\":6}}],[\"dictiterator\",{\"1\":{\"296\":2}}],[\"dictionary\",{\"1\":{\"41\":1,\"296\":2}}],[\"dictnextpower\",{\"1\":{\"296\":1}}],[\"dictnext\",{\"1\":{\"296\":1}}],[\"dictfind\",{\"1\":{\"296\":1,\"346\":1}}],[\"dictaddraw\",{\"1\":{\"296\":2}}],[\"dictadd\",{\"1\":{\"296\":2}}],[\"dicttype结构与dict\",{\"1\":{\"296\":1}}],[\"dicttype\",{\"1\":{\"296\":3}}],[\"dict\",{\"0\":{\"296\":1},\"1\":{\"292\":1,\"296\":25,\"346\":3}}],[\"distinct\",{\"1\":{\"229\":1,\"230\":2}}],[\"disabled\",{\"1\":{\"300\":1}}],[\"disable\",{\"1\":{\"226\":1}}],[\"die\",{\"1\":{\"36\":1}}],[\"dup\",{\"1\":{\"295\":2}}],[\"duplicates\",{\"1\":{\"33\":1}}],[\"dump\",{\"1\":{\"117\":1,\"192\":1,\"333\":1,\"335\":1,\"339\":1,\"342\":1,\"352\":1}}],[\"during\",{\"1\":{\"32\":1,\"300\":1}}],[\"duration\",{\"1\":{\"12\":1,\"421\":1,\"431\":2}}],[\"d\",{\"0\":{\"456\":1,\"457\":1,\"458\":1,\"460\":1,\"463\":1},\"1\":{\"6\":1,\"35\":2,\"296\":66,\"424\":2,\"436\":2,\"445\":1,\"446\":1,\"447\":1,\"448\":1,\"449\":1,\"450\":2,\"451\":2,\"452\":1,\"453\":1,\"454\":1,\"500\":1,\"507\":1}}],[\"doubling\",{\"1\":{\"296\":1}}],[\"doublecheck\",{\"1\":{\"448\":1}}],[\"double\",{\"1\":{\"141\":1,\"296\":1,\"297\":2}}],[\"does\",{\"1\":{\"296\":1,\"490\":5,\"502\":1,\"508\":1}}],[\"doesn\",{\"1\":{\"32\":1,\"299\":1}}],[\"document\",{\"1\":{\"294\":1}}],[\"docs\",{\"1\":{\"238\":1}}],[\"domain\",{\"1\":{\"265\":6}}],[\"domin\",{\"1\":{\"265\":1}}],[\"do\",{\"1\":{\"6\":2,\"7\":2,\"448\":1,\"502\":1}}],[\"done\",{\"1\":{\"5\":2,\"6\":2,\"7\":2,\"52\":1,\"53\":1,\"57\":1,\"58\":3,\"366\":1,\"401\":1,\"407\":2,\"418\":2,\"424\":2,\"431\":2,\"447\":1,\"448\":4,\"502\":1}}],[\"death\",{\"1\":{\"502\":1}}],[\"deadline\",{\"1\":{\"502\":3}}],[\"deadlock\",{\"0\":{\"4\":1},\"1\":{\"4\":1,\"6\":1,\"36\":1}}],[\"dead\",{\"1\":{\"36\":1}}],[\"debug\",{\"1\":{\"355\":1}}],[\"del\",{\"1\":{\"346\":1}}],[\"delta\",{\"1\":{\"346\":3,\"396\":1}}],[\"del命令除外\",{\"1\":{\"345\":1}}],[\"delete语句执行后数据文件大小并没有改变\",{\"1\":{\"255\":1}}],[\"delete与truncate的区别\",{\"0\":{\"177\":1}}],[\"delete\",{\"1\":{\"41\":2,\"52\":4,\"53\":3,\"117\":1,\"171\":2,\"177\":1,\"192\":1,\"214\":1,\"215\":1,\"424\":1,\"453\":1}}],[\"delegates\",{\"1\":{\"12\":1}}],[\"de\",{\"1\":{\"296\":8,\"346\":3}}],[\"detection\",{\"1\":{\"296\":1}}],[\"details\",{\"1\":{\"235\":1,\"238\":2,\"266\":2}}],[\"declaration\",{\"1\":{\"502\":1}}],[\"decay\",{\"1\":{\"347\":1}}],[\"decompressed\",{\"1\":{\"300\":1}}],[\"decode\",{\"1\":{\"299\":1}}],[\"decrrefcount\",{\"1\":{\"346\":1}}],[\"decr\",{\"1\":{\"268\":1}}],[\"decimal和numeric值作为字符串存储\",{\"1\":{\"132\":1}}],[\"decimal\",{\"1\":{\"132\":1}}],[\"desc\",{\"1\":{\"341\":1}}],[\"describing\",{\"1\":{\"300\":2}}],[\"describes\",{\"1\":{\"31\":1,\"33\":1}}],[\"destroy\",{\"1\":{\"264\":1}}],[\"depth\",{\"1\":{\"300\":1}}],[\"deptid==b\",{\"1\":{\"112\":1}}],[\"deptid\",{\"1\":{\"112\":10}}],[\"deprecated\",{\"1\":{\"262\":3}}],[\"deployed\",{\"1\":{\"12\":1}}],[\"deepequal\",{\"1\":{\"44\":2}}],[\"define\",{\"1\":{\"298\":3}}],[\"defalut语句是可选的\",{\"1\":{\"7\":1}}],[\"defaulttransport\",{\"1\":{\"502\":5}}],[\"defaultclient\",{\"1\":{\"502\":1}}],[\"default404body\",{\"1\":{\"12\":1}}],[\"defaultservemux\",{\"1\":{\"12\":2}}],[\"default\",{\"1\":{\"7\":1,\"48\":1,\"145\":5,\"234\":2,\"300\":1,\"435\":1}}],[\"deferred\",{\"1\":{\"502\":1}}],[\"deferreturn的时候\",{\"1\":{\"405\":1}}],[\"deferreturn\",{\"1\":{\"405\":1}}],[\"deferproc时会将需要defer的表达式记录在表中\",{\"1\":{\"405\":1}}],[\"deferproc\",{\"1\":{\"405\":1}}],[\"deferproc而不是runtime\",{\"1\":{\"405\":1}}],[\"defererror\",{\"1\":{\"397\":3}}],[\"defer\",{\"1\":{\"5\":3,\"6\":1,\"7\":2,\"12\":2,\"19\":2,\"52\":4,\"53\":1,\"57\":3,\"58\":6,\"397\":2,\"405\":7,\"410\":3,\"412\":1,\"418\":2,\"421\":1,\"424\":3,\"428\":1,\"431\":2,\"445\":2,\"446\":3,\"448\":1,\"502\":1}}],[\"2不调整\",{\"1\":{\"469\":1}}],[\"2为轴\",{\"1\":{\"374\":1}}],[\"2代表压缩过\",{\"1\":{\"300\":1}}],[\"2版本之后\",{\"1\":{\"300\":1}}],[\"2版本之前\",{\"1\":{\"300\":1}}],[\"2版本后新加的\",{\"1\":{\"300\":1}}],[\"2^31\",{\"1\":{\"299\":2}}],[\"2的概率为\",{\"1\":{\"297\":1}}],[\"27093465\",{\"1\":{\"266\":1}}],[\"27\",{\"0\":{\"127\":1}}],[\"26\",{\"0\":{\"125\":1}}],[\"23\",{\"0\":{\"117\":1},\"1\":{\"72\":1,\"406\":1,\"473\":1}}],[\"295\",{\"1\":{\"200\":1}}],[\"294\",{\"1\":{\"200\":1}}],[\"29\",{\"0\":{\"129\":1},\"1\":{\"72\":1}}],[\"2443\",{\"1\":{\"339\":1}}],[\"24\",{\"0\":{\"120\":1},\"1\":{\"72\":1,\"406\":1}}],[\"28\",{\"0\":{\"128\":1},\"1\":{\"69\":1,\"450\":1}}],[\"28在26和30之间\",{\"1\":{\"69\":1}}],[\"215\",{\"1\":{\"200\":1}}],[\"21\",{\"0\":{\"114\":1},\"1\":{\"63\":2,\"441\":2}}],[\"250\",{\"1\":{\"502\":1}}],[\"254\",{\"1\":{\"299\":3}}],[\"25^i\",{\"1\":{\"297\":1}}],[\"25^30\",{\"1\":{\"297\":1}}],[\"255之间\",{\"1\":{\"347\":1}}],[\"255\",{\"1\":{\"145\":1,\"401\":2}}],[\"25\",{\"0\":{\"121\":1},\"1\":{\"72\":1,\"297\":4}}],[\"25倍\",{\"1\":{\"63\":2}}],[\"256mib\",{\"1\":{\"450\":1}}],[\"256\",{\"1\":{\"20\":1,\"35\":1,\"200\":1,\"370\":2}}],[\"2倍或者1\",{\"1\":{\"63\":1}}],[\"22\",{\"0\":{\"116\":1},\"1\":{\"47\":1,\"72\":1,\"406\":1,\"441\":2}}],[\"2\",{\"0\":{\"81\":1,\"275\":1,\"293\":1,\"294\":1,\"295\":2,\"296\":1,\"297\":1,\"298\":1,\"299\":1,\"300\":1,\"301\":1,\"310\":1,\"315\":1,\"322\":1,\"326\":1,\"392\":1,\"406\":1,\"446\":1,\"457\":1,\"481\":1,\"484\":1},\"1\":{\"5\":1,\"7\":1,\"12\":1,\"47\":1,\"63\":12,\"66\":1,\"72\":1,\"91\":1,\"132\":1,\"206\":1,\"217\":1,\"218\":15,\"219\":25,\"238\":1,\"262\":3,\"277\":1,\"294\":1,\"296\":3,\"298\":1,\"300\":6,\"319\":1,\"326\":1,\"346\":2,\"374\":1,\"386\":2,\"397\":1,\"410\":8,\"411\":2,\"418\":1,\"428\":2,\"438\":1,\"446\":1,\"449\":1,\"451\":1}}],[\"207\",{\"1\":{\"502\":1}}],[\"2019\",{\"1\":{\"288\":1,\"347\":1}}],[\"2038\",{\"1\":{\"193\":1}}],[\"200\",{\"1\":{\"175\":1,\"206\":2}}],[\"20的查询时\",{\"1\":{\"152\":1}}],[\"20\",{\"0\":{\"113\":1,\"176\":3},\"1\":{\"3\":1,\"63\":2,\"176\":6,\"382\":2,\"407\":1,\"410\":3}}],[\"wuyanzu\",{\"1\":{\"399\":1}}],[\"w后\",{\"1\":{\"301\":1}}],[\"would\",{\"1\":{\"299\":1}}],[\"word被修改为hello\",{\"1\":{\"301\":1}}],[\"world\",{\"1\":{\"47\":1,\"292\":1,\"490\":3}}],[\"worker\",{\"1\":{\"36\":1}}],[\"work\",{\"1\":{\"34\":2,\"36\":3,\"352\":1}}],[\"wpjamer\",{\"1\":{\"266\":1}}],[\"www\",{\"1\":{\"234\":1,\"235\":1,\"238\":1,\"262\":1,\"265\":1,\"266\":1,\"500\":1}}],[\"why\",{\"1\":{\"502\":1}}],[\"whole\",{\"1\":{\"296\":1}}],[\"while\",{\"1\":{\"296\":6,\"297\":2,\"299\":1,\"346\":2}}],[\"which\",{\"1\":{\"32\":1,\"299\":1,\"346\":1}}],[\"when\",{\"1\":{\"36\":1,\"299\":6,\"300\":1}}],[\"where条件要包含分区列\",{\"1\":{\"234\":1}}],[\"where子句中使用最频繁的一列放在最左边\",{\"1\":{\"147\":1}}],[\"where时一定用引号括起来\",{\"1\":{\"78\":1}}],[\"where\",{\"1\":{\"32\":1,\"72\":2,\"93\":3,\"98\":1,\"111\":1,\"112\":5,\"152\":1,\"158\":1,\"206\":2,\"214\":4,\"230\":2,\"234\":1,\"341\":1}}],[\"what\",{\"1\":{\"35\":1}}],[\"wakep\",{\"1\":{\"407\":1}}],[\"wakeup\",{\"1\":{\"19\":1}}],[\"wang\",{\"1\":{\"406\":1}}],[\"want\",{\"1\":{\"299\":1}}],[\"warning\",{\"1\":{\"262\":5,\"299\":1}}],[\"wasn\",{\"1\":{\"502\":1}}],[\"was\",{\"1\":{\"12\":1,\"34\":1,\"35\":1,\"300\":1}}],[\"waitforbodyread\",{\"1\":{\"502\":8}}],[\"waittimeout\",{\"0\":{\"431\":1},\"1\":{\"431\":4}}],[\"wait用来等待字母打印完成后退出循环\",{\"1\":{\"366\":1}}],[\"waiting\",{\"1\":{\"36\":3}}],[\"wait\",{\"1\":{\"5\":1,\"6\":1,\"7\":1,\"35\":1,\"52\":1,\"53\":1,\"57\":1,\"58\":1,\"366\":7,\"407\":1,\"418\":1,\"424\":5,\"431\":2,\"447\":1,\"458\":1,\"502\":1}}],[\"waitgroup支持timeout功能\",{\"1\":{\"431\":2}}],[\"waitgroup\",{\"0\":{\"431\":1,\"447\":1},\"1\":{\"5\":1,\"6\":1,\"7\":1,\"52\":1,\"53\":1,\"57\":1,\"58\":1,\"366\":2,\"407\":1,\"418\":1,\"424\":1,\"431\":5,\"447\":1,\"458\":1}}],[\"wroterequest\",{\"1\":{\"502\":2}}],[\"writeloop\",{\"1\":{\"502\":1}}],[\"writer\",{\"1\":{\"490\":1}}],[\"writersem\",{\"1\":{\"58\":1}}],[\"writers\",{\"1\":{\"58\":1}}],[\"writermem\",{\"1\":{\"12\":3}}],[\"writes\",{\"1\":{\"32\":1,\"352\":2}}],[\"write\",{\"1\":{\"32\":3,\"141\":1,\"264\":2,\"288\":2,\"299\":1,\"319\":1,\"412\":1}}],[\"writeheadernow\",{\"1\":{\"12\":1}}],[\"wrap\",{\"1\":{\"12\":1}}],[\"will\",{\"1\":{\"35\":1,\"299\":2,\"502\":1}}],[\"wild\",{\"1\":{\"12\":1}}],[\"wire\",{\"1\":{\"12\":1}}],[\"without\",{\"1\":{\"35\":1,\"36\":1}}],[\"with\",{\"1\":{\"12\":1,\"31\":1,\"32\":1,\"34\":1,\"36\":1,\"296\":1,\"300\":1}}],[\"withcancel\",{\"1\":{\"12\":1,\"424\":1}}],[\"withvalue\",{\"1\":{\"12\":2}}],[\"weight=10\",{\"1\":{\"266\":2}}],[\"weight和访问比率成正比\",{\"1\":{\"266\":1}}],[\"weixin\",{\"1\":{\"37\":1,\"473\":1,\"490\":1}}],[\"web开发中主要使用\",{\"1\":{\"266\":1}}],[\"wechat\",{\"1\":{\"37\":1}}],[\"well\",{\"1\":{\"12\":1,\"299\":1}}],[\"we\",{\"1\":{\"12\":5,\"32\":2,\"294\":1,\"296\":8,\"299\":6,\"300\":1,\"346\":3}}],[\"w\",{\"1\":{\"12\":18,\"58\":1}}],[\"wg\",{\"1\":{\"5\":5,\"6\":4,\"7\":5,\"52\":4,\"53\":4,\"57\":4,\"58\":6,\"407\":5,\"418\":5,\"431\":11,\"447\":5}}],[\"s1\",{\"1\":{\"378\":4}}],[\"s1和一个string\",{\"1\":{\"378\":1}}],[\"s2\",{\"1\":{\"378\":4}}],[\"skiplist\",{\"1\":{\"339\":1}}],[\"skiplists\",{\"1\":{\"297\":1}}],[\"small\",{\"1\":{\"300\":1}}],[\"smaller\",{\"1\":{\"296\":1}}],[\"sz\",{\"1\":{\"300\":6}}],[\"s64\",{\"1\":{\"296\":1}}],[\"sripathikrishnan\",{\"1\":{\"338\":1}}],[\"src\",{\"1\":{\"295\":1,\"296\":2,\"483\":1,\"502\":4}}],[\"srv即为server\",{\"1\":{\"12\":1}}],[\"srv\",{\"1\":{\"12\":14}}],[\"sdsfree\",{\"1\":{\"346\":1}}],[\"sds的api内部不负责清除未使用的闲置内存空间\",{\"1\":{\"294\":1}}],[\"sds的总体概览如下图\",{\"1\":{\"294\":1}}],[\"sds除了是某些value\",{\"1\":{\"294\":1}}],[\"sds不会自动回收预留空间\",{\"1\":{\"294\":1}}],[\"sdsremovefreespace\",{\"1\":{\"294\":2}}],[\"sds也提供了接口用于移除所有未使用的内存空间\",{\"1\":{\"294\":1}}],[\"sdslenbestkey\",{\"1\":{\"346\":1}}],[\"sdslen\",{\"1\":{\"294\":1}}],[\"sdsmakeroomfor\",{\"1\":{\"294\":2}}],[\"sdsnew用于带字符串创建sds实例\",{\"1\":{\"294\":1}}],[\"sdsnew\",{\"1\":{\"294\":1}}],[\"sdsnewlen用于带二进制数据创建sds实例\",{\"1\":{\"294\":1}}],[\"sdsnewlen\",{\"1\":{\"294\":1}}],[\"sdsempty\",{\"1\":{\"294\":1}}],[\"sds有五种不同的头部\",{\"1\":{\"294\":1}}],[\"sdshdrsize\",{\"1\":{\"294\":1}}],[\"sdshdr64\",{\"1\":{\"294\":1}}],[\"sdshdr32\",{\"1\":{\"294\":1}}],[\"sdshdr16\",{\"1\":{\"294\":1}}],[\"sdshdr8\",{\"1\":{\"294\":2}}],[\"sdshdr5\",{\"1\":{\"294\":2}}],[\"sds\",{\"0\":{\"294\":1},\"1\":{\"292\":1,\"294\":13,\"297\":2}}],[\"ssh\",{\"1\":{\"201\":2,\"496\":3}}],[\"saweof\",{\"1\":{\"502\":2}}],[\"samples指定\",{\"1\":{\"346\":1}}],[\"samples\",{\"1\":{\"346\":4}}],[\"same\",{\"1\":{\"296\":1}}],[\"safe\",{\"1\":{\"296\":5}}],[\"sale\",{\"1\":{\"268\":2}}],[\"salt\",{\"1\":{\"201\":2}}],[\"salary\",{\"1\":{\"132\":1}}],[\"save命令时\",{\"1\":{\"325\":1}}],[\"saves\",{\"1\":{\"32\":1}}],[\"saved\",{\"1\":{\"32\":1}}],[\"save\",{\"1\":{\"28\":1,\"29\":1,\"264\":1,\"352\":6,\"355\":3}}],[\"squid2\",{\"1\":{\"266\":1}}],[\"squid1\",{\"1\":{\"266\":1}}],[\"square\",{\"1\":{\"48\":2}}],[\"sqlite>select\",{\"1\":{\"341\":4}}],[\"sqlite>\",{\"1\":{\"341\":3,\"342\":3}}],[\"sqlite3\",{\"1\":{\"341\":1,\"342\":1}}],[\"sqlite版本必须是3\",{\"1\":{\"340\":1}}],[\"sqlite\",{\"1\":{\"333\":1,\"340\":1,\"342\":1}}],[\"sql更新语句的执行\",{\"0\":{\"244\":1}}],[\"sql查询语句的执行\",{\"0\":{\"243\":1}}],[\"sql执行线程\",{\"1\":{\"192\":1}}],[\"sql的生命周期\",{\"0\":{\"179\":1}}],[\"sql语句查看当前连接线程是否有废线程\",{\"1\":{\"224\":1}}],[\"sql语句查看当前连接数\",{\"1\":{\"224\":1}}],[\"sql语句\",{\"1\":{\"169\":1}}],[\"sql语句+索引\",{\"1\":{\"120\":1}}],[\"sql\",{\"0\":{\"173\":1},\"1\":{\"103\":3,\"126\":1,\"190\":4,\"237\":1,\"340\":1}}],[\"sql优化的一般步骤是什么\",{\"0\":{\"103\":1}}],[\"switches\",{\"1\":{\"392\":1}}],[\"switch\",{\"0\":{\"48\":1},\"1\":{\"48\":2,\"386\":3,\"392\":2}}],[\"sn=15949fbeb48985c6c3781583df6956e6\",{\"1\":{\"37\":1}}],[\"sl2\",{\"1\":{\"378\":3}}],[\"sl1\",{\"1\":{\"378\":3}}],[\"slen\",{\"1\":{\"299\":6}}],[\"sleep\",{\"1\":{\"5\":1,\"6\":1,\"12\":1,\"19\":1,\"58\":3,\"395\":1,\"397\":4,\"398\":1,\"431\":2,\"446\":2,\"447\":1,\"450\":3,\"451\":1}}],[\"slot\",{\"1\":{\"296\":1}}],[\"slow\",{\"1\":{\"237\":1}}],[\"slave把这个id发送给master\",{\"1\":{\"321\":1}}],[\"slave会保存master的这个id\",{\"1\":{\"321\":1}}],[\"slaves\",{\"1\":{\"319\":2,\"346\":1}}],[\"slave心跳任务\",{\"1\":{\"319\":1}}],[\"slave接收命令后执行命令\",{\"1\":{\"317\":1}}],[\"slaveof等少数命令\",{\"1\":{\"328\":1}}],[\"slaveof\",{\"1\":{\"309\":1,\"311\":1}}],[\"slave主要用来读数据\",{\"1\":{\"307\":1}}],[\"slave\",{\"1\":{\"238\":1,\"305\":1,\"319\":1}}],[\"sliceheader\",{\"1\":{\"63\":1,\"496\":3}}],[\"slice\",{\"1\":{\"35\":2,\"41\":1,\"44\":1,\"47\":1,\"63\":6,\"489\":2},\"2\":{\"65\":1}}],[\"score\",{\"1\":{\"297\":3}}],[\"scale\",{\"1\":{\"132\":1}}],[\"scanning\",{\"1\":{\"32\":1}}],[\"scene=19\",{\"1\":{\"37\":1}}],[\"schedt\",{\"1\":{\"36\":1,\"37\":1}}],[\"schedt结构体用来保存调度器的状态信息和goroutine的全局运行队列\",{\"1\":{\"36\":1}}],[\"schedt结构体\",{\"0\":{\"36\":1}}],[\"schedtick\",{\"1\":{\"35\":1}}],[\"schedt和p结构体\",{\"1\":{\"29\":1}}],[\"scheduling\",{\"1\":{\"34\":1,\"35\":1}}],[\"schedules\",{\"1\":{\"35\":1}}],[\"scheduler\",{\"1\":{\"35\":1,\"401\":2}}],[\"schedule函数实现调度逻辑\",{\"1\":{\"28\":1,\"29\":1}}],[\"schedule\",{\"1\":{\"28\":2,\"29\":2}}],[\"schedlink\",{\"1\":{\"33\":1,\"34\":1}}],[\"schedlink字段指向全局运行队列中的下一个g\",{\"1\":{\"33\":1}}],[\"sched\",{\"1\":{\"19\":1,\"33\":1,\"34\":1,\"37\":1}}],[\"synamic\",{\"1\":{\"292\":1}}],[\"synchronized\",{\"1\":{\"212\":1}}],[\"sync\",{\"0\":{\"57\":1,\"58\":1,\"59\":1,\"431\":1,\"506\":1},\"1\":{\"5\":1,\"6\":1,\"7\":1,\"52\":2,\"53\":1,\"57\":3,\"58\":4,\"366\":2,\"407\":1,\"412\":2,\"418\":1,\"421\":1,\"424\":4,\"431\":7,\"445\":2,\"446\":2,\"447\":2,\"448\":2,\"449\":2,\"450\":2,\"453\":2,\"464\":1,\"507\":2}}],[\"syssession\",{\"1\":{\"264\":2}}],[\"systemstack\",{\"1\":{\"407\":1}}],[\"systems\",{\"1\":{\"36\":1,\"300\":1}}],[\"system\",{\"1\":{\"35\":1,\"36\":2,\"195\":1,\"296\":1,\"401\":2}}],[\"syscalltick\",{\"1\":{\"35\":1}}],[\"syscall\",{\"1\":{\"34\":1}}],[\"sysmontick\",{\"1\":{\"35\":2}}],[\"sysmon是我们的保洁阿姨\",{\"1\":{\"23\":1}}],[\"sysmon\",{\"0\":{\"23\":1},\"1\":{\"35\":1}}],[\"sys\",{\"1\":{\"19\":1,\"32\":1,\"407\":1}}],[\"speak\",{\"1\":{\"414\":3}}],[\"spec\",{\"1\":{\"392\":1}}],[\"specialized\",{\"1\":{\"297\":1}}],[\"sprintf\",{\"1\":{\"394\":1,\"424\":2}}],[\"springcache等\",{\"1\":{\"282\":1}}],[\"span字段代表forward字段指向的结点\",{\"1\":{\"297\":1}}],[\"span\",{\"1\":{\"297\":2}}],[\"space\",{\"1\":{\"294\":1,\"299\":1}}],[\"spl\",{\"1\":{\"262\":1}}],[\"spl提供了一系列标准异常\",{\"1\":{\"262\":1}}],[\"sphinxsearch\",{\"1\":{\"238\":1}}],[\"sphinx全文索引\",{\"1\":{\"238\":1}}],[\"spinning\",{\"1\":{\"34\":1}}],[\"spinning状态\",{\"1\":{\"34\":1}}],[\"sp\",{\"1\":{\"19\":2,\"32\":2,\"421\":1}}],[\"shifted\",{\"1\":{\"346\":1}}],[\"shift\",{\"1\":{\"346\":1}}],[\"shrinking\",{\"1\":{\"299\":1}}],[\"shutdown时\",{\"1\":{\"355\":1}}],[\"shutdown\",{\"1\":{\"262\":3,\"264\":1}}],[\"shuttingdown\",{\"1\":{\"12\":1}}],[\"share\",{\"1\":{\"214\":1}}],[\"sharding\",{\"0\":{\"116\":1},\"1\":{\"85\":1,\"109\":1,\"116\":2}}],[\"showb\",{\"1\":{\"408\":7}}],[\"showa\",{\"1\":{\"408\":3}}],[\"show\",{\"1\":{\"103\":1,\"130\":2,\"190\":1,\"224\":1,\"391\":3,\"415\":2}}],[\"should\",{\"1\":{\"35\":1,\"296\":2}}],[\"sh\",{\"1\":{\"12\":2,\"294\":1}}],[\"some\",{\"1\":{\"299\":1}}],[\"soar\",{\"1\":{\"238\":1}}],[\"sortedset\",{\"1\":{\"273\":1,\"339\":2}}],[\"sort\",{\"1\":{\"130\":1}}],[\"sound\",{\"1\":{\"42\":1}}],[\"so\",{\"1\":{\"12\":1,\"32\":2,\"296\":2,\"299\":2,\"300\":1}}],[\"siz\",{\"1\":{\"407\":2}}],[\"sizeof\",{\"1\":{\"296\":2,\"298\":3,\"346\":1}}],[\"sizemask\",{\"1\":{\"296\":5}}],[\"size缓冲池大小\",{\"1\":{\"237\":1}}],[\"size查询缓存的总内存空间\",{\"1\":{\"236\":1}}],[\"size\",{\"1\":{\"12\":2,\"237\":2,\"294\":2,\"296\":14,\"299\":5,\"300\":2,\"322\":1,\"326\":2,\"339\":1,\"341\":3,\"342\":1,\"346\":4,\"353\":1,\"450\":2}}],[\"since\",{\"1\":{\"346\":1}}],[\"simple\",{\"0\":{\"294\":1},\"1\":{\"292\":1}}],[\"simultaneous\",{\"1\":{\"12\":1}}],[\"signal\",{\"1\":{\"33\":1}}],[\"side\",{\"1\":{\"31\":1}}],[\"sudo\",{\"1\":{\"338\":1}}],[\"subsequent\",{\"1\":{\"502\":1}}],[\"sub\",{\"1\":{\"424\":1}}],[\"subtract\",{\"1\":{\"299\":1}}],[\"subquery\",{\"1\":{\"195\":2}}],[\"sum\",{\"1\":{\"297\":1,\"341\":1}}],[\"sure\",{\"1\":{\"36\":1,\"296\":1,\"299\":1}}],[\"sutter曾经说过\",{\"1\":{\"16\":1}}],[\"support\",{\"1\":{\"12\":1,\"508\":1}}],[\"success++\",{\"1\":{\"424\":1}}],[\"success\",{\"1\":{\"6\":1,\"424\":8}}],[\"s\",{\"1\":{\"12\":2,\"32\":2,\"35\":4,\"36\":9,\"37\":1,\"294\":5,\"296\":1,\"299\":5,\"300\":1,\"370\":12,\"374\":3,\"382\":6,\"386\":11,\"391\":3,\"411\":5,\"413\":1,\"441\":3,\"473\":1,\"490\":9}}],[\"stdout\",{\"1\":{\"490\":1}}],[\"steal\",{\"1\":{\"300\":1}}],[\"stop\",{\"1\":{\"299\":1,\"352\":2}}],[\"storage\",{\"1\":{\"34\":1}}],[\"store存储错误\",{\"1\":{\"507\":1}}],[\"stored\",{\"1\":{\"300\":1}}],[\"store进行\",{\"1\":{\"268\":1}}],[\"store\",{\"1\":{\"12\":1,\"268\":4,\"296\":1,\"299\":1,\"507\":1,\"508\":1}}],[\"style字符串时\",{\"1\":{\"294\":1}}],[\"style字符串\",{\"1\":{\"294\":1}}],[\"stu\",{\"1\":{\"406\":4,\"414\":1,\"415\":3}}],[\"stus\",{\"1\":{\"406\":2}}],[\"student\",{\"1\":{\"152\":1,\"392\":3,\"399\":3,\"406\":4,\"414\":8,\"415\":6,\"439\":5,\"441\":3}}],[\"stuct等等\",{\"1\":{\"41\":1}}],[\"still\",{\"1\":{\"32\":1}}],[\"stktopsp\",{\"1\":{\"19\":1}}],[\"stale\",{\"1\":{\"328\":1}}],[\"start\",{\"1\":{\"264\":1}}],[\"startbackgroundread\",{\"1\":{\"12\":2}}],[\"stacks\",{\"1\":{\"33\":2,\"36\":2}}],[\"stack结构体主要用来记录goroutine所使用的栈的信息\",{\"1\":{\"31\":1}}],[\"stack结构体\",{\"0\":{\"31\":1}}],[\"stackpreempt\",{\"1\":{\"19\":1,\"33\":2}}],[\"stackguard1\",{\"1\":{\"19\":1,\"33\":2}}],[\"stackguard0\",{\"1\":{\"19\":2,\"33\":3}}],[\"stack\",{\"1\":{\"12\":1,\"19\":3,\"31\":4,\"32\":1,\"33\":13,\"34\":1,\"36\":1}}],[\"stats\",{\"1\":{\"450\":3}}],[\"stat\",{\"1\":{\"346\":1}}],[\"static\",{\"1\":{\"296\":3}}],[\"statement\",{\"1\":{\"140\":2,\"238\":1,\"244\":1}}],[\"state\",{\"1\":{\"57\":1,\"502\":1}}],[\"stateactive\",{\"1\":{\"12\":1}}],[\"stateclosed\",{\"1\":{\"12\":1}}],[\"statenew\",{\"1\":{\"12\":1}}],[\"statusnotfound\",{\"1\":{\"12\":1}}],[\"status\",{\"1\":{\"6\":2,\"28\":2,\"29\":1,\"35\":2,\"81\":1,\"103\":1,\"130\":1,\"224\":1,\"238\":1}}],[\"stru2\",{\"1\":{\"481\":2}}],[\"stru1\",{\"1\":{\"481\":2}}],[\"stru=\",{\"1\":{\"481\":6}}],[\"stru\",{\"1\":{\"481\":2}}],[\"structure\",{\"1\":{\"296\":1}}],[\"structures\",{\"1\":{\"31\":1,\"300\":1}}],[\"struct等\",{\"1\":{\"47\":1}}],[\"struct是可以比较\",{\"1\":{\"44\":1}}],[\"struct的比较\",{\"0\":{\"44\":1}}],[\"struct的方法\",{\"0\":{\"43\":1}}],[\"struct可以嵌套自身的特性使之在实现树和链表上更加方便\",{\"1\":{\"42\":1}}],[\"struct能够实现面向对象中的重写\",{\"1\":{\"42\":1}}],[\"struct中的字段可以不用给名称\",{\"1\":{\"42\":1}}],[\"struct定义结构\",{\"1\":{\"42\":1}}],[\"struct类型都不能作为key\",{\"1\":{\"41\":1}}],[\"struct\",{\"0\":{\"40\":1,\"42\":1},\"1\":{\"6\":1,\"12\":1,\"19\":5,\"20\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":2,\"36\":2,\"42\":4,\"43\":1,\"45\":1,\"52\":1,\"53\":1,\"57\":1,\"58\":2,\"63\":1,\"294\":5,\"295\":5,\"296\":6,\"297\":6,\"298\":1,\"300\":10,\"391\":1,\"392\":1,\"393\":2,\"394\":1,\"397\":1,\"399\":1,\"406\":1,\"408\":2,\"412\":1,\"414\":1,\"415\":1,\"421\":3,\"424\":2,\"431\":4,\"439\":1,\"441\":1,\"448\":1,\"449\":1,\"481\":1,\"490\":1,\"496\":2,\"502\":1},\"2\":{\"50\":1,\"364\":1,\"368\":1,\"372\":1,\"376\":1,\"380\":1,\"384\":1,\"388\":1,\"403\":1,\"417\":1,\"420\":1,\"423\":1,\"426\":1,\"430\":1,\"433\":1,\"443\":1,\"467\":1,\"471\":1,\"475\":1,\"486\":1,\"492\":1,\"498\":1,\"505\":1,\"510\":1}}],[\"str=aaa\",{\"1\":{\"481\":1}}],[\"str=\",{\"1\":{\"481\":5}}],[\"str2\",{\"1\":{\"438\":10,\"481\":2}}],[\"str1\",{\"1\":{\"438\":9,\"481\":2}}],[\"str\",{\"1\":{\"299\":1,\"374\":8,\"481\":2}}],[\"strpos\",{\"1\":{\"262\":1}}],[\"strconv\",{\"1\":{\"53\":1}}],[\"strict\",{\"1\":{\"262\":5}}],[\"strictly\",{\"1\":{\"12\":1}}],[\"stringheader\",{\"1\":{\"496\":5}}],[\"stringer\",{\"1\":{\"394\":1}}],[\"strings\",{\"1\":{\"294\":1,\"370\":4,\"378\":3,\"382\":1}}],[\"string类型是二进制安全的\",{\"1\":{\"274\":1}}],[\"string需要拷贝\",{\"1\":{\"43\":1}}],[\"string\",{\"0\":{\"274\":1,\"294\":1},\"1\":{\"6\":1,\"12\":1,\"41\":5,\"42\":4,\"43\":2,\"44\":3,\"45\":5,\"52\":5,\"53\":5,\"58\":5,\"273\":1,\"274\":1,\"292\":2,\"294\":1,\"299\":1,\"339\":6,\"342\":1,\"366\":2,\"370\":5,\"374\":3,\"378\":3,\"382\":3,\"386\":2,\"391\":1,\"392\":1,\"393\":1,\"394\":8,\"399\":3,\"400\":13,\"406\":2,\"409\":4,\"410\":1,\"412\":3,\"414\":4,\"421\":4,\"424\":6,\"435\":1,\"437\":13,\"438\":1,\"439\":1,\"440\":4,\"441\":1,\"445\":1,\"481\":2,\"489\":1,\"490\":2,\"507\":2,\"508\":2}}],[\"search\",{\"1\":{\"296\":1}}],[\"sessionhandlerinterface\",{\"1\":{\"264\":1}}],[\"session和cookie的关系\",{\"1\":{\"264\":1}}],[\"session\",{\"1\":{\"190\":1,\"264\":8,\"274\":2}}],[\"sent\",{\"1\":{\"130\":1}}],[\"sendexpectationfailed\",{\"1\":{\"12\":1}}],[\"sender\",{\"1\":{\"4\":2}}],[\"sender每发送一个数据\",{\"1\":{\"3\":1}}],[\"sender发送一个数据\",{\"1\":{\"3\":1}}],[\"sender端可以向channel中send多个数据\",{\"1\":{\"3\":1}}],[\"sender端向channel中send一个数据\",{\"1\":{\"3\":1}}],[\"send的时候会直接阻塞main\",{\"1\":{\"4\":1}}],[\"send和recv是一个整体行为\",{\"1\":{\"3\":1}}],[\"send操作将导致painc\",{\"1\":{\"2\":1}}],[\"send\",{\"1\":{\"2\":2,\"3\":2,\"4\":3,\"480\":2,\"483\":2,\"502\":3}}],[\"security\",{\"1\":{\"264\":2}}],[\"section\",{\"1\":{\"57\":1}}],[\"second\",{\"1\":{\"5\":1,\"6\":1,\"8\":2,\"58\":3,\"296\":1,\"326\":1,\"395\":1,\"397\":3,\"398\":1,\"428\":1,\"431\":4,\"446\":2,\"450\":1,\"451\":2}}],[\"sema\",{\"1\":{\"57\":1}}],[\"see\",{\"1\":{\"36\":1,\"299\":2,\"502\":1}}],[\"sel的值越接近1越好\",{\"1\":{\"229\":1}}],[\"sel\",{\"1\":{\"229\":1}}],[\"self\",{\"1\":{\"29\":3}}],[\"selected\",{\"1\":{\"484\":2}}],[\"select查询语句是不会加锁的\",{\"1\":{\"105\":1}}],[\"select的方式进行使用\",{\"1\":{\"8\":1}}],[\"select的行为模式主要是对channel是否可读进行轮询\",{\"1\":{\"7\":1}}],[\"select将会结束\",{\"1\":{\"7\":1}}],[\"select确实是随机选择case进行执行\",{\"1\":{\"7\":1}}],[\"select会放在一个无限循环语句中\",{\"1\":{\"7\":1}}],[\"select会被return\",{\"1\":{\"7\":1}}],[\"select所在goroutine才会被阻塞\",{\"1\":{\"7\":1}}],[\"select\",{\"0\":{\"104\":1,\"105\":1},\"1\":{\"7\":2,\"8\":5,\"87\":1,\"93\":4,\"98\":1,\"111\":1,\"112\":8,\"130\":1,\"158\":1,\"189\":1,\"195\":1,\"205\":1,\"206\":3,\"214\":4,\"215\":1,\"219\":5,\"229\":1,\"230\":3,\"234\":1,\"366\":2,\"409\":1,\"424\":1,\"428\":3,\"502\":1}}],[\"select多路监听\",{\"0\":{\"7\":1}}],[\"sequential\",{\"1\":{\"17\":1}}],[\"serializable隔离级别\",{\"1\":{\"207\":1}}],[\"serializable\",{\"1\":{\"95\":1}}],[\"serialized\",{\"1\":{\"12\":1}}],[\"serving\",{\"1\":{\"12\":1}}],[\"serveerror\",{\"1\":{\"12\":1}}],[\"serve中\",{\"1\":{\"12\":1}}],[\"serve\",{\"1\":{\"12\":5,\"328\":1}}],[\"server2\",{\"1\":{\"266\":1}}],[\"server1\",{\"1\":{\"266\":1}}],[\"server层\",{\"1\":{\"242\":1}}],[\"serverhandler\",{\"1\":{\"12\":5}}],[\"servercontextkey\",{\"1\":{\"12\":1}}],[\"server\",{\"1\":{\"12\":10,\"116\":1,\"266\":10,\"297\":1,\"308\":2,\"310\":1,\"311\":1,\"346\":9}}],[\"servehttp\",{\"1\":{\"12\":8}}],[\"setreqcanceler\",{\"1\":{\"502\":1}}],[\"setreaddeadline\",{\"1\":{\"12\":1}}],[\"setvalue\",{\"1\":{\"396\":1}}],[\"setup\",{\"1\":{\"338\":1}}],[\"setting\",{\"1\":{\"296\":1}}],[\"settrue\",{\"1\":{\"12\":1}}],[\"setcookie\",{\"1\":{\"265\":1}}],[\"setexprie\",{\"1\":{\"264\":1}}],[\"set由值类型和指针类型的receiver共同组成\",{\"1\":{\"46\":1}}],[\"set由不同receiver类型的方法组成\",{\"1\":{\"46\":1}}],[\"set只由值类型的receiver\",{\"1\":{\"46\":1}}],[\"setage\",{\"1\":{\"43\":6}}],[\"setname\",{\"1\":{\"43\":5,\"45\":3}}],[\"set\",{\"0\":{\"277\":1},\"1\":{\"32\":1,\"35\":2,\"46\":3,\"214\":1,\"262\":8,\"264\":1,\"273\":1,\"292\":2,\"296\":3,\"299\":2,\"309\":1,\"346\":1,\"413\":4}}],[\"setstate\",{\"1\":{\"12\":3}}],[\"awaiting\",{\"1\":{\"502\":1}}],[\"away\",{\"1\":{\"238\":1}}],[\"aaa\",{\"1\":{\"481\":1,\"496\":1}}],[\"aaaaaaa\",{\"1\":{\"415\":1}}],[\"above\",{\"1\":{\"502\":1}}],[\"abort\",{\"1\":{\"299\":2}}],[\"abc\",{\"1\":{\"398\":4}}],[\"aof文件直接采用的文本协议\",{\"1\":{\"356\":1}}],[\"aof重写是为了减少aof文件的大小\",{\"1\":{\"356\":1}}],[\"aof重写期间是否同步\",{\"1\":{\"353\":1}}],[\"aof的重写都需要fork\",{\"1\":{\"358\":1}}],[\"aof的整个流程大体来看可以分为两步\",{\"1\":{\"356\":1}}],[\"aof的原理\",{\"0\":{\"356\":1}}],[\"aof的配置\",{\"0\":{\"353\":1}}],[\"aof\",{\"1\":{\"350\":1,\"353\":6}}],[\"avoid\",{\"1\":{\"296\":1,\"299\":2}}],[\"avail\",{\"1\":{\"294\":1}}],[\"available\",{\"1\":{\"35\":1,\"299\":1}}],[\"against\",{\"1\":{\"296\":1}}],[\"ages\",{\"1\":{\"412\":3}}],[\"age=\",{\"1\":{\"246\":1}}],[\"age实际上等价于\",{\"1\":{\"43\":1}}],[\"age\",{\"1\":{\"42\":4,\"43\":5,\"63\":2,\"152\":2,\"246\":2,\"406\":4,\"412\":4,\"441\":5}}],[\"app\",{\"1\":{\"352\":1}}],[\"apply\",{\"1\":{\"299\":1}}],[\"appropriate\",{\"1\":{\"299\":1}}],[\"appendfsync\",{\"1\":{\"353\":3,\"356\":1}}],[\"appendfilename\",{\"1\":{\"353\":1}}],[\"appendonly\",{\"1\":{\"353\":2}}],[\"append\",{\"1\":{\"63\":2,\"411\":1,\"438\":2,\"489\":1}}],[\"apache\",{\"1\":{\"266\":1}}],[\"ajax模式下错误响应\",{\"1\":{\"262\":1}}],[\"a的评率更高\",{\"1\":{\"246\":1}}],[\"advance\",{\"1\":{\"299\":1}}],[\"adlist\",{\"1\":{\"295\":2}}],[\"adparking\",{\"1\":{\"238\":1}}],[\"adds\",{\"1\":{\"502\":1}}],[\"addint64\",{\"1\":{\"424\":1}}],[\"adding\",{\"1\":{\"35\":1}}],[\"added\",{\"1\":{\"296\":1}}],[\"addlen\",{\"1\":{\"294\":2}}],[\"add方法中使用了互斥锁\",{\"1\":{\"57\":1}}],[\"address\",{\"1\":{\"299\":1,\"507\":2}}],[\"addr\",{\"1\":{\"12\":6}}],[\"add\",{\"1\":{\"5\":1,\"6\":1,\"7\":1,\"52\":3,\"53\":4,\"57\":3,\"58\":4,\"112\":2,\"145\":1,\"229\":1,\"230\":1,\"366\":1,\"407\":2,\"412\":1,\"418\":1,\"424\":1,\"431\":2,\"447\":2,\"458\":1}}],[\"autocommit=0配置进行关闭\",{\"1\":{\"245\":1}}],[\"auto\",{\"1\":{\"234\":1,\"353\":2}}],[\"amoeba\",{\"1\":{\"191\":1}}],[\"ahead\",{\"1\":{\"141\":1}}],[\"ahi\",{\"1\":{\"141\":1}}],[\"a和b的总金额是不变的\",{\"1\":{\"106\":1}}],[\"attempted\",{\"1\":{\"300\":2}}],[\"attribute\",{\"1\":{\"294\":5}}],[\"attached\",{\"1\":{\"34\":2}}],[\"atlas\",{\"1\":{\"85\":1}}],[\"at\",{\"1\":{\"36\":1,\"119\":1,\"300\":2,\"502\":1}}],[\"atomic\",{\"1\":{\"396\":2,\"424\":2}}],[\"atomicinteger\",{\"1\":{\"268\":1}}],[\"atomically\",{\"1\":{\"36\":2}}],[\"atomicstatus\",{\"1\":{\"19\":1}}],[\"arguments\",{\"1\":{\"490\":1}}],[\"argp\",{\"1\":{\"407\":2}}],[\"argv\",{\"1\":{\"260\":1}}],[\"artical\",{\"1\":{\"339\":1}}],[\"articles\",{\"1\":{\"266\":1}}],[\"article\",{\"1\":{\"235\":1,\"238\":2,\"266\":2}}],[\"array\",{\"1\":{\"262\":4}}],[\"arr\",{\"1\":{\"63\":1}}],[\"arises\",{\"1\":{\"35\":1}}],[\"arm\",{\"1\":{\"33\":1}}],[\"are\",{\"1\":{\"4\":1,\"6\":1,\"31\":1,\"32\":1,\"58\":1,\"296\":4,\"300\":1,\"414\":1}}],[\"always\",{\"1\":{\"353\":1}}],[\"algorithm\",{\"1\":{\"347\":1}}],[\"already\",{\"1\":{\"296\":5}}],[\"alias\",{\"1\":{\"401\":1}}],[\"alive=true那读goroutine继续活着\",{\"1\":{\"502\":1}}],[\"alive\",{\"1\":{\"215\":2,\"218\":3,\"219\":5,\"502\":14}}],[\"alignment\",{\"1\":{\"36\":1}}],[\"alter\",{\"1\":{\"145\":1,\"225\":1,\"226\":1,\"227\":1,\"229\":1,\"230\":1,\"246\":1,\"255\":1}}],[\"also\",{\"1\":{\"12\":1}}],[\"allkeys\",{\"1\":{\"345\":4,\"346\":6,\"347\":1}}],[\"all的区别\",{\"0\":{\"178\":1}}],[\"allp\",{\"1\":{\"37\":2}}],[\"allgs\",{\"1\":{\"37\":1}}],[\"allocate\",{\"1\":{\"296\":2}}],[\"allocated\",{\"1\":{\"32\":1}}],[\"alloc分别以uint8\",{\"1\":{\"294\":1}}],[\"alloc\",{\"1\":{\"294\":4,\"450\":1}}],[\"allowed\",{\"1\":{\"36\":1,\"296\":1}}],[\"allm和allp都不包含任何g\",{\"1\":{\"37\":1}}],[\"allm\",{\"1\":{\"34\":1,\"37\":1}}],[\"alllink\",{\"1\":{\"34\":1}}],[\"allnoroute\",{\"1\":{\"12\":1}}],[\"all\",{\"1\":{\"4\":1,\"6\":1,\"12\":1,\"178\":2,\"195\":1,\"262\":3,\"296\":2,\"300\":2,\"346\":1}}],[\"ascii字符字符一共有256个\",{\"1\":{\"370\":1}}],[\"ascii字符\",{\"1\":{\"370\":1}}],[\"asap\",{\"1\":{\"294\":1}}],[\"aside中是由应用服务\",{\"1\":{\"288\":1}}],[\"aside\",{\"1\":{\"288\":2}}],[\"assert\",{\"1\":{\"296\":1}}],[\"assembly\",{\"1\":{\"32\":2}}],[\"assumption\",{\"1\":{\"296\":1}}],[\"associated\",{\"1\":{\"35\":1}}],[\"as\",{\"1\":{\"12\":1,\"32\":2,\"35\":1,\"229\":1,\"230\":2,\"296\":2,\"299\":2,\"502\":1}}],[\"asleep\",{\"1\":{\"4\":1,\"6\":1}}],[\"analyze\",{\"1\":{\"252\":1}}],[\"ansible\",{\"1\":{\"201\":2}}],[\"answer\",{\"1\":{\"12\":1}}],[\"an\",{\"1\":{\"57\":1,\"299\":1,\"502\":1}}],[\"animal\",{\"1\":{\"42\":2}}],[\"and\",{\"1\":{\"12\":2,\"32\":5,\"33\":2,\"34\":1,\"35\":3,\"36\":1,\"72\":2,\"111\":2,\"206\":1,\"234\":1,\"246\":2,\"294\":5,\"296\":5,\"299\":3,\"300\":1,\"341\":1,\"346\":3,\"412\":1,\"502\":2}}],[\"another\",{\"1\":{\"12\":1}}],[\"any\",{\"1\":{\"12\":1,\"32\":1,\"47\":5}}],[\"ack指令到主节点\",{\"1\":{\"327\":1}}],[\"ack\",{\"1\":{\"319\":2}}],[\"account\",{\"1\":{\"299\":1}}],[\"access\",{\"1\":{\"294\":1}}],[\"accessed\",{\"1\":{\"35\":1,\"36\":1,\"296\":1}}],[\"accept\",{\"1\":{\"12\":2,\"296\":1}}],[\"acid指\",{\"1\":{\"223\":1}}],[\"actually\",{\"1\":{\"300\":1}}],[\"actual\",{\"1\":{\"33\":1}}],[\"actor\",{\"1\":{\"16\":1}}],[\"actively\",{\"1\":{\"34\":1}}],[\"active\",{\"1\":{\"12\":2}}],[\"a\",{\"0\":{\"464\":1},\"1\":{\"12\":1,\"28\":1,\"29\":2,\"31\":1,\"32\":4,\"33\":2,\"34\":2,\"35\":4,\"41\":2,\"52\":1,\"53\":1,\"57\":4,\"58\":1,\"93\":3,\"112\":11,\"206\":6,\"246\":2,\"262\":1,\"265\":2,\"296\":5,\"297\":1,\"299\":3,\"300\":7,\"346\":1,\"366\":1,\"395\":3,\"397\":3,\"398\":3,\"410\":9,\"414\":1,\"436\":2,\"438\":1,\"445\":5,\"446\":3,\"447\":1,\"448\":1,\"449\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":3,\"454\":4,\"490\":15,\"496\":4,\"502\":2,\"507\":1}}],[\"afterfunc\",{\"1\":{\"431\":1}}],[\"after进行初始化\",{\"1\":{\"8\":1}}],[\"after\",{\"1\":{\"8\":4,\"57\":1,\"171\":3}}],[\"此方法不会阻塞\",{\"1\":{\"421\":1}}],[\"此方案有问题\",{\"1\":{\"287\":1}}],[\"此机制实现与近似lru中采样类似\",{\"1\":{\"347\":1}}],[\"此类方案有php的opcache\",{\"1\":{\"282\":1}}],[\"此时goroutine个数=\",{\"1\":{\"500\":1}}],[\"此时执行写\",{\"1\":{\"483\":1}}],[\"此时同时读写资源存在竞争关系\",{\"1\":{\"412\":1}}],[\"此时最早写入也就是最佳淘汰键\",{\"1\":{\"346\":1}}],[\"此时就会让主从数据同步到一致\",{\"1\":{\"317\":1}}],[\"此时为旧数据\",{\"1\":{\"288\":1}}],[\"此时缓存数据不一致\",{\"1\":{\"287\":1}}],[\"此时缓存中为旧数据\",{\"1\":{\"287\":1}}],[\"此时间差范围内的请求会进行回源\",{\"1\":{\"284\":1}}],[\"此时视图还是如此\",{\"1\":{\"219\":1}}],[\"此时的\",{\"1\":{\"219\":1}}],[\"此时\",{\"1\":{\"218\":4,\"219\":3}}],[\"此时判断\",{\"1\":{\"218\":1}}],[\"此时链表头的\",{\"1\":{\"218\":1}}],[\"此时获取到的数据肯定是这样的\",{\"1\":{\"218\":1}}],[\"此时主库创建一个binlog\",{\"1\":{\"117\":1,\"192\":1}}],[\"此时又回到了聚集索引的查找流程\",{\"1\":{\"72\":1}}],[\"此时表结构是这样的\",{\"1\":{\"72\":1}}],[\"此时不满足条件\",{\"1\":{\"72\":1}}],[\"此时不需要到磁盘中读取数据\",{\"1\":{\"72\":1}}],[\"此时我们需要拿着页8中的p指针去读取页9中的数据\",{\"1\":{\"72\":1}}],[\"此时我们需要根据指针p2\",{\"1\":{\"72\":1}}],[\"此时我们已经找到一条满足条件的数据了\",{\"1\":{\"72\":1}}],[\"此时因为已经到数据页了\",{\"1\":{\"72\":1}}],[\"此时可以根据二分查找法定位到键值18\",{\"1\":{\"72\":1}}],[\"此时ch是一个nil\",{\"1\":{\"2\":2}}],[\"此goroutine正在被哪个工作线程执行\",{\"1\":{\"33\":1}}],[\"此channel中recv的操作<\",{\"1\":{\"4\":1}}],[\"操作会出错\",{\"1\":{\"391\":1}}],[\"操作会阻塞\",{\"1\":{\"355\":1}}],[\"操作并判断是否小于0\",{\"1\":{\"268\":1}}],[\"操作在大多数情况下都会锁表\",{\"1\":{\"225\":1}}],[\"操作进行选取\",{\"1\":{\"219\":1}}],[\"操作就是快照读\",{\"1\":{\"214\":1}}],[\"操作只是对读锁数量减1\",{\"1\":{\"58\":1}}],[\"操作系统线程的创建和切换都需要进入内核\",{\"1\":{\"27\":1}}],[\"操作\",{\"1\":{\"4\":1,\"215\":1,\"219\":3,\"268\":1,\"401\":1}}],[\"死锁与索引密不可分\",{\"1\":{\"159\":1}}],[\"死锁有四个必要条件\",{\"1\":{\"159\":1}}],[\"死锁是指两个或多个事务在同一资源上相互占用\",{\"1\":{\"159\":1}}],[\"死锁\",{\"0\":{\"4\":1}}],[\"都阻塞\",{\"1\":{\"462\":1}}],[\"都停止后进行的\",{\"1\":{\"401\":1}}],[\"都插入到ht\",{\"1\":{\"296\":1}}],[\"都不会额外分配预留内存空间\",{\"1\":{\"294\":1}}],[\"都不可以再拆分\",{\"1\":{\"138\":1}}],[\"都属于\",{\"1\":{\"265\":1}}],[\"都要养成用explain分析的习惯\",{\"1\":{\"182\":1}}],[\"都会发生逃逸\",{\"1\":{\"490\":1}}],[\"都会被迭代到\",{\"1\":{\"296\":1}}],[\"都会被遍历到\",{\"1\":{\"296\":1}}],[\"都会被频繁查询\",{\"1\":{\"246\":1}}],[\"都会预留大量的空间\",{\"1\":{\"294\":1}}],[\"都会拷贝整个实例对象\",{\"1\":{\"43\":1}}],[\"都会重新初始化一个全新的计时器\",{\"1\":{\"8\":1}}],[\"都是以主机序\",{\"1\":{\"298\":1}}],[\"都是耍流氓\",{\"1\":{\"253\":1}}],[\"都是按照磁盘块来读取的\",{\"1\":{\"69\":1}}],[\"都是按值传递的\",{\"1\":{\"43\":1}}],[\"都是拷贝指针\",{\"1\":{\"43\":2}}],[\"都是拷贝整个底层数据结构的\",{\"1\":{\"43\":1}}],[\"都是在向channel发送请求\",{\"1\":{\"3\":1}}],[\"都返回数据对象的指针给变量\",{\"1\":{\"42\":1}}],[\"都塞满了怎么办呢\",{\"1\":{\"21\":1}}],[\"都将会阻塞\",{\"1\":{\"2\":1}}],[\"无输出\",{\"1\":{\"447\":1}}],[\"无缓存旧数据问题\",{\"1\":{\"288\":1}}],[\"无缓存则取回源数据\",{\"1\":{\"287\":2}}],[\"无缓冲情况下\",{\"1\":{\"418\":1}}],[\"无缓冲同步通信示例\",{\"0\":{\"5\":1}}],[\"无缓冲\",{\"1\":{\"3\":3}}],[\"无法绝对杜绝并发读写问题\",{\"1\":{\"288\":1}}],[\"无法多端数据同步\",{\"1\":{\"282\":1}}],[\"无法加载读锁\",{\"1\":{\"58\":1}}],[\"无需回表\",{\"1\":{\"246\":1}}],[\"无需额外的proxy\",{\"1\":{\"116\":1}}],[\"无论是指针类型的实例p1还是值类型的p2\",{\"1\":{\"43\":1}}],[\"无论是使用值类型的实例还是指针类型的实例\",{\"1\":{\"43\":2}}],[\"无论是send还是recv操作\",{\"1\":{\"3\":1}}],[\"无视它们的类型\",{\"1\":{\"43\":1}}],[\"并立即取消仍在执行查询任务的goroutine\",{\"1\":{\"473\":1}}],[\"并解释下为什么这么打印的\",{\"0\":{\"438\":1}}],[\"并说明原因\",{\"0\":{\"407\":1}}],[\"并调度后面的\",{\"1\":{\"401\":1}}],[\"并随时间更新计数器\",{\"1\":{\"347\":1}}],[\"并刷新ziplist中的level字段\",{\"1\":{\"297\":1}}],[\"并开启平滑扩容\",{\"1\":{\"296\":1}}],[\"并对选择方案的利弊有足够且深入理解\",{\"1\":{\"288\":1}}],[\"并对外暴露数据库连接的获取和返回方法\",{\"1\":{\"122\":1}}],[\"并集\",{\"1\":{\"277\":1}}],[\"并在每次运行时进行gc操作\",{\"1\":{\"264\":1}}],[\"并做适当处理\",{\"1\":{\"262\":1}}],[\"并不需要读取老的aof文件进行分析\",{\"1\":{\"356\":1}}],[\"并不能取出理想lru理论中最佳淘汰key\",{\"1\":{\"346\":1}}],[\"并不会覆盖以前的日志\",{\"1\":{\"244\":1}}],[\"并不是一条一条的读\",{\"1\":{\"69\":1}}],[\"并分发到不同的数据库中\",{\"1\":{\"191\":1}}],[\"并进行逻辑处理\",{\"1\":{\"179\":1}}],[\"并请求锁定对方的资源\",{\"1\":{\"159\":1}}],[\"并根据字符集的排序规则对值进行排序和比较\",{\"1\":{\"131\":1}}],[\"并静悄悄地提交\",{\"1\":{\"96\":1}}],[\"并通过和页8中一样的方式进行数据的查找\",{\"1\":{\"72\":1}}],[\"并通过goruntine来处理这个连接\",{\"1\":{\"12\":1}}],[\"并赋值给私有全局变量self\",{\"1\":{\"29\":1}}],[\"并发题目测试\",{\"0\":{\"444\":1}}],[\"并发读写时多个协程见是通过指针访问同一个地址\",{\"1\":{\"412\":1}}],[\"并发读写\",{\"1\":{\"288\":1}}],[\"并发性越低\",{\"1\":{\"245\":1}}],[\"并发度一般\",{\"1\":{\"133\":1}}],[\"并发度高\",{\"1\":{\"133\":1}}],[\"并发度最低\",{\"1\":{\"133\":1}}],[\"并发模型\",{\"0\":{\"16\":1}}],[\"并发安全的map\",{\"0\":{\"52\":1}}],[\"并发安全\",{\"2\":{\"10\":1,\"55\":1,\"61\":1}}],[\"并发送第二个数据的时候才被阻塞\",{\"1\":{\"3\":1}}],[\"并退出此次select\",{\"1\":{\"7\":1}}],[\"并报错\",{\"1\":{\"4\":1}}],[\"并且从链表的尾部开始组起\",{\"1\":{\"469\":1}}],[\"并且旧的指针地址在map改变时会变得无效\",{\"1\":{\"399\":1}}],[\"并且知道字符串的真实长度\",{\"1\":{\"382\":1}}],[\"并且数据需高度一直\",{\"1\":{\"328\":1}}],[\"并且每个字节都有自己的偏移量\",{\"1\":{\"322\":1}}],[\"并且每个节点拥有更多的子节点\",{\"1\":{\"69\":1}}],[\"并且以字节分开\",{\"1\":{\"322\":1}}],[\"并且发送复制缓冲区的数据给从节点\",{\"1\":{\"317\":1}}],[\"并且执行pysnc命令同步\",{\"1\":{\"317\":1}}],[\"并且保证每个服务器的数据是同步的\",{\"1\":{\"306\":1}}],[\"并且使用者可以通过自定义quicklist\",{\"1\":{\"300\":1}}],[\"并且超过254字节的话\",{\"1\":{\"299\":1}}],[\"并且最高两位均是11\",{\"1\":{\"299\":1}}],[\"并且字典的实现给了使用者非常大的灵活性\",{\"1\":{\"296\":1}}],[\"并且在移除结点后\",{\"1\":{\"299\":1}}],[\"并且在不需要的时候\",{\"1\":{\"255\":1}}],[\"并且在用户态上实现了属于自己的调度模型\",{\"1\":{\"1\":1}}],[\"并且不能使用覆盖索引\",{\"1\":{\"253\":1}}],[\"并且不会推出main\",{\"1\":{\"8\":1}}],[\"并且有删除过数据的表\",{\"1\":{\"252\":1}}],[\"并且有一个事务d进行了快照读\",{\"1\":{\"219\":1}}],[\"并且记录redolog\",{\"1\":{\"244\":1}}],[\"并且重建整表\",{\"1\":{\"225\":1}}],[\"并且null有很多坑的\",{\"1\":{\"185\":1}}],[\"并且\",{\"1\":{\"158\":1,\"297\":1}}],[\"并且排序和比较基于列值中的字节的数值\",{\"1\":{\"131\":1}}],[\"并且会占用更多的磁盘空间以保留数据和索引\",{\"1\":{\"87\":1}}],[\"并且是连续的\",{\"1\":{\"206\":1}}],[\"并且是有序排列的\",{\"1\":{\"72\":1}}],[\"并且是非线程安全的\",{\"1\":{\"52\":1}}],[\"并且遵循了\",{\"1\":{\"1\":1}}],[\"01\",{\"1\":{\"347\":1}}],[\"01xxxxxx\",{\"1\":{\"299\":1}}],[\"0开始\",{\"1\":{\"347\":1}}],[\"0比2\",{\"1\":{\"346\":1}}],[\"0中新增两种lfu淘汰机制\",{\"1\":{\"347\":1}}],[\"0中新的lfu算法\",{\"0\":{\"347\":1}}],[\"0中采样值为10时\",{\"1\":{\"346\":1}}],[\"0中将进一步改善lru淘汰效果逼近理论lru\",{\"1\":{\"346\":1}}],[\"0中近似lru算法通过增加待淘汰元素池的方式进一步优化\",{\"1\":{\"346\":1}}],[\"0中近似lru算法\",{\"0\":{\"346\":1},\"1\":{\"346\":2}}],[\"0中已有淘汰机制\",{\"1\":{\"345\":1}}],[\"0以上\",{\"1\":{\"340\":1}}],[\"0=off\",{\"1\":{\"300\":1}}],[\"0b\",{\"1\":{\"299\":5}}],[\"0000\",{\"1\":{\"299\":4}}],[\"0001~1111\",{\"1\":{\"299\":1}}],[\"00xxxxxx\",{\"1\":{\"299\":1}}],[\"0xffff\",{\"1\":{\"297\":2}}],[\"0字节\",{\"1\":{\"294\":1}}],[\"02\",{\"1\":{\"288\":1}}],[\"0版本已废弃\",{\"1\":{\"243\":1}}],[\"0\",{\"1\":{\"3\":1,\"6\":1,\"7\":1,\"8\":2,\"12\":3,\"28\":1,\"29\":1,\"47\":1,\"57\":1,\"58\":1,\"63\":9,\"126\":1,\"262\":6,\"266\":6,\"269\":1,\"294\":9,\"296\":40,\"297\":7,\"299\":16,\"300\":1,\"304\":2,\"309\":4,\"339\":5,\"346\":5,\"347\":1,\"370\":2,\"374\":3,\"386\":9,\"395\":1,\"398\":1,\"401\":1,\"407\":3,\"410\":3,\"411\":5,\"418\":1,\"424\":6,\"431\":2,\"441\":1,\"448\":1,\"450\":2,\"452\":1,\"453\":1,\"454\":2,\"465\":1,\"483\":2,\"484\":4,\"490\":1,\"500\":1}}],[\"先会执行一次全量复制这次的全量复制是无法避免的\",{\"1\":{\"316\":1}}],[\"先需要把之前使用客户端命令行连接的断开\",{\"1\":{\"310\":1}}],[\"先知道这么个概念\",{\"1\":{\"305\":1}}],[\"先讲一下entry中都存储了哪些信息\",{\"1\":{\"299\":1}}],[\"先步进迁移一个bucket索引\",{\"1\":{\"296\":1}}],[\"先迁移一个bucket索引中的结点至新表\",{\"1\":{\"296\":1}}],[\"先是插入操作的外部逻辑\",{\"1\":{\"296\":1}}],[\"先保证至少有addlen可用\",{\"1\":{\"294\":1}}],[\"先数据源更新后\",{\"1\":{\"288\":1}}],[\"先删除缓存\",{\"1\":{\"287\":1}}],[\"先操作change\",{\"1\":{\"251\":1}}],[\"先将数据写入缓冲池\",{\"1\":{\"250\":1}}],[\"先写到\",{\"1\":{\"198\":1}}],[\"先检查该语句是否有权限\",{\"1\":{\"126\":1}}],[\"先看一下mysql的逻辑架构图吧~\",{\"1\":{\"125\":1}}],[\"先复习一下主从复制原理吧\",{\"1\":{\"117\":1}}],[\"先从a表做循环\",{\"1\":{\"112\":1}}],[\"先执行主查询\",{\"1\":{\"112\":1}}],[\"先查询部门表b\",{\"1\":{\"112\":1}}],[\"先放过去修改\",{\"1\":{\"99\":1}}],[\"先快速定位需要获取的id段\",{\"1\":{\"93\":1}}],[\"先找到根节点也就是页1\",{\"1\":{\"69\":1}}],[\"先进先出\",{\"1\":{\"3\":1}}],[\"先发送数据的\",{\"1\":{\"1\":1}}],[\"<autogenerated>\",{\"1\":{\"490\":1}}],[\"<=\",{\"1\":{\"296\":1,\"401\":2}}],[\"<0\",{\"1\":{\"268\":1}}],[\"<40或者范围值\",{\"1\":{\"72\":1}}],[\"<40\",{\"1\":{\"72\":1}}],[\"<<\",{\"1\":{\"12\":1,\"450\":2}}],[\"<\",{\"1\":{\"3\":4,\"4\":7,\"5\":2,\"6\":7,\"7\":7,\"8\":6,\"12\":2,\"28\":1,\"29\":1,\"52\":1,\"53\":7,\"57\":1,\"58\":1,\"78\":1,\"152\":1,\"218\":5,\"219\":7,\"262\":2,\"265\":1,\"269\":1,\"294\":1,\"297\":2,\"299\":2,\"300\":1,\"301\":2,\"346\":1,\"366\":4,\"370\":3,\"374\":1,\"386\":1,\"395\":3,\"397\":1,\"398\":2,\"400\":2,\"407\":2,\"409\":4,\"413\":2,\"418\":2,\"424\":6,\"428\":1,\"431\":9,\"437\":2,\"450\":1,\"451\":2,\"452\":2,\"454\":2,\"465\":1,\"480\":1,\"481\":11,\"484\":2,\"500\":1,\"502\":9}}],[\"ireq\",{\"1\":{\"502\":2}}],[\"i=255\",{\"1\":{\"401\":1}}],[\"i=0\",{\"1\":{\"112\":2}}],[\"iction\",{\"1\":{\"346\":1}}],[\"ip绑定\",{\"1\":{\"266\":1}}],[\"ip\",{\"1\":{\"264\":1,\"266\":4,\"424\":10}}],[\"ibd为后缀的文件里\",{\"1\":{\"255\":1}}],[\"ibdata之外\",{\"1\":{\"198\":1}}],[\"ibdata文件里面\",{\"1\":{\"198\":1}}],[\"ivictor\",{\"1\":{\"238\":1}}],[\"i<a\",{\"1\":{\"112\":1}}],[\"i<b\",{\"1\":{\"112\":1}}],[\"ioutil\",{\"1\":{\"500\":2,\"502\":2,\"503\":1}}],[\"iota\",{\"1\":{\"386\":1,\"436\":4}}],[\"io资源竞争\",{\"1\":{\"358\":1}}],[\"io线程\",{\"1\":{\"192\":1}}],[\"io\",{\"1\":{\"72\":1,\"251\":2,\"288\":1,\"347\":1,\"401\":2,\"489\":1,\"490\":1,\"500\":1,\"502\":7}}],[\"id是什么\",{\"1\":{\"321\":1}}],[\"id选项\",{\"1\":{\"238\":1}}],[\"idx\",{\"1\":{\"230\":1,\"296\":4}}],[\"idx=1\",{\"1\":{\"37\":1}}],[\"id列上没有索引\",{\"1\":{\"207\":2}}],[\"id列是二级非唯一索引\",{\"1\":{\"207\":2}}],[\"id列是二级唯一索引\",{\"1\":{\"207\":2}}],[\"id列是主键\",{\"1\":{\"207\":2}}],[\"id=2\",{\"1\":{\"244\":1}}],[\"id==b\",{\"1\":{\"112\":1}}],[\"id=b\",{\"1\":{\"93\":1}}],[\"id为索引\",{\"1\":{\"93\":1}}],[\"id>1000000\",{\"1\":{\"93\":1}}],[\"id>=18\",{\"1\":{\"72\":1}}],[\"id问题\",{\"1\":{\"86\":1}}],[\"id\",{\"0\":{\"321\":1},\"1\":{\"36\":1,\"72\":3,\"93\":5,\"112\":1,\"158\":3,\"195\":1,\"206\":2,\"214\":2,\"215\":15,\"217\":5,\"218\":24,\"219\":46,\"230\":1,\"325\":1,\"339\":2}}],[\"idle\",{\"1\":{\"21\":1,\"35\":1,\"36\":3,\"346\":1,\"502\":2}}],[\"image数据类型的列不要建立索引\",{\"1\":{\"144\":1}}],[\"import\",{\"1\":{\"58\":1,\"341\":1,\"342\":1,\"386\":1,\"401\":1,\"405\":1,\"414\":1,\"415\":1,\"424\":2,\"428\":1,\"431\":2,\"435\":1,\"436\":1,\"437\":1,\"438\":1,\"439\":1,\"440\":1,\"441\":1,\"445\":1,\"446\":1,\"447\":1,\"448\":1,\"449\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"481\":1,\"490\":1,\"496\":1,\"500\":1,\"507\":1}}],[\"implicit\",{\"1\":{\"31\":1}}],[\"implements\",{\"1\":{\"264\":1}}],[\"implement\",{\"1\":{\"12\":1,\"296\":1}}],[\"im\",{\"1\":{\"23\":1,\"207\":1,\"219\":1,\"329\":1,\"358\":1,\"469\":1}}],[\"iseof\",{\"1\":{\"502\":3}}],[\"isexist\",{\"1\":{\"421\":3}}],[\"isnumber\",{\"1\":{\"386\":1}}],[\"isletter判断字符是否是字母\",{\"1\":{\"382\":1}}],[\"isletter\",{\"1\":{\"382\":1}}],[\"isregroup\",{\"1\":{\"378\":1}}],[\"isuniqstring3\",{\"1\":{\"370\":1}}],[\"isuniquestring2\",{\"1\":{\"370\":1}}],[\"isuniquestring\",{\"1\":{\"370\":1}}],[\"isfatal\",{\"1\":{\"262\":1}}],[\"isdelete\",{\"1\":{\"215\":1,\"217\":2,\"219\":2}}],[\"isdelete是我自己取的\",{\"1\":{\"215\":1}}],[\"is\",{\"1\":{\"12\":1,\"29\":1,\"32\":2,\"33\":5,\"34\":3,\"35\":2,\"57\":2,\"78\":1,\"262\":1,\"294\":3,\"296\":11,\"299\":8,\"300\":13,\"346\":3,\"502\":1}}],[\"item\",{\"1\":{\"421\":6}}],[\"items\",{\"1\":{\"300\":1}}],[\"iter\",{\"1\":{\"413\":1}}],[\"iterating\",{\"1\":{\"296\":2}}],[\"iterator\",{\"1\":{\"296\":3,\"300\":1}}],[\"iterators\",{\"1\":{\"296\":2}}],[\"its\",{\"1\":{\"299\":1,\"346\":1}}],[\"itkingone\",{\"1\":{\"266\":1}}],[\"itoa\",{\"1\":{\"53\":1}}],[\"it\",{\"1\":{\"12\":2,\"32\":8,\"33\":3,\"35\":1,\"296\":7,\"299\":2,\"300\":1,\"346\":1,\"473\":1,\"502\":2}}],[\"inlining\",{\"1\":{\"490\":2}}],[\"inline\",{\"1\":{\"490\":2}}],[\"info中可见\",{\"1\":{\"346\":1}}],[\"individual\",{\"1\":{\"300\":1}}],[\"indexing\",{\"1\":{\"508\":1}}],[\"index和strings\",{\"1\":{\"370\":2}}],[\"index的方式强制使用指定的索引\",{\"1\":{\"252\":1}}],[\"index命令创建\",{\"1\":{\"145\":1}}],[\"index\",{\"1\":{\"12\":2,\"145\":4,\"195\":3,\"260\":1,\"262\":1,\"296\":7,\"370\":1,\"410\":2,\"500\":2}}],[\"index++\",{\"1\":{\"12\":2,\"500\":1}}],[\"invalid\",{\"1\":{\"296\":1,\"508\":1}}],[\"incr\",{\"1\":{\"268\":1,\"299\":1}}],[\"incremental\",{\"1\":{\"296\":3,\"353\":1}}],[\"increment\",{\"1\":{\"234\":1}}],[\"incremented\",{\"1\":{\"35\":2}}],[\"increasing\",{\"1\":{\"36\":1}}],[\"ini\",{\"1\":{\"264\":1}}],[\"initialization\",{\"1\":{\"296\":1}}],[\"initialized\",{\"1\":{\"299\":1}}],[\"initialize\",{\"1\":{\"296\":1}}],[\"initial\",{\"1\":{\"296\":2}}],[\"initialreadlimitsize\",{\"1\":{\"12\":1}}],[\"initlen\",{\"1\":{\"294\":1}}],[\"init\",{\"1\":{\"262\":1,\"294\":3,\"490\":1}}],[\"initm\",{\"1\":{\"29\":1}}],[\"inner\",{\"1\":{\"135\":1,\"137\":1}}],[\"innodb里是全表扫描\",{\"1\":{\"256\":1}}],[\"innodb存储引擎处理的逻辑是不一样的\",{\"1\":{\"250\":1}}],[\"innodb存储引擎支持\",{\"1\":{\"230\":1}}],[\"innodb独有的\",{\"1\":{\"244\":1}}],[\"innodb中使用聚簇索引的方式存储数据\",{\"1\":{\"231\":1}}],[\"innodb中页的默认大小是16kb\",{\"1\":{\"70\":1,\"91\":1,\"148\":1}}],[\"innodb采用聚簇索引的方式存储数据\",{\"1\":{\"223\":1}}],[\"innodb使用mvcc实现并发控制\",{\"1\":{\"223\":1}}],[\"innodb的索引\",{\"1\":{\"246\":1}}],[\"innodb的索引策略是聚簇索引\",{\"1\":{\"223\":1}}],[\"innodb的数据和索引放在一起\",{\"1\":{\"231\":1}}],[\"innodb的事务与日志的实现方式\",{\"0\":{\"196\":1}}],[\"innodb的事务实现原理\",{\"0\":{\"194\":1}}],[\"innodb会使用该rowid创建一个聚簇索引\",{\"1\":{\"215\":1}}],[\"innodb两种日志redo和undo\",{\"1\":{\"197\":1}}],[\"innodb引擎的4大特性\",{\"0\":{\"141\":1}}],[\"innodb引擎中的索引策略\",{\"0\":{\"127\":1}}],[\"innodb按主键大小有序插入\",{\"1\":{\"87\":1}}],[\"innodb表需要更多的内存和存储\",{\"1\":{\"87\":1}}],[\"innodb表必须有主键\",{\"1\":{\"87\":1}}],[\"innodb不支持全文索引\",{\"1\":{\"87\":1}}],[\"innodb就需要全表扫描\",{\"1\":{\"87\":1}}],[\"innodb支持热备份\",{\"1\":{\"223\":1}}],[\"innodb支持表\",{\"1\":{\"87\":1}}],[\"innodb支持外键\",{\"1\":{\"87\":1}}],[\"innodb支持事务\",{\"1\":{\"87\":1,\"223\":1}}],[\"innodb与myisam的区别\",{\"0\":{\"87\":1}}],[\"innodb\",{\"0\":{\"210\":1},\"1\":{\"81\":1,\"87\":4,\"119\":1,\"198\":1,\"215\":1,\"234\":3,\"237\":2,\"242\":1,\"246\":1,\"251\":1},\"2\":{\"221\":1}}],[\"inset结构中的encoding的取值有三个\",{\"1\":{\"298\":1}}],[\"inserted\",{\"1\":{\"299\":1}}],[\"insert\",{\"1\":{\"117\":1,\"141\":1,\"171\":2,\"192\":1,\"214\":1,\"215\":1,\"296\":1,\"299\":1}}],[\"inside\",{\"1\":{\"296\":1}}],[\"install\",{\"1\":{\"139\":1,\"337\":1,\"338\":1}}],[\"instead\",{\"1\":{\"35\":1,\"502\":1}}],[\"ins\",{\"1\":{\"48\":9}}],[\"inherit\",{\"1\":{\"35\":1}}],[\"in通道只用于接收数据\",{\"1\":{\"6\":1}}],[\"in\",{\"1\":{\"6\":1,\"12\":4,\"32\":1,\"33\":2,\"35\":4,\"36\":1,\"78\":1,\"112\":1,\"214\":1,\"262\":1,\"296\":6,\"299\":6,\"300\":6,\"339\":1,\"341\":3,\"342\":1,\"502\":1}}],[\"intn\",{\"1\":{\"418\":1}}],[\"intrev32ifbe\",{\"1\":{\"299\":9}}],[\"integer\",{\"1\":{\"299\":1}}],[\"intest\",{\"1\":{\"298\":1}}],[\"inter\",{\"1\":{\"42\":1}}],[\"interface类型断言和type\",{\"0\":{\"48\":1}}],[\"interface\",{\"0\":{\"40\":1,\"45\":1},\"1\":{\"12\":1,\"45\":2,\"47\":3,\"48\":1,\"391\":1,\"392\":1,\"394\":1,\"397\":3,\"413\":2,\"414\":1,\"415\":1,\"421\":5,\"450\":1,\"489\":2,\"490\":2,\"508\":4},\"2\":{\"50\":1,\"364\":1,\"368\":1,\"372\":1,\"376\":1,\"380\":1,\"384\":1,\"388\":1,\"403\":1,\"417\":1,\"420\":1,\"423\":1,\"426\":1,\"430\":1,\"433\":1,\"443\":1,\"467\":1,\"471\":1,\"475\":1,\"486\":1,\"492\":1,\"498\":1,\"505\":1,\"510\":1}}],[\"into\",{\"1\":{\"214\":1}}],[\"int16时\",{\"1\":{\"298\":1}}],[\"int16\",{\"1\":{\"298\":3}}],[\"int1切片的data属性的指针地址和ints的指针地址是一样的\",{\"1\":{\"63\":1}}],[\"int1\",{\"1\":{\"63\":13}}],[\"intset适合于如下数据的存储\",{\"1\":{\"298\":1}}],[\"intset的编码方式一经升级\",{\"1\":{\"298\":1}}],[\"intset的代码实现中\",{\"1\":{\"298\":1}}],[\"intset中的数值是以升序排列存储的\",{\"1\":{\"298\":1}}],[\"intset中各字段\",{\"1\":{\"298\":1}}],[\"intset\",{\"0\":{\"298\":1},\"1\":{\"292\":1,\"298\":10}}],[\"ints\",{\"1\":{\"63\":14}}],[\"int被初始化为数字0\",{\"1\":{\"37\":1}}],[\"int32时\",{\"1\":{\"298\":1}}],[\"int32\",{\"1\":{\"35\":1,\"36\":6,\"37\":2,\"57\":1,\"58\":2,\"298\":3,\"396\":2,\"407\":1}}],[\"int8\",{\"1\":{\"12\":1,\"298\":1}}],[\"int64\",{\"1\":{\"6\":2,\"19\":1,\"36\":2,\"296\":1,\"298\":3,\"424\":1,\"502\":2}}],[\"int\",{\"1\":{\"2\":2,\"3\":4,\"4\":3,\"5\":1,\"6\":6,\"7\":4,\"8\":2,\"41\":5,\"42\":3,\"43\":2,\"47\":2,\"48\":2,\"52\":5,\"53\":6,\"57\":4,\"58\":8,\"63\":7,\"112\":4,\"145\":3,\"176\":1,\"234\":3,\"262\":1,\"295\":2,\"296\":8,\"297\":5,\"299\":4,\"300\":13,\"341\":3,\"342\":3,\"346\":1,\"386\":5,\"395\":1,\"397\":1,\"398\":1,\"400\":1,\"406\":1,\"407\":1,\"409\":4,\"410\":2,\"411\":1,\"412\":3,\"418\":1,\"424\":1,\"431\":2,\"437\":1,\"441\":1,\"446\":1,\"449\":1,\"450\":1,\"451\":3,\"452\":2,\"454\":2,\"480\":1,\"481\":1,\"496\":3,\"502\":1}}],[\"if\",{\"1\":{\"3\":1,\"7\":2,\"12\":23,\"29\":1,\"34\":1,\"35\":4,\"44\":1,\"48\":2,\"53\":1,\"58\":1,\"63\":1,\"112\":2,\"262\":2,\"268\":2,\"269\":1,\"294\":3,\"296\":29,\"297\":3,\"299\":17,\"300\":2,\"346\":10,\"366\":1,\"370\":11,\"374\":1,\"378\":2,\"382\":2,\"393\":1,\"395\":1,\"396\":1,\"397\":1,\"407\":4,\"412\":1,\"414\":1,\"415\":1,\"421\":3,\"424\":5,\"428\":1,\"431\":2,\"435\":1,\"448\":2,\"483\":1,\"484\":3,\"502\":10}}],[\"i++\",{\"1\":{\"3\":1,\"6\":2,\"7\":1,\"8\":2,\"12\":1,\"28\":1,\"29\":1,\"52\":1,\"53\":1,\"57\":1,\"58\":1,\"112\":2,\"297\":1,\"366\":4,\"374\":1,\"386\":1,\"395\":1,\"398\":1,\"401\":2,\"407\":2,\"418\":1,\"424\":2,\"431\":2,\"450\":2}}],[\"i\",{\"1\":{\"3\":7,\"6\":12,\"7\":8,\"8\":4,\"12\":4,\"28\":2,\"29\":2,\"41\":1,\"47\":1,\"48\":2,\"52\":5,\"53\":7,\"57\":3,\"58\":11,\"112\":4,\"297\":7,\"366\":7,\"374\":6,\"386\":2,\"395\":3,\"398\":3,\"400\":4,\"401\":4,\"407\":10,\"418\":4,\"424\":4,\"431\":6,\"437\":5,\"450\":4,\"502\":1}}],[\"1kib\",{\"1\":{\"450\":1}}],[\"1<<63\",{\"1\":{\"397\":1}}],[\"1<<n\",{\"1\":{\"370\":2}}],[\"1<2\",{\"1\":{\"218\":1}}],[\"1mb来控制缓冲区大小\",{\"1\":{\"322\":1}}],[\"1意思就是主节点的数据我全要\",{\"1\":{\"318\":1}}],[\"1代表未压缩\",{\"1\":{\"300\":1}}],[\"1+nextdiff\",{\"1\":{\"299\":1}}],[\"1字节的二进制数据\",{\"1\":{\"299\":1}}],[\"1字节\",{\"1\":{\"299\":1}}],[\"1的概率为\",{\"1\":{\"297\":1}}],[\"1时\",{\"1\":{\"296\":1}}],[\"1758\",{\"1\":{\"502\":1}}],[\"174\",{\"1\":{\"502\":1}}],[\"17\",{\"0\":{\"108\":1}}],[\"16kb\",{\"1\":{\"300\":1}}],[\"168\",{\"1\":{\"266\":6,\"424\":2}}],[\"16mb\",{\"1\":{\"200\":1}}],[\"16\",{\"0\":{\"106\":1},\"1\":{\"200\":1,\"300\":4,\"339\":1,\"340\":1,\"490\":4}}],[\"1500000000\",{\"1\":{\"234\":2}}],[\"15\",{\"0\":{\"104\":1},\"1\":{\"266\":3,\"490\":2}}],[\"1400000000\",{\"1\":{\"234\":2}}],[\"14\",{\"0\":{\"103\":1},\"1\":{\"266\":3,\"490\":2}}],[\"13\",{\"0\":{\"100\":1},\"1\":{\"299\":1,\"490\":6}}],[\"192\",{\"1\":{\"266\":6,\"370\":2,\"424\":2}}],[\"1970\",{\"1\":{\"193\":1}}],[\"19\",{\"0\":{\"112\":1},\"1\":{\"72\":1}}],[\"12ab34cd56ef78gh910ij1112kl1314mn1516op1718qr1920st2122uv2324wx2526yz2728\",{\"1\":{\"366\":1}}],[\"123\",{\"1\":{\"309\":1}}],[\"123456789\",{\"1\":{\"299\":1}}],[\"129\",{\"1\":{\"299\":1}}],[\"127\",{\"1\":{\"299\":1,\"309\":2,\"370\":2}}],[\"128之后的是键盘上无法找到的\",{\"1\":{\"370\":1}}],[\"128\",{\"1\":{\"299\":2,\"341\":4,\"342\":4,\"370\":2}}],[\"12这十五个数值\",{\"1\":{\"299\":1}}],[\"12\",{\"0\":{\"97\":1},\"1\":{\"299\":2,\"300\":1,\"502\":4}}],[\"12等于12\",{\"1\":{\"67\":1}}],[\"12大于10\",{\"1\":{\"67\":1}}],[\"18029\",{\"1\":{\"339\":1}}],[\"18\",{\"0\":{\"111\":1},\"1\":{\"63\":2,\"72\":1,\"187\":1}}],[\"1100\",{\"1\":{\"299\":1}}],[\"1101\",{\"1\":{\"299\":2}}],[\"111\",{\"1\":{\"400\":1,\"437\":1}}],[\"1110\",{\"1\":{\"299\":2}}],[\"1111\",{\"1\":{\"299\":2}}],[\"11\",{\"0\":{\"96\":1,\"401\":1,\"415\":1},\"1\":{\"47\":2,\"145\":2,\"234\":3,\"288\":1,\"393\":1,\"490\":2}}],[\"1是在main\",{\"1\":{\"4\":1}}],[\"1\",{\"0\":{\"77\":1,\"167\":1,\"274\":1,\"292\":1,\"294\":1,\"309\":1,\"314\":1,\"321\":1,\"325\":1,\"391\":1,\"405\":1,\"428\":1,\"445\":1,\"456\":1,\"480\":1,\"483\":1},\"1\":{\"3\":1,\"4\":5,\"5\":1,\"6\":3,\"12\":3,\"41\":1,\"47\":1,\"52\":2,\"53\":2,\"57\":1,\"63\":7,\"66\":1,\"72\":2,\"91\":1,\"112\":1,\"119\":1,\"145\":1,\"167\":1,\"187\":1,\"206\":1,\"215\":1,\"217\":4,\"218\":8,\"219\":11,\"238\":1,\"244\":1,\"246\":1,\"262\":2,\"268\":2,\"275\":1,\"276\":1,\"277\":1,\"294\":1,\"296\":33,\"297\":4,\"299\":5,\"300\":7,\"309\":2,\"318\":2,\"346\":4,\"352\":2,\"366\":2,\"370\":1,\"374\":2,\"382\":1,\"386\":4,\"397\":2,\"407\":1,\"409\":4,\"410\":6,\"411\":2,\"412\":1,\"424\":6,\"428\":3,\"431\":3,\"438\":5,\"440\":4,\"446\":1,\"447\":2,\"448\":2,\"449\":3,\"450\":3,\"451\":4,\"452\":2,\"453\":2,\"454\":2,\"469\":4,\"480\":2,\"481\":1,\"490\":1,\"502\":4}}],[\"1024\",{\"1\":{\"63\":2,\"294\":2}}],[\"10000\",{\"1\":{\"352\":1,\"391\":1}}],[\"100000000000000\",{\"1\":{\"397\":1}}],[\"1000000\",{\"0\":{\"93\":1},\"1\":{\"93\":2}}],[\"1000\",{\"1\":{\"341\":1,\"382\":1,\"395\":1,\"398\":1,\"424\":3,\"450\":1}}],[\"1001\",{\"1\":{\"193\":1}}],[\"100\",{\"0\":{\"207\":1},\"1\":{\"6\":2,\"12\":1,\"353\":1,\"354\":1,\"395\":1,\"397\":1,\"398\":1,\"424\":4}}],[\"10\",{\"0\":{\"95\":1,\"400\":1,\"414\":1,\"454\":1,\"465\":1},\"1\":{\"3\":2,\"6\":2,\"7\":2,\"8\":2,\"12\":1,\"52\":1,\"53\":1,\"57\":1,\"93\":3,\"230\":2,\"296\":1,\"300\":1,\"341\":1,\"346\":1,\"347\":1,\"352\":2,\"354\":1,\"386\":1,\"395\":1,\"398\":1,\"407\":2,\"410\":2,\"431\":4,\"450\":1,\"490\":5}}],[\"f函数可能会被执行多次\",{\"1\":{\"448\":1}}],[\"fn\",{\"1\":{\"400\":2,\"407\":3,\"437\":3,\"502\":8}}],[\"f\",{\"1\":{\"386\":2,\"448\":2,\"454\":2,\"465\":1}}],[\"f前进一步\",{\"1\":{\"386\":1}}],[\"folders\",{\"1\":{\"490\":1}}],[\"followed\",{\"1\":{\"300\":1}}],[\"foo\",{\"1\":{\"490\":4}}],[\"found\",{\"1\":{\"473\":2}}],[\"for启动协程时传参\",{\"1\":{\"424\":1}}],[\"fork的操作也是发生在重写这一步\",{\"1\":{\"356\":1}}],[\"fork\",{\"1\":{\"355\":1}}],[\"forbids\",{\"1\":{\"346\":1}}],[\"forward字段指向比自己得分高的某个结点\",{\"1\":{\"297\":1}}],[\"forward\",{\"1\":{\"297\":1}}],[\"forcelarge\",{\"1\":{\"299\":3}}],[\"force\",{\"1\":{\"252\":1,\"296\":1,\"401\":1}}],[\"format\",{\"1\":{\"238\":1}}],[\"foreign\",{\"1\":{\"173\":1}}],[\"for在循环时\",{\"1\":{\"8\":1}}],[\"for+select\",{\"1\":{\"8\":1}}],[\"for\",{\"0\":{\"104\":1,\"105\":1},\"1\":{\"3\":2,\"6\":3,\"7\":2,\"8\":5,\"12\":5,\"28\":2,\"29\":2,\"32\":1,\"34\":3,\"36\":4,\"41\":1,\"47\":1,\"52\":1,\"53\":2,\"57\":2,\"58\":1,\"63\":1,\"98\":2,\"105\":1,\"112\":4,\"158\":2,\"214\":1,\"296\":4,\"297\":1,\"299\":5,\"300\":6,\"346\":1,\"366\":2,\"370\":3,\"374\":1,\"378\":1,\"382\":1,\"386\":2,\"395\":2,\"396\":1,\"397\":3,\"398\":2,\"400\":1,\"401\":4,\"406\":2,\"407\":2,\"413\":1,\"418\":3,\"424\":6,\"428\":1,\"431\":2,\"437\":1,\"450\":4,\"451\":1,\"500\":1,\"502\":6}}],[\"flag始终为一字节\",{\"1\":{\"294\":1}}],[\"flags\",{\"1\":{\"294\":6}}],[\"flushslavesoutputbuffers\",{\"1\":{\"346\":1}}],[\"flush\",{\"1\":{\"119\":1}}],[\"features\",{\"1\":{\"264\":1}}],[\"fsync\",{\"1\":{\"198\":1,\"353\":1}}],[\"fwrite\",{\"1\":{\"198\":1}}],[\"frequently\",{\"1\":{\"296\":1,\"347\":1}}],[\"free的值最大只能是254\",{\"1\":{\"301\":1}}],[\"free\",{\"1\":{\"224\":1,\"295\":2,\"300\":1,\"301\":2,\"346\":1}}],[\"freed++\",{\"1\":{\"346\":1}}],[\"freed\",{\"1\":{\"36\":1,\"346\":2}}],[\"freememoryifneeded\",{\"1\":{\"346\":1}}],[\"freem\",{\"1\":{\"34\":1}}],[\"freelink\",{\"1\":{\"34\":1}}],[\"francisq\",{\"1\":{\"219\":1}}],[\"frm\",{\"1\":{\"87\":1}}],[\"from\",{\"1\":{\"12\":1,\"28\":1,\"29\":2,\"32\":2,\"35\":1,\"72\":2,\"87\":1,\"93\":4,\"98\":1,\"111\":1,\"112\":8,\"152\":1,\"158\":1,\"206\":3,\"214\":4,\"229\":1,\"230\":3,\"234\":1,\"296\":1,\"341\":4,\"346\":1}}],[\"future\",{\"1\":{\"300\":2}}],[\"fullpath\",{\"1\":{\"12\":2}}],[\"func4\",{\"1\":{\"400\":1,\"437\":1}}],[\"func3\",{\"1\":{\"400\":1,\"437\":1}}],[\"func2\",{\"1\":{\"400\":1,\"437\":1}}],[\"func1\",{\"1\":{\"400\":1,\"437\":1}}],[\"funcval\",{\"1\":{\"32\":1,\"407\":1}}],[\"functions\",{\"1\":{\"296\":1}}],[\"function\",{\"1\":{\"12\":1,\"44\":1,\"262\":13,\"264\":9,\"502\":2}}],[\"func\",{\"1\":{\"3\":4,\"4\":4,\"5\":3,\"6\":5,\"7\":4,\"8\":4,\"12\":9,\"19\":1,\"28\":1,\"29\":1,\"34\":1,\"41\":1,\"43\":2,\"44\":1,\"45\":2,\"52\":6,\"53\":12,\"57\":5,\"58\":11,\"63\":2,\"366\":2,\"370\":3,\"374\":1,\"378\":1,\"382\":1,\"386\":2,\"391\":1,\"392\":1,\"393\":1,\"394\":2,\"395\":3,\"396\":1,\"397\":6,\"398\":2,\"399\":1,\"400\":8,\"401\":3,\"405\":5,\"406\":1,\"407\":5,\"408\":4,\"409\":1,\"410\":2,\"411\":1,\"412\":2,\"413\":2,\"414\":2,\"415\":3,\"418\":3,\"421\":1,\"424\":9,\"428\":8,\"431\":8,\"435\":1,\"436\":1,\"437\":8,\"438\":1,\"439\":1,\"440\":1,\"441\":1,\"445\":4,\"446\":4,\"447\":2,\"448\":2,\"449\":1,\"450\":5,\"451\":3,\"452\":3,\"453\":1,\"454\":2,\"480\":1,\"481\":1,\"483\":1,\"484\":1,\"490\":2,\"496\":1,\"500\":1,\"502\":19,\"507\":1,\"508\":1}}],[\"figure\",{\"1\":{\"299\":1}}],[\"fivezh\",{\"1\":{\"288\":1,\"347\":1}}],[\"fill的值影响着每个链表结点中\",{\"1\":{\"300\":1}}],[\"fill字段影响着每个链表结点中ziplist的最大占用空间\",{\"1\":{\"300\":1}}],[\"fill\",{\"1\":{\"300\":5}}],[\"file中\",{\"1\":{\"356\":1}}],[\"file=\",{\"1\":{\"238\":1}}],[\"file\",{\"1\":{\"237\":1,\"255\":1,\"260\":1,\"262\":3,\"490\":1}}],[\"filtered\",{\"1\":{\"195\":1}}],[\"first\",{\"1\":{\"57\":1,\"296\":2}}],[\"fields\",{\"1\":{\"296\":1,\"300\":1}}],[\"fieldn\",{\"1\":{\"275\":1}}],[\"field1\",{\"1\":{\"275\":1}}],[\"field除了名称和数据类型\",{\"1\":{\"42\":1}}],[\"field\",{\"1\":{\"42\":1,\"299\":2,\"300\":1}}],[\"finish\",{\"1\":{\"502\":1}}],[\"finishrequest\",{\"1\":{\"12\":1}}],[\"fingerprint\",{\"1\":{\"296\":2}}],[\"find\",{\"1\":{\"12\":2,\"28\":1,\"29\":2,\"52\":3,\"53\":3,\"299\":1}}],[\"fifo\",{\"1\":{\"1\":1,\"3\":1}}],[\"factor\",{\"1\":{\"300\":2,\"347\":1}}],[\"facebook推荐方案\",{\"1\":{\"288\":1}}],[\"fair\",{\"1\":{\"266\":2}}],[\"failure\",{\"1\":{\"12\":1}}],[\"false代表存在相同的字符\",{\"1\":{\"370\":1}}],[\"false\",{\"1\":{\"12\":1,\"215\":1,\"217\":3,\"262\":1,\"265\":1,\"268\":2,\"269\":1,\"370\":8,\"374\":1,\"378\":2,\"382\":3,\"424\":2,\"431\":1,\"478\":1,\"484\":1,\"502\":9}}],[\"fatalexceptionfromerror\",{\"1\":{\"262\":1}}],[\"fatal\",{\"1\":{\"4\":1,\"6\":1,\"412\":1}}],[\"f2\",{\"1\":{\"5\":3}}],[\"f1\",{\"1\":{\"5\":3}}],[\"fmt\",{\"1\":{\"3\":5,\"4\":5,\"5\":2,\"6\":1,\"7\":4,\"44\":2,\"45\":1,\"47\":1,\"48\":6,\"63\":8,\"366\":4,\"393\":2,\"394\":2,\"395\":3,\"397\":2,\"398\":2,\"400\":1,\"401\":3,\"405\":4,\"407\":2,\"408\":3,\"409\":1,\"410\":1,\"411\":1,\"414\":2,\"415\":3,\"418\":1,\"424\":6,\"428\":2,\"431\":6,\"435\":2,\"436\":5,\"437\":2,\"438\":3,\"439\":3,\"440\":3,\"441\":2,\"445\":2,\"446\":2,\"449\":2,\"450\":2,\"451\":2,\"452\":2,\"453\":2,\"481\":13,\"490\":3,\"496\":2,\"500\":2,\"507\":2,\"508\":1}}],[\"阻塞和不阻塞是由channel控制的\",{\"1\":{\"3\":1}}],[\"阻塞\",{\"1\":{\"3\":1,\"212\":1,\"401\":3}}],[\"有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢\",{\"1\":{\"495\":1}}],[\"有没有必要查这么后的分页啦\",{\"1\":{\"93\":1}}],[\"有并发问题\",{\"1\":{\"448\":1}}],[\"有一张表记录defer\",{\"1\":{\"405\":1}}],[\"有一下几个问题\",{\"1\":{\"397\":1}}],[\"有一个机器人\",{\"1\":{\"386\":1}}],[\"有两种安装方式\",{\"1\":{\"336\":1}}],[\"有可能会导致反复的全量复制\",{\"1\":{\"326\":1}}],[\"有主节点提供写服务\",{\"1\":{\"307\":1}}],[\"有安全迭代器可用\",{\"1\":{\"296\":1}}],[\"有序集合经典使用场景\",{\"1\":{\"278\":1}}],[\"有序集合中的元素不可以重复\",{\"1\":{\"278\":1}}],[\"有序集合中的元素是可以排序的\",{\"1\":{\"278\":1}}],[\"有序集合和集合有着必然的联系\",{\"1\":{\"278\":1}}],[\"有序集合\",{\"0\":{\"278\":1}}],[\"有序数组\",{\"1\":{\"246\":1}}],[\"有人发布微博\",{\"1\":{\"276\":1}}],[\"有限集合\",{\"1\":{\"276\":1}}],[\"有的时候我们一个网站有很多服务模块\",{\"1\":{\"265\":1}}],[\"有的时候php本身对错误的处理难以满足我们的业务需求\",{\"1\":{\"262\":1}}],[\"有利于后期排查\",{\"1\":{\"262\":2}}],[\"有多少种日志\",{\"0\":{\"197\":1}}],[\"有大量的\",{\"1\":{\"190\":1}}],[\"有实战过吗\",{\"0\":{\"188\":1}}],[\"有哪些优缺点\",{\"0\":{\"169\":1}}],[\"有共享锁和排他锁\",{\"1\":{\"157\":1}}],[\"有三种格式哈\",{\"1\":{\"140\":1}}],[\"有以下3种\",{\"1\":{\"133\":1}}],[\"有以下两个名称冲突的规则\",{\"1\":{\"42\":1}}],[\"有关于复合索引\",{\"1\":{\"111\":1}}],[\"有线程过来\",{\"1\":{\"99\":1}}],[\"有心的读者可能还发现上图b+树中各个页之间是通过双向链表连接的\",{\"1\":{\"70\":1}}],[\"有写锁时优先进行写锁定\",{\"1\":{\"58\":1}}],[\"有写锁时\",{\"1\":{\"58\":1}}],[\"有了上述数据结构以及工作线程与数据结构之间的映射机制\",{\"1\":{\"29\":1}}],[\"有了它\",{\"1\":{\"20\":1}}],[\"有了它才能建立g\",{\"1\":{\"18\":1}}],[\"有40多个成员变量\",{\"1\":{\"19\":1}}],[\"有缓冲chan一般在进行并发限制的时候用的较多\",{\"1\":{\"6\":1}}],[\"有缓冲chan\",{\"0\":{\"6\":1}}],[\"有缓冲\",{\"1\":{\"3\":3}}],[\"有属于自己的栈空间\",{\"1\":{\"1\":1}}],[\"只可能有一个协程写入成功\",{\"1\":{\"437\":1}}],[\"只执行一次内存重分配\",{\"1\":{\"299\":1}}],[\"只更新缓存\",{\"1\":{\"288\":1}}],[\"只允许可承受流量\",{\"1\":{\"285\":1}}],[\"只是表象\",{\"1\":{\"292\":1}}],[\"只是\",{\"1\":{\"292\":1}}],[\"只是标记为可复用\",{\"1\":{\"255\":1}}],[\"只是一种\",{\"1\":{\"213\":1}}],[\"只欠东风了\",{\"1\":{\"215\":1}}],[\"只包括列名那一列\",{\"1\":{\"167\":1}}],[\"只保留两张表中完全匹配的结果集\",{\"1\":{\"135\":1}}],[\"只能存放在\",{\"1\":{\"198\":1}}],[\"只能等待锁被释放才可以执行\",{\"1\":{\"101\":1}}],[\"只能保证map是线程安全的\",{\"1\":{\"57\":1}}],[\"只有组合\",{\"1\":{\"408\":1}}],[\"只有有变化就会给每个slave进行发送\",{\"1\":{\"318\":1}}],[\"只有一套存储系统\",{\"1\":{\"288\":1}}],[\"只有未命中缓存时才进行数据回源\",{\"1\":{\"282\":1}}],[\"只有普通索引会用到change\",{\"1\":{\"250\":1}}],[\"只有id和name的学生表\",{\"1\":{\"217\":1}}],[\"只有当系统没有比这个log更早的read\",{\"1\":{\"215\":1}}],[\"只有主键索引是聚簇索引\",{\"1\":{\"150\":1}}],[\"只有在unlock后才会解除阻塞\",{\"1\":{\"57\":1}}],[\"只有必要时才会去访问全局运行队列\",{\"1\":{\"29\":1}}],[\"只需要把\",{\"1\":{\"496\":1}}],[\"只需要重新启动redis即可\",{\"1\":{\"357\":1}}],[\"只需要在save的最后一行写上\",{\"1\":{\"352\":1}}],[\"只需要\",{\"1\":{\"201\":1}}],[\"只需要创建一次过程\",{\"1\":{\"169\":1}}],[\"只需要2次磁盘io\",{\"1\":{\"70\":1}}],[\"只需在schedule函数中定义一个局部变量就行了\",{\"1\":{\"29\":1}}],[\"只需将send操作放在另一个goroutine中执行即可\",{\"1\":{\"4\":1}}],[\"只用于接收数据的通道<\",{\"1\":{\"6\":1}}],[\"只要是发生类型强转都会发生内存拷贝\",{\"1\":{\"495\":1}}],[\"只要内存里脏页\",{\"1\":{\"251\":1}}],[\"只要修改了记录中其他字段的值\",{\"1\":{\"128\":1}}],[\"只要redo\",{\"1\":{\"107\":1,\"194\":1}}],[\"只要receiver是指针类型的\",{\"1\":{\"43\":1}}],[\"只要receiver是值类型的\",{\"1\":{\"43\":1}}],[\"只要每个工作线程拥有了各自私有的m结构体全局变量\",{\"1\":{\"29\":1}}],[\"只要有一个case满足条件\",{\"1\":{\"7\":1}}],[\"只要所有goroutine都被阻塞\",{\"1\":{\"4\":1}}],[\"只要channel未关闭\",{\"1\":{\"6\":1}}],[\"只要channel非空\",{\"1\":{\"3\":1}}],[\"只要channel容量未满\",{\"1\":{\"3\":2}}],[\"只在sender端上显式使用close\",{\"1\":{\"2\":1}}],[\"只不过有一个指针指向对应的数据块\",{\"1\":{\"92\":1}}],[\"只不过\",{\"1\":{\"1\":2}}],[\"在读完\",{\"1\":{\"502\":1}}],[\"在里面会执行\",{\"1\":{\"502\":1}}],[\"在c语言中妥妥野指针\",{\"1\":{\"490\":1}}],[\"在编译时\",{\"1\":{\"489\":1}}],[\"在编译器会固定大小\",{\"1\":{\"63\":1}}],[\"在栈中回收\",{\"1\":{\"489\":1}}],[\"在方法内把局部变量指针返回\",{\"1\":{\"489\":1,\"490\":1}}],[\"在查找到目标值或者超时后立刻结束所有goroutine的执行\",{\"1\":{\"473\":1}}],[\"在查询执行期限间创建的临时表和文件\",{\"1\":{\"130\":1}}],[\"在单核cpu中\",{\"1\":{\"461\":1}}],[\"在单一缓存故障时\",{\"1\":{\"285\":1}}],[\"在调用\",{\"1\":{\"458\":1}}],[\"在初始化切片时指定了长度\",{\"1\":{\"411\":1}}],[\"在定义的时候会计算好调用函数的参数\",{\"1\":{\"410\":1}}],[\"在定时任务未到期之前\",{\"1\":{\"8\":1}}],[\"在多核cpu中\",{\"1\":{\"459\":1}}],[\"在多个case\",{\"1\":{\"409\":1}}],[\"在多并发操作里是属于协程安全的\",{\"1\":{\"1\":1}}],[\"在defer出现的地方\",{\"1\":{\"405\":1}}],[\"在dictht\",{\"1\":{\"296\":1}}],[\"在题目中\",{\"1\":{\"395\":1}}],[\"在json\",{\"1\":{\"393\":1}}],[\"在线上我们到底该怎么做\",{\"1\":{\"358\":1}}],[\"在重写期间\",{\"1\":{\"356\":1}}],[\"在介绍原理之前先说下redis内部的定时任务机制\",{\"1\":{\"354\":1}}],[\"在加载时发现aof尾部不正确是\",{\"1\":{\"353\":1}}],[\"在指定的时间间隔能对你的数据进行快照存储\",{\"1\":{\"350\":1}}],[\"在循环内同步\",{\"1\":{\"346\":1}}],[\"在一般情况下\",{\"1\":{\"339\":1}}],[\"在一个切片上存储指针或带指针的值\",{\"1\":{\"489\":1}}],[\"在一个高并发的web服务器中\",{\"1\":{\"424\":1}}],[\"在一个事务里可以多次读取到当前事务第一次读取的数据\",{\"1\":{\"245\":1}}],[\"在一个事务里可以读取其他事务未提交的数据变更\",{\"1\":{\"245\":1}}],[\"在一个事务里只能读取已提交事务的变更数据\",{\"1\":{\"245\":1}}],[\"在一个事务范围内\",{\"1\":{\"96\":1}}],[\"在一个表中存在的另一个表的主键称此表的外键\",{\"1\":{\"172\":1}}],[\"在一个struct中\",{\"1\":{\"42\":1}}],[\"在分析内存的时候\",{\"1\":{\"335\":1}}],[\"在心跳机制中\",{\"1\":{\"327\":1}}],[\"在心跳机制里边slave\",{\"1\":{\"319\":1}}],[\"在命令传播阶段\",{\"1\":{\"322\":1}}],[\"在命令传播阶段是\",{\"1\":{\"319\":1}}],[\"在命令传播阶段出现断网的情况\",{\"1\":{\"317\":1}}],[\"在全量复制后\",{\"1\":{\"318\":1}}],[\"在建立完主从复制后主节点会创建master\",{\"1\":{\"325\":1}}],[\"在建立连接的过程中\",{\"1\":{\"315\":1}}],[\"在建表的时候\",{\"1\":{\"215\":1}}],[\"在启动redis服务器时直接就启动主从复制\",{\"1\":{\"311\":1}}],[\"在根据配置文件启动redis服务\",{\"1\":{\"310\":1}}],[\"在主从复制模式replication下\",{\"1\":{\"345\":1}}],[\"在主从复制初次启动时\",{\"1\":{\"321\":1}}],[\"在主节点执行shutdown\",{\"1\":{\"325\":1}}],[\"在主节点的第3步下面\",{\"1\":{\"318\":1}}],[\"在主节点的客户端输入info打印的信息\",{\"1\":{\"310\":1}}],[\"在主节点的客户端输入命令行info查看\",{\"1\":{\"310\":1}}],[\"在主节点打印的info\",{\"1\":{\"310\":1}}],[\"在主服务器上创建一个复制账号\",{\"1\":{\"238\":1}}],[\"在哪可以查看从节点已经断开了主节点呢\",{\"1\":{\"310\":1}}],[\"在从主机执行slaveof\",{\"1\":{\"310\":1}}],[\"在master这台服务器上执行俩个set\",{\"1\":{\"309\":1}}],[\"在mysql5\",{\"1\":{\"246\":1}}],[\"在mysql中\",{\"1\":{\"71\":1}}],[\"在mysql中数据读取的基本单位都是页\",{\"1\":{\"69\":1}}],[\"在myisam中\",{\"1\":{\"70\":1,\"72\":1}}],[\"在3\",{\"1\":{\"300\":2,\"346\":2}}],[\"在大规模数值存储中\",{\"1\":{\"299\":1}}],[\"在大量缓存同时失效的情况下\",{\"1\":{\"284\":1}}],[\"在这里需要你写算法\",{\"1\":{\"428\":2}}],[\"在这个阶段提到了三个新点\",{\"1\":{\"316\":1}}],[\"在这种情况下会出现的第一个问题就是服务器宕机\",{\"1\":{\"306\":1}}],[\"在这两个字节16位中\",{\"1\":{\"299\":1}}],[\"在这一字节中\",{\"1\":{\"299\":1}}],[\"在这一区间内的代码是严格被lock\",{\"1\":{\"57\":1}}],[\"在画图展示entry的内存布局之前\",{\"1\":{\"299\":1}}],[\"在接口zslinsert的实现中\",{\"1\":{\"297\":1}}],[\"在给定一个分值的情况下\",{\"1\":{\"297\":1}}],[\"在原版跳跃表的基础上\",{\"1\":{\"297\":1}}],[\"在redis中rdb持久化的触发分为两种\",{\"1\":{\"355\":1}}],[\"在redis中\",{\"1\":{\"297\":1}}],[\"在rr模式下\",{\"1\":{\"218\":1}}],[\"在迭代起始时\",{\"1\":{\"296\":1}}],[\"在迭代过程中\",{\"1\":{\"296\":1}}],[\"在旧bucket中\",{\"1\":{\"296\":1}}],[\"在旧表中由于冲突而被链接在同一索引位上的结点\",{\"1\":{\"296\":1}}],[\"在计算键在bucket中的索引值时\",{\"1\":{\"296\":1}}],[\"在计算新插入结点键的bucket索引值时\",{\"1\":{\"296\":1}}],[\"在平滑扩容的过程中时\",{\"1\":{\"296\":1}}],[\"在lru中\",{\"1\":{\"347\":1}}],[\"在list的实现中\",{\"1\":{\"295\":1}}],[\"在lock\",{\"1\":{\"57\":1}}],[\"在总体占用空间不超过阈值sds\",{\"1\":{\"294\":1}}],[\"在扩充空间时\",{\"1\":{\"294\":1}}],[\"在缓存失效下写操作的处理后\",{\"1\":{\"288\":1}}],[\"在缓存系统设置空值来拦截\",{\"1\":{\"286\":1}}],[\"在故障后快速恢复缓存系统\",{\"1\":{\"285\":1}}],[\"在解决高性能\",{\"1\":{\"285\":1}}],[\"在服务端控制层需要针对同一个访问uid\",{\"1\":{\"268\":1}}],[\"在前端和后端服务之间增加一个中间层\",{\"1\":{\"268\":1}}],[\"在时间范围内\",{\"1\":{\"268\":1}}],[\"在web开发中\",{\"1\":{\"264\":1}}],[\"在php\",{\"1\":{\"266\":1}}],[\"在php中通过上述代码就可以让a\",{\"1\":{\"265\":1}}],[\"在php中采用\",{\"1\":{\"262\":1}}],[\"在php7以上\",{\"1\":{\"262\":1}}],[\"在innodb里引擎对他做了相关优化\",{\"1\":{\"256\":1}}],[\"在innodb中\",{\"1\":{\"70\":1,\"150\":1}}],[\"在每次存储字段值的时候计算hash值并把hash存储hash列\",{\"1\":{\"253\":1}}],[\"在更新之后需要立马查询的表中\",{\"1\":{\"250\":1}}],[\"在等值查询和范围查询场景中的性能就都非常优\",{\"1\":{\"246\":1}}],[\"在没有比这个版本更老的视图的时候进行删除\",{\"1\":{\"245\":1}}],[\"在某一时间段内只允许用户提交一次请求\",{\"1\":{\"268\":1}}],[\"在某个数据页上做了什么修改\",{\"1\":{\"244\":1}}],[\"在某些时候可以自动被关闭\",{\"1\":{\"2\":1}}],[\"在高并发的情况下建议关闭查询缓存\",{\"1\":{\"236\":1}}],[\"在高并发情况下\",{\"0\":{\"97\":1}}],[\"在设计innodb主键的时候\",{\"1\":{\"230\":1}}],[\"在实际业务中可以通过使用相同的列不同的顺序来创建更多的索引\",{\"1\":{\"228\":1}}],[\"在并发高的情况下进行读写操作的时候性能很差\",{\"1\":{\"223\":1}}],[\"在活跃事务数组中故不可见\",{\"1\":{\"219\":1}}],[\"在活跃列表中\",{\"1\":{\"218\":1}}],[\"在进行分区查询的时候\",{\"1\":{\"234\":1}}],[\"在进行快照读的时候我们会创建一个\",{\"1\":{\"218\":1}}],[\"在进行函数体地址\",{\"1\":{\"21\":1}}],[\"在快照读的时候还是需要的\",{\"1\":{\"215\":1}}],[\"在讲\",{\"1\":{\"214\":1}}],[\"在最快时间之内重启\",{\"0\":{\"201\":1}}],[\"在记\",{\"1\":{\"199\":1}}],[\"在页修改的时候\",{\"1\":{\"198\":1}}],[\"在不使用\",{\"1\":{\"374\":1}}],[\"在不影响业务的情况\",{\"1\":{\"189\":1}}],[\"在不能转换时\",{\"1\":{\"48\":1}}],[\"在关系模式中\",{\"1\":{\"172\":1}}],[\"在用到这个功能的时候调用即可\",{\"1\":{\"169\":1}}],[\"在统计结果的时候\",{\"1\":{\"167\":3}}],[\"在同一个事务中\",{\"1\":{\"159\":1}}],[\"在索引的叶子节点上\",{\"1\":{\"152\":1}}],[\"在索引列上使用mysql的内置函数\",{\"1\":{\"78\":1}}],[\"在对链表进行销毁\",{\"1\":{\"295\":1}}],[\"在对sds中的数据进行修改时\",{\"1\":{\"294\":1}}],[\"在对应的叶子节点\",{\"1\":{\"150\":1}}],[\"在对实例初始化的时候\",{\"1\":{\"53\":1}}],[\"在bucket索引值冲突时\",{\"1\":{\"296\":1}}],[\"在b+树的索引中\",{\"1\":{\"150\":1}}],[\"在b+树的叶子节点中\",{\"1\":{\"71\":1}}],[\"在b+树中\",{\"1\":{\"148\":1}}],[\"在b树中\",{\"1\":{\"148\":1}}],[\"在创建多列索引时\",{\"1\":{\"147\":1}}],[\"在order\",{\"1\":{\"144\":1,\"228\":1}}],[\"在满足第二范式的基础上\",{\"1\":{\"138\":1}}],[\"在满足二叉查找树特性的基础上\",{\"1\":{\"68\":1}}],[\"在第一范式的基础上\",{\"1\":{\"138\":1}}],[\"在两张表进行连接查询时\",{\"1\":{\"135\":3}}],[\"在内存中有拷贝\",{\"1\":{\"250\":1}}],[\"在内存中直接搜索索引\",{\"1\":{\"231\":1}}],[\"在内存比在磁盘的数据\",{\"1\":{\"90\":1}}],[\"在内部对象池中\",{\"1\":{\"122\":1}}],[\"在业务允许的情况下限制页数\",{\"1\":{\"93\":1}}],[\"在叶子节点中\",{\"1\":{\"72\":1}}],[\"在底层数组上int1是ints的子集\",{\"1\":{\"63\":1}}],[\"在另一个地方不lock\",{\"1\":{\"57\":1}}],[\"在上文中我们查看启动日志信息也可以看到\",{\"1\":{\"321\":1}}],[\"在上边我们说了为什么使用redis的主从复制\",{\"1\":{\"307\":1}}],[\"在上节介绍b+树索引的时候\",{\"1\":{\"71\":1}}],[\"在上个总结的线程安全的map一文中是有一处错误的\",{\"1\":{\"57\":1}}],[\"在上一个总结中我们在实现线程安全的map的时候用到了锁的概念\",{\"1\":{\"56\":1}}],[\"在上一个总结中我们知道map是引用类型的\",{\"1\":{\"52\":1}}],[\"在上面horse中嵌套了其它的struct\",{\"1\":{\"42\":1}}],[\"在上面的示例中\",{\"1\":{\"4\":1}}],[\"在有需要的时候\",{\"1\":{\"48\":1}}],[\"在数据结构中存储任意类型的数据\",{\"1\":{\"47\":1}}],[\"在\",{\"0\":{\"418\":1},\"1\":{\"44\":1,\"126\":1,\"198\":1,\"219\":1,\"266\":1,\"345\":1,\"395\":1,\"412\":1,\"414\":1,\"428\":1,\"483\":1,\"489\":2}}],[\"在需要的时候\",{\"1\":{\"43\":1}}],[\"在sds的使用者需要节省内存时\",{\"1\":{\"294\":1}}],[\"在struct中\",{\"1\":{\"42\":1}}],[\"在select查询中加上limit关键字\",{\"1\":{\"232\":1}}],[\"在serverhandler的servehttp方法中判断server的handler是否为nil\",{\"1\":{\"12\":1}}],[\"在sender和receiver接收到ok消息之前\",{\"1\":{\"3\":1}}],[\"在函数中我们传递一个对象的实例可以是对象的值也可以是对象的指针\",{\"1\":{\"42\":1}}],[\"在函数中map作为参数传递时\",{\"1\":{\"41\":1}}],[\"在其它地方常称为hash\",{\"1\":{\"41\":1}}],[\"在程序初始化时\",{\"1\":{\"37\":1}}],[\"在执行\",{\"1\":{\"412\":1}}],[\"在执行create\",{\"1\":{\"145\":1}}],[\"在执行调度代码时需要使用这个栈\",{\"1\":{\"34\":1}}],[\"在执行操作系统代码时\",{\"1\":{\"29\":1}}],[\"在简单的介绍了go语言调度器以及它所需要的数据结构之后\",{\"1\":{\"29\":1}}],[\"在协程切换\",{\"1\":{\"19\":1}}],[\"在使用\",{\"1\":{\"394\":1}}],[\"在使用配置文件启动主从复制之前呢\",{\"1\":{\"310\":1}}],[\"在使用联合索引时\",{\"1\":{\"246\":1}}],[\"在使用非主键索引查询时\",{\"1\":{\"246\":1}}],[\"在使用的时候要正确使用\",{\"1\":{\"8\":1}}],[\"在使用send的时候\",{\"1\":{\"7\":1}}],[\"在golang中式非阻塞的\",{\"1\":{\"418\":1}}],[\"在golang中string\",{\"1\":{\"394\":1}}],[\"在go语言中数组是固定长度的\",{\"1\":{\"63\":1}}],[\"在go语言调度器源代码中\",{\"1\":{\"29\":1}}],[\"在goruntine中已有的锁在没有被释放前去获取锁\",{\"1\":{\"57\":1}}],[\"在go中允许这样\",{\"1\":{\"57\":1}}],[\"在go中map的元素是无序的\",{\"1\":{\"41\":1}}],[\"在go中提供了定时器功能\",{\"1\":{\"8\":1}}],[\"在go调度器源代码中\",{\"1\":{\"29\":1}}],[\"在go的内部行为中\",{\"1\":{\"3\":1}}],[\"在task的do方法中我们使用指向的chan\",{\"1\":{\"6\":1}}],[\"在任务执行之前对chan进行写操作\",{\"1\":{\"6\":1}}],[\"cn\",{\"1\":{\"503\":2}}],[\"cnblogs\",{\"1\":{\"234\":1,\"235\":1,\"238\":1,\"265\":1,\"266\":1}}],[\"cerr\",{\"1\":{\"502\":3}}],[\"centos7\",{\"1\":{\"304\":1}}],[\"cm\",{\"1\":{\"502\":2}}],[\"cmd\",{\"1\":{\"386\":2}}],[\"cycle\",{\"1\":{\"450\":1}}],[\"cd\",{\"1\":{\"338\":1}}],[\"cdn加速\",{\"1\":{\"268\":1}}],[\"c两个文件中\",{\"1\":{\"301\":1}}],[\"c中\",{\"1\":{\"294\":1,\"295\":1,\"296\":1,\"298\":1,\"300\":1}}],[\"cstruct\",{\"1\":{\"481\":4}}],[\"cs\",{\"1\":{\"481\":8}}],[\"csv\",{\"1\":{\"339\":4,\"340\":1,\"341\":2,\"342\":3}}],[\"csdn\",{\"1\":{\"235\":1,\"238\":2,\"266\":2}}],[\"csp又火了起来\",{\"1\":{\"17\":1}}],[\"csp篇\",{\"0\":{\"17\":1}}],[\"csp\",{\"1\":{\"16\":1,\"17\":1}}],[\"c>x\",{\"1\":{\"230\":1}}],[\"ci<\",{\"1\":{\"481\":1}}],[\"ci\",{\"1\":{\"481\":5}}],[\"cityid\",{\"1\":{\"230\":9}}],[\"city\",{\"1\":{\"229\":3,\"507\":1}}],[\"circle\",{\"1\":{\"48\":2}}],[\"cpu更值钱\",{\"1\":{\"352\":1}}],[\"cpu\",{\"1\":{\"190\":2,\"358\":1}}],[\"cpu运行该goroutine\",{\"1\":{\"28\":1,\"29\":1}}],[\"cumulative\",{\"1\":{\"36\":1}}],[\"cursor\",{\"1\":{\"299\":1}}],[\"cur\",{\"1\":{\"299\":5}}],[\"curlen+extra\",{\"1\":{\"299\":1}}],[\"curlen+reqlen+nextdiff\",{\"1\":{\"299\":1}}],[\"curlen\",{\"1\":{\"299\":5}}],[\"curent\",{\"1\":{\"219\":1}}],[\"currently\",{\"1\":{\"296\":1,\"300\":1}}],[\"current\",{\"1\":{\"33\":1,\"34\":1,\"35\":2,\"193\":1,\"205\":1,\"219\":2,\"299\":1,\"300\":2}}],[\"curreq\",{\"1\":{\"12\":1}}],[\"curg\",{\"1\":{\"19\":2,\"34\":1}}],[\"cgo\",{\"1\":{\"33\":1}}],[\"crc32\",{\"1\":{\"266\":1}}],[\"cross\",{\"1\":{\"137\":1}}],[\"crud比较慢\",{\"0\":{\"108\":1}}],[\"critical\",{\"1\":{\"57\":1}}],[\"crash\",{\"1\":{\"33\":1}}],[\"createstringobject\",{\"1\":{\"346\":1}}],[\"created\",{\"1\":{\"36\":1,\"130\":1}}],[\"create\",{\"1\":{\"28\":1,\"29\":1,\"145\":2,\"234\":1,\"341\":1,\"342\":1}}],[\"clear\",{\"1\":{\"346\":1}}],[\"cleared\",{\"1\":{\"32\":1}}],[\"client\",{\"1\":{\"502\":4}}],[\"cli直接连接就可以\",{\"1\":{\"308\":1}}],[\"cli\",{\"1\":{\"308\":1}}],[\"class\",{\"1\":{\"262\":5,\"264\":1}}],[\"clone\",{\"1\":{\"338\":1}}],[\"clojure之道\",{\"1\":{\"16\":1}}],[\"closech\",{\"1\":{\"502\":1}}],[\"closed\",{\"1\":{\"480\":2,\"483\":4,\"484\":2,\"502\":3}}],[\"close并非强制需要使用close\",{\"1\":{\"2\":1}}],[\"close\",{\"1\":{\"2\":1,\"3\":3,\"5\":1,\"6\":1,\"7\":4,\"12\":1,\"53\":1,\"264\":2,\"395\":3,\"398\":2,\"413\":1,\"418\":1,\"421\":1,\"431\":6,\"452\":1,\"480\":1,\"481\":3,\"490\":1,\"500\":1,\"501\":1,\"502\":5,\"503\":2}}],[\"collection\",{\"1\":{\"276\":1}}],[\"column\",{\"1\":{\"145\":2}}],[\"columns\",{\"1\":{\"139\":2}}],[\"cookie\",{\"1\":{\"264\":2}}],[\"core\",{\"1\":{\"262\":3}}],[\"copied\",{\"1\":{\"57\":1}}],[\"count++\",{\"1\":{\"446\":1,\"449\":2,\"452\":1}}],[\"counters计数器占用少量位数来评估每个对象的访问频率\",{\"1\":{\"347\":1}}],[\"counted\",{\"1\":{\"36\":1}}],[\"count指的是整个quicklist中的所有ziplist中的entry的数目\",{\"1\":{\"300\":1}}],[\"count\",{\"0\":{\"167\":3,\"256\":1},\"1\":{\"87\":1,\"167\":3,\"229\":2,\"230\":4,\"300\":7,\"341\":1,\"370\":5,\"378\":3,\"446\":2,\"449\":3,\"452\":2}}],[\"could\",{\"1\":{\"12\":1}}],[\"com进行cookie之间的相互传递\",{\"1\":{\"265\":1}}],[\"compareandswapint32\",{\"1\":{\"396\":2}}],[\"compared\",{\"1\":{\"33\":2}}],[\"compress的值影响着quicklistnode\",{\"1\":{\"300\":1}}],[\"compress影响着是否要对每个ziplist以lz4算法进行进一步压缩以更节省内存空间\",{\"1\":{\"300\":1}}],[\"compression\",{\"1\":{\"300\":1}}],[\"compressed\",{\"1\":{\"300\":7}}],[\"compress\",{\"1\":{\"300\":6}}],[\"compile\",{\"1\":{\"262\":4}}],[\"com\",{\"1\":{\"37\":1,\"130\":1,\"234\":1,\"235\":1,\"238\":2,\"265\":8,\"266\":1,\"338\":1,\"473\":1,\"490\":1,\"500\":1}}],[\"command\",{\"1\":{\"490\":1}}],[\"commit\",{\"1\":{\"119\":1,\"199\":2,\"244\":1}}],[\"committed\",{\"1\":{\"95\":1}}],[\"comments\",{\"1\":{\"339\":1}}],[\"comment\",{\"1\":{\"36\":1,\"502\":1}}],[\"communicate\",{\"1\":{\"35\":1}}],[\"code\",{\"1\":{\"34\":2}}],[\"coded\",{\"1\":{\"32\":1}}],[\"condfn\",{\"1\":{\"502\":3}}],[\"concurrent\",{\"1\":{\"412\":1}}],[\"concurrency\",{\"1\":{\"212\":1}}],[\"conf\",{\"1\":{\"308\":4,\"310\":1}}],[\"conforms\",{\"1\":{\"12\":1}}],[\"container字段指示的是每个链表结点所持有的数据类型是什么\",{\"1\":{\"300\":1}}],[\"container\",{\"1\":{\"300\":2}}],[\"contains\",{\"1\":{\"299\":1}}],[\"contain\",{\"1\":{\"296\":1}}],[\"control\",{\"1\":{\"212\":1,\"262\":1}}],[\"contents中以int32\",{\"1\":{\"298\":1}}],[\"contents中以int16\",{\"1\":{\"298\":1}}],[\"contents指向实际存储数值的连续内存区域\",{\"1\":{\"298\":1}}],[\"contents\",{\"1\":{\"298\":1}}],[\"contentlength\",{\"1\":{\"12\":1}}],[\"context\",{\"1\":{\"12\":12,\"424\":5,\"502\":4}}],[\"continue\",{\"1\":{\"12\":2,\"346\":2}}],[\"construct\",{\"1\":{\"264\":1}}],[\"constants\",{\"1\":{\"262\":1}}],[\"const\",{\"1\":{\"12\":1,\"195\":1,\"294\":2,\"296\":6,\"300\":2,\"386\":1,\"436\":2}}],[\"connectmethod\",{\"1\":{\"502\":2}}],[\"connect\",{\"1\":{\"317\":1}}],[\"connected\",{\"1\":{\"224\":1}}],[\"connector\",{\"1\":{\"187\":1}}],[\"connections\",{\"1\":{\"237\":1,\"502\":2}}],[\"connection\",{\"1\":{\"12\":1,\"317\":1}}],[\"connreader\",{\"1\":{\"12\":1}}],[\"conn\",{\"1\":{\"12\":4}}],[\"conncontext\",{\"1\":{\"12\":2}}],[\"connctx\",{\"1\":{\"12\":5}}],[\"calc\",{\"1\":{\"410\":5}}],[\"calls\",{\"1\":{\"502\":1}}],[\"caller\",{\"1\":{\"502\":1}}],[\"callerpc\",{\"1\":{\"483\":1}}],[\"called\",{\"1\":{\"296\":1}}],[\"callable\",{\"1\":{\"262\":1}}],[\"call\",{\"1\":{\"33\":1,\"35\":2,\"36\":1,\"296\":1,\"401\":2,\"405\":2,\"490\":2,\"502\":1}}],[\"caching\",{\"1\":{\"288\":1}}],[\"caches\",{\"1\":{\"502\":1}}],[\"cache\",{\"1\":{\"36\":1,\"236\":2,\"237\":1,\"288\":2},\"2\":{\"290\":1}}],[\"catch\",{\"1\":{\"262\":1}}],[\"cardinality\",{\"1\":{\"252\":1}}],[\"cascade\",{\"1\":{\"299\":1}}],[\"cas\",{\"1\":{\"212\":1,\"407\":1}}],[\"case结构用于做多种类型的探测\",{\"1\":{\"48\":1}}],[\"case\",{\"1\":{\"7\":4,\"8\":4,\"48\":3,\"366\":2,\"386\":11,\"392\":1,\"409\":2,\"418\":1,\"424\":2,\"428\":1,\"502\":6}}],[\"capacity\",{\"1\":{\"502\":1}}],[\"cap为4的int类型切片\",{\"1\":{\"63\":1}}],[\"cap\",{\"1\":{\"63\":5,\"489\":1,\"496\":1,\"502\":1}}],[\"canceled\",{\"1\":{\"502\":1}}],[\"cancelrequest\",{\"1\":{\"502\":2}}],[\"cancelation\",{\"1\":{\"502\":1}}],[\"cancel\",{\"1\":{\"424\":2,\"502\":1}}],[\"cancelctx\",{\"1\":{\"12\":5}}],[\"cannot\",{\"1\":{\"12\":1}}],[\"canwritecontinue\",{\"1\":{\"12\":1}}],[\"can\",{\"1\":{\"12\":2,\"33\":1,\"296\":4,\"299\":2,\"300\":1,\"490\":2}}],[\"cc\",{\"1\":{\"12\":3}}],[\"ctxt\",{\"1\":{\"32\":3}}],[\"ctx\",{\"1\":{\"12\":9,\"424\":4,\"502\":1}}],[\"c\",{\"0\":{\"459\":1,\"461\":1,\"462\":1},\"1\":{\"12\":60,\"33\":1,\"230\":1,\"244\":1,\"262\":1,\"339\":1,\"342\":1,\"421\":3,\"424\":1,\"428\":1,\"431\":6,\"436\":2,\"438\":1,\"445\":5,\"446\":3,\"447\":1,\"448\":1,\"449\":1,\"450\":1,\"451\":3,\"452\":1,\"453\":1,\"454\":4,\"465\":1,\"480\":3,\"483\":4,\"484\":11,\"490\":4,\"502\":5,\"507\":1}}],[\"chain\",{\"1\":{\"445\":9}}],[\"char\",{\"1\":{\"176\":1,\"294\":13,\"299\":10,\"300\":5}}],[\"charset=utf8\",{\"1\":{\"145\":1,\"234\":1}}],[\"chanrecv\",{\"1\":{\"484\":1}}],[\"chansend\",{\"1\":{\"483\":1}}],[\"changed\",{\"1\":{\"299\":3}}],[\"changebuffer跟普通数据页一样也是存在磁盘里\",{\"1\":{\"251\":1}}],[\"change\",{\"0\":{\"251\":1},\"1\":{\"238\":1,\"250\":3,\"251\":1,\"299\":2}}],[\"chan不可被关闭\",{\"1\":{\"6\":1}}],[\"chan<\",{\"1\":{\"6\":1}}],[\"chan进行send\",{\"1\":{\"2\":1}}],[\"chan\",{\"0\":{\"480\":1,\"481\":1,\"483\":1,\"484\":1},\"1\":{\"2\":4,\"3\":4,\"4\":4,\"5\":1,\"6\":5,\"7\":2,\"8\":2,\"53\":3,\"366\":2,\"395\":1,\"397\":3,\"398\":1,\"400\":1,\"409\":8,\"413\":2,\"418\":1,\"421\":1,\"431\":5,\"437\":1,\"451\":3,\"452\":1,\"454\":1,\"477\":1,\"478\":6,\"480\":1,\"481\":3,\"483\":1,\"484\":1}}],[\"channel的实现只能保证这个map在并发读写的时候不会panic\",{\"1\":{\"53\":1}}],[\"channel的两种分类\",{\"0\":{\"3\":1}}],[\"channel实现并发安全的map\",{\"0\":{\"53\":1}}],[\"channel等等\",{\"1\":{\"42\":1}}],[\"channel中send数据的操作ch\",{\"1\":{\"4\":1}}],[\"channel中按序receive其中数据\",{\"1\":{\"3\":1}}],[\"channel不会返回ok消息\",{\"1\":{\"3\":1}}],[\"channel不会向sender返回ok\",{\"1\":{\"3\":1}}],[\"channel都会向其返回ok消息\",{\"1\":{\"3\":1}}],[\"channel都会向sender的请求直接返回一个ok消息\",{\"1\":{\"3\":1}}],[\"channel才会向sender和receiver双方发送ok消息\",{\"1\":{\"3\":1}}],[\"channel暂时不会向sender的请求返回ok消息\",{\"1\":{\"3\":1}}],[\"channel可以认为是容量为0的buffered\",{\"1\":{\"3\":1}}],[\"channel分为两种\",{\"1\":{\"3\":1}}],[\"channel是golang在语言层面提供的goroutine间的通信方式\",{\"1\":{\"1\":1}}],[\"channel\",{\"0\":{\"1\":1,\"451\":1,\"452\":1},\"1\":{\"1\":3,\"3\":8,\"366\":3,\"395\":1,\"401\":2,\"413\":1,\"418\":3,\"421\":1,\"478\":1,\"480\":2,\"483\":2,\"489\":2},\"2\":{\"10\":1}}],[\"ch代表chan\",{\"1\":{\"53\":1}}],[\"checksum等\",{\"1\":{\"203\":1}}],[\"check\",{\"1\":{\"48\":1,\"173\":1,\"296\":1,\"325\":1}}],[\"checkdead\",{\"1\":{\"36\":1}}],[\"checkconnerrorwriter\",{\"1\":{\"12\":1}}],[\"ch也是在main\",{\"1\":{\"4\":1}}],[\"ch<\",{\"1\":{\"3\":1}}],[\"ch2读数据\",{\"1\":{\"7\":1}}],[\"ch2\",{\"1\":{\"3\":1,\"7\":8}}],[\"ch1\",{\"1\":{\"3\":1,\"7\":8}}],[\"ch\",{\"1\":{\"2\":3,\"3\":10,\"4\":9,\"5\":4,\"6\":9,\"8\":8,\"53\":10,\"395\":4,\"400\":3,\"413\":4,\"421\":4,\"431\":4,\"437\":4,\"451\":6,\"452\":4,\"462\":1,\"463\":1}}],[\"读goroutine\",{\"1\":{\"503\":1}}],[\"读完数据抛出\",{\"1\":{\"502\":1}}],[\"读chan的协程结束\",{\"1\":{\"481\":6}}],[\"读已经关闭的\",{\"0\":{\"481\":1},\"1\":{\"478\":1}}],[\"读已提交\",{\"1\":{\"95\":1}}],[\"读库+更新缓存\",{\"1\":{\"288\":1}}],[\"读数据比写数据快\",{\"1\":{\"288\":1}}],[\"读操作回源取数据\",{\"1\":{\"288\":1}}],[\"读操作\",{\"1\":{\"287\":2,\"288\":1}}],[\"读提交\",{\"1\":{\"245\":1}}],[\"读视图\",{\"1\":{\"215\":2}}],[\"读取一个key\",{\"1\":{\"421\":1}}],[\"读取数据时\",{\"1\":{\"288\":1}}],[\"读取数据到内存\",{\"1\":{\"179\":1}}],[\"读取的是当前版本\",{\"1\":{\"214\":1}}],[\"读取的只是当前事务的可见版本\",{\"1\":{\"214\":1}}],[\"读取主库传过来的binlog内容并写入到relay\",{\"1\":{\"117\":1,\"192\":1}}],[\"读取同一条记录\",{\"1\":{\"96\":1}}],[\"读取请求内容\",{\"1\":{\"12\":1}}],[\"读未提交\",{\"1\":{\"95\":1,\"245\":1}}],[\"读写都是阻塞的\",{\"1\":{\"418\":1}}],[\"读写都用一台服务器\",{\"1\":{\"328\":1}}],[\"读写i\",{\"1\":{\"288\":1}}],[\"读写并发的场景下先删缓存操作可能导致脏数据入缓存\",{\"1\":{\"287\":1}}],[\"读写分离常见方案\",{\"0\":{\"191\":1}}],[\"读写分离\",{\"1\":{\"82\":1,\"120\":1,\"129\":1}}],[\"读写锁当有一个协程在等待写锁时\",{\"1\":{\"457\":1}}],[\"读写锁常被用于读多写少的场景\",{\"1\":{\"58\":1}}],[\"读写锁允许有多个读锁和一个写锁\",{\"1\":{\"58\":1}}],[\"读者看到这张图的时候可能会蒙\",{\"1\":{\"72\":1}}],[\"读者可能猜想到应该还有一个局部运行队列\",{\"1\":{\"29\":1}}],[\"读和读却是冲突的\",{\"1\":{\"58\":1}}],[\"读多写少\",{\"1\":{\"58\":1}}],[\"读锁又被称为共享锁\",{\"1\":{\"223\":1}}],[\"读锁才会继续执行\",{\"1\":{\"58\":1}}],[\"读锁解锁\",{\"1\":{\"58\":1}}],[\"读锁可以加载多个\",{\"1\":{\"58\":1}}],[\"读锁\",{\"1\":{\"58\":1}}],[\"读锁需要等待写锁释放的信号量\",{\"1\":{\"58\":1}}],[\"读\",{\"1\":{\"2\":1}}],[\"写已经关闭的\",{\"0\":{\"480\":1},\"1\":{\"478\":1}}],[\"写和读都会阻塞\",{\"1\":{\"462\":1}}],[\"写代码实现两个\",{\"1\":{\"418\":1}}],[\"写出以下代码的问题\",{\"0\":{\"440\":1}}],[\"写出以下代码出现的问题\",{\"0\":{\"435\":1}}],[\"写出以下打印结果\",{\"0\":{\"438\":1,\"439\":1}}],[\"写出以下打印内容\",{\"0\":{\"436\":1}}],[\"写出以下逻辑\",{\"0\":{\"428\":1}}],[\"写出下面代码输出内容\",{\"0\":{\"405\":1}}],[\"写出打印的结果\",{\"0\":{\"393\":1}}],[\"写数据\",{\"1\":{\"317\":1}}],[\"写数据时\",{\"1\":{\"288\":1}}],[\"写操作\",{\"1\":{\"287\":3,\"288\":1}}],[\"写缓存\",{\"1\":{\"287\":1,\"288\":1}}],[\"写的效率差一些\",{\"1\":{\"87\":1}}],[\"写锁被称为排它锁\",{\"1\":{\"223\":1}}],[\"写锁解锁\",{\"1\":{\"58\":1}}],[\"写锁\",{\"1\":{\"58\":1}}],[\"写锁需要等待读锁释放的信号量\",{\"1\":{\"58\":1}}],[\"写\",{\"1\":{\"2\":1}}],[\"对已经关闭的的\",{\"1\":{\"477\":1}}],[\"对已经关闭的的chan进行读写\",{\"0\":{\"476\":1}}],[\"对比lru与lfu的差别\",{\"1\":{\"347\":1}}],[\"对比图2和图1\",{\"1\":{\"346\":1}}],[\"对比主节点和从节点的差异\",{\"1\":{\"323\":1}}],[\"对库存的判断出现了问题\",{\"1\":{\"269\":1}}],[\"对代码的修改建议\",{\"1\":{\"262\":1}}],[\"对当前列做索引\",{\"1\":{\"253\":1}}],[\"对数据表进行相关重建\",{\"1\":{\"255\":1}}],[\"对数据的修改记录在changebuffer里的时候\",{\"1\":{\"251\":1}}],[\"对数据加上排他锁\",{\"1\":{\"157\":1}}],[\"对数据加上共享锁\",{\"1\":{\"157\":1}}],[\"对优化mysql查询至关重要\",{\"1\":{\"224\":1}}],[\"对慢查询都怎么优化过\",{\"0\":{\"182\":1}}],[\"对两个结果集进行并集操作\",{\"1\":{\"178\":2}}],[\"对单表或多表的增删改查\",{\"1\":{\"169\":1}}],[\"对视图内容的更新\",{\"1\":{\"164\":1}}],[\"对文本的内容进行分词\",{\"1\":{\"143\":1}}],[\"对索引中包含的字段先做判断\",{\"1\":{\"127\":1}}],[\"对索引列运算\",{\"1\":{\"78\":1}}],[\"对安全性的要求比从服务器要高\",{\"1\":{\"119\":1}}],[\"对应的该字段的值是2\",{\"1\":{\"300\":1}}],[\"对应的value是string类型\",{\"1\":{\"292\":1}}],[\"对应的sql语句为select\",{\"1\":{\"72\":2}}],[\"对应的是一个匿名函数\",{\"1\":{\"53\":1}}],[\"对同一个map下的key进行并发读写\",{\"1\":{\"52\":1}}],[\"对\",{\"1\":{\"44\":2}}],[\"对chan进行了nil赋值\",{\"1\":{\"7\":1}}],[\"对于上图有四个关键点补充一下\",{\"1\":{\"356\":1}}],[\"对于增量追加到文件这一步主要的流程是\",{\"1\":{\"356\":1}}],[\"对于使用者来说\",{\"1\":{\"300\":1}}],[\"对于一些特定场合使用的键数据\",{\"1\":{\"296\":1}}],[\"对于每一种value\",{\"1\":{\"292\":1}}],[\"对于每个用户的秒杀\",{\"1\":{\"268\":1}}],[\"对于redis的使用者来说\",{\"1\":{\"292\":2}}],[\"对于recv来说\",{\"1\":{\"6\":1}}],[\"对于receiver也一样\",{\"1\":{\"3\":1}}],[\"对于读多写少业务\",{\"1\":{\"268\":1}}],[\"对于特殊的字符可以采用倒序的方法创建索引\",{\"1\":{\"253\":1}}],[\"对于innodb来说最重要的两个配置为\",{\"1\":{\"237\":1}}],[\"对于引擎是myisam的数据表在迁移或转入大量数据的时候\",{\"1\":{\"225\":1}}],[\"对于第四条小亮的也是一样判断\",{\"1\":{\"219\":1}}],[\"对于非常容易产生死锁的业务部分\",{\"1\":{\"159\":1}}],[\"对于非接口类型\",{\"1\":{\"46\":1}}],[\"对于定义为text\",{\"1\":{\"144\":1}}],[\"对于叶子节点中的x\",{\"1\":{\"72\":1}}],[\"对于这个时候的事务c的select结果是没有影响的\",{\"1\":{\"219\":1}}],[\"对于这个结构体我们添加了三个方法\",{\"1\":{\"52\":1}}],[\"对于这一次的选择\",{\"1\":{\"7\":1}}],[\"对于指针类型的实例p1\",{\"1\":{\"43\":1}}],[\"对于buffered\",{\"1\":{\"3\":1}}],[\"对于unbuffered\",{\"1\":{\"3\":1}}],[\"对nil\",{\"1\":{\"2\":1}}],[\"对象也需要阻塞的读\",{\"1\":{\"431\":1}}],[\"对象的\",{\"1\":{\"431\":1}}],[\"对象上打上一个标志\",{\"1\":{\"401\":1}}],[\"对象\",{\"1\":{\"1\":1}}],[\"=make\",{\"1\":{\"481\":1}}],[\"=>同步到aof磁盘\",{\"1\":{\"356\":1}}],[\"=>\",{\"1\":{\"262\":4}}],[\"==\",{\"1\":{\"12\":6,\"35\":1,\"37\":1,\"41\":1,\"219\":1,\"296\":10,\"297\":5,\"298\":2,\"299\":8,\"346\":10,\"370\":1,\"382\":1,\"386\":13,\"407\":1,\"414\":1,\"415\":1,\"435\":1,\"439\":2,\"440\":2,\"448\":2,\"484\":2,\"502\":2}}],[\"=\",{\"1\":{\"2\":1,\"3\":7,\"4\":3,\"5\":4,\"6\":8,\"7\":9,\"8\":7,\"12\":55,\"19\":1,\"28\":2,\"29\":4,\"33\":1,\"37\":1,\"41\":7,\"42\":1,\"43\":2,\"44\":2,\"45\":3,\"47\":5,\"48\":9,\"52\":7,\"53\":10,\"57\":1,\"58\":5,\"63\":14,\"78\":1,\"112\":3,\"119\":1,\"158\":1,\"206\":2,\"214\":2,\"218\":10,\"219\":41,\"230\":2,\"234\":3,\"238\":3,\"262\":7,\"264\":4,\"268\":1,\"294\":4,\"296\":32,\"297\":13,\"299\":41,\"326\":1,\"346\":7,\"366\":4,\"370\":15,\"374\":4,\"378\":5,\"382\":2,\"386\":19,\"391\":2,\"392\":2,\"393\":3,\"394\":1,\"395\":3,\"396\":1,\"397\":6,\"398\":3,\"399\":2,\"400\":4,\"401\":1,\"406\":4,\"407\":10,\"408\":1,\"409\":4,\"410\":5,\"411\":2,\"412\":2,\"413\":2,\"414\":4,\"418\":4,\"421\":5,\"424\":19,\"428\":3,\"431\":7,\"435\":2,\"436\":5,\"437\":4,\"438\":5,\"441\":4,\"445\":4,\"448\":1,\"449\":1,\"450\":4,\"451\":2,\"454\":2,\"469\":1,\"480\":1,\"481\":11,\"483\":2,\"484\":5,\"490\":5,\"496\":3,\"500\":4,\"502\":26,\"507\":1}}],[\"声明如下\",{\"1\":{\"42\":1}}],[\"声明一个空接口实例\",{\"1\":{\"47\":1}}],[\"声明一个map类型的变量\",{\"1\":{\"41\":2}}],[\"声明一个chan\",{\"1\":{\"2\":1}}],[\"声明和创建\",{\"0\":{\"2\":1}}],[\"的用法\",{\"0\":{\"506\":1}}],[\"的用户都非常值得掌握的一个方法\",{\"1\":{\"333\":1}}],[\"的作用是根据需要建立网络连接并缓存它们以供后续调用重用\",{\"1\":{\"502\":1}}],[\"的地址强转成\",{\"1\":{\"496\":1}}],[\"的情况\",{\"1\":{\"490\":1}}],[\"的情况下\",{\"1\":{\"374\":1,\"500\":1}}],[\"的背后存储都逃逸掉\",{\"1\":{\"489\":1}}],[\"的背后数组被重新分配了\",{\"1\":{\"489\":1}}],[\"的元素\",{\"1\":{\"438\":1}}],[\"的元素对应的是\",{\"1\":{\"438\":1}}],[\"的第三个元素呢\",{\"1\":{\"438\":1}}],[\"的指针\",{\"1\":{\"414\":1}}],[\"的方法\",{\"1\":{\"408\":1}}],[\"的方式\",{\"1\":{\"342\":1}}],[\"的方式做类型探测在探测类型数量多时不是很方便\",{\"1\":{\"48\":1}}],[\"的方式将接口实例ins直接转回type类型的实例\",{\"1\":{\"48\":1}}],[\"的方式来构造struct实例\",{\"1\":{\"42\":1}}],[\"的限制\",{\"1\":{\"397\":1}}],[\"的参数数值太大\",{\"1\":{\"397\":1}}],[\"的调度时间是不确定的\",{\"1\":{\"395\":1}}],[\"的语法\",{\"1\":{\"393\":1}}],[\"的评价标准最终形成对键重要性的评判\",{\"1\":{\"347\":1}}],[\"的内容时会执行\",{\"1\":{\"502\":1}}],[\"的内容\",{\"1\":{\"342\":1}}],[\"的内存数据进行各种分析了\",{\"1\":{\"340\":1}}],[\"的内连接\",{\"0\":{\"135\":1}}],[\"的解析\",{\"1\":{\"335\":1}}],[\"的定义后本身没有初始化值\",{\"1\":{\"415\":1}}],[\"的定义为32\",{\"1\":{\"297\":1}}],[\"的定时任务还是在时间堆中等待触发\",{\"1\":{\"8\":1}}],[\"的长度都大\",{\"1\":{\"297\":1}}],[\"的长度为32\",{\"1\":{\"297\":1}}],[\"的值和切片b\",{\"1\":{\"489\":1}}],[\"的值\",{\"1\":{\"294\":1}}],[\"的桥梁的\",{\"1\":{\"292\":1}}],[\"的维护缓存信息\",{\"1\":{\"275\":1}}],[\"的存储的例子\",{\"1\":{\"264\":1}}],[\"的存储空间为\",{\"1\":{\"193\":2}}],[\"的当前值\",{\"1\":{\"262\":1}}],[\"的写入拆成了两个步骤\",{\"1\":{\"244\":1}}],[\"的字段\",{\"1\":{\"243\":1}}],[\"的字段默认不为空\",{\"1\":{\"193\":1}}],[\"的路径和文件名\",{\"1\":{\"238\":1}}],[\"的结果为\",{\"1\":{\"219\":1}}],[\"的小张记录发现可见并返回\",{\"1\":{\"219\":1}}],[\"的三个属性应该是\",{\"1\":{\"218\":1}}],[\"的都知道\",{\"1\":{\"218\":1}}],[\"的非常重要的部分\",{\"1\":{\"215\":1}}],[\"的两种读形式\",{\"0\":{\"214\":1},\"1\":{\"214\":1}}],[\"的两级线程模型\",{\"1\":{\"28\":1}}],[\"的概念\",{\"1\":{\"212\":1}}],[\"的修改\",{\"1\":{\"199\":1}}],[\"的文件系统缓存里面\",{\"1\":{\"198\":1}}],[\"的默认值为\",{\"1\":{\"193\":1}}],[\"的时间范围是\",{\"1\":{\"193\":1}}],[\"的时候会溢出\",{\"1\":{\"401\":1}}],[\"的时候会直接调用\",{\"1\":{\"394\":1}}],[\"的时候会创建一个\",{\"1\":{\"215\":1}}],[\"的时候产生的\",{\"1\":{\"215\":1}}],[\"的时候\",{\"1\":{\"63\":1}}],[\"的日期范围是\",{\"1\":{\"193\":1}}],[\"的计数\",{\"1\":{\"167\":1}}],[\"的区别\",{\"0\":{\"167\":1,\"176\":1}}],[\"的基础架构图\",{\"0\":{\"136\":1}}],[\"的话可以起到优化的作用\",{\"1\":{\"134\":1}}],[\"的执行\",{\"1\":{\"405\":1,\"465\":1}}],[\"的执行权\",{\"1\":{\"401\":1}}],[\"的执行计划\",{\"1\":{\"103\":1}}],[\"的执行频率\",{\"1\":{\"103\":1}}],[\"的记录\",{\"1\":{\"98\":1}}],[\"的容量是要\",{\"1\":{\"63\":1}}],[\"的场景\",{\"1\":{\"58\":1}}],[\"的\",{\"1\":{\"44\":2,\"199\":1,\"215\":1,\"274\":1,\"395\":1,\"401\":1,\"406\":1,\"408\":1,\"421\":1,\"435\":1,\"502\":2}}],[\"的底层会调用new\",{\"1\":{\"42\":1}}],[\"的问题\",{\"1\":{\"27\":1}}],[\"的副本\",{\"1\":{\"19\":1}}],[\"的实现原理\",{\"0\":{\"215\":1}}],[\"的实现原理之前\",{\"1\":{\"214\":1}}],[\"的实现形式\",{\"1\":{\"213\":2}}],[\"的实现方式\",{\"1\":{\"212\":1}}],[\"的实现\",{\"1\":{\"12\":1}}],[\"的组合会导致内存泄露\",{\"1\":{\"8\":1}}],[\"的性能开销很小\",{\"1\":{\"1\":1}}],[\"的发送方和接受方是\",{\"1\":{\"1\":1}}],[\"是body在执行read方法\",{\"1\":{\"502\":1}}],[\"是干嘛的呢\",{\"1\":{\"502\":1}}],[\"是切片在go的底层结构\",{\"1\":{\"496\":1}}],[\"是字符串在go的底层结构\",{\"1\":{\"496\":1}}],[\"是没有办法知道哪个\",{\"1\":{\"489\":1}}],[\"是互斥锁\",{\"1\":{\"456\":1}}],[\"是从数组的第二个元素开始\",{\"1\":{\"438\":1}}],[\"是非缓冲的\",{\"1\":{\"437\":1}}],[\"是启动了一个协程每分钟检查一下map中的过期ip\",{\"1\":{\"424\":1}}],[\"是两种类型\",{\"1\":{\"414\":1}}],[\"是无缓冲的\",{\"1\":{\"413\":1}}],[\"是私有的\",{\"1\":{\"393\":1}}],[\"是折中方案\",{\"1\":{\"353\":1}}],[\"是为了保护持久化的数据一致性问题\",{\"1\":{\"352\":1}}],[\"是为所谓的buf\",{\"1\":{\"294\":1}}],[\"是每一个\",{\"1\":{\"333\":1}}],[\"是由40个随机的十六进制字符串组成\",{\"1\":{\"321\":1}}],[\"是由参数repl\",{\"1\":{\"319\":1}}],[\"是反复同步数据\",{\"1\":{\"314\":1}}],[\"是master给slave同步数据的过程\",{\"1\":{\"314\":1}}],[\"是mysql秒级创建视图的必要条件\",{\"1\":{\"215\":1}}],[\"是mysql用来分析当前会话sql语句执行的资源消耗情况\",{\"1\":{\"130\":1}}],[\"是持久化之外的另一种方式\",{\"1\":{\"307\":1}}],[\"是因为\",{\"1\":{\"299\":1}}],[\"是因为在mysql的innodb存储引擎中\",{\"1\":{\"70\":1}}],[\"是直接存储在v字段中的\",{\"1\":{\"296\":1}}],[\"是有序的\",{\"1\":{\"276\":1}}],[\"是有索引键的列\",{\"1\":{\"158\":1}}],[\"是redis中最基本的数据类型\",{\"1\":{\"274\":1}}],[\"是的\",{\"1\":{\"259\":1}}],[\"是可以追加写入的\",{\"1\":{\"244\":1}}],[\"是循环写的\",{\"1\":{\"244\":1}}],[\"是逻辑日志\",{\"1\":{\"244\":1}}],[\"是物理日志\",{\"1\":{\"244\":1}}],[\"是通过dictentry这个结构间接持有的\",{\"1\":{\"296\":1}}],[\"是通过\",{\"1\":{\"219\":1}}],[\"是如何做到的\",{\"1\":{\"218\":1}}],[\"是\",{\"1\":{\"215\":1,\"218\":1,\"415\":1}}],[\"是什么\",{\"0\":{\"211\":1}}],[\"是否读成功\",{\"1\":{\"478\":1}}],[\"是否全都不同\",{\"1\":{\"370\":1}}],[\"是否开启aof\",{\"1\":{\"353\":1}}],[\"是否压缩\",{\"1\":{\"352\":1}}],[\"是否压缩quicklist中的每个ziplist实例是一个可配置项\",{\"1\":{\"300\":1}}],[\"是否可进一步解决此问题\",{\"1\":{\"288\":1}}],[\"是否可拆表等\",{\"1\":{\"129\":1}}],[\"是否能够正常工作\",{\"1\":{\"266\":1}}],[\"是否能够将请求均匀的发送给后端\",{\"1\":{\"266\":1}}],[\"是否能落到同一台机器\",{\"1\":{\"266\":1}}],[\"是否只读\",{\"1\":{\"237\":1}}],[\"是否在\",{\"1\":{\"218\":1}}],[\"是否在活跃事务的数组中\",{\"1\":{\"215\":1}}],[\"是否小于\",{\"1\":{\"218\":1}}],[\"是否被删除\",{\"1\":{\"217\":1}}],[\"是否\",{\"1\":{\"215\":1}}],[\"是否是\",{\"1\":{\"215\":1}}],[\"是否删除字段\",{\"1\":{\"215\":1}}],[\"是否命中索引等\",{\"1\":{\"182\":1}}],[\"是否加载了不必要的字段\",{\"1\":{\"182\":1}}],[\"是最小超键\",{\"1\":{\"172\":1}}],[\"是表的抽象和在逻辑意义上建立的新关系\",{\"1\":{\"164\":1}}],[\"是数据库管理系统执行过程中的一个逻辑单位\",{\"1\":{\"154\":1}}],[\"是目前搜索引擎使用的一种关键技术\",{\"1\":{\"143\":1}}],[\"是以\",{\"1\":{\"116\":1}}],[\"是基于\",{\"1\":{\"116\":2}}],[\"是使用\",{\"1\":{\"107\":1,\"194\":1}}],[\"是线程安全的\",{\"1\":{\"57\":1}}],[\"是一款轻型的数据库\",{\"1\":{\"340\":1}}],[\"是一块连续空间的顺序表\",{\"1\":{\"296\":1}}],[\"是一种灵活地\",{\"1\":{\"63\":1}}],[\"是一种类型\",{\"1\":{\"45\":1}}],[\"是一个\",{\"1\":{\"335\":1}}],[\"是一个mapmap\",{\"1\":{\"275\":1}}],[\"是一个表中的数据经过某种筛选后的显示方式\",{\"1\":{\"162\":1}}],[\"是一个不可分割的工作单位\",{\"1\":{\"154\":1}}],[\"是一个合格的servemux了\",{\"1\":{\"12\":1}}],[\"是一个通道\",{\"1\":{\"1\":1}}],[\"是不对用户公开的\",{\"1\":{\"292\":1}}],[\"是不能比较的\",{\"1\":{\"44\":1}}],[\"是不会被\",{\"1\":{\"8\":1}}],[\"是指\",{\"1\":{\"244\":1,\"484\":1}}],[\"是指程序代码按照一定的算法在适当的时候挑选出合适的goroutine并放到cpu上去运行的过程\",{\"1\":{\"28\":1}}],[\"是指m个goroutine运行在n个操作系统线程之上\",{\"1\":{\"28\":1}}],[\"是在换个文件的参数\",{\"1\":{\"260\":1}}],[\"是在第一次快照读的时候确定的\",{\"1\":{\"219\":1}}],[\"是在\",{\"1\":{\"8\":1}}],[\"是在channel中已有一个数据\",{\"1\":{\"3\":1}}],[\"是引用类型\",{\"1\":{\"1\":1}}],[\"是轻量级的协程\",{\"1\":{\"1\":1}}],[\"这了执行了\",{\"1\":{\"502\":1}}],[\"这其实是一道变形的链表反转题\",{\"1\":{\"469\":1}}],[\"这回导致\",{\"1\":{\"438\":1}}],[\"这块能否复制成功还有一个因素就是偏移量\",{\"1\":{\"321\":1}}],[\"这俩个参数表示从节点的数量就剩余2个\",{\"1\":{\"319\":1}}],[\"这张图是详细描述第一次从节点连接主节点时的数据同步过程\",{\"1\":{\"316\":1}}],[\"这张图是使用从节点使用客户端命令行连接主节点后\",{\"1\":{\"310\":1}}],[\"这会导致切片的内容逃逸\",{\"1\":{\"489\":1}}],[\"这会带来cpu的更多消耗\",{\"1\":{\"354\":1}}],[\"这会带来很多的开销\",{\"1\":{\"234\":1}}],[\"这会应该会有很多疑问\",{\"1\":{\"306\":1}}],[\"这代表每次写操作都会进行内存分配操作\",{\"1\":{\"299\":1}}],[\"这意味着redis若运行在ppc这样的大端字节序的机器上时\",{\"1\":{\"298\":1}}],[\"这保证任何一次插入操作都是顺畅的\",{\"1\":{\"296\":1}}],[\"这给了list的使用者相当大的灵活性\",{\"1\":{\"295\":1}}],[\"这五个字节是如何存储的\",{\"1\":{\"292\":1}}],[\"这对于用户来说是不必要了解的\",{\"1\":{\"292\":1}}],[\"这对于redis的使用者来说是不公开的\",{\"1\":{\"292\":1}}],[\"这对于sync\",{\"1\":{\"57\":1}}],[\"这套对调用方是透明的\",{\"1\":{\"288\":1}}],[\"这也体现了工程应用是空间与时间的平衡性\",{\"1\":{\"345\":1}}],[\"这也就是部分复制\",{\"1\":{\"316\":1}}],[\"这也就是为什么索引不在key\",{\"1\":{\"231\":1}}],[\"这也就意味这每台redis服务器都有可能会称为主节点\",{\"1\":{\"305\":1}}],[\"这也是ziplist能存储的二进制数据的最大长度\",{\"1\":{\"299\":1}}],[\"这也是上图中\",{\"1\":{\"297\":1}}],[\"这也是为什么dict结构中有一个iterators字段的原因\",{\"1\":{\"296\":1}}],[\"这也是为什么sds类型即是char\",{\"1\":{\"294\":1}}],[\"这也是缓存系统的引入\",{\"1\":{\"285\":1}}],[\"这一行的\",{\"1\":{\"244\":1}}],[\"这两个因子形成一种平衡\",{\"1\":{\"347\":1}}],[\"这两个记录被双双刷新了\",{\"1\":{\"300\":1}}],[\"这两个是同源域名\",{\"1\":{\"265\":1}}],[\"这两条记录\",{\"1\":{\"218\":2}}],[\"这两种类型被mysql实现为同样的类型\",{\"1\":{\"132\":1}}],[\"这两者有什么区别呢\",{\"1\":{\"53\":1}}],[\"这种方式仅限于少量数据\",{\"1\":{\"328\":1}}],[\"这种方式配置也是很简单\",{\"1\":{\"311\":1}}],[\"这种代码的特点就是\",{\"1\":{\"299\":1}}],[\"这种平滑扩容的优点有两个\",{\"1\":{\"296\":1}}],[\"这种问题出现概率极低\",{\"1\":{\"288\":1}}],[\"这种锁是一种\",{\"1\":{\"212\":1}}],[\"这种情况就需要跟应用一起来分析为何连接数会激增\",{\"1\":{\"190\":1}}],[\"这种索引叫做组合索引\",{\"1\":{\"153\":1}}],[\"这种索引叫做复合索引\",{\"1\":{\"111\":1}}],[\"这种通过二级索引查询出来的过程\",{\"1\":{\"149\":1}}],[\"这种以主键作为b+树索引的键值而构建的b+树索引\",{\"1\":{\"71\":1}}],[\"这点非常重要\",{\"1\":{\"103\":1}}],[\"这点精妙之处在于\",{\"1\":{\"22\":1}}],[\"这就解释了上面代码为什么关闭的\",{\"1\":{\"484\":1}}],[\"这就解释了上面代码为什么关闭的chan\",{\"1\":{\"484\":1}}],[\"这就导致了主从不一致\",{\"1\":{\"118\":1}}],[\"这就要看是不是用了索引\",{\"1\":{\"105\":1}}],[\"这就是为什么代码明明不规范但却看不到明显内存泄漏的原因\",{\"1\":{\"503\":1}}],[\"这就是为什么一次http\",{\"1\":{\"502\":1}}],[\"这就是一个双链表的定义\",{\"1\":{\"300\":1}}],[\"这就是\",{\"1\":{\"244\":1}}],[\"这就是聚簇索引和非聚簇索引\",{\"1\":{\"150\":1}}],[\"这就是in和exists的区别\",{\"1\":{\"112\":1}}],[\"这就是最左匹配原则\",{\"1\":{\"111\":1,\"147\":1}}],[\"这就是幻读\",{\"1\":{\"96\":1}}],[\"这就是不可重复读\",{\"1\":{\"96\":1}}],[\"这就是脏读\",{\"1\":{\"96\":1}}],[\"这就会导致严重的内存泄漏\",{\"1\":{\"8\":1}}],[\"这是上面提到的\",{\"1\":{\"490\":1}}],[\"这是当备份进程出错时\",{\"1\":{\"352\":1}}],[\"这是原版跳跃表中所没有的\",{\"1\":{\"297\":1}}],[\"这是普通的链表实现\",{\"1\":{\"295\":1}}],[\"这是一道很简单的golang基础题目\",{\"1\":{\"418\":1}}],[\"这是一种\",{\"1\":{\"300\":1}}],[\"这是一种用于存储二进制数据的一种结构\",{\"1\":{\"294\":1}}],[\"这是一个重量级操作\",{\"1\":{\"358\":1}}],[\"这是一个用于存储在序的整数的数据结构\",{\"1\":{\"298\":1}}],[\"这是一个平平无奇的链表的实现\",{\"1\":{\"295\":1}}],[\"这是一个很低级的api\",{\"1\":{\"294\":1}}],[\"这是因为切片\",{\"1\":{\"438\":1}}],[\"这是因为delete\",{\"1\":{\"255\":1}}],[\"这是因为innodb是把数据存放在b+树中的\",{\"1\":{\"71\":1}}],[\"这是我们分析的重点\",{\"1\":{\"218\":1}}],[\"这是啥东西啊\",{\"1\":{\"72\":1}}],[\"这是个零切片\",{\"1\":{\"63\":1}}],[\"这是比较方便的语法\",{\"1\":{\"48\":1}}],[\"这40个临界区是随机被访问的\",{\"1\":{\"57\":1}}],[\"这时候\",{\"1\":{\"215\":1}}],[\"这时候可以使用反射方法\",{\"1\":{\"44\":1}}],[\"这时需要类型断言\",{\"1\":{\"48\":1}}],[\"这时称为匿名字段\",{\"1\":{\"42\":1}}],[\"这时将会出现死锁问题\",{\"1\":{\"4\":1}}],[\"这几种称呼都是对同一种数据结构的不同称呼\",{\"1\":{\"41\":1}}],[\"这些任务可能会阻塞主进程导致redis性能下降\",{\"1\":{\"354\":1}}],[\"这些value的类型\",{\"1\":{\"292\":1}}],[\"这些sql语句代码像一个方法一样实现一些功能\",{\"1\":{\"169\":1}}],[\"这些操作要么全部执行\",{\"1\":{\"154\":1}}],[\"这些权限表分别user\",{\"1\":{\"139\":1}}],[\"这些全变量都会被初始化为0值\",{\"1\":{\"37\":1}}],[\"这些结构体的定义全部位于go语言的源代码路径下的runtime\",{\"1\":{\"30\":1}}],[\"这些负责对goroutine进行调度的程序代码我们称之为goroutine调度器\",{\"1\":{\"28\":1}}],[\"这完美的解决我们的问题\",{\"1\":{\"29\":1}}],[\"这不正是我们所需要的吗\",{\"1\":{\"29\":1}}],[\"这大大减少了锁冲突\",{\"1\":{\"29\":1}}],[\"这段伪代码对goroutine的调度代码做了高度的抽象\",{\"1\":{\"28\":1}}],[\"这段伪代码表达的意思是\",{\"1\":{\"28\":1}}],[\"这在多数情况下已经够用了\",{\"1\":{\"27\":1}}],[\"这决定了在某些特殊场景下系统线程栈还是有溢出的风险\",{\"1\":{\"27\":1}}],[\"这导致了浪费\",{\"1\":{\"27\":1}}],[\"这么饥渴\",{\"1\":{\"21\":1}}],[\"这里需要一个类型断言\",{\"1\":{\"508\":1}}],[\"这里需要注意的是每次启动的id都会不一样\",{\"1\":{\"321\":1}}],[\"这里会有一个io\",{\"1\":{\"502\":1}}],[\"这里使用三个值表示机器人当前的状况\",{\"1\":{\"386\":1}}],[\"这里使用了golang内置方法unicode\",{\"1\":{\"382\":1}}],[\"这里还是使用golang内置方法\",{\"1\":{\"378\":1}}],[\"这里规定\",{\"1\":{\"378\":1}}],[\"这里有几个重点\",{\"1\":{\"370\":1}}],[\"这里有俩个参数可以进行配置调整\",{\"1\":{\"319\":1}}],[\"这里用到了两个channel负责通知\",{\"1\":{\"366\":1}}],[\"这里注意的是\",{\"1\":{\"355\":1}}],[\"这里说一下持久化的时间策略具体是什么意思\",{\"1\":{\"352\":1}}],[\"这里只是为了演示\",{\"1\":{\"308\":1}}],[\"这里只根据实际经验给出在不同一致性要求下的建议\",{\"1\":{\"287\":1}}],[\"这里就不贴代码片断了\",{\"1\":{\"300\":1}}],[\"这里就不详细介绍了\",{\"1\":{\"72\":1}}],[\"这里定义了五个结构体\",{\"1\":{\"300\":1}}],[\"这里不展开讲\",{\"1\":{\"296\":1}}],[\"这里不做过多涉及\",{\"1\":{\"212\":1}}],[\"这里也涉及到缓存更新策略问题\",{\"1\":{\"284\":1}}],[\"这里为了一起解释方便\",{\"1\":{\"218\":1}}],[\"这里为了方便我直接写成物理日志\",{\"1\":{\"218\":1}}],[\"这里其实位置无所谓\",{\"1\":{\"215\":1}}],[\"这里我们要求\",{\"1\":{\"370\":1}}],[\"这里我们着重介绍innodb中的聚集索引和非聚集索引\",{\"1\":{\"71\":1}}],[\"这里我们选择的是读写锁\",{\"1\":{\"52\":1}}],[\"这里我们的handler是由gin框架实现的一个servemux\",{\"1\":{\"12\":1}}],[\"这里的一个难点是解析重复指令\",{\"1\":{\"386\":1}}],[\"这里的runid不匹配只有的可能是从节点重启了这个问题后边会解决\",{\"1\":{\"318\":1}}],[\"这里的空不是只空字符串或者0\",{\"1\":{\"167\":1}}],[\"这里的\",{\"1\":{\"28\":1}}],[\"这里涉及到了\",{\"1\":{\"1\":1}}],[\"这样的坏场景下\",{\"1\":{\"299\":1}}],[\"这样支持ziplist反向遍历\",{\"1\":{\"299\":1}}],[\"这样虽然不能保证在迭代过程中插入的结点会被遍历到\",{\"1\":{\"296\":1}}],[\"这样\",{\"1\":{\"296\":1}}],[\"这样计算出的索引值能覆盖到所有bucket索引位\",{\"1\":{\"296\":1}}],[\"这样做的考量是\",{\"1\":{\"294\":1}}],[\"这样做的用意是\",{\"1\":{\"294\":1}}],[\"这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人\",{\"1\":{\"277\":1}}],[\"这样有会有大并发的更新操作\",{\"1\":{\"118\":1}}],[\"这样非常容易管理\",{\"1\":{\"255\":1}}],[\"这样可能比较占用空间\",{\"1\":{\"253\":1}}],[\"这样可以兼顾速度与安全\",{\"1\":{\"353\":1}}],[\"这样可以在查询的时候减少分区的扫描\",{\"1\":{\"234\":1}}],[\"这样可以节省空间且提高检索效率\",{\"1\":{\"186\":1}}],[\"这样才能用到索引\",{\"1\":{\"228\":1}}],[\"这样系统就受不了了\",{\"1\":{\"112\":1}}],[\"这样就可以实现共享session了\",{\"1\":{\"264\":1}}],[\"这样就变成了下面这样\",{\"1\":{\"219\":1}}],[\"这样就只做了两次\",{\"1\":{\"112\":1}}],[\"这样就限制了goruntine的个数\",{\"1\":{\"6\":1}}],[\"这样写就等价于\",{\"1\":{\"112\":1}}],[\"这样写等价于\",{\"1\":{\"112\":1}}],[\"这样它们就可以用来存放任意类型的对象\",{\"1\":{\"47\":1}}],[\"这样在之后的代码中就使用该全局变量来访问自己的m结构体对象以及与m相关联的p和g对象\",{\"1\":{\"29\":1}}],[\"这样每个访客固定访问一个后端服务器\",{\"1\":{\"266\":1}}],[\"这样每个工作线程都可以访问它以及它所拥有的goroutine运行队列\",{\"1\":{\"29\":1}}],[\"这样每次循环的时候就不会对time\",{\"1\":{\"8\":1}}],[\"这样既没有栈溢出的风险\",{\"1\":{\"27\":1}}],[\"这个字段的\",{\"1\":{\"502\":1}}],[\"这个字段中存储的是整个ziplist所占用的内存的字节数\",{\"1\":{\"299\":1}}],[\"这个输出结果决定来自于调度器优先调度哪个g\",{\"1\":{\"407\":1}}],[\"这个等于指令\",{\"1\":{\"386\":1}}],[\"这个题目很好做\",{\"1\":{\"370\":1}}],[\"这个命令是如何完成rdb的持久化的\",{\"1\":{\"355\":1}}],[\"这个配置表示1s内执行10次\",{\"1\":{\"354\":1}}],[\"这个配置也是非常重要的一项配置\",{\"1\":{\"352\":1}}],[\"这个问题在后边集群会说到\",{\"1\":{\"328\":1}}],[\"这个问题直接在客户端维护一个可用节点列表\",{\"1\":{\"328\":1}}],[\"这个问题我们无需考虑\",{\"1\":{\"325\":1}}],[\"这个参数一但设置就只能响应info\",{\"1\":{\"328\":1}}],[\"这个参数默认为60秒\",{\"1\":{\"327\":1}}],[\"这个因素是没有办法避免的\",{\"1\":{\"328\":1}}],[\"这个生成的策略跟runid一样\",{\"1\":{\"325\":1}}],[\"这个偏移量也就是复制偏移量\",{\"1\":{\"322\":1}}],[\"这个比例可以根据自己的服务器内存来修改\",{\"1\":{\"322\":1}}],[\"这个指令可携带偏移量\",{\"1\":{\"319\":1}}],[\"这个指令\",{\"1\":{\"319\":1}}],[\"这个发送的过程称之为心跳机制\",{\"1\":{\"318\":1}}],[\"这个offset为主节点的\",{\"1\":{\"318\":1}}],[\"这个连接做的事情下文会说\",{\"1\":{\"315\":1}}],[\"这个过程就是主从复制最齐全的流程讲解\",{\"1\":{\"318\":1}}],[\"这个过程就是slave跟master连接的过程\",{\"1\":{\"314\":1}}],[\"这个过程称之为命令传播\",{\"1\":{\"317\":1}}],[\"这个过程称为回表\",{\"1\":{\"246\":1}}],[\"这个是从节点的信息\",{\"1\":{\"312\":1}}],[\"这个是主节点的日志信息\",{\"1\":{\"312\":1}}],[\"这个是go中特有的\",{\"1\":{\"6\":1}}],[\"这个图是在从节点执行完slaveof\",{\"1\":{\"310\":1}}],[\"这个结构描述的就是链表中的结点\",{\"1\":{\"300\":1}}],[\"这个结构是redis在3\",{\"1\":{\"300\":1}}],[\"这个值也就是来自己于复制缓冲积压区里边的那个偏移量\",{\"1\":{\"323\":1}}],[\"这个值只占16位\",{\"1\":{\"299\":1}}],[\"这个值会是\",{\"1\":{\"262\":1}}],[\"这个迭代器中有字段safe以标示该迭代器是\",{\"1\":{\"296\":1}}],[\"这个数组字段\",{\"1\":{\"296\":1}}],[\"这个数据结构除了能存储二进制数据\",{\"1\":{\"294\":1}}],[\"这个数据结构是一个名叫g的结构体\",{\"1\":{\"29\":1}}],[\"这个阈值的默认值为\",{\"1\":{\"294\":1}}],[\"这个产品很好的实现了单点登录\",{\"1\":{\"265\":1}}],[\"这个解决方案是解决了主域名和子域名下的会话管理问题\",{\"1\":{\"265\":1}}],[\"这个类只对致命性错误和语法错误进行防范处理\",{\"1\":{\"262\":1}}],[\"这个机制对调试应用程序\",{\"1\":{\"262\":1}}],[\"这个可以通过阅读框架的源码看下\",{\"1\":{\"260\":1}}],[\"这个就是命令模式下的入口文件\",{\"1\":{\"260\":1}}],[\"这个就是go高并发的原理\",{\"1\":{\"12\":1}}],[\"这个入口文件叫\",{\"1\":{\"260\":1}}],[\"这个基数越大\",{\"1\":{\"252\":1}}],[\"这个索引的区分度就越好\",{\"1\":{\"252\":1}}],[\"这个方法对主键\",{\"1\":{\"227\":1}}],[\"这个特性会导致\",{\"1\":{\"223\":1}}],[\"这个操作的流程图如下\",{\"1\":{\"218\":1}}],[\"这个操作可以让当前case禁用\",{\"1\":{\"7\":1}}],[\"这个read\",{\"1\":{\"215\":1,\"502\":1}}],[\"这个jar包\",{\"1\":{\"187\":1}}],[\"这个权限表不受grant和revoke语句的影响\",{\"1\":{\"139\":1}}],[\"这个目的还是分散读的压力\",{\"1\":{\"119\":1}}],[\"这个\",{\"1\":{\"112\":1,\"502\":4}}],[\"这个非聚集索引表示的是用户幸运数字的索引\",{\"1\":{\"72\":1}}],[\"这个再根据聚集索引查找数据的过程\",{\"1\":{\"71\":1}}],[\"这个和内存分配策略相关\",{\"1\":{\"63\":1}}],[\"这个概念很重要\",{\"1\":{\"63\":1}}],[\"这个叫做锁竞争\",{\"1\":{\"57\":1}}],[\"这个要看struct的场景\",{\"1\":{\"44\":1}}],[\"这个时候主节点master还是会继续往replbackbuffer\",{\"1\":{\"317\":1}}],[\"这个时候就要考虑到使用集群方案\",{\"1\":{\"266\":1}}],[\"这个时候就变成了下面的样子\",{\"1\":{\"219\":1}}],[\"这个时候出现了幻读\",{\"1\":{\"245\":1}}],[\"这个时候idx\",{\"1\":{\"230\":1}}],[\"这个时候ints的长度小于容量\",{\"1\":{\"63\":1}}],[\"这个时候int1的长度小于容量\",{\"1\":{\"63\":1}}],[\"这个时候返回的表则是这样的\",{\"1\":{\"219\":1}}],[\"这个时候整张表其实会变成这样让这个\",{\"1\":{\"219\":1}}],[\"这个时候事务a已经提交\",{\"1\":{\"218\":1}}],[\"这个时候我们就成功的配置了俩个redis服务\",{\"1\":{\"308\":1}}],[\"这个时候我们就要考虑到单点登录了\",{\"1\":{\"265\":1}}],[\"这个时候我们想实现多个域名之间的会话管理\",{\"1\":{\"265\":1}}],[\"这个时候我们可以自定义一个错误处理方法来接管php本身的错误处理方式\",{\"1\":{\"262\":1}}],[\"这个时候我们进行\",{\"1\":{\"219\":2}}],[\"这个时候我们再来分析一下\",{\"1\":{\"218\":1}}],[\"这个时候我们将事务a提交\",{\"1\":{\"218\":1}}],[\"这个时候我们将我们需要的隐藏列也标识出来\",{\"1\":{\"217\":1}}],[\"这个时候我们的\",{\"1\":{\"218\":1}}],[\"这个时候插入三行数据\",{\"1\":{\"217\":1}}],[\"这个时候可以看到我们的二叉查找树变成了一个链表\",{\"1\":{\"68\":1}}],[\"这个时候杠精面试官问\",{\"1\":{\"52\":1}}],[\"这个时候\",{\"1\":{\"21\":1,\"63\":1}}],[\"这次结束后就结束select\",{\"1\":{\"7\":1}}],[\"这有点像我们平常使用的消息队列\",{\"1\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
