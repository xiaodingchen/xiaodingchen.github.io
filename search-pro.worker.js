const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":107,\"nextId\":107,\"documentIds\":{\"0\":\"v-2e3eac9e\",\"1\":\"v-1473bf53\",\"2\":\"v-1473bf53#目录\",\"3\":\"v-1473bf53@0\",\"4\":\"v-4e65ec78\",\"5\":\"v-4e65ec78@0\",\"6\":\"v-4e65ec78@1\",\"7\":\"v-c151bf32\",\"8\":\"v-c151bf32@0\",\"9\":\"v-c151bf32@1\",\"10\":\"v-438ffe52\",\"11\":\"v-438ffe52#markdown-介绍\",\"12\":\"v-438ffe52#markdown-配置\",\"13\":\"v-438ffe52#markdown-扩展\",\"14\":\"v-438ffe52#vuepress-扩展\",\"15\":\"v-438ffe52#主题扩展\",\"16\":\"v-438ffe52#自定义容器\",\"17\":\"v-438ffe52#代码块\",\"18\":\"v-438ffe52#上下角标\",\"19\":\"v-438ffe52#自定义对齐\",\"20\":\"v-438ffe52#attrs\",\"21\":\"v-438ffe52#脚注\",\"22\":\"v-438ffe52#标记\",\"23\":\"v-438ffe52#任务列表\",\"24\":\"v-438ffe52#图片增强\",\"25\":\"v-438ffe52#卡片\",\"26\":\"v-438ffe52#图表\",\"27\":\"v-438ffe52#echarts\",\"28\":\"v-438ffe52#流程图\",\"29\":\"v-438ffe52#mermaid\",\"30\":\"v-438ffe52#tex-语法\",\"31\":\"v-438ffe52#导入文件\",\"32\":\"v-438ffe52#代码演示\",\"33\":\"v-438ffe52#样式化\",\"34\":\"v-438ffe52#交互演示\",\"35\":\"v-438ffe52#vue-交互演示\",\"36\":\"v-438ffe52#幻灯片\",\"37\":\"v-438ffe52@0\",\"38\":\"v-438ffe52@1\",\"39\":\"v-6e19edb7\",\"40\":\"v-6e19edb7#页面信息\",\"41\":\"v-6e19edb7#页面内容\",\"42\":\"v-6e19edb7#页面结构\",\"43\":\"v-6e19edb7@0\",\"44\":\"v-6e19edb7@1\",\"45\":\"v-55325e94\",\"46\":\"v-55325e94#channel\",\"47\":\"v-55325e94#声明和创建\",\"48\":\"v-55325e94#channel的两种分类\",\"49\":\"v-55325e94#死锁-deadlock\",\"50\":\"v-55325e94#无缓冲同步通信示例\",\"51\":\"v-55325e94#有缓冲chan\",\"52\":\"v-55325e94#select多路监听\",\"53\":\"v-55325e94#准确使用定时器\",\"54\":\"v-55325e94@0\",\"55\":\"v-55325e94@1\",\"56\":\"v-197289d8\",\"57\":\"v-197289d8#构建servemux\",\"58\":\"v-197289d8@0\",\"59\":\"v-197289d8@1\",\"60\":\"v-fffb8e28\",\"61\":\"v-fffb8e28#功能亮点\",\"62\":\"v-fffb8e28#bar\",\"63\":\"v-fffb8e28#foo\",\"64\":\"v-255721be\",\"65\":\"v-255721be#myisam和innodb的区别\",\"66\":\"v-255721be#mysql优化相关\",\"67\":\"v-255721be#mysql修改表相关\",\"68\":\"v-255721be#关闭索引\",\"69\":\"v-255721be#开启索引\",\"70\":\"v-255721be#索引相关\",\"71\":\"v-255721be#前缀索引\",\"72\":\"v-255721be#多列索引\",\"73\":\"v-255721be#myisam和innodb的索引总结。\",\"74\":\"v-255721be#查询优化相关\",\"75\":\"v-255721be#mysql高级特性\",\"76\":\"v-255721be#分区\",\"77\":\"v-255721be#视图\",\"78\":\"v-255721be#绑定变量\",\"79\":\"v-255721be#配置优化\",\"80\":\"v-255721be#复制\",\"81\":\"v-255721be@0\",\"82\":\"v-255721be@1\",\"83\":\"v-4b4371d9\",\"84\":\"v-4b4371d9#php的命令模式实现\",\"85\":\"v-4b4371d9#php的错误和异常处理\",\"86\":\"v-4b4371d9#错误处理\",\"87\":\"v-4b4371d9#会话管理-跨域-单点登录\",\"88\":\"v-4b4371d9#会话管理\",\"89\":\"v-4b4371d9#会话跨域和单点登录\",\"90\":\"v-4b4371d9#负载均衡\",\"91\":\"v-4b4371d9#秒杀活动和超卖\",\"92\":\"v-4b4371d9#秒杀设计\",\"93\":\"v-4b4371d9#超卖问题\",\"94\":\"v-4b4371d9@0\",\"95\":\"v-4b4371d9@1\",\"96\":\"v-5d5c2d30\",\"97\":\"v-5d5c2d30#介绍\",\"98\":\"v-5d5c2d30#详情\",\"99\":\"v-177e1f06\",\"100\":\"v-5d5821d6\",\"101\":\"v-5d5821d6#介绍\",\"102\":\"v-5d5821d6#详情\",\"103\":\"v-0b6fc5f8\",\"104\":\"v-7630e300\",\"105\":\"v-14f0d3a9\",\"106\":\"v-744b4c30\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[1,5],\"3\":[null,null,1],\"4\":[1,18],\"5\":[null,null,1],\"6\":[null,null,1],\"7\":[1,7],\"8\":[null,null,1],\"9\":[null,null,1],\"10\":[2,11],\"11\":[2,8],\"12\":[2,13],\"13\":[2,11],\"14\":[2,10],\"15\":[1,10],\"16\":[1,19],\"17\":[1,1],\"18\":[1,3],\"19\":[1,3],\"20\":[1,5],\"21\":[1,3],\"22\":[1,3],\"23\":[1,5],\"24\":[1,2],\"25\":[1,23],\"26\":[1,1],\"27\":[1,1],\"28\":[1,1],\"29\":[1,1],\"30\":[2,10],\"31\":[1,6],\"32\":[1,1],\"33\":[1,5],\"34\":[1,1],\"35\":[2,1],\"36\":[1,3],\"37\":[null,null,1],\"38\":[null,null,1],\"39\":[1,3],\"40\":[1,20],\"41\":[1,17],\"42\":[1,16],\"43\":[null,null,1],\"44\":[null,null,2],\"45\":[1],\"46\":[1,27],\"47\":[1,38],\"48\":[1,86],\"49\":[3,48],\"50\":[1,32],\"51\":[1,91],\"52\":[1,102],\"53\":[1,74],\"54\":[null,null,1],\"55\":[null,null,3],\"56\":[1],\"57\":[1,333],\"58\":[null,null,1],\"59\":[null,null,5],\"60\":[1],\"61\":[1],\"62\":[1,2],\"63\":[1,2],\"64\":[1],\"65\":[1,31],\"66\":[1,35],\"67\":[1,9],\"68\":[1,6],\"69\":[1,7],\"70\":[1,24],\"71\":[1,32],\"72\":[1,55],\"73\":[2,23],\"74\":[1,18],\"75\":[1],\"76\":[1,76],\"77\":[1,21],\"78\":[1,14],\"79\":[2,28],\"80\":[1,105],\"81\":[null,null,1],\"82\":[null,null,3],\"83\":[2,7],\"84\":[1,29],\"85\":[1],\"86\":[1,216],\"87\":[3],\"88\":[1,100],\"89\":[1,59],\"90\":[1,101],\"91\":[1,6],\"92\":[1,108],\"93\":[1,24],\"94\":[null,null,1],\"95\":[null,null,4],\"96\":[2],\"97\":[1,4],\"98\":[1,2],\"99\":[1,2],\"100\":[2],\"101\":[1,4],\"102\":[1,2],\"103\":[1,2],\"104\":[1],\"105\":[1],\"106\":[1]},\"averageFieldLength\":[1.168887528038224,25.453819930559156,0.825264509765908],\"storedFields\":{\"0\":{\"h\":\"幻灯片页\"},\"1\":{\"h\":\"主要功能与配置演示\"},\"2\":{\"h\":\"目录\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\"]},\"3\":{\"c\":[\"使用指南\"]},\"4\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"5\":{\"c\":[\"使用指南\"]},\"6\":{\"c\":[\"禁用\"]},\"7\":{\"h\":\"密码加密的文章\",\"t\":[\"实际的文章内容。\",\"段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。\",\"段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。\"]},\"8\":{\"c\":[\"使用指南\"]},\"9\":{\"c\":[\"文章加密\"]},\"10\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"11\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"12\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"相关信息\",\"Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 Frontmatter 介绍。\"]},\"13\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"14\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"15\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"16\":{\"h\":\"自定义容器\",\"t\":[\"安全的在 Markdown 中使用 {{ variable }}。\",\"自定义标题\",\"信息容器，包含 代码 与 链接。\",\"const a = 1; \",\"自定义标题\",\"提示容器\",\"自定义标题\",\"警告容器\",\"自定义标题\",\"危险容器\",\"自定义标题\",\"详情容器\",\"查看详情\"]},\"17\":{\"h\":\"代码块\",\"t\":[\"查看详情\"]},\"18\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"19\":{\"h\":\"自定义对齐\",\"t\":[\"我是居中的\",\"我在右对齐\",\"查看详情\"]},\"20\":{\"h\":\"Attrs\",\"t\":[\"一个拥有 ID 的 单词。\",\"查看详情\"]},\"21\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注[1].\",\"查看详情\"]},\"22\":{\"h\":\"标记\",\"t\":[\"你可以标记 重要的内容 。\",\"查看详情\"]},\"23\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"24\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小\",\"查看详情\"]},\"25\":{\"h\":\"卡片\",\"t\":[\"title: Mr.Hope desc: Where there is light, there is hope logo: https://mister-hope.com/logo.svg link: https://mister-hope.com color: rgba(253, 230, 138, 0.15) \",\"查看详情\"]},\"26\":{\"h\":\"图表\",\"t\":[\"查看详情\"]},\"27\":{\"h\":\"Echarts\",\"t\":[\"查看详情\"]},\"28\":{\"h\":\"流程图\",\"t\":[\"查看详情\"]},\"29\":{\"h\":\"Mermaid\",\"t\":[\"查看详情\"]},\"30\":{\"h\":\"Tex 语法\",\"t\":[\"∂ωr∂r​(ωyω​)=(ωyω​){(logy)r+i=1∑r​ωi(−1)ir⋯(r−i+1)(logy)r−i​}\",\"查看详情\"]},\"31\":{\"h\":\"导入文件\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\",\"查看详情\"]},\"32\":{\"h\":\"代码演示\",\"t\":[\"查看详情\"]},\"33\":{\"h\":\"样式化\",\"t\":[\"向 Mr.Hope 捐赠一杯咖啡。 \",\"查看详情\"]},\"34\":{\"h\":\"交互演示\",\"t\":[\"查看详情\"]},\"35\":{\"h\":\"Vue 交互演示\",\"t\":[\"查看详情\"]},\"36\":{\"h\":\"幻灯片\",\"t\":[\"查看详情\",\"这是脚注内容 ↩︎\"]},\"37\":{\"c\":[\"使用指南\"]},\"38\":{\"c\":[\"Markdown\"]},\"39\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"40\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"41\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"提示\",\"你可以将图片和 Markdown 文件放置在一起，但是你需要使用相对链接./ 进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\",\"主题包含了一个自定义徽章可以使用:\",\"文字结尾应该有深蓝色的 徽章文字 徽章。 \"]},\"42\":{\"h\":\"页面结构\",\"t\":[\"此页面应当包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"导航栏\",\"侧边栏\",\"页脚\",\"返回顶部按钮\",\"你可以通过主题选项和页面 Frontmatter 自定义它们。\"]},\"43\":{\"c\":[\"使用指南\"]},\"44\":{\"c\":[\"页面配置\",\"使用指南\"]},\"45\":{\"h\":\"Channel的使用\"},\"46\":{\"h\":\"channel\",\"t\":[\"channel是Golang在语言层面提供的goroutine间的通信方式。channel 是一个通道，用于端到端的数据传输，这有点像我们平常使用的消息队列，只不过 channel 的发送方和接受方是 goroutine 对象，属于内存级别的通信。\",\"这里涉及到了 goroutine 概念，goroutine 是轻量级的协程，有属于自己的栈空间。 我们可以把它理解为线程，只不过 goroutine 的性能开销很小，并且在用户态上实现了属于自己的调度模型。\",\"channel 是引用类型，在多并发操作里是属于协程安全的，并且遵循了 FIFO 特性。即先执行读取的 goroutine 会先获取到数据，先发送数据的 goroutine 会先输入数据。\"]},\"47\":{\"h\":\"声明和创建\",\"t\":[\"var ch chan int // 声明一个chan，此时ch是一个nil chan ch := make(chan int) // 创建一个无缓冲的chan \",\"上面的代码我们看到首先声明了一个chan，此时ch是一个nil chan，对nil chan进行send(写、发送)，recv(读、接收)都将会阻塞。\",\"每个channel都有3种操作：send、receive和close\",\"send：表示sender端的goroutine向channel中投放数据\",\"receive：表示receiver端的goroutine从channel中读取数据\",\"close：表示关闭channel \",\"关闭channel后，send操作将导致painc\",\"关闭channel后，若没有缓冲数据，recv操作将返回对应类型的0值以及一个状态码false\",\"close并非强制需要使用close(ch)来关闭channel，在某些时候可以自动被关闭\",\"只在sender端上显式使用close()关闭channel。因为关闭通道意味着没有数据再需要发送\",\"如果使用close()，建议条件允许的情况下加上defer\"]},\"48\":{\"h\":\"channel的两种分类\",\"t\":[\"channel分为两种：unbuffered channel(无缓冲)和buffered channel（有缓冲）\",\"ch1 := make(chan int) // 无缓冲 ch2 := make(chan int, 10) // 有缓冲 \",\"unbuffered channel(无缓冲)：阻塞，同步模式\",\"sender端向channel中send一个数据，然后阻塞，直到receiver端将此数据receive\",\"receiver端一直阻塞，直到sender端向channel发送了一个数据\",\"func main(){ ch := make(chan int) go func(){ fmt.Println(\\\"go send\\\") ch<-1 close(ch) }() i := <-ch fmt.Println(\\\"ch val: \\\", i) } \",\"buffered channel（有缓冲）：非阻塞，异步模式\",\"sender端可以向channel中send多个数据(只要channel容量未满)，容量满之前不会阻塞\",\"receiver端按照队列的方式(FIFO,先进先出)从buffered channel中按序receive其中数据\",\"func main() { ch := make(chan int, 10) go func() { fmt.Println(\\\"go send\\\") for i := 0; i < 20; i++ { ch <- i } close(ch) }() for { i, ok := <-ch if !ok { fmt.Println(\\\"ch close\\\") return } fmt.Println(\\\"ch val: \\\", i) } } \",\"unbuffered channel可以认为是容量为0的buffered channel，所以每发送一个数据就被阻塞。注意，不是容量为1的buffered channel，因为容量为1的channel，是在channel中已有一个数据，并发送第二个数据的时候才被阻塞。\",\"阻塞和不阻塞是由channel控制的，无论是send还是recv操作，都是在向channel发送请求：\",\"对于unbuffered channel，sender发送一个数据，channel暂时不会向sender的请求返回ok消息，而是等到receiver准备接收channel数据了，channel才会向sender和receiver双方发送ok消息。在sender和receiver接收到ok消息之前，两者一直处于阻塞。\",\"对于buffered channel，sender每发送一个数据，只要channel容量未满，channel都会向sender的请求直接返回一个ok消息，使得sender不会阻塞，直到channel容量已满，channel不会向sender返回ok，于是sender被阻塞。对于receiver也一样，只要channel非空，receiver每次请求channel时，channel都会向其返回ok消息，直到channel为空，channel不会返回ok消息，receiver被阻塞。\",\"在Go的内部行为中，send和recv是一个整体行为，数据未读就表示未send成功。所以对已经关闭的chan进行send操作会引发panic\"]},\"49\":{\"h\":\"死锁(deadlock)\",\"t\":[\"当channel的某一端(sender/receiver)期待另一端的(receiver/sender)操作，另一端正好在期待本端的操作时，也就是说两端都因为对方而使得自己当前处于阻塞状态，这时将会出现死锁问题。更通俗地说，只要所有goroutine都被阻塞，就会出现死锁。\",\"func main() { ch := make(chan int) ch <- 1 fmt.Println(\\\"recv\\\") <-ch } \",\"在上面的示例中，向unbuffered channel中send数据的操作ch <- 1是在main goroutine中进行的，此channel中recv的操作<-ch也是在main goroutine中进行的。send的时候会直接阻塞main goroutine，使得recv操作无法被执行，go将探测到此问题，并报错：\",\"fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: \",\"解决方法，只需将send操作放在另一个goroutine中执行即可：\",\"func main() { ch := make(chan int) go func() { fmt.Println(\\\"send\\\") ch <- 1 }() fmt.Println(\\\"recv\\\") <-ch } \",\"或者讲无缓冲chan设置为有缓冲chan：\",\"func main() { ch := make(chan int, 1) fmt.Println(\\\"send\\\") ch <- 1 fmt.Println(\\\"recv\\\") <-ch } \"]},\"50\":{\"h\":\"无缓冲同步通信示例\",\"t\":[\"func main() { ch := make(chan int) defer close(ch) wg := sync.WaitGroup{} wg.Add(2) f1 := func() { defer wg.Done() time.Sleep(3 * time.Second) fmt.Println(\\\"f1 end.\\\") ch <- 1 } f2 := func() { defer wg.Done() <-ch fmt.Println(\\\"f2 end\\\") } go f1() go f2() wg.Wait() } \",\"上面的代码表示必须f1函数执行完成才能执行f2函数，否则f2一直阻塞，两个协程之间通过ch进行通信。\"]},\"51\":{\"h\":\"有缓冲chan\",\"t\":[\"有缓冲chan一般在进行并发限制的时候用的较多，案例：\",\"type Task struct { TaskId int64 Status string } func (t *Task) Do(ch <-chan int) { time.Sleep(time.Second * 3) t.Status = \\\"Success\\\" log.Printf(\\\"task %d done.\\\\n\\\", t.TaskId) <-ch } func main() { ch := make(chan int, 10) wg := sync.WaitGroup{} for i := 1; i < 100; i++ { wg.Add(1) ch <- i go func(i int) { defer wg.Done() task := &Task{TaskId: int64(i)} task.Do(ch) }(i) } wg.Wait() } \",\"案例中我们生成100个任务，每次最多并发执行10个，使用了有缓冲的chan，在任务执行之前对chan进行写操作，任务完成后对chan进行读操作，这样就限制了goruntine的个数。 同时上面的案例中，在task的Do方法中我们使用指向的chan，这个是Go中特有的，表明这个chan参数只能进行读取操作。\",\"in <-chan int：表示channel in通道只用于接收数据\",\"out chan<- int：表示channel out通道只用于发送数据\",\"只用于接收数据的通道<-chan不可被关闭，因为关闭通道是针对发送数据而言的，表示无数据再需发送。对于recv来说，关闭通道是没有意义的。\",\"案例：\",\"func main() { ch := make(chan int, 10) go func() { for i := 0; i < 100; i++ { ch <- i } close(ch) // 若没有此操作，使用range读取ch将会发生panic，产生死锁 }() for i := range ch { fmt.Println(\\\"i: \\\", i) } } \",\"前面都是在for无限循环中读取channel中的数据，但也可以使用range来迭代channel，它会返回每次迭代过程中所读取的数据，直到channel被关闭。必须注意，只要channel未关闭，range迭代channel就会一直被阻塞。\",\"fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: \"]},\"52\":{\"h\":\"select多路监听\",\"t\":[\"很多时候想要同时操作多个channel，比如从ch1、ch2读数据。Go提供了一个select语句块，它像switch一样工作，里面放一些case语句块，用来轮询每个case语句块的send或recv情况。\",\"用法示例：\",\"select{ case <-ch1: // do case v := <-ch2: // do default: // 所有case都不满足条件时，执行default } \",\"defalut语句是可选的，不允许fall through行为，但允许case语句块为空块。select会被return、break关键字中断：return是退出整个函数，break是退出当前select。\",\"select的行为模式主要是对channel是否可读进行轮询，但也可以用来向channel发送数据。它的行为如下：\",\"如果所有的case语句块评估时都被阻塞，则阻塞直到某个语句块可以被处理\",\"如果多个case同时满足条件，则随机选择一个进行处理，对于这一次的选择，其它的case都不会被阻塞，而是处理完被选中的case后进入下一轮select(如果select在循环中)或者结束select(如果select不在循环中或循环次数结束)\",\"如果存在default且其它case都不满足条件，则执行default。所以default必须要可执行而不能阻塞\",\"所有的case块都是按源代码书写顺序进行评估的。当select未在循环中时，它将只对所有case评估一次，这次结束后就结束select。某次评估过程中如果有满足条件的case，则所有其它case都直接结束评估，并退出此次select。\",\"其实如果注意到select语句是在某一个goroutine中评估的，就不难理解只有所有case都不满足条件时，select所在goroutine才会被阻塞，只要有一个case满足条件，本次select就不会出现阻塞的情况。\",\"需要注意的是，如果在select中执行send操作，则可能会永远被send阻塞。所以，在使用send的时候，应该也使用defalut语句块，保证send不会被阻塞。如果没有default，或者能确保select不阻塞的语句块，则迟早会被send阻塞。\",\"一般来说，select会放在一个无限循环语句中，一直轮询channel的可读事件。\",\"案例：\",\"func main() { ch1 := make(chan int) ch2 := make(chan int, 10) wg := sync.WaitGroup{} go func() { for { select { case v, ok := <-ch1: if !ok { fmt.Println(\\\"ch1 close\\\") ch1 = nil } fmt.Println(\\\"ch1: \\\", v) case v, ok := <-ch2: if !ok { fmt.Println(\\\"ch2 close\\\") ch2 = nil } fmt.Println(\\\"ch2: \\\", v) } } }() for i := 0; i < 10; i++ { wg.Add(2) go func(i int) { defer wg.Done() ch2 <- i }(i) go func(i int) { defer wg.Done() ch1 <- i }(i) } wg.Wait() close(ch1) close(ch2) } \",\"执行这段代码，select确实是随机选择case进行执行，同时我们在检测到chan关闭时，对chan进行了nil赋值，这个操作可以让当前case禁用，当select中的case都在禁用状态，select将会结束，达到终止循环的效果\"]},\"53\":{\"h\":\"准确使用定时器\",\"t\":[\"在Go中提供了定时器功能，一般都是通过 for-select的方式进行使用，在使用的时候要正确使用，防止内存泄漏\",\"func main() { ch := make(chan int, 10) go func() { i := 0 for { ch <- i i++ } }() for { select { case <-time.After(3 * time.Second): log.Println(\\\"timeout.\\\") return case v := <-ch: log.Println(\\\"ch: \\\", v) } } } \",\"看上面的案例，我们本意是在3秒之后停止main goruntine，但是我们代码运行下来发现是一直输出数据，并且不会推出main goruntine。原因在于 for+select，再加上 time.After 的组合会导致内存泄露。因为 for在循环时，就会调用都 select 语句，因此在每次进行 select 时，都会重新初始化一个全新的计时器（Timer）。我们这个计时器，是在 3秒后才会被触发去执行某些事，但重点在于计时器激活后，却又发现和 select 之间没有引用关系了，因此很合理的也就被 GC 给清理掉了，因为没有人需要 “我” 了。\",\"要命的还在后头，被抛弃的 time.After 的定时任务还是在时间堆中等待触发，在定时任务未到期之前，是不会被 GC 清除的。这就会导致严重的内存泄漏。改进方法如下：\",\"func main() { ch := make(chan int, 10) go func() { i := 0 for { ch <- i i++ } }() timer := time.After(3 * time.Second) for { select { case <-timer: log.Println(\\\"timeout.\\\") return case v := <-ch: log.Println(\\\"ch: \\\", v) } } } \",\"将延时器放到for循环之外定义，这样每次循环的时候就不会对time.After进行初始化，防止了内存泄漏，同时达到了3秒程序结束的效果.\"]},\"54\":{\"c\":[\"golang\"]},\"55\":{\"c\":[\"go\",\"channel\",\"并发\"]},\"56\":{\"h\":\"Golang通过Gin框架创建http服务源码剖析\"},\"57\":{\"h\":\"构建ServeMux\",\"t\":[\"net/http包中有默认的DefaultServeMux，gin框架也实现了这个，主要是实现 http.Handler接口，接口只包含一个方法 ServeHTTP(ResponseWriter, *Request)\",\"我们看下gin中怎么实现的\",\" // ServeHTTP conforms to the http.Handler interface. func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) // 具体的执行请求返回响应的方法 engine.pool.Put(c) } \",\"gin框架构建ServeMux流程如下：\",\" engine := gin.New() // 初始化gin，实现了http.Handler接口，是一个合格的ServeMux了 engine.Use() // 初始化全局中间件 engine.Get(\\\"/path\\\", function(ctx *gin.Context){}) // 添加路由 构建Server http服务的底层走的是tcp协议，需要监听端口 srv := http.Server{ Handler: engine, // http.Handler接口的实现者 Addr: \\\":8080\\\", // 监听http端口 } srv.ListenAndServe() \",\"上面的代码监听了8080端口来提供http服务，服务的具体执行者就是我们的gin框架，那么具体是怎么执行一个http请求的呢，具体要看 net/http包中Server.ListenAndServe()的实现，代码如下：\",\"func (srv *Server) ListenAndServe() error { if srv.shuttingDown() { return ErrServerClosed } addr := srv.Addr if addr == \\\"\\\" { addr = \\\":http\\\" } ln, err := net.Listen(\\\"tcp\\\", addr) if err != nil { return err } return srv.Serve(ln) } \",\"我们看到这个方法两个步骤，tcp协议监听端口，处理监听serve，我们主要看serve，代码如下：\",\"func (srv *Server) Serve(l net.Listener) error { ····· ..... baseCtx := context.Background() if srv.BaseContext != nil { baseCtx = srv.BaseContext(origListener) if baseCtx == nil { panic(\\\"BaseContext returned a nil context\\\") } } var tempDelay time.Duration // how long to sleep on accept failure ctx := context.WithValue(baseCtx, ServerContextKey, srv) for { rw, err := l.Accept() if err != nil { ····· ····· return err } connCtx := ctx if cc := srv.ConnContext; cc != nil { connCtx = cc(connCtx, rw) if connCtx == nil { panic(\\\"ConnContext returned nil\\\") } } tempDelay = 0 c := srv.newConn(rw) c.setState(c.rwc, StateNew, runHooks) // before Serve can return go c.serve(connCtx) } } \",\"我们通过代码可以看到，监听端口，然后accept阻塞直到返回下一个链接，经过一系列相关处理，创建一个新的连接，然后开一个goruntine处理这个连接，即每次一个http请求都会建立一个连接，每个连接中都会被赋予Server的信息，并通过goruntine来处理这个连接，这个就是go高并发的原理，具体连接的处理在conn.serve中，我们看到这个方法的参数是一个连接的上下文，方法代码如下：\",\" func (c *conn) serve(ctx context.Context) { c.remoteAddr = c.rwc.RemoteAddr().String() ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr()) defer func() { if err := recover(); err != nil && err != ErrAbortHandler { const size = 64 << 10 buf := make([]byte, size) buf = buf[:runtime.Stack(buf, false)] c.server.logf(\\\"http: panic serving %v: %v\\\\n%s\\\", c.remoteAddr, err, buf) } if !c.hijacked() { c.close() c.setState(c.rwc, StateClosed, runHooks) } }() ........ ........ // HTTP/1.x from here on. ctx, cancelCtx := context.WithCancel(ctx) c.cancelCtx = cancelCtx defer cancelCtx() c.r = &connReader{conn: c} c.bufr = newBufioReader(c.r) c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4<<10) for { w, err := c.readRequest(ctx) if c.r.remain != c.server.initialReadLimitSize() { // If we read any bytes off the wire, we're active. c.setState(c.rwc, StateActive, runHooks) } if err != nil { ....... ....... return } // Expect 100 Continue support req := w.req if req.expectsContinue() { if req.ProtoAtLeast(1, 1) && req.ContentLength != 0 { // Wrap the Body reader with one that replies on the connection req.Body = &expectContinueReader{readCloser: req.Body, resp: w} w.canWriteContinue.setTrue() } } else if req.Header.get(\\\"Expect\\\") != \\\"\\\" { w.sendExpectationFailed() return } c.curReq.Store(w) if requestBodyRemains(req.Body) { registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead) } else { w.conn.r.startBackgroundRead() } // HTTP cannot have multiple simultaneous active requests.[*] // Until the server replies to this request, it can't read another, // so we might as well run the handler in this goroutine. // [*] Not strictly true: HTTP pipelining. We could let them all process // in parallel even if their responses need to be serialized. // But we're not going to implement HTTP pipelining because it // was never deployed in the wild and the answer is HTTP/2. serverHandler{c.server}.ServeHTTP(w, w.req) w.cancelCtx() if c.hijacked() { return } w.finishRequest() .......... .......... c.rwc.SetReadDeadline(time.Time{}) } } \",\"我们看到这个方法中做了哪些事，方法执行完毕关闭当前连接，读取请求内容，处理并相应。具体处理请求的代码是这个 serverHandler{c.server}.ServeHTTP(w, w.req)我们看到实例化了一个serverHandler并调用了其ServeHTTP方法来处理，我看下这个serverHandler，代码如下：\",\" // serverHandler delegates to either the server's Handler or // DefaultServeMux and also handles \\\"OPTIONS *\\\" requests. type serverHandler struct { srv *Server } func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { handler := sh.srv.Handler if handler == nil { handler = DefaultServeMux } if req.RequestURI == \\\"*\\\" && req.Method == \\\"OPTIONS\\\" { handler = globalOptionsHandler{} } handler.ServeHTTP(rw, req) } \",\"我们看到代码里serverHandler中的 srv即为Server，在serverHandler的ServeHTTP方法中判断Server的Handler是否为nil，如果是nil则使用默认的DefaultServeMux，这里我们的Handler是由gin框架实现的一个ServeMux，调用ServeMux的ServeHTTP方法来处理请求，即交由gin来处理请求。gin中主要通过context.Next()方法来执行具体的gin.HandlerFunc函数，代码如下\",\" func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) engine.pool.Put(c) } func (engine *Engine) handleHTTPRequest(c *Context) { ........ ........ // Find root of the tree for the given HTTP method t := engine.trees for i, tl := 0, len(t); i < tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // Find route in tree value := root.getValue(rPath, c.Params, unescape) if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() c.writermem.WriteHeaderNow() return } ...... ...... break } ...... ...... c.handlers = engine.allNoRoute serveError(c, http.StatusNotFound, default404Body) } func (c *Context) Next() { c.index++ for c.index < int8(len(c.handlers)) { c.handlers[c.index](c) // 执行具体的HandlerFunc c.index++ } } \"]},\"58\":{\"c\":[\"golang\"]},\"59\":{\"c\":[\"go\",\"gin\",\"源码\",\"面试\",\"面试总结\"]},\"60\":{\"h\":\"指南\"},\"61\":{\"h\":\"功能亮点\"},\"62\":{\"h\":\"Bar\",\"t\":[\"baz\",\"...\"]},\"63\":{\"h\":\"Foo\",\"t\":[\"ray\",\"...\"]},\"64\":{\"h\":\"MySQL相关知识点浅析\"},\"65\":{\"h\":\"Myisam和Innodb的区别\",\"t\":[\"innodb支持事务，锁级别是行级锁，支持四个事务隔离级别，分别是未提交读、提交读、可重复读、串行化\",\"innodb的索引策略是聚簇索引\",\"innodb使用MVCC实现并发控制、也就是多版本并发控制，同时也支持索引间隙锁\",\"innodb支持热备份\",\"myisam支持全文索引、表压缩\",\"myisam的锁不支持行级锁，支持表级锁，这个特性会导致，在并发高的情况下进行读写操作的时候性能很差。\",\"myisam支持延迟更新索引键\",\"myisam崩溃的概率比innodb要大很多，MySQL的数据恢复相较于innodb较差\",\"数据存储方式不一样，innodb采用聚簇索引的方式存储数据，myisam采用索引和列的值分离的方式存储数据。\",\"读锁又被称为共享锁，写锁被称为排它锁。\",\"ACID指：原子性、一致性、隔离性、持久性\"]},\"66\":{\"h\":\"mysql优化相关\",\"t\":[\"慢查询日志，对优化MySQL查询至关重要。可以通过long_query_time参数来设置日志记录行为，当值为0时，记录所有的查询\",\"使用show global status SQL语句查看当前连接数(threads_connected)、查询线程数(threads_running)、查询数(queries)\",\"使用 show processlist SQL语句查看当前连接线程是否有废线程，比如locked、free 状态的\",\"设计表的时候选择合适的数据类型，尽量使用NOT NULL，列不要太多\",\"主键最好使用整数类型，避免使用字符串类型\",\"查询SQL数据表关联不要过多，一般最多12个表\",\"根据实际业务创建相关汇总表和缓存表\",\"使用索引。\"]},\"67\":{\"h\":\"mysql修改表相关\",\"t\":[\"alter table 操作在大多数情况下都会锁表，并且重建整表，慎用\",\"对于引擎是myisam的数据表在迁移或转入大量数据的时候，可以先关闭索引，等待数据载入之后开启索引，相关操作如下\"]},\"68\":{\"h\":\"关闭索引\",\"t\":[\"alter table table_name disable keys; \"]},\"69\":{\"h\":\"开启索引\",\"t\":[\"alter table table_name enable keys; \",\"这个方法对主键、唯一索引无效\"]},\"70\":{\"h\":\"索引相关\",\"t\":[\"大多数MySQL存储引擎都实现了b-tree索引，b-tree索引是有序的，在order by 和group by语句中也会用到索引\",\"索引总是遵循最左前缀\",\"索引中的列不能被跳过，如果一个查询中有范围查询，那么只能用到范围查询之前的列，右边的用不到。\",\"可以通过伪哈希索引的手段来优化查询语句\",\"查询中的条件的列不能是一个表达式或函数的参数，要是单独的列，这样才能用到索引\",\"索引中列的顺序不同效果也不一样，在实际业务中可以通过使用相同的列不同的顺序来创建更多的索引\",\"索引可以减少服务器扫描的数据量，避免排序和临时表，索引可以将随机I/O变为顺序I/O\"]},\"71\":{\"h\":\"前缀索引\",\"t\":[\"前缀索引主要是对字符串类型的列取公共前缀进行索引。可以通过不断比较公共前缀出现的次数和总记录的商来取前缀，方法如下：\",\"假设表名为testcity，字符串列名为'city',可以通过如下语句来计算\",\"select count(distinct left(city,3)) /count(*) as sel from testcity;\",\"sel的值越接近1越好。\",\"下面添加一个前缀索引\",\"alter table testcity add key(city(3));\",\"前缀索引更小，更快，不过在order by 和group by中无法使用。\",\"当使用explain分析查询语句时，如果索引类型为index_merge则说明表的索引策略很糟糕，要优化了\"]},\"72\":{\"h\":\"多列索引\",\"t\":[\"选择合适的索引顺序至关重要。我们同样可以使用前缀索引中的方法来比较，不过这次我们不是比较前缀出现的次数而是整个列的记录不重复的次数：\",\"表：testcity 列：cityid, xianid。\",\"select count(distinct cityid) /count(*) as c, count(distinct xianid) /count(*) as x from testcity;\",\"计算的结果中值越接近1的就越往前，比如 c>x,那么索引应该这样加\",\"alter table testcity add key(cityid, xianid);\",\"如果一个索引包含所有要查询字段的值，那这个索引就被称之为覆盖索引。比如下面这个语句：\",\"select cityid from testcity where cityid = 10;\",\"其中 idx_cityid_xianid就是cityid的覆盖索引\",\"select cityid,id, xianid from testcity where cityid = 10;这个时候idx_cityid_xianid就不是覆盖索引\",\"聚簇索引是一种数据存储方式，innodb存储引擎支持，主要是通过主键来实现，如果表中没有定义主键，那就会喧杂一个唯一的非空索引替代，如果没有符合条件的，会自行创建一个隐式主键。它将索引和列的值存储在一起。使数据访问更快，但是特消耗存储空间，二级索引访问需要两次查找，而不是一次（首先二级索引先找到主键，然后通过主键找到具体的值，两次索引查找）\",\"在设计innodb主键的时候，建议使用单调顺序自增类型，比如自增ID，因为innodb是顺序插入的。\"]},\"73\":{\"h\":\"myisam和innodb的索引总结。\",\"t\":[\"两者都支持，主键索引、唯一索引、单列、多列索引及前缀索引，不同的是两者实现的存储方式不一样，innodb中使用聚簇索引的方式存储数据，也就是把索引和列的值存在一起，myisam却不同，索引和值分离；：因为myisam的索引和数据是分开存储存储的，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因 ；innodb的数据和索引放在一起，当找到索引也就找到了数据。\"]},\"74\":{\"h\":\"查询优化相关\",\"t\":[\"减少不必要列的查询\",\"尽量优化查询，使之可以使用到覆盖索引\",\"建立合适的索引，减少查询时扫描的行数\",\"拆分复杂的查询，分解关联查询，简单的查询可以减少锁的竞争，易缓存，减少冗余记录查询\",\"在select查询中加上limit关键字，可以减少资源占用\",\"子查询尽量少用，合理使用子查询，可以使用表连接代替（MySQL版本5.6及以上可以放心大胆的去用子查询）\"]},\"75\":{\"h\":\"MySQL高级特性\"},\"76\":{\"h\":\"分区\",\"t\":[\"range 分区\",\"CREATE TABLE `request_log` ( `id` int(11) NOT NULL AUTO_INCREMENT, `ip` int(11) NOT NULL, `uri` varchar(30) DEFAULT NULL, `request_time` int(11) NOT NULL, PRIMARY KEY (`id`,`request_time`), UNIQUE KEY `ip` (`ip`,`request_time`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 partition BY RANGE (request_time) (partition p0 VALUES LESS THAN (1400000000) ENGINE = InnoDB, partition p1 VALUES LESS THAN (1500000000) ENGINE = InnoDB, PARTITION pall VALUES LESS THAN MAXVALUE ENGINE = InnoDB); \",\"同时还有别的分区，比如，list分区，hash分区，key分区。具体可以参考：https://www.cnblogs.com/mliudong/p/3625522.html 简单了解下\",\"分区的时候最好不要选择默认为NULL的列，选择的列最好有索引（分区列和索引列匹配），分区在查询的时候需要锁住所有的底层表，这会带来很多的开销，要控制合适的分区的个数。分区的维护成本比较高\",\"在进行分区查询的时候，where条件要包含分区列，分区列不能在表达式中，这样可以在查询的时候减少分区的扫描。\",\"比如：partitions select * from request_log where request_time between 1400000000 and 1500000000;\"]},\"77\":{\"h\":\"视图\",\"t\":[\"具体视图相关可以参考：https://blog.csdn.net/moxigandashu/article/details/63254901\",\"全文索引\",\"MySQL5.6版本innodb开始支持全文索引，之前的版本只有myisam支持，具体可以参考：https://www.cnblogs.com/PaulMa/p/5238682.html\"]},\"78\":{\"h\":\"绑定变量\",\"t\":[\"以二进制的方式向服务端发送参数和句柄，节约内存和网络开销。服务器也只对器进行一次解析。\",\"相对安全，减少了SQL注入和攻击\",\"在高并发的情况下建议关闭查询缓存，如果非要使用的话不要设置太大的内存占用，相关参数：query_cache_type是否开启缓存；query_cache_size查询缓存的总内存空间，单位字节。\"]},\"79\":{\"h\":\"配置优化：\",\"t\":[\"对于innodb来说最重要的两个配置为：\",\"innodb_buffer_pool_size缓冲池大小\",\"innodb_log_file_size 日志文件大小\",\"基本配置\",\"slow_query_log 慢查询是否开启\",\"long_query_time 慢查询衡量标准，单位秒\",\"max-connections 最大连接数\",\"read-only 是否只读\",\"table_cache_size\",\"sql_mode 服务器模式\"]},\"80\":{\"h\":\"复制\",\"t\":[\"二进制日志（binlog）建议指定确切路径和文件名，同时在备库上也建议指定中继日志（relay_log）的路径和文件名\",\"相关参数：\",\"主库：\",\"log_bin = /var/lib/mysql/mysql-bin\",\"备库：\",\"relay_log = /var/lib/mysql/relay-bin\",\"复制模式，两种，基于语句(statement)，基于行(row)。\",\"基于语句消耗资源少，执行速度快，但是很多情况下无法正确复制数据。比如有存储过程的语句，语句里有变量的\",\"基于行的复制，顾名思义就是一行一行复制，但是在数据更改比较大的情况下，消耗资源多，复制慢。\",\"一般都是在实际应用中采用混合模式复制(mixed)，即基于行和基于语句一起使用，5.7.7之前默认是基于语句，之后基于行，可以通过参数设置：\",\"binlog_format = mixed|row|statement\",\"参考文章：https://www.cnblogs.com/ivictor/p/5764978.html\",\"主从复制开启步骤\",\"1、在主服务器上创建一个复制账号\",\"2、主库从库配置server_id选项，一般是机器IP32位的后八位，主库配置二进制文件地址，从库配置中继日志文件地址，可以通过show master status 查看binlog日志的名字\",\"3、从库启动复制：\",\"命令： change master to master_host='hostip',master_user='masteruser',master_password='password',master_log_file='binlogname',master_log_pos=0;\",\"master_log_pos设置为0表示从日志开头读起，配置好之后，开始执行命令start slave;\",\"sphinx全文索引\",\"主索引和增量索引都要定时维护。具体相关实现可以参考：bbc，相关知识点，搞清楚文档、属性、关联字段。\",\"相关参考文章：https://blog.csdn.net/soar_away/article/details/52035072\",\"https://blog.csdn.net/adparking/article/details/7080278\",\"手册地址：http://sphinxsearch.com/docs/\"]},\"81\":{\"c\":[\"mysql\"]},\"82\":{\"c\":[\"mysql\",\"面试\",\"面试总结\"]},\"83\":{\"h\":\"PHP面试总结 v20180824\",\"t\":[\"今天面试主要和面试官讨论这些问题，我自我感觉回答的很渣。不错，我就是个技术混子，嗯，是的。\"]},\"84\":{\"h\":\"PHP的命令模式实现\",\"t\":[\"PHP的命令模式也就是cli模式，就是把PHP文件当做脚本执行的一种方式。一般最简单的实现就是如下：\",\"php file.php \",\"上面的列子很简单，但是这个问题不是那么简单的。通常我们在web模式下都会有个入口文件，这个入口文件叫 index.php，那么命令模式下是不是也可以有个入口文件呢？答案是可以的，比如ThinkPHP5和yii框架都实现了这个功能。比如：\",\"php think list \",\"上面例子中，think 这个就是命令模式下的入口文件，list 是在换个文件的参数，可以通过 $SERVER['argv'] 获取，获取到参数之后，执行响应的逻辑。一般的框架都会实现命令的注册，每个框架的处理机制不一样，这个可以通过阅读框架的源码看下。\"]},\"85\":{\"h\":\"PHP的错误和异常处理\"},\"86\":{\"h\":\"错误处理\",\"t\":[\"一般编程语言都有自己的错误处理机制，这个机制对调试应用程序，处理业务逻辑有很大的帮助。 PHP提供了 error_reporting() 函数来设置错误级别。一般PHP常见的错误级别有这几种：E_ALL, E_ERROR, E_WARNING, E_NOTICE, E_STRICT, E_DEPRECATED。下面是对这几种错误级别的介绍。\",\"E_ERROR：致命错误，会导致脚本终止运行\",\"E_WARNING：运行时警告 (非致命错误)。仅给出提示信息，但是脚本不会终止运行\",\"E_NOTICE：运行时通知。表示脚本遇到可能会表现为错误的情况，但是在可以正常运行的脚本里面也可能会有类似的通知。\",\"E_STRICT：启用 PHP 对代码的修改建议，以确保代码具有最佳的互操作性和向前兼容性。\",\"E_DEPRECATED：运行时通知。启用后将会对在未来版本中可能无法正常工作的代码给出警告。（可忽略）\",\"E_ALL：E_STRICT 除外的所有错误和警告信息。\",\"同时用户也可以设置自身的错误级别，主要通过 trigger_error() 函数实现。用户级别的错误有：E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE, E_USER_DEPRECATED。\",\"上面的错误级别可以参考PHP官方文档：http://php.net/manual/zh/errorfunc.constants.php\",\"有的时候PHP本身对错误的处理难以满足我们的业务需求，这个时候我们可以自定义一个错误处理方法来接管PHP本身的错误处理方式。我们可以通过set_error_handler(callable $error_handler [, int $error_types = E_ALL | E_STRICT ]) 函数来注册这个方法。需要注意的是要记住 error_types 里指定的错误类型都会绕过 PHP 标准错误处理程序， 除非回调函数返回了 FALSE。 error_reporting() 设置将不会起到作用而你的错误处理函数继续会被调用 —— 不过你仍然可以获取 error_reporting 的当前值，并做适当处理。 需要特别注意的是带 @ error-control operator 前缀的语句发生错误时，这个值会是 0。 以下级别的错误不能由用户定义的函数来处理： E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，和在 调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT。可在 register_shutdown_function() 中处理( 但脚本仍会结束 )\",\"error_get_last()获取最后发生的错误，返回了一个关联数组，描述了最后错误的信息，以该错误的 “type”、 “message”、”file” 和 “line” 为数组的键。 如果该错误由 PHP 内置函数导致的，”message”会以该函数名开头。 如果还没有错误则返回 NULL。\",\"Array ( [type] => 8 [message] => Undefined variable: a [file] => C:\\\\WWW\\\\index.php [line] => 2 ) \",\"一般在做错误处理的时候这个函数会被register_shutdown_function()注册到脚本运行结束前。\",\"具体使用方法可以参考PHP官方手册：http://php.net/manual/zh/function.set-error-handler.php\",\"异常处理 在PHP中采用 try...catch 模式来处理异常，使用 throw关键字抛出异常。PHP的异常处理基类是 Exception，所有的异常处理类都继承它。官方手册地址：http://php.net/manual/zh/class.exception.php\",\"同时PHP也提供了 ErrorException 错误异常处理类，可以使用set_error_handler()函数将错误信息托管至ErrorException：\",\"<?php function exception_error_handler($errno, $errstr, $errfile, $errline ) { throw new ErrorException($errstr, 0, $errno, $errfile, $errline); } set_error_handler(\\\"exception_error_handler\\\"); /* Trigger exception */ strpos(); ?> \",\"具体可参考PHP官方手册：http://php.net/manual/zh/class.errorexception.php\",\"除了上述两个标准异常之外，SPL提供了一系列标准异常。具体可参考：http://php.net/manual/zh/spl.exceptions.php\",\"PHP官方提供了 set_exception_handler() 函数来帮助开发者自定义异常处理行为。手册地址：http://php.net/manual/zh/function.set-exception-handler.php\",\"错误和异常统一处理 一般在框架中都会封装一套属于框架自身的错误和异常处理模块，通常错误会被转化为异常进行统一处理。以下是简单的实现思路\",\"<?php class handleExceptions { public function init() { // 致命错误和语法错误 error_reporting(E_ERROR | E_USER_ERROR | E_PARSE | E_COMPILE_ERROR); set_error_handler([$this, 'errorHandler']); set_exception_handler([$this, 'exceptionHandler']); // 获取最后一次错误 register_shutdown_function([$this, 'handlerShutdown']); } public function errorHandler($level, $message, $file = '', $line = 0, $context = array()) { // 判断错误级别是否是设置的 if (error_reporting() & $level) { throw new \\\\ErrorException($message, 0, $level, $file, $line); } } public function exceptionHandler(Exception $e) { // 所有的错误和异常都在这里进行处理,一般处理错误的时候需要进行以下几点 // 1、根据错误级别记录错误日志，有利于后期排查 // 2、根据当前业务场景做出相应的动作，比如在开发模式下，就把错误全面的展现出来，如果是生产模式下就要进行优雅的错误处理。 } public function handlerShutdown() { $error = error_get_last(); if ( ! is_null($error) && $this->isFatal($error['type'])) { $this->exceptionHandler($this->fatalExceptionFromError($error, 0)); } } protected function fatalExceptionFromError(array $error, $traceOffset = null) { return new \\\\ErrorException( $error['message'], 0, $error['type'], $error['file'], $error['line'] ); } protected function isFatal($type) { $a = in_array($type, [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE]); return $a; } } \",\"上面的例子中，我们自定义了一个处理类，这个类只对致命性错误和语法错误进行防范处理，其他的错误进行了忽略。（可重写errorHandler方法，让其对其他级别的错误进行处理）handleExceptions::exceptionHandler()方法让错误和异常都在这里进行处理。 一般处理错误的时候需要进行：\",\"1、根据错误级别记录错误日志，有利于后期排查\",\"2、根据当前业务场景做出相应的动作，比如在开发模式下，就把错误全面的展现出来，如果是生产模式下就要进行优雅的错误处理。（比如错误页面啊，Ajax模式下错误响应，错误恢复脚本继续执行等等）\",\"在PHP7以上，E_ERROR的错误可以交由set_exception_handler，即自定义异常来捕获。具体参考：http://php.net/manual/en/class.error.php 和 http://php.net/manual/en/class.throwable.php 及 http://php.net/manual/zh/function.set-exception-handler.php\"]},\"87\":{\"h\":\"会话管理，跨域，单点登录\"},\"88\":{\"h\":\"会话管理\",\"t\":[\"在web开发中，总是会用到会话管理。所谓会话管理指的是因为HTTP协议是无状态的一种协议，为了识别当前用户而创建的一种技术手段。会话管理主要有两个部分组成，客户端和服务器端。一般客户端指的是COOKIE，服务器端指的是SESSION。\",\"Session和cookie的关系。会话是由客户端发起请求，服务器端响应。比如用户登录，用户发起登录请求，服务器校验请求是否正确，正确的话就在服务器端生成一个唯一sessionID，然后通过HTTP协议把这个sessionID放到cookie里返回给客户端，客户端收到cookie后会在每次请求的时候带上cookie。格式如下：\",\"Cookie: PHPSESSID=q0fm8up72q58ne1b6khf37dlos\",\"PHP提供了很简单两个全局变量来操作cookie和session，分别是 $_COOKIE 和 $_SESSION，开发者不需要考虑sessionID的问题。PHP默认会把session存储在服务器的临时目录中，并在每次运行时进行GC操作。你可以通过配置 php.ini 文件改变它。同时你也可以通过自定义会话管理器来管理会话。自定义会话管理可以实现共享session。下面是利用 Redis 来实现 session 的存储的例子。\",\" class sysSession implements SessionHandlerInterface { private $client; private $exprie; public function __construct($client) { $this->client = $client; } public function setExprie($exprie) { $this->exprie = $exprie; } public function open($savePath, $sessionName) { return true; } public function close() { return true; } public function read($id) { return $this->client->get($id); } public function write($id, $data) { return $this->client->setsetEx($id, $this->exprie, $data); } public function destroy($id) { return $this->client->delete($id); } public function gc($lifetime) { return true; } } \",\"使用示例：\",\" $redis = new Redis; $redis->open(\\\"ip\\\", \\\"port\\\", \\\"timeout\\\"); $handler = new sysSession($redis); $handler->setExprie(3600); session_set_save_handler($handler, true); register_shutdown_function('session_write_close'); session_start(); \",\"你可以把session存储到一个公共的服务器或集群中，这样就可以实现共享session了\",\"关于session相关知识可以阅读PHP官方手册：http://php.net/manual/zh/session.examples.php 会话安全方面PHP官方手册进行了说明，地址：http://php.net/manual/zh/session.security.php 和 http://php.net/manual/zh/features.session.security.management.php\"]},\"89\":{\"h\":\"会话跨域和单点登录\",\"t\":[\"有的时候我们一个网站有很多服务模块，每个模块都有一个域名，这个时候我们想实现多个域名之间的会话管理，那应该怎么办呢？首先我们要知道跨域，浏览器有一种同源策略。比如： a.domin.com 不能访问 b.explame.com 下的cookie，因为他们不同源，如果是这两个域名 a.domain.com 和 b.domain.com 呢？这两个是同源域名，都属于 domain.com，看下列代码：\",\"<?php setcookie(\\\"TestCookie\\\", \\\"\\\", time() - 3600, \\\"/\\\", \\\"domain.com\\\", false, true); \",\"在PHP中通过上述代码就可以让a.domain.com 和 b.domain.com进行cookie之间的相互传递，然后在每次请求的时候把cookie相关信息带上，服务端实现session共享，就可以实现会话的跨域了。这个解决方案是解决了主域名和子域名下的会话管理问题，如果是多个不同的域名呢，应该怎么办？这个时候我们就要考虑到单点登录了\",\"关于单点登录，可以参考这篇文章：https://www.cnblogs.com/ywlaker/p/6113927.html 一般单点登录的使用场景是多系统之间。比如淘宝和天猫。淘宝和天猫是两种不同的系统，域名也不一样，但是你在淘宝上登录之后在天猫上也可以访问自己的个人中心。（所有的一切都是基于统一浏览器上）\",\"同样PHP有个比较好的项目叫做 UCenter，这个产品很好的实现了单点登录，可以自己动手实现下。\"]},\"90\":{\"h\":\"负载均衡\",\"t\":[\"当业务发展到一定程度之后，单台服务器就无法满足业务需求，这个时候就要考虑到使用集群方案。负载均衡是集群方案中的一种策略。负载均衡的主要作用就是根据不同的算法分发请求至服务集群中的某个节点。在PHP web开发中主要使用 Nginx或者 Apache 来做负载均衡执行者。在 Nginx 中主要采用反向代理的方式来实现负载均衡。Nginx默认采用轮询算法。同时还用 IP_hash 算法。Nginx 默认提供这两种算法，同时也支持第三方的算法。下面是这些算法的介绍。\",\"轮询算法(默认)\",\"每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\",\"upstream backserver { server 192.168.0.14; server 192.168.0.15; } \",\"同时也可以指定权重，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\",\"upstream backserver { server 192.168.0.14 weight=10; server 192.168.0.15 weight=10; } \",\"IP绑定 ip_hash\",\"每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\",\"upstream backserver { ip_hash; server 192.168.0.14:88; server 192.168.0.15:80; } \",\"当ip hash失效时，会退化为轮询策略，因此不会有丢失流量的情况。从这个层面上说，ip hash也可以看成是轮询的升级版。\",\"fair（第三方）\",\"按后端服务器的响应时间来分配请求，响应时间短的优先分配。\",\"upstream backserver { server server1; server server2; fair; } \",\"url_hash（第三方）\",\"按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\",\"upstream backserver { server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32; } \",\"关于Nginx负责均衡算法策略的选择，要根据业务场景来选择,一般选择的标准可以参考这三个指标：\",\"均衡性：是否能够将请求均匀的发送给后端\",\"一致性：同一个key的请求，是否能落到同一台机器\",\"容灾性：当部分后端机器挂掉时，是否能够正常工作 可以参考这篇文章：https://www.cnblogs.com/wpjamer/articles/6443332.html\",\"负载均衡相关知识可参考：https://blog.csdn.net/qq_27093465/article/details/78273656 关于Nginx轮询算法的解释可以看这篇文章：https://blog.csdn.net/itkingone/article/details/80365212\"]},\"91\":{\"h\":\"秒杀活动和超卖\",\"t\":[\"一般做程序开发都会遇到这种业务需求：秒杀活动。比如双十一的商品秒杀，某游戏的内测号等等。一般面试的时候问这个问题主要是考察候选人的综合能力。\"]},\"92\":{\"h\":\"秒杀设计\",\"t\":[\"首先考虑秒杀的场景，秒杀是指在指定时间范围内有限库存限制下的售卖行为。在时间范围内，随着请求的增加怎么保持服务的快速响应，怎么限制用户的下单行为，商品库存的增减等等都是要考虑的。我们一一分析下。\",\"高并发下的秒杀活动页面快速响应\",\"从前端来讲可以这样搞：\",\"页面静态化：像秒杀活动页面一般都是访问比较高的，商品信息和库存都是固定的。所以把页面进行静态化处理是一种很好的方法，同时可以使用JS异步请求服务端，做一些简单的逻辑处理。比如倒计时、购买按钮禁止，库存修改、禁止重复提交和无限刷新等。\",\"CDN加速：静态资源可以使用CDN加速。\",\"用户限流：在某一时间段内只允许用户提交一次请求，比如可以采取IP限流\",\"后端的角度可以这样搞：\",\"-在前端和后端服务之间增加一个中间层。一般这个中间层就是我们上文提到的负载均衡，通过负载均衡把请求分发到不同的节点。\",\"-限制同一UserID访问频率：尽量拦截浏览器请求，在服务端控制层需要针对同一个访问uid，限制访问频率。\",\"-业务分离:将秒杀业务系统和其他业务分离，单独放在专门用来做秒杀活动的服务器集群上。\",\"-采用消息队列缓存请求：将大流量请求写到消息队列缓存，利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求\",\"-利用缓存应对读请求：对于读多写少业务，大部分请求是查询请求，所以可以读写分离，利用缓存分担数据库压力\",\"-利用缓存应对写请求：缓存也是可以应对写请求的，可把数据库中的库存数据转移到Redis缓存中，所有减库存操作都在Redis中进行，然后再通过后台进程把Redis中的用户秒杀请求同步到数据库中。\",\"-随机选取用户执行秒杀逻辑，没有选取到的用户返回秒杀失败\",\"我们在创建秒杀活动的时候就要把商品相关信息写入到缓存中，比如商品实际库存、秒杀限制库存，商品相关信息等。\",\"我们可以采用Redis 最简单的key-value数据结构，用一个原子类型的变量值(AtomicInteger)作为key，把用户id作为value，库存数量便是原子变量的最大值。对于每个用户的秒杀，我们使用 RPUSH key value插入秒杀请求， 当插入的秒杀请求数达到上限时，停止所有后续插入。下面是简单样例：\",\"// 假设商品库存有10个,key键名为 goods.store $nums = $redis->get('goods.store'); if($nums<=0){ return false; } if ($redis->decr('goods.store')<0){ return false; } $redis->rpush('sale:1', 'uid') \",\"上面的示例中，我们定义了几个key，分别是：goods.store(商品库存)、sale:1(秒杀队列的key)，开始的时候我们判断商品库存是否小于等于0，成立的话就说明秒杀失败，不成立的话就对商品库存进行 decr 操作并判断是否小于0，成立说明秒杀失败，不成立的话就把秒杀用户ID加入到秒杀队列中，然后去消费秒杀队列，用户在对订单付完款之后减商品数据库库存，然后把用户ID加入到秒杀购买成功队列,如果订单在一定时间内不付款就把此订单状态改为失败然后redis里的 goods.store进行 incr 操作。\"]},\"93\":{\"h\":\"超卖问题\",\"t\":[\"关于超卖问题，一般都是在并发下，对库存的判断出现了问题，上个例子中已经采用了原子操作，可以极大可能的避免超卖，但是会导致少卖，同时也可以使用redis的乐观锁和事务实现：\",\"$redis->watch(key) if(redis->get(key) < 0){ echo '抢购失败';return false; } $redis->multi(); $redis->decr(key); $redis->rpush(); $redis-exec(); \"]},\"94\":{\"c\":[\"golang\"]},\"95\":{\"c\":[\"php\",\"面试\",\"面试总结\",\"php面试总结\"]},\"96\":{\"h\":\"Bar 功能\"},\"97\":{\"h\":\"介绍\",\"t\":[\"我们支持 bar 功能，...\"]},\"98\":{\"h\":\"详情\",\"t\":[\"baz\",\"...\"]},\"99\":{\"h\":\"Baz\",\"t\":[\"功能详情...\"]},\"100\":{\"h\":\"Foo 功能\"},\"101\":{\"h\":\"介绍\",\"t\":[\"我们支持 foo 功能，...\"]},\"102\":{\"h\":\"详情\",\"t\":[\"ray\",\"...\"]},\"103\":{\"h\":\"Ray\",\"t\":[\"功能详情...\"]},\"104\":{\"h\":\"Golang\"},\"105\":{\"h\":\"Mark\"},\"106\":{\"h\":\"Php\"}},\"dirtCount\":0,\"index\":[[\"详情\",{\"0\":{\"98\":1,\"102\":1}}],[\"详情容器\",{\"1\":{\"16\":1}}],[\"功能详情\",{\"1\":{\"99\":1,\"103\":1}}],[\"功能\",{\"0\":{\"96\":1,\"100\":1},\"1\":{\"97\":1,\"101\":1}}],[\"功能亮点\",{\"0\":{\"61\":1}}],[\"抢购失败\",{\"1\":{\"93\":1}}],[\"超卖问题\",{\"0\":{\"93\":1}}],[\"成立说明秒杀失败\",{\"1\":{\"92\":1}}],[\"成立的话就说明秒杀失败\",{\"1\":{\"92\":1}}],[\"假设商品库存有10个\",{\"1\":{\"92\":1}}],[\"假设表名为testcity\",{\"1\":{\"71\":1}}],[\"停止所有后续插入\",{\"1\":{\"92\":1}}],[\"库存数量便是原子变量的最大值\",{\"1\":{\"92\":1}}],[\"库存修改\",{\"1\":{\"92\":1}}],[\"把用户id作为value\",{\"1\":{\"92\":1}}],[\"作为key\",{\"1\":{\"92\":1}}],[\"作者设置为\",{\"1\":{\"40\":1}}],[\"最简单的key\",{\"1\":{\"92\":1}}],[\"最大连接数\",{\"1\":{\"79\":1}}],[\"没有选取到的用户返回秒杀失败\",{\"1\":{\"92\":1}}],[\"随机选取用户执行秒杀逻辑\",{\"1\":{\"92\":1}}],[\"随着请求的增加怎么保持服务的快速响应\",{\"1\":{\"92\":1}}],[\"缓存也是可以应对写请求的\",{\"1\":{\"92\":1}}],[\"大部分请求是查询请求\",{\"1\":{\"92\":1}}],[\"大多数mysql存储引擎都实现了b\",{\"1\":{\"70\":1}}],[\"利用缓存应对写请求\",{\"1\":{\"92\":1}}],[\"利用缓存应对读请求\",{\"1\":{\"92\":1}}],[\"利用缓存分担数据库压力\",{\"1\":{\"92\":1}}],[\"利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求\",{\"1\":{\"92\":1}}],[\"采用消息队列缓存请求\",{\"1\":{\"92\":1}}],[\"将大流量请求写到消息队列缓存\",{\"1\":{\"92\":1}}],[\"将秒杀业务系统和其他业务分离\",{\"1\":{\"92\":1}}],[\"将延时器放到for循环之外定义\",{\"1\":{\"53\":1}}],[\"业务分离\",{\"1\":{\"92\":1}}],[\"限制访问频率\",{\"1\":{\"92\":1}}],[\"限制同一userid访问频率\",{\"1\":{\"92\":1}}],[\"后端的角度可以这样搞\",{\"1\":{\"92\":1}}],[\"后端服务器为缓存时比较有效\",{\"1\":{\"90\":1}}],[\"静态资源可以使用cdn加速\",{\"1\":{\"92\":1}}],[\"禁止重复提交和无限刷新等\",{\"1\":{\"92\":1}}],[\"禁用\",{\"2\":{\"6\":1}}],[\"禁用了如下功能\",{\"1\":{\"4\":1}}],[\"禁用展示\",{\"1\":{\"2\":1,\"31\":1}}],[\"购买按钮禁止\",{\"1\":{\"92\":1}}],[\"做一些简单的逻辑处理\",{\"1\":{\"92\":1}}],[\"商品库存\",{\"1\":{\"92\":1}}],[\"商品库存的增减等等都是要考虑的\",{\"1\":{\"92\":1}}],[\"商品相关信息等\",{\"1\":{\"92\":1}}],[\"商品信息和库存都是固定的\",{\"1\":{\"92\":1}}],[\"像秒杀活动页面一般都是访问比较高的\",{\"1\":{\"92\":1}}],[\"高并发下的秒杀活动页面快速响应\",{\"1\":{\"92\":1}}],[\"怎么限制用户的下单行为\",{\"1\":{\"92\":1}}],[\"秒杀队列的key\",{\"1\":{\"92\":1}}],[\"秒杀限制库存\",{\"1\":{\"92\":1}}],[\"秒杀是指在指定时间范围内有限库存限制下的售卖行为\",{\"1\":{\"92\":1}}],[\"秒杀设计\",{\"0\":{\"92\":1}}],[\"秒杀活动\",{\"1\":{\"91\":1}}],[\"秒杀活动和超卖\",{\"0\":{\"91\":1}}],[\"某游戏的内测号等等\",{\"1\":{\"91\":1}}],[\"某次评估过程中如果有满足条件的case\",{\"1\":{\"52\":1}}],[\"qq\",{\"1\":{\"90\":1}}],[\"queries\",{\"1\":{\"66\":1}}],[\"query\",{\"1\":{\"66\":1,\"78\":2,\"79\":2}}],[\"容灾性\",{\"1\":{\"90\":1}}],[\"容量满之前不会阻塞\",{\"1\":{\"48\":1}}],[\"均衡性\",{\"1\":{\"90\":1}}],[\"按访问url的hash结果来分配请求\",{\"1\":{\"90\":1}}],[\"按后端服务器的响应时间来分配请求\",{\"1\":{\"90\":1}}],[\"响应时间短的优先分配\",{\"1\":{\"90\":1}}],[\"第三方\",{\"1\":{\"90\":2}}],[\"指定轮询几率\",{\"1\":{\"90\":1}}],[\"指南\",{\"0\":{\"60\":1}}],[\"能自动剔除\",{\"1\":{\"90\":1}}],[\"默认\",{\"1\":{\"90\":1}}],[\"默认提供这两种算法\",{\"1\":{\"90\":1}}],[\"轮询算法\",{\"1\":{\"90\":1}}],[\"算法\",{\"1\":{\"90\":1}}],[\"负载均衡相关知识可参考\",{\"1\":{\"90\":1}}],[\"负载均衡的主要作用就是根据不同的算法分发请求至服务集群中的某个节点\",{\"1\":{\"90\":1}}],[\"负载均衡是集群方案中的一种策略\",{\"1\":{\"90\":1}}],[\"负载均衡\",{\"0\":{\"90\":1}}],[\"域名也不一样\",{\"1\":{\"89\":1}}],[\"淘宝和天猫是两种不同的系统\",{\"1\":{\"89\":1}}],[\"ywlaker\",{\"1\":{\"89\":1}}],[\"应该怎么办\",{\"1\":{\"89\":1}}],[\"应该也使用defalut语句块\",{\"1\":{\"52\":1}}],[\"看下列代码\",{\"1\":{\"89\":1}}],[\"看上面的案例\",{\"1\":{\"53\":1}}],[\"呢\",{\"1\":{\"89\":1}}],[\"浏览器有一种同源策略\",{\"1\":{\"89\":1}}],[\"首先考虑秒杀的场景\",{\"1\":{\"92\":1}}],[\"首先我们要知道跨域\",{\"1\":{\"89\":1}}],[\"首先二级索引先找到主键\",{\"1\":{\"72\":1}}],[\"地址\",{\"1\":{\"88\":1}}],[\"格式如下\",{\"1\":{\"88\":1}}],[\"客户端收到cookie后会在每次请求的时候带上cookie\",{\"1\":{\"88\":1}}],[\"客户端和服务器端\",{\"1\":{\"88\":1}}],[\"正确的话就在服务器端生成一个唯一sessionid\",{\"1\":{\"88\":1}}],[\"总是会用到会话管理\",{\"1\":{\"88\":1}}],[\"跨域\",{\"0\":{\"87\":1}}],[\"及\",{\"1\":{\"86\":1}}],[\"让其对其他级别的错误进行处理\",{\"1\":{\"86\":1}}],[\"根据当前业务场景做出相应的动作\",{\"1\":{\"86\":2}}],[\"根据错误级别记录错误日志\",{\"1\":{\"86\":2}}],[\"根据实际业务创建相关汇总表和缓存表\",{\"1\":{\"66\":1}}],[\"判断错误级别是否是设置的\",{\"1\":{\"86\":1}}],[\">multi\",{\"1\":{\"93\":1}}],[\">watch\",{\"1\":{\"93\":1}}],[\">rpush\",{\"1\":{\"92\":1,\"93\":1}}],[\">decr\",{\"1\":{\"92\":1,\"93\":1}}],[\">delete\",{\"1\":{\"88\":1}}],[\">setexprie\",{\"1\":{\"88\":1}}],[\">setsetex\",{\"1\":{\"88\":1}}],[\">open\",{\"1\":{\"88\":1}}],[\">get\",{\"1\":{\"88\":1,\"92\":1,\"93\":1}}],[\">exprie\",{\"1\":{\"88\":2}}],[\">exceptionhandler\",{\"1\":{\"86\":1}}],[\">client\",{\"1\":{\"88\":4}}],[\">fatalexceptionfromerror\",{\"1\":{\"86\":1}}],[\">isfatal\",{\"1\":{\"86\":1}}],[\">\",{\"1\":{\"86\":1}}],[\"错误恢复脚本继续执行等等\",{\"1\":{\"86\":1}}],[\"错误和异常统一处理\",{\"1\":{\"86\":1}}],[\"错误异常处理类\",{\"1\":{\"86\":1}}],[\"错误处理\",{\"0\":{\"86\":1}}],[\"官方手册地址\",{\"1\":{\"86\":1}}],[\"模式来处理异常\",{\"1\":{\"86\":1}}],[\"异常处理\",{\"1\":{\"86\":1}}],[\"异步模式\",{\"1\":{\"48\":1}}],[\"80365212\",{\"1\":{\"90\":1}}],[\"80\",{\"1\":{\"90\":1}}],[\"8080\",{\"1\":{\"57\":1}}],[\"88\",{\"1\":{\"90\":1}}],[\"8\",{\"1\":{\"86\":1}}],[\"内置函数导致的\",{\"1\":{\"86\":1}}],[\"内容\",{\"1\":{\"13\":1}}],[\"描述了最后错误的信息\",{\"1\":{\"86\":1}}],[\"返回了一个关联数组\",{\"1\":{\"86\":1}}],[\"返回顶部按钮\",{\"1\":{\"4\":1,\"42\":1}}],[\"调用\",{\"1\":{\"86\":1}}],[\"调用servemux的servehttp方法来处理请求\",{\"1\":{\"57\":1}}],[\"设置将不会起到作用而你的错误处理函数继续会被调用\",{\"1\":{\"86\":1}}],[\"设计表的时候选择合适的数据类型\",{\"1\":{\"66\":1}}],[\"除了上述两个标准异常之外\",{\"1\":{\"86\":1}}],[\"除非回调函数返回了\",{\"1\":{\"86\":1}}],[\"除外的所有错误和警告信息\",{\"1\":{\"86\":1}}],[\"里指定的错误类型都会绕过\",{\"1\":{\"86\":1}}],[\"里面放一些case语句块\",{\"1\":{\"52\":1}}],[\"|\",{\"1\":{\"86\":4}}],[\"$nums<=0\",{\"1\":{\"92\":1}}],[\"$nums\",{\"1\":{\"92\":1}}],[\"$request\",{\"1\":{\"90\":1}}],[\"$redis\",{\"1\":{\"88\":3,\"92\":3,\"93\":5}}],[\"$handler\",{\"1\":{\"88\":3}}],[\"$data\",{\"1\":{\"88\":2}}],[\"$id\",{\"1\":{\"88\":6}}],[\"$sessionname\",{\"1\":{\"88\":1}}],[\"$server\",{\"1\":{\"84\":1}}],[\"$savepath\",{\"1\":{\"88\":1}}],[\"$client\",{\"1\":{\"88\":3}}],[\"$context\",{\"1\":{\"86\":1}}],[\"$\",{\"1\":{\"88\":2}}],[\"$a\",{\"1\":{\"86\":2}}],[\"$type\",{\"1\":{\"86\":2}}],[\"$traceoffset\",{\"1\":{\"86\":1}}],[\"$this\",{\"1\":{\"86\":6,\"88\":6}}],[\"$exprie\",{\"1\":{\"88\":3}}],[\"$e\",{\"1\":{\"86\":1}}],[\"$errline\",{\"1\":{\"86\":2}}],[\"$errfile\",{\"1\":{\"86\":2}}],[\"$errstr\",{\"1\":{\"86\":2}}],[\"$errno\",{\"1\":{\"86\":2}}],[\"$error\",{\"1\":{\"86\":11}}],[\"$lifetime\",{\"1\":{\"88\":1}}],[\"$line\",{\"1\":{\"86\":2}}],[\"$level\",{\"1\":{\"86\":3}}],[\"$file\",{\"1\":{\"86\":2}}],[\"$message\",{\"1\":{\"86\":2}}],[\"zh\",{\"1\":{\"86\":7,\"88\":3}}],[\"函数将错误信息托管至errorexception\",{\"1\":{\"86\":1}}],[\"函数所在文件中产生的大多数\",{\"1\":{\"86\":1}}],[\"函数来帮助开发者自定义异常处理行为\",{\"1\":{\"86\":1}}],[\"函数来注册这个方法\",{\"1\":{\"86\":1}}],[\"函数来设置错误级别\",{\"1\":{\"86\":1}}],[\"函数实现\",{\"1\":{\"86\":1}}],[\"启用后将会对在未来版本中可能无法正常工作的代码给出警告\",{\"1\":{\"86\":1}}],[\"启用\",{\"1\":{\"86\":1}}],[\"运行时通知\",{\"1\":{\"86\":2}}],[\"运行时警告\",{\"1\":{\"86\":1}}],[\"仅给出提示信息\",{\"1\":{\"86\":1}}],[\"非致命错误\",{\"1\":{\"86\":1}}],[\"非阻塞\",{\"1\":{\"48\":1}}],[\"致命错误和语法错误\",{\"1\":{\"86\":1}}],[\"致命错误\",{\"1\":{\"86\":1}}],[\"获取最后一次错误\",{\"1\":{\"86\":1}}],[\"获取最后发生的错误\",{\"1\":{\"86\":1}}],[\"获取到参数之后\",{\"1\":{\"84\":1}}],[\"获取\",{\"1\":{\"84\":1}}],[\"答案是可以的\",{\"1\":{\"84\":1}}],[\"通常错误会被转化为异常进行统一处理\",{\"1\":{\"86\":1}}],[\"通常我们在web模式下都会有个入口文件\",{\"1\":{\"84\":1}}],[\"通过负载均衡把请求分发到不同的节点\",{\"1\":{\"92\":1}}],[\"通过索引访问数据\",{\"1\":{\"73\":1}}],[\"通过\",{\"1\":{\"12\":1,\"15\":1}}],[\"嗯\",{\"1\":{\"83\":1}}],[\"今天面试主要和面试官讨论这些问题\",{\"1\":{\"83\":1}}],[\"手册地址\",{\"1\":{\"80\":1,\"86\":1}}],[\"属性\",{\"1\":{\"80\":1}}],[\"属于内存级别的通信\",{\"1\":{\"46\":1}}],[\"搞清楚文档\",{\"1\":{\"80\":1}}],[\"开始的时候我们判断商品库存是否小于等于0\",{\"1\":{\"92\":1}}],[\"开始执行命令start\",{\"1\":{\"80\":1}}],[\"开发者不需要考虑sessionid的问题\",{\"1\":{\"88\":1}}],[\"开启索引\",{\"0\":{\"69\":1}}],[\"命令\",{\"1\":{\"80\":1}}],[\"从前端来讲可以这样搞\",{\"1\":{\"92\":1}}],[\"从这个层面上说\",{\"1\":{\"90\":1}}],[\"从库启动复制\",{\"1\":{\"80\":1}}],[\"从库配置中继日志文件地址\",{\"1\":{\"80\":1}}],[\"从buffered\",{\"1\":{\"48\":1}}],[\"参考文章\",{\"1\":{\"80\":1}}],[\"78273656\",{\"1\":{\"90\":1}}],[\"7080278\",{\"1\":{\"80\":1}}],[\"7之前默认是基于语句\",{\"1\":{\"80\":1}}],[\"7\",{\"1\":{\"80\":1}}],[\"52035072\",{\"1\":{\"80\":1}}],[\"5238682\",{\"1\":{\"77\":1}}],[\"5764978\",{\"1\":{\"80\":1}}],[\"5\",{\"1\":{\"80\":1}}],[\"消耗资源多\",{\"1\":{\"80\":1}}],[\"顾名思义就是一行一行复制\",{\"1\":{\"80\":1}}],[\"基于行的复制\",{\"1\":{\"80\":1}}],[\"基于行\",{\"1\":{\"80\":1}}],[\"基于语句消耗资源少\",{\"1\":{\"80\":1}}],[\"基于语句\",{\"1\":{\"80\":1}}],[\"基本配置\",{\"1\":{\"79\":1}}],[\"备库\",{\"1\":{\"80\":1}}],[\"二进制日志\",{\"1\":{\"80\":1}}],[\"二级索引访问需要两次查找\",{\"1\":{\"72\":1}}],[\"复制慢\",{\"1\":{\"80\":1}}],[\"复制模式\",{\"1\":{\"80\":1}}],[\"复制\",{\"0\":{\"80\":1}}],[\"慢查询衡量标准\",{\"1\":{\"79\":1}}],[\"慢查询是否开启\",{\"1\":{\"79\":1}}],[\"慢查询日志\",{\"1\":{\"66\":1}}],[\"相对安全\",{\"1\":{\"78\":1}}],[\"相关参考文章\",{\"1\":{\"80\":1}}],[\"相关参数\",{\"1\":{\"78\":1,\"80\":1}}],[\"相关知识点\",{\"1\":{\"80\":1}}],[\"相关操作如下\",{\"1\":{\"67\":1}}],[\"相关信息\",{\"1\":{\"12\":1}}],[\"服务端实现session共享\",{\"1\":{\"89\":1}}],[\"服务器校验请求是否正确\",{\"1\":{\"88\":1}}],[\"服务器端响应\",{\"1\":{\"88\":1}}],[\"服务器端指的是session\",{\"1\":{\"88\":1}}],[\"服务器模式\",{\"1\":{\"79\":1}}],[\"服务器也只对器进行一次解析\",{\"1\":{\"78\":1}}],[\"服务的具体执行者就是我们的gin框架\",{\"1\":{\"57\":1}}],[\"节约内存和网络开销\",{\"1\":{\"78\":1}}],[\"以下是简单的实现思路\",{\"1\":{\"86\":1}}],[\"以下级别的错误不能由用户定义的函数来处理\",{\"1\":{\"86\":1}}],[\"以该错误的\",{\"1\":{\"86\":1}}],[\"以确保代码具有最佳的互操作性和向前兼容性\",{\"1\":{\"86\":1}}],[\"以二进制的方式向服务端发送参数和句柄\",{\"1\":{\"78\":1}}],[\"以便\",{\"1\":{\"10\":1}}],[\"绑定变量\",{\"0\":{\"78\":1}}],[\"之后基于行\",{\"1\":{\"80\":1}}],[\"之前的版本只有myisam支持\",{\"1\":{\"77\":1}}],[\"之间没有引用关系了\",{\"1\":{\"53\":1}}],[\"全文索引\",{\"1\":{\"77\":1}}],[\"视图\",{\"0\":{\"77\":1}}],[\"选择的列最好有索引\",{\"1\":{\"76\":1}}],[\"选择合适的索引顺序至关重要\",{\"1\":{\"72\":1}}],[\"简单了解下\",{\"1\":{\"76\":1}}],[\"简单的查询可以减少锁的竞争\",{\"1\":{\"74\":1}}],[\"`uri`\",{\"1\":{\"76\":1}}],[\"`ip`\",{\"1\":{\"76\":3}}],[\"`id`\",{\"1\":{\"76\":2}}],[\"`request\",{\"1\":{\"76\":4}}],[\"6113927\",{\"1\":{\"89\":1}}],[\"6版本innodb开始支持全文索引\",{\"1\":{\"77\":1}}],[\"63254901\",{\"1\":{\"77\":1}}],[\"6及以上可以放心大胆的去用子查询\",{\"1\":{\"74\":1}}],[\"6443332\",{\"1\":{\"90\":1}}],[\"64\",{\"1\":{\"57\":1}}],[\"合理使用子查询\",{\"1\":{\"74\":1}}],[\"子查询尽量少用\",{\"1\":{\"74\":1}}],[\"易缓存\",{\"1\":{\"74\":1}}],[\"拆分复杂的查询\",{\"1\":{\"74\":1}}],[\"减少了sql注入和攻击\",{\"1\":{\"78\":1}}],[\"减少冗余记录查询\",{\"1\":{\"74\":1}}],[\"减少查询时扫描的行数\",{\"1\":{\"74\":1}}],[\"减少不必要列的查询\",{\"1\":{\"74\":1}}],[\"建立合适的索引\",{\"1\":{\"74\":1}}],[\"建议指定确切路径和文件名\",{\"1\":{\"80\":1}}],[\"建议使用单调顺序自增类型\",{\"1\":{\"72\":1}}],[\"建议条件允许的情况下加上defer\",{\"1\":{\"47\":1}}],[\"尽量拦截浏览器请求\",{\"1\":{\"92\":1}}],[\"尽量优化查询\",{\"1\":{\"74\":1}}],[\"尽量使用not\",{\"1\":{\"66\":1}}],[\"速度慢的原因\",{\"1\":{\"73\":1}}],[\"单独放在专门用来做秒杀活动的服务器集群上\",{\"1\":{\"92\":1}}],[\"单台服务器就无法满足业务需求\",{\"1\":{\"90\":1}}],[\"单点登录\",{\"0\":{\"87\":1}}],[\"单位秒\",{\"1\":{\"79\":1}}],[\"单位字节\",{\"1\":{\"78\":1}}],[\"单列\",{\"1\":{\"73\":1}}],[\"单词\",{\"1\":{\"20\":1}}],[\"唯一索引\",{\"1\":{\"73\":1}}],[\"唯一索引无效\",{\"1\":{\"69\":1}}],[\"而不是一次\",{\"1\":{\"72\":1}}],[\"而是处理完被选中的case后进入下一轮select\",{\"1\":{\"52\":1}}],[\"而是等到receiver准备接收channel数据了\",{\"1\":{\"48\":1}}],[\"聚簇索引是一种数据存储方式\",{\"1\":{\"72\":1}}],[\"那应该怎么办呢\",{\"1\":{\"89\":1}}],[\"那就会喧杂一个唯一的非空索引替代\",{\"1\":{\"72\":1}}],[\"那这个索引就被称之为覆盖索引\",{\"1\":{\"72\":1}}],[\"那么命令模式下是不是也可以有个入口文件呢\",{\"1\":{\"84\":1}}],[\"那么索引应该这样加\",{\"1\":{\"72\":1}}],[\"那么只能用到范围查询之前的列\",{\"1\":{\"70\":1}}],[\"那么具体是怎么执行一个http请求的呢\",{\"1\":{\"57\":1}}],[\"计算的结果中值越接近1的就越往前\",{\"1\":{\"72\":1}}],[\"计划\",{\"1\":{\"23\":2}}],[\"列\",{\"1\":{\"72\":1}}],[\"列不要太多\",{\"1\":{\"66\":1}}],[\"多列索引及前缀索引\",{\"1\":{\"73\":1}}],[\"多列索引\",{\"0\":{\"72\":1}}],[\"key键名为\",{\"1\":{\"92\":1}}],[\"key分区\",{\"1\":{\"76\":1}}],[\"key\",{\"1\":{\"71\":1,\"72\":1,\"76\":2,\"92\":1,\"93\":3}}],[\"keys\",{\"1\":{\"68\":1,\"69\":1}}],[\"下的cookie\",{\"1\":{\"89\":1}}],[\"下面是简单样例\",{\"1\":{\"92\":1}}],[\"下面是这些算法的介绍\",{\"1\":{\"90\":1}}],[\"下面是利用\",{\"1\":{\"88\":1}}],[\"下面是对这几种错误级别的介绍\",{\"1\":{\"86\":1}}],[\"下面添加一个前缀索引\",{\"1\":{\"71\":1}}],[\"下一篇\",{\"1\":{\"4\":1}}],[\"字符串列名为\",{\"1\":{\"71\":1}}],[\"前缀的语句发生错误时\",{\"1\":{\"86\":1}}],[\"前缀索引更小\",{\"1\":{\"71\":1}}],[\"前缀索引主要是对字符串类型的列取公共前缀进行索引\",{\"1\":{\"71\":1}}],[\"前缀索引\",{\"0\":{\"71\":1}}],[\"前面都是在for无限循环中读取channel中的数据\",{\"1\":{\"51\":1}}],[\"避免排序和临时表\",{\"1\":{\"70\":1}}],[\"避免使用字符串类型\",{\"1\":{\"66\":1}}],[\"要根据业务场景来选择\",{\"1\":{\"90\":1}}],[\"要控制合适的分区的个数\",{\"1\":{\"76\":1}}],[\"要优化了\",{\"1\":{\"71\":1}}],[\"要是单独的列\",{\"1\":{\"70\":1}}],[\"要命的还在后头\",{\"1\":{\"53\":1}}],[\"右边的用不到\",{\"1\":{\"70\":1}}],[\"索引和值分离\",{\"1\":{\"73\":1}}],[\"索引可以将随机i\",{\"1\":{\"70\":1}}],[\"索引可以减少服务器扫描的数据量\",{\"1\":{\"70\":1}}],[\"索引中列的顺序不同效果也不一样\",{\"1\":{\"70\":1}}],[\"索引中的列不能被跳过\",{\"1\":{\"70\":1}}],[\"索引总是遵循最左前缀\",{\"1\":{\"70\":1}}],[\"索引相关\",{\"0\":{\"70\":1}}],[\"等待数据载入之后开启索引\",{\"1\":{\"67\":1}}],[\"慎用\",{\"1\":{\"67\":1}}],[\"状态的\",{\"1\":{\"66\":1}}],[\"比如商品实际库存\",{\"1\":{\"92\":1}}],[\"比如可以采取ip限流\",{\"1\":{\"92\":1}}],[\"比如倒计时\",{\"1\":{\"92\":1}}],[\"比如双十一的商品秒杀\",{\"1\":{\"91\":1}}],[\"比如淘宝和天猫\",{\"1\":{\"89\":1}}],[\"比如用户登录\",{\"1\":{\"88\":1}}],[\"比如错误页面啊\",{\"1\":{\"86\":1}}],[\"比如在开发模式下\",{\"1\":{\"86\":2}}],[\"比如thinkphp5和yii框架都实现了这个功能\",{\"1\":{\"84\":1}}],[\"比如有存储过程的语句\",{\"1\":{\"80\":1}}],[\"比如自增id\",{\"1\":{\"72\":1}}],[\"比如下面这个语句\",{\"1\":{\"72\":1}}],[\"比如\",{\"1\":{\"72\":1,\"76\":2,\"84\":1,\"89\":1}}],[\"比如locked\",{\"1\":{\"66\":1}}],[\"比如从ch1\",{\"1\":{\"52\":1}}],[\"查看binlog日志的名字\",{\"1\":{\"80\":1}}],[\"查看详情\",{\"1\":{\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1}}],[\"查询优化相关\",{\"0\":{\"74\":1}}],[\"查询中的条件的列不能是一个表达式或函数的参数\",{\"1\":{\"70\":1}}],[\"查询sql数据表关联不要过多\",{\"1\":{\"66\":1}}],[\"查询数\",{\"1\":{\"66\":1}}],[\"查询线程数\",{\"1\":{\"66\":1}}],[\"记录所有的查询\",{\"1\":{\"66\":1}}],[\"持久性\",{\"1\":{\"65\":1}}],[\"隔离性\",{\"1\":{\"65\":1}}],[\"原子性\",{\"1\":{\"65\":1}}],[\"原因在于\",{\"1\":{\"53\":1}}],[\"数据存储方式不一样\",{\"1\":{\"65\":1}}],[\"数据未读就表示未send成功\",{\"1\":{\"48\":1}}],[\"也就是把索引和列的值存在一起\",{\"1\":{\"73\":1}}],[\"也就是多版本并发控制\",{\"1\":{\"65\":1}}],[\"也就是说两端都因为对方而使得自己当前处于阻塞状态\",{\"1\":{\"49\":1}}],[\"串行化\",{\"1\":{\"65\":1}}],[\"可把数据库中的库存数据转移到redis缓存中\",{\"1\":{\"92\":1}}],[\"可重写errorhandler方法\",{\"1\":{\"86\":1}}],[\"可重复读\",{\"1\":{\"65\":1}}],[\"可在\",{\"1\":{\"86\":1}}],[\"可忽略\",{\"1\":{\"86\":1}}],[\"可以极大可能的避免超卖\",{\"1\":{\"93\":1}}],[\"可以解决session的问题\",{\"1\":{\"90\":1}}],[\"可以自己动手实现下\",{\"1\":{\"89\":1}}],[\"可以参考这篇文章\",{\"1\":{\"89\":1,\"90\":1}}],[\"可以使用set\",{\"1\":{\"86\":1}}],[\"可以使用表连接代替\",{\"1\":{\"74\":1}}],[\"可以减少资源占用\",{\"1\":{\"74\":1}}],[\"可以通过\",{\"1\":{\"84\":1}}],[\"可以通过show\",{\"1\":{\"80\":1}}],[\"可以通过参数设置\",{\"1\":{\"80\":1}}],[\"可以通过如下语句来计算\",{\"1\":{\"71\":1}}],[\"可以通过不断比较公共前缀出现的次数和总记录的商来取前缀\",{\"1\":{\"71\":1}}],[\"可以通过伪哈希索引的手段来优化查询语句\",{\"1\":{\"70\":1}}],[\"可以通过long\",{\"1\":{\"66\":1}}],[\"可以先关闭索引\",{\"1\":{\"67\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"10\":1}}],[\"分别是\",{\"1\":{\"88\":1,\"92\":1}}],[\"分别是未提交读\",{\"1\":{\"65\":1}}],[\"分区列不能在表达式中\",{\"1\":{\"76\":1}}],[\"分区列和索引列匹配\",{\"1\":{\"76\":1}}],[\"分区的维护成本比较高\",{\"1\":{\"76\":1}}],[\"分区的时候最好不要选择默认为null的列\",{\"1\":{\"76\":1}}],[\"分区在查询的时候需要锁住所有的底层表\",{\"1\":{\"76\":1}}],[\"分区\",{\"0\":{\"76\":1},\"1\":{\"76\":1}}],[\"分解关联查询\",{\"1\":{\"74\":1}}],[\"分类为\",{\"1\":{\"40\":1}}],[\"支持表级锁\",{\"1\":{\"65\":1}}],[\"支持四个事务隔离级别\",{\"1\":{\"65\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"24\":1}}],[\"锁级别是行级锁\",{\"1\":{\"65\":1}}],[\"面试总结\",{\"2\":{\"59\":1,\"82\":1,\"95\":1}}],[\"面试\",{\"2\":{\"59\":1,\"82\":1,\"95\":1}}],[\"源码\",{\"2\":{\"59\":1}}],[\"处理业务逻辑有很大的帮助\",{\"1\":{\"86\":1}}],[\"处理并相应\",{\"1\":{\"57\":1}}],[\"处理监听serve\",{\"1\":{\"57\":1}}],[\"方法让错误和异常都在这里进行处理\",{\"1\":{\"86\":1}}],[\"方法如下\",{\"1\":{\"71\":1}}],[\"方法来执行具体的gin\",{\"1\":{\"57\":1}}],[\"方法执行完毕关闭当前连接\",{\"1\":{\"57\":1}}],[\"方法代码如下\",{\"1\":{\"57\":1}}],[\"4<<10\",{\"1\":{\"57\":1}}],[\"xianid就不是覆盖索引\",{\"1\":{\"72\":1}}],[\"xianid就是cityid的覆盖索引\",{\"1\":{\"72\":1}}],[\"xianid\",{\"1\":{\"72\":4}}],[\"x\",{\"1\":{\"57\":1,\"72\":1}}],[\"即自定义异常来捕获\",{\"1\":{\"86\":1}}],[\"即基于行和基于语句一起使用\",{\"1\":{\"80\":1}}],[\"即交由gin来处理请求\",{\"1\":{\"57\":1}}],[\"即每次一个http请求都会建立一个连接\",{\"1\":{\"57\":1}}],[\"即先执行读取的\",{\"1\":{\"46\":1}}],[\"创建一个新的连接\",{\"1\":{\"57\":1}}],[\"创建一个无缓冲的chan\",{\"1\":{\"47\":1}}],[\"经过一系列相关处理\",{\"1\":{\"57\":1}}],[\"然后把用户id加入到秒杀购买成功队列\",{\"1\":{\"92\":1}}],[\"然后去消费秒杀队列\",{\"1\":{\"92\":1}}],[\"然后再通过后台进程把redis中的用户秒杀请求同步到数据库中\",{\"1\":{\"92\":1}}],[\"然后在每次请求的时候把cookie相关信息带上\",{\"1\":{\"89\":1}}],[\"然后通过http协议把这个sessionid放到cookie里返回给客户端\",{\"1\":{\"88\":1}}],[\"然后通过索引找到磁盘相应数据\",{\"1\":{\"73\":1}}],[\"然后通过主键找到具体的值\",{\"1\":{\"72\":1}}],[\"然后开一个goruntine处理这个连接\",{\"1\":{\"57\":1}}],[\"然后accept阻塞直到返回下一个链接\",{\"1\":{\"57\":1}}],[\"然后阻塞\",{\"1\":{\"48\":1}}],[\"监听端口\",{\"1\":{\"57\":1}}],[\"监听http端口\",{\"1\":{\"57\":1}}],[\"具体参考\",{\"1\":{\"86\":1}}],[\"具体可参考\",{\"1\":{\"86\":1}}],[\"具体可参考php官方手册\",{\"1\":{\"86\":1}}],[\"具体可以参考\",{\"1\":{\"76\":1,\"77\":1}}],[\"具体使用方法可以参考php官方手册\",{\"1\":{\"86\":1}}],[\"具体相关实现可以参考\",{\"1\":{\"80\":1}}],[\"具体视图相关可以参考\",{\"1\":{\"77\":1}}],[\"具体处理请求的代码是这个\",{\"1\":{\"57\":1}}],[\"具体连接的处理在conn\",{\"1\":{\"57\":1}}],[\"具体要看\",{\"1\":{\"57\":1}}],[\"具体的执行请求返回响应的方法\",{\"1\":{\"57\":1}}],[\"需要特别注意的是带\",{\"1\":{\"86\":1}}],[\"需要监听端口\",{\"1\":{\"57\":1}}],[\"需要注意的是要记住\",{\"1\":{\"86\":1}}],[\"需要注意的是\",{\"1\":{\"52\":1}}],[\"构建server\",{\"1\":{\"57\":1}}],[\"构建servemux\",{\"0\":{\"57\":1}}],[\"添加路由\",{\"1\":{\"57\":1}}],[\"初始化全局中间件\",{\"1\":{\"57\":1}}],[\"初始化gin\",{\"1\":{\"57\":1}}],[\"uid\",{\"1\":{\"92\":1}}],[\"uri\",{\"1\":{\"90\":1}}],[\"url\",{\"1\":{\"90\":1}}],[\"upstream\",{\"1\":{\"90\":5}}],[\"ucenter\",{\"1\":{\"89\":1}}],[\"undefined\",{\"1\":{\"86\":1}}],[\"unique\",{\"1\":{\"76\":1}}],[\"unescape\",{\"1\":{\"57\":1}}],[\"until\",{\"1\":{\"57\":1}}],[\"unbuffered\",{\"1\":{\"48\":3}}],[\"user\",{\"1\":{\"86\":5}}],[\"user=\",{\"1\":{\"80\":1}}],[\"use\",{\"1\":{\"57\":1}}],[\"实现了http\",{\"1\":{\"57\":1}}],[\"实际的文章内容\",{\"1\":{\"7\":1}}],[\"接口只包含一个方法\",{\"1\":{\"57\":1}}],[\"接收\",{\"1\":{\"47\":1}}],[\"防止了内存泄漏\",{\"1\":{\"53\":1}}],[\"防止内存泄漏\",{\"1\":{\"53\":1}}],[\"改进方法如下\",{\"1\":{\"53\":1}}],[\"清除的\",{\"1\":{\"53\":1}}],[\"被抛弃的\",{\"1\":{\"53\":1}}],[\"了\",{\"1\":{\"53\":1}}],[\"给清理掉了\",{\"1\":{\"53\":1}}],[\"global\",{\"1\":{\"66\":1}}],[\"globaloptionshandler\",{\"1\":{\"57\":1}}],[\"given\",{\"1\":{\"57\":1}}],[\"gin中主要通过context\",{\"1\":{\"57\":1}}],[\"gin\",{\"1\":{\"57\":2},\"2\":{\"59\":1}}],[\"gin框架构建servemux流程如下\",{\"1\":{\"57\":1}}],[\"gin框架也实现了这个\",{\"1\":{\"57\":1}}],[\"getvalue\",{\"1\":{\"57\":1}}],[\"get\",{\"1\":{\"57\":4,\"86\":2}}],[\"gc\",{\"1\":{\"53\":2,\"88\":1}}],[\"goods\",{\"1\":{\"92\":5}}],[\"going\",{\"1\":{\"57\":1}}],[\"golang通过gin框架创建http服务源码剖析\",{\"0\":{\"56\":1}}],[\"golang\",{\"0\":{\"104\":1},\"2\":{\"54\":1,\"58\":1,\"94\":1}}],[\"goruntine\",{\"1\":{\"53\":2}}],[\"goroutines\",{\"1\":{\"49\":1,\"51\":1}}],[\"goroutine中进行的\",{\"1\":{\"49\":2}}],[\"goroutine\",{\"1\":{\"46\":6,\"49\":2,\"51\":1,\"57\":1}}],[\"go提供了一个select语句块\",{\"1\":{\"52\":1}}],[\"go将探测到此问题\",{\"1\":{\"49\":1}}],[\"go\",{\"1\":{\"48\":4,\"49\":1,\"50\":2,\"51\":2,\"52\":3,\"53\":2,\"57\":1},\"2\":{\"55\":1,\"59\":1}}],[\"却又发现和\",{\"1\":{\"53\":1}}],[\"时\",{\"1\":{\"53\":1}}],[\"语句里有变量的\",{\"1\":{\"80\":1}}],[\"语句\",{\"1\":{\"53\":1}}],[\"语法\",{\"0\":{\"30\":1},\"1\":{\"15\":1}}],[\"语法进行了扩展\",{\"1\":{\"14\":1}}],[\"语法扩展\",{\"1\":{\"13\":1}}],[\"再加上\",{\"1\":{\"53\":1}}],[\"准确使用定时器\",{\"0\":{\"53\":1}}],[\"达到终止循环的效果\",{\"1\":{\"52\":1}}],[\"执行响应的逻辑\",{\"1\":{\"84\":1}}],[\"执行速度快\",{\"1\":{\"80\":1}}],[\"执行具体的handlerfunc\",{\"1\":{\"57\":1}}],[\"执行这段代码\",{\"1\":{\"52\":1}}],[\"执行default\",{\"1\":{\"52\":1}}],[\"一致性\",{\"1\":{\"65\":1,\"90\":1}}],[\"一般这个中间层就是我们上文提到的负载均衡\",{\"1\":{\"92\":1}}],[\"一般面试的时候问这个问题主要是考察候选人的综合能力\",{\"1\":{\"91\":1}}],[\"一般做程序开发都会遇到这种业务需求\",{\"1\":{\"91\":1}}],[\"一般选择的标准可以参考这三个指标\",{\"1\":{\"90\":1}}],[\"一般单点登录的使用场景是多系统之间\",{\"1\":{\"89\":1}}],[\"一般客户端指的是cookie\",{\"1\":{\"88\":1}}],[\"一般处理错误的时候需要进行\",{\"1\":{\"86\":1}}],[\"一般处理错误的时候需要进行以下几点\",{\"1\":{\"86\":1}}],[\"一般在框架中都会封装一套属于框架自身的错误和异常处理模块\",{\"1\":{\"86\":1}}],[\"一般在做错误处理的时候这个函数会被register\",{\"1\":{\"86\":1}}],[\"一般php常见的错误级别有这几种\",{\"1\":{\"86\":1}}],[\"一般编程语言都有自己的错误处理机制\",{\"1\":{\"86\":1}}],[\"一般的框架都会实现命令的注册\",{\"1\":{\"84\":1}}],[\"一般最简单的实现就是如下\",{\"1\":{\"84\":1}}],[\"一般最多12个表\",{\"1\":{\"66\":1}}],[\"一般是机器ip32位的后八位\",{\"1\":{\"80\":1}}],[\"一般都是在并发下\",{\"1\":{\"93\":1}}],[\"一般都是在实际应用中采用混合模式复制\",{\"1\":{\"80\":1}}],[\"一般都是通过\",{\"1\":{\"53\":1}}],[\"一般来说\",{\"1\":{\"52\":1}}],[\"一直轮询channel的可读事件\",{\"1\":{\"52\":1}}],[\"一个拥有\",{\"1\":{\"20\":1}}],[\"保证send不会被阻塞\",{\"1\":{\"52\":1}}],[\"本次select就不会出现阻塞的情况\",{\"1\":{\"52\":1}}],[\"本页面就是一个示例\",{\"1\":{\"4\":1}}],[\"就可以实现会话的跨域了\",{\"1\":{\"89\":1}}],[\"就把错误全面的展现出来\",{\"1\":{\"86\":2}}],[\"就是把php文件当做脚本执行的一种方式\",{\"1\":{\"84\":1}}],[\"就会调用都\",{\"1\":{\"53\":1}}],[\"就会出现死锁\",{\"1\":{\"49\":1}}],[\"就不难理解只有所有case都不满足条件时\",{\"1\":{\"52\":1}}],[\"其他的错误进行了忽略\",{\"1\":{\"86\":1}}],[\"其中\",{\"1\":{\"72\":1}}],[\"其实如果注意到select语句是在某一个goroutine中评估的\",{\"1\":{\"52\":1}}],[\"其它的case都不会被阻塞\",{\"1\":{\"52\":1}}],[\"当插入的秒杀请求数达到上限时\",{\"1\":{\"92\":1}}],[\"当部分后端机器挂掉时\",{\"1\":{\"90\":1}}],[\"当ip\",{\"1\":{\"90\":1}}],[\"当业务发展到一定程度之后\",{\"1\":{\"90\":1}}],[\"当找到索引也就找到了数据\",{\"1\":{\"73\":1}}],[\"当需要访问数据时\",{\"1\":{\"73\":1}}],[\"当使用explain分析查询语句时\",{\"1\":{\"71\":1}}],[\"当值为0时\",{\"1\":{\"66\":1}}],[\"当select中的case都在禁用状态\",{\"1\":{\"52\":1}}],[\"当select未在循环中时\",{\"1\":{\"52\":1}}],[\"当channel的某一端\",{\"1\":{\"49\":1}}],[\"或者能确保select不阻塞的语句块\",{\"1\":{\"52\":1}}],[\"或者结束select\",{\"1\":{\"52\":1}}],[\"或者讲无缓冲chan设置为有缓冲chan\",{\"1\":{\"49\":1}}],[\"则迟早会被send阻塞\",{\"1\":{\"52\":1}}],[\"则可能会永远被send阻塞\",{\"1\":{\"52\":1}}],[\"则所有其它case都直接结束评估\",{\"1\":{\"52\":1}}],[\"则执行default\",{\"1\":{\"52\":1}}],[\"则随机选择一个进行处理\",{\"1\":{\"52\":1}}],[\"则阻塞直到某个语句块可以被处理\",{\"1\":{\"52\":1}}],[\"bbc\",{\"1\":{\"80\":1}}],[\"bin\",{\"1\":{\"80\":3}}],[\"binlogname\",{\"1\":{\"80\":1}}],[\"binlog\",{\"1\":{\"80\":2}}],[\"blog\",{\"1\":{\"77\":1,\"80\":2,\"90\":2}}],[\"by中无法使用\",{\"1\":{\"71\":1}}],[\"by语句中也会用到索引\",{\"1\":{\"70\":1}}],[\"by\",{\"1\":{\"70\":1,\"71\":1,\"76\":1}}],[\"bytes\",{\"1\":{\"57\":1}}],[\"byte\",{\"1\":{\"57\":1}}],[\"b\",{\"1\":{\"70\":1,\"89\":3}}],[\"but\",{\"1\":{\"57\":1}}],[\"buffer\",{\"1\":{\"79\":1}}],[\"buffer命中时\",{\"1\":{\"73\":1}}],[\"buffer把索引先缓存到内存中\",{\"1\":{\"73\":1}}],[\"buffered\",{\"1\":{\"48\":1}}],[\"bufw\",{\"1\":{\"57\":1}}],[\"bufr\",{\"1\":{\"57\":1}}],[\"buf\",{\"1\":{\"57\":5}}],[\"between\",{\"1\":{\"76\":1}}],[\"because\",{\"1\":{\"57\":1}}],[\"be\",{\"1\":{\"57\":1}}],[\"before\",{\"1\":{\"57\":1}}],[\"body\",{\"1\":{\"57\":5}}],[\"backserver\",{\"1\":{\"90\":5}}],[\"background\",{\"1\":{\"57\":1}}],[\"baz\",{\"0\":{\"99\":1},\"1\":{\"62\":1,\"98\":1}}],[\"bar\",{\"0\":{\"62\":1,\"96\":1},\"1\":{\"97\":1}}],[\"basecontext\",{\"1\":{\"57\":3}}],[\"basectx\",{\"1\":{\"57\":4}}],[\"break\",{\"1\":{\"57\":1}}],[\"break是退出当前select\",{\"1\":{\"52\":1}}],[\"break关键字中断\",{\"1\":{\"52\":1}}],[\"不成立的话就把秒杀用户id加入到秒杀队列中\",{\"1\":{\"92\":1}}],[\"不成立的话就对商品库存进行\",{\"1\":{\"92\":1}}],[\"不能访问\",{\"1\":{\"89\":1}}],[\"不错\",{\"1\":{\"83\":1}}],[\"不同的是两者实现的存储方式不一样\",{\"1\":{\"73\":1}}],[\"不过你仍然可以获取\",{\"1\":{\"86\":1}}],[\"不过这次我们不是比较前缀出现的次数而是整个列的记录不重复的次数\",{\"1\":{\"72\":1}}],[\"不过在order\",{\"1\":{\"71\":1}}],[\"不允许fall\",{\"1\":{\"52\":1}}],[\"不是容量为1的buffered\",{\"1\":{\"48\":1}}],[\"所谓会话管理指的是因为http协议是无状态的一种协议\",{\"1\":{\"88\":1}}],[\"所有减库存操作都在redis中进行\",{\"1\":{\"92\":1}}],[\"所有的一切都是基于统一浏览器上\",{\"1\":{\"89\":1}}],[\"所有的错误和异常都在这里进行处理\",{\"1\":{\"86\":1}}],[\"所有的异常处理类都继承它\",{\"1\":{\"86\":1}}],[\"所有的case块都是按源代码书写顺序进行评估的\",{\"1\":{\"52\":1}}],[\"所有case都不满足条件时\",{\"1\":{\"52\":1}}],[\"所以可以读写分离\",{\"1\":{\"92\":1}}],[\"所以把页面进行静态化处理是一种很好的方法\",{\"1\":{\"92\":1}}],[\"所以\",{\"1\":{\"52\":1}}],[\"所以default必须要可执行而不能阻塞\",{\"1\":{\"52\":1}}],[\"所以对已经关闭的chan进行send操作会引发panic\",{\"1\":{\"48\":1}}],[\"所以每发送一个数据就被阻塞\",{\"1\":{\"48\":1}}],[\"用一个原子类型的变量值\",{\"1\":{\"92\":1}}],[\"用于后端服务器性能不均的情况\",{\"1\":{\"90\":1}}],[\"用于端到端的数据传输\",{\"1\":{\"46\":1}}],[\"用户在对订单付完款之后减商品数据库库存\",{\"1\":{\"92\":1}}],[\"用户限流\",{\"1\":{\"92\":1}}],[\"用户发起登录请求\",{\"1\":{\"88\":1}}],[\"用户级别的错误有\",{\"1\":{\"86\":1}}],[\"用法示例\",{\"1\":{\"52\":1}}],[\"用来轮询每个case语句块的send或recv情况\",{\"1\":{\"52\":1}}],[\"它将索引和列的值存储在一起\",{\"1\":{\"72\":1}}],[\"它将只对所有case评估一次\",{\"1\":{\"52\":1}}],[\"它的行为如下\",{\"1\":{\"52\":1}}],[\"它像switch一样工作\",{\"1\":{\"52\":1}}],[\"它会返回每次迭代过程中所读取的数据\",{\"1\":{\"51\":1}}],[\"很多时候想要同时操作多个channel\",{\"1\":{\"52\":1}}],[\"必须注意\",{\"1\":{\"51\":1}}],[\"但脚本仍会结束\",{\"1\":{\"86\":1}}],[\"但重点在于计时器激活后\",{\"1\":{\"53\":1}}],[\"但是会导致少卖\",{\"1\":{\"93\":1}}],[\"但是你在淘宝上登录之后在天猫上也可以访问自己的个人中心\",{\"1\":{\"89\":1}}],[\"但是你需要使用相对链接\",{\"1\":{\"41\":1}}],[\"但是在可以正常运行的脚本里面也可能会有类似的通知\",{\"1\":{\"86\":1}}],[\"但是在数据更改比较大的情况下\",{\"1\":{\"80\":1}}],[\"但是脚本不会终止运行\",{\"1\":{\"86\":1}}],[\"但是这个问题不是那么简单的\",{\"1\":{\"84\":1}}],[\"但是很多情况下无法正确复制数据\",{\"1\":{\"80\":1}}],[\"但是特消耗存储空间\",{\"1\":{\"72\":1}}],[\"但是我们代码运行下来发现是一直输出数据\",{\"1\":{\"53\":1}}],[\"但也可以用来向channel发送数据\",{\"1\":{\"52\":1}}],[\"但也可以使用range来迭代channel\",{\"1\":{\"51\":1}}],[\"但允许case语句块为空块\",{\"1\":{\"52\":1}}],[\"产生死锁\",{\"1\":{\"51\":1}}],[\"若没有此操作\",{\"1\":{\"51\":1}}],[\"若没有缓冲数据\",{\"1\":{\"47\":1}}],[\"open\",{\"1\":{\"88\":1}}],[\"operator\",{\"1\":{\"86\":1}}],[\"options\",{\"1\":{\"57\":2}}],[\"o\",{\"1\":{\"70\":1}}],[\"o变为顺序i\",{\"1\":{\"70\":1}}],[\"of\",{\"1\":{\"57\":1}}],[\"off\",{\"1\":{\"57\":1}}],[\"or\",{\"1\":{\"57\":1}}],[\"origlistener\",{\"1\":{\"57\":1}}],[\"only\",{\"1\":{\"79\":1}}],[\"one\",{\"1\":{\"57\":1}}],[\"on\",{\"1\":{\"57\":3}}],[\"out通道只用于发送数据\",{\"1\":{\"51\":1}}],[\"out\",{\"1\":{\"51\":1}}],[\"ok\",{\"1\":{\"48\":2,\"52\":4}}],[\"表\",{\"1\":{\"72\":1}}],[\"表压缩\",{\"1\":{\"65\":1}}],[\"表明这个chan参数只能进行读取操作\",{\"1\":{\"51\":1}}],[\"表示脚本遇到可能会表现为错误的情况\",{\"1\":{\"86\":1}}],[\"表示无数据再需发送\",{\"1\":{\"51\":1}}],[\"表示channel\",{\"1\":{\"51\":2}}],[\"表示关闭channel\",{\"1\":{\"47\":1}}],[\"表示receiver端的goroutine从channel中读取数据\",{\"1\":{\"47\":1}}],[\"表示sender端的goroutine向channel中投放数据\",{\"1\":{\"47\":1}}],[\"同一个key的请求\",{\"1\":{\"90\":1}}],[\"同样php有个比较好的项目叫做\",{\"1\":{\"89\":1}}],[\"同时可以使用js异步请求服务端\",{\"1\":{\"92\":1}}],[\"同时也可以使用redis的乐观锁和事务实现\",{\"1\":{\"93\":1}}],[\"同时也可以指定权重\",{\"1\":{\"90\":1}}],[\"同时也支持第三方的算法\",{\"1\":{\"90\":1}}],[\"同时也支持索引间隙锁\",{\"1\":{\"65\":1}}],[\"同时还用\",{\"1\":{\"90\":1}}],[\"同时还有别的分区\",{\"1\":{\"76\":1}}],[\"同时你也可以通过自定义会话管理器来管理会话\",{\"1\":{\"88\":1}}],[\"同时php也提供了\",{\"1\":{\"86\":1}}],[\"同时用户也可以设置自身的错误级别\",{\"1\":{\"86\":1}}],[\"同时在备库上也建议指定中继日志\",{\"1\":{\"80\":1}}],[\"同时达到了3秒程序结束的效果\",{\"1\":{\"53\":1}}],[\"同时我们在检测到chan关闭时\",{\"1\":{\"52\":1}}],[\"同时上面的案例中\",{\"1\":{\"51\":1}}],[\"同步模式\",{\"1\":{\"48\":1}}],[\"任务完成后对chan进行读操作\",{\"1\":{\"51\":1}}],[\"任务列表\",{\"0\":{\"23\":1}}],[\"每个请求按访问ip的hash结果分配\",{\"1\":{\"90\":1}}],[\"每个请求按时间顺序逐一分配到不同的后端服务器\",{\"1\":{\"90\":1}}],[\"每个模块都有一个域名\",{\"1\":{\"89\":1}}],[\"每个框架的处理机制不一样\",{\"1\":{\"84\":1}}],[\"每个连接中都会被赋予server的信息\",{\"1\":{\"57\":1}}],[\"每个channel都有3种操作\",{\"1\":{\"47\":1}}],[\"每次最多并发执行10个\",{\"1\":{\"51\":1}}],[\"nginx默认采用轮询算法\",{\"1\":{\"90\":1}}],[\"nginx\",{\"1\":{\"90\":2}}],[\"nginx或者\",{\"1\":{\"90\":1}}],[\"name\",{\"1\":{\"68\":1,\"69\":1}}],[\"null\",{\"1\":{\"66\":1,\"76\":4,\"86\":3}}],[\"notice\",{\"1\":{\"86\":3}}],[\"not\",{\"1\":{\"57\":2,\"76\":3}}],[\"next\",{\"1\":{\"57\":3}}],[\"never\",{\"1\":{\"57\":1}}],[\"need\",{\"1\":{\"57\":1}}],[\"newbufiowritersize\",{\"1\":{\"57\":1}}],[\"newbufioreader\",{\"1\":{\"57\":1}}],[\"newconn\",{\"1\":{\"57\":1}}],[\"new\",{\"1\":{\"57\":1,\"86\":3,\"88\":2}}],[\"net\",{\"1\":{\"57\":4,\"77\":1,\"80\":2,\"86\":9,\"88\":3,\"90\":2}}],[\"nil\",{\"1\":{\"52\":2,\"57\":12}}],[\"n\",{\"1\":{\"51\":1,\"57\":1}}],[\"案例中我们生成100个任务\",{\"1\":{\"51\":1}}],[\"案例\",{\"1\":{\"51\":2,\"52\":1}}],[\"两种\",{\"1\":{\"80\":1}}],[\"两者都支持\",{\"1\":{\"73\":1}}],[\"两者一直处于阻塞\",{\"1\":{\"48\":1}}],[\"两次索引查找\",{\"1\":{\"72\":1}}],[\"两个协程之间通过ch进行通信\",{\"1\":{\"50\":1}}],[\"否则f2一直阻塞\",{\"1\":{\"50\":1}}],[\"3128\",{\"1\":{\"90\":2}}],[\"3600\",{\"1\":{\"88\":1,\"89\":1}}],[\"3625522\",{\"1\":{\"76\":1}}],[\"30\",{\"1\":{\"76\":1}}],[\"3秒后才会被触发去执行某些事\",{\"1\":{\"53\":1}}],[\"3\",{\"1\":{\"50\":1,\"51\":1,\"53\":2,\"71\":2,\"80\":1}}],[\"distinct\",{\"1\":{\"71\":1,\"72\":2}}],[\"disable\",{\"1\":{\"68\":1}}],[\"duration\",{\"1\":{\"57\":1}}],[\"d\",{\"1\":{\"51\":1}}],[\"domain\",{\"1\":{\"89\":6}}],[\"domin\",{\"1\":{\"89\":1}}],[\"docs\",{\"1\":{\"80\":1}}],[\"do\",{\"1\":{\"51\":2,\"52\":2}}],[\"done\",{\"1\":{\"50\":2,\"51\":2,\"52\":2}}],[\"decr\",{\"1\":{\"92\":1}}],[\"destroy\",{\"1\":{\"88\":1}}],[\"desc\",{\"1\":{\"25\":1}}],[\"deprecated\",{\"1\":{\"86\":3}}],[\"deployed\",{\"1\":{\"57\":1}}],[\"details\",{\"1\":{\"77\":1,\"80\":2,\"90\":2}}],[\"delegates\",{\"1\":{\"57\":1}}],[\"defalut语句是可选的\",{\"1\":{\"52\":1}}],[\"default404body\",{\"1\":{\"57\":1}}],[\"defaultservemux\",{\"1\":{\"57\":2}}],[\"default\",{\"1\":{\"52\":1,\"76\":2}}],[\"defer\",{\"1\":{\"50\":3,\"51\":1,\"52\":2,\"57\":2}}],[\"deadlock\",{\"0\":{\"49\":1},\"1\":{\"49\":1,\"51\":1}}],[\"wpjamer\",{\"1\":{\"90\":1}}],[\"www\",{\"1\":{\"76\":1,\"77\":1,\"80\":1,\"86\":1,\"89\":1,\"90\":1}}],[\"warning\",{\"1\":{\"86\":5}}],[\"was\",{\"1\":{\"57\":1}}],[\"wait\",{\"1\":{\"50\":1,\"51\":1,\"52\":1}}],[\"waitgroup\",{\"1\":{\"50\":1,\"51\":1,\"52\":1}}],[\"write\",{\"1\":{\"88\":2}}],[\"writeheadernow\",{\"1\":{\"57\":1}}],[\"writermem\",{\"1\":{\"57\":3}}],[\"wrap\",{\"1\":{\"57\":1}}],[\"wild\",{\"1\":{\"57\":1}}],[\"wire\",{\"1\":{\"57\":1}}],[\"with\",{\"1\":{\"57\":1}}],[\"withcancel\",{\"1\":{\"57\":1}}],[\"withvalue\",{\"1\":{\"57\":2}}],[\"weight=10\",{\"1\":{\"90\":2}}],[\"weight和访问比率成正比\",{\"1\":{\"90\":1}}],[\"web开发中主要使用\",{\"1\":{\"90\":1}}],[\"well\",{\"1\":{\"57\":1}}],[\"we\",{\"1\":{\"57\":5}}],[\"w\",{\"1\":{\"57\":18}}],[\"wg\",{\"1\":{\"50\":5,\"51\":4,\"52\":5}}],[\"where条件要包含分区列\",{\"1\":{\"76\":1}}],[\"where\",{\"1\":{\"25\":1,\"72\":2,\"76\":1}}],[\"解决方法\",{\"1\":{\"49\":1}}],[\"更快\",{\"1\":{\"71\":1}}],[\"更通俗地说\",{\"1\":{\"49\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"42\":1}}],[\"更新时间\",{\"1\":{\"4\":1}}],[\"另一端正好在期待本端的操作时\",{\"1\":{\"49\":1}}],[\"操作并判断是否小于0\",{\"1\":{\"92\":1}}],[\"操作在大多数情况下都会锁表\",{\"1\":{\"67\":1}}],[\"操作\",{\"1\":{\"49\":1,\"92\":1}}],[\"期待另一端的\",{\"1\":{\"49\":1}}],[\"死锁\",{\"0\":{\"49\":1}}],[\"于是sender被阻塞\",{\"1\":{\"48\":1}}],[\"使每个url定向到同一个后端服务器\",{\"1\":{\"90\":1}}],[\"使之可以使用到覆盖索引\",{\"1\":{\"74\":1}}],[\"使数据访问更快\",{\"1\":{\"72\":1}}],[\"使用示例\",{\"1\":{\"88\":1}}],[\"使用索引\",{\"1\":{\"66\":1}}],[\"使用\",{\"1\":{\"66\":1,\"86\":1}}],[\"使用show\",{\"1\":{\"66\":1}}],[\"使用range读取ch将会发生panic\",{\"1\":{\"51\":1}}],[\"使用了有缓冲的chan\",{\"1\":{\"51\":1}}],[\"使用指南\",{\"1\":{\"40\":2},\"2\":{\"3\":1,\"5\":1,\"8\":1,\"37\":1,\"43\":1,\"44\":1}}],[\"使得recv操作无法被执行\",{\"1\":{\"49\":1}}],[\"使得sender不会阻塞\",{\"1\":{\"48\":1}}],[\"都属于\",{\"1\":{\"89\":1}}],[\"都会重新初始化一个全新的计时器\",{\"1\":{\"53\":1}}],[\"都是在向channel发送请求\",{\"1\":{\"48\":1}}],[\"都将会阻塞\",{\"1\":{\"47\":1}}],[\"无论是send还是recv操作\",{\"1\":{\"48\":1}}],[\"无缓冲同步通信示例\",{\"0\":{\"50\":1}}],[\"无缓冲\",{\"1\":{\"48\":3}}],[\"并在每次运行时进行gc操作\",{\"1\":{\"88\":1}}],[\"并做适当处理\",{\"1\":{\"86\":1}}],[\"并通过goruntine来处理这个连接\",{\"1\":{\"57\":1}}],[\"并发\",{\"2\":{\"55\":1}}],[\"并发送第二个数据的时候才被阻塞\",{\"1\":{\"48\":1}}],[\"并退出此次select\",{\"1\":{\"52\":1}}],[\"并报错\",{\"1\":{\"49\":1}}],[\"并且重建整表\",{\"1\":{\"67\":1}}],[\"并且不会推出main\",{\"1\":{\"53\":1}}],[\"并且遵循了\",{\"1\":{\"46\":1}}],[\"并且在用户态上实现了属于自己的调度模型\",{\"1\":{\"46\":1}}],[\"注册到脚本运行结束前\",{\"1\":{\"86\":1}}],[\"注意\",{\"1\":{\"48\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"39\":1}}],[\"先进先出\",{\"1\":{\"48\":1}}],[\"先发送数据的\",{\"1\":{\"46\":1}}],[\"<0\",{\"1\":{\"92\":1}}],[\"<<\",{\"1\":{\"57\":1}}],[\"<\",{\"1\":{\"48\":4,\"49\":7,\"50\":2,\"51\":7,\"52\":7,\"53\":6,\"57\":2,\"86\":2,\"89\":1,\"93\":1}}],[\"直到channel被关闭\",{\"1\":{\"51\":1}}],[\"直到channel为空\",{\"1\":{\"48\":1}}],[\"直到channel容量已满\",{\"1\":{\"48\":1}}],[\"直到sender端向channel发送了一个数据\",{\"1\":{\"48\":1}}],[\"直到receiver端将此数据receive\",{\"1\":{\"48\":1}}],[\"阻塞和不阻塞是由channel控制的\",{\"1\":{\"48\":1}}],[\"阻塞\",{\"1\":{\"48\":1}}],[\"有的时候我们一个网站有很多服务模块\",{\"1\":{\"89\":1}}],[\"有的时候php本身对错误的处理难以满足我们的业务需求\",{\"1\":{\"86\":1}}],[\"有利于后期排查\",{\"1\":{\"86\":2}}],[\"有缓冲chan一般在进行并发限制的时候用的较多\",{\"1\":{\"51\":1}}],[\"有缓冲chan\",{\"0\":{\"51\":1}}],[\"有缓冲\",{\"1\":{\"48\":3}}],[\"有属于自己的栈空间\",{\"1\":{\"46\":1}}],[\"如果订单在一定时间内不付款就把此订单状态改为失败然后redis里的\",{\"1\":{\"92\":1}}],[\"如果后端服务器down掉\",{\"1\":{\"90\":1}}],[\"如果是多个不同的域名呢\",{\"1\":{\"89\":1}}],[\"如果是这两个域名\",{\"1\":{\"89\":1}}],[\"如果是生产模式下就要进行优雅的错误处理\",{\"1\":{\"86\":2}}],[\"如果是nil则使用默认的defaultservemux\",{\"1\":{\"57\":1}}],[\"如果还没有错误则返回\",{\"1\":{\"86\":1}}],[\"如果该错误由\",{\"1\":{\"86\":1}}],[\"如果非要使用的话不要设置太大的内存占用\",{\"1\":{\"78\":1}}],[\"如果没有符合条件的\",{\"1\":{\"72\":1}}],[\"如果没有default\",{\"1\":{\"52\":1}}],[\"如果表中没有定义主键\",{\"1\":{\"72\":1}}],[\"如果一个索引包含所有要查询字段的值\",{\"1\":{\"72\":1}}],[\"如果一个查询中有范围查询\",{\"1\":{\"70\":1}}],[\"如果索引类型为index\",{\"1\":{\"71\":1}}],[\"如果在select中执行send操作\",{\"1\":{\"52\":1}}],[\"如果存在default且其它case都不满足条件\",{\"1\":{\"52\":1}}],[\"如果select不在循环中或循环次数结束\",{\"1\":{\"52\":1}}],[\"如果select在循环中\",{\"1\":{\"52\":1}}],[\"如果多个case同时满足条件\",{\"1\":{\"52\":1}}],[\"如果所有的case语句块评估时都被阻塞\",{\"1\":{\"52\":1}}],[\"如果使用close\",{\"1\":{\"47\":1}}],[\"如果你不了解它\",{\"1\":{\"12\":1}}],[\"如果你是一个新手\",{\"1\":{\"11\":1}}],[\"因为他们不同源\",{\"1\":{\"89\":1}}],[\"因为myisam的索引和数据是分开存储存储的\",{\"1\":{\"73\":1}}],[\"因为innodb是顺序插入的\",{\"1\":{\"72\":1}}],[\"因为没有人需要\",{\"1\":{\"53\":1}}],[\"因为\",{\"1\":{\"53\":1}}],[\"因为关闭通道是针对发送数据而言的\",{\"1\":{\"51\":1}}],[\"因为关闭通道意味着没有数据再需要发送\",{\"1\":{\"47\":1}}],[\"因为容量为1的channel\",{\"1\":{\"48\":1}}],[\"因此不会有丢失流量的情况\",{\"1\":{\"90\":1}}],[\"因此很合理的也就被\",{\"1\":{\"53\":1}}],[\"因此在每次进行\",{\"1\":{\"53\":1}}],[\"因此可以借助于\",{\"1\":{\"13\":1}}],[\"因此\",{\"1\":{\"10\":1}}],[\"只用于接收数据的通道<\",{\"1\":{\"51\":1}}],[\"只需将send操作放在另一个goroutine中执行即可\",{\"1\":{\"49\":1}}],[\"只要有一个case满足条件\",{\"1\":{\"52\":1}}],[\"只要所有goroutine都被阻塞\",{\"1\":{\"49\":1}}],[\"只要channel未关闭\",{\"1\":{\"51\":1}}],[\"只要channel非空\",{\"1\":{\"48\":1}}],[\"只要channel容量未满\",{\"1\":{\"48\":2}}],[\"只在sender端上显式使用close\",{\"1\":{\"47\":1}}],[\"只不过\",{\"1\":{\"46\":2}}],[\"来做负载均衡执行者\",{\"1\":{\"90\":1}}],[\"来实现\",{\"1\":{\"88\":1}}],[\"来关闭channel\",{\"1\":{\"47\":1}}],[\"来解析\",{\"1\":{\"13\":1}}],[\"关于超卖问题\",{\"1\":{\"93\":1}}],[\"关于nginx轮询算法的解释可以看这篇文章\",{\"1\":{\"90\":1}}],[\"关于nginx负责均衡算法策略的选择\",{\"1\":{\"90\":1}}],[\"关于单点登录\",{\"1\":{\"89\":1}}],[\"关于session相关知识可以阅读php官方手册\",{\"1\":{\"88\":1}}],[\"关于这些扩展\",{\"1\":{\"14\":1}}],[\"关联字段\",{\"1\":{\"80\":1}}],[\"关闭索引\",{\"0\":{\"68\":1}}],[\"关闭通道是没有意义的\",{\"1\":{\"51\":1}}],[\"关闭channel\",{\"1\":{\"47\":1}}],[\"关闭channel后\",{\"1\":{\"47\":2}}],[\"sale\",{\"1\":{\"92\":2}}],[\"save\",{\"1\":{\"88\":1}}],[\"squid2\",{\"1\":{\"90\":1}}],[\"squid1\",{\"1\":{\"90\":1}}],[\"sql\",{\"1\":{\"79\":1}}],[\"sql语句查看当前连接线程是否有废线程\",{\"1\":{\"66\":1}}],[\"sql语句查看当前连接数\",{\"1\":{\"66\":1}}],[\"syssession\",{\"1\":{\"88\":2}}],[\"sync\",{\"1\":{\"50\":1,\"51\":1,\"52\":1}}],[\"spl\",{\"1\":{\"86\":1}}],[\"spl提供了一系列标准异常\",{\"1\":{\"86\":1}}],[\"sphinxsearch\",{\"1\":{\"80\":1}}],[\"sphinx全文索引\",{\"1\":{\"80\":1}}],[\"slave\",{\"1\":{\"80\":1}}],[\"slow\",{\"1\":{\"79\":1}}],[\"sleep\",{\"1\":{\"50\":1,\"51\":1,\"57\":1}}],[\"shutdown\",{\"1\":{\"86\":3,\"88\":1}}],[\"shuttingdown\",{\"1\":{\"57\":1}}],[\"show\",{\"1\":{\"66\":1}}],[\"sh\",{\"1\":{\"57\":2}}],[\"soar\",{\"1\":{\"80\":1}}],[\"so\",{\"1\":{\"57\":1}}],[\"simultaneous\",{\"1\":{\"57\":1}}],[\"size缓冲池大小\",{\"1\":{\"79\":1}}],[\"size查询缓存的总内存空间\",{\"1\":{\"78\":1}}],[\"size\",{\"1\":{\"57\":2,\"79\":2}}],[\"support\",{\"1\":{\"57\":1}}],[\"success\",{\"1\":{\"51\":1}}],[\"s\",{\"1\":{\"57\":2}}],[\"srv即为server\",{\"1\":{\"57\":1}}],[\"srv\",{\"1\":{\"57\":14}}],[\"store进行\",{\"1\":{\"92\":1}}],[\"store\",{\"1\":{\"57\":1,\"92\":4}}],[\"start\",{\"1\":{\"88\":1}}],[\"startbackgroundread\",{\"1\":{\"57\":2}}],[\"stack\",{\"1\":{\"57\":1}}],[\"statement\",{\"1\":{\"80\":1}}],[\"stateactive\",{\"1\":{\"57\":1}}],[\"stateclosed\",{\"1\":{\"57\":1}}],[\"statenew\",{\"1\":{\"57\":1}}],[\"statusnotfound\",{\"1\":{\"57\":1}}],[\"status\",{\"1\":{\"51\":2,\"66\":1,\"80\":1}}],[\"strpos\",{\"1\":{\"86\":1}}],[\"strict\",{\"1\":{\"86\":5}}],[\"strictly\",{\"1\":{\"57\":1}}],[\"string\",{\"1\":{\"51\":1,\"57\":1}}],[\"struct\",{\"1\":{\"51\":1,\"57\":1}}],[\"security\",{\"1\":{\"88\":2}}],[\"second\",{\"1\":{\"50\":1,\"51\":1,\"53\":2}}],[\"sessionhandlerinterface\",{\"1\":{\"88\":1}}],[\"session\",{\"1\":{\"88\":8}}],[\"session和cookie的关系\",{\"1\":{\"88\":1}}],[\"sel的值越接近1越好\",{\"1\":{\"71\":1}}],[\"sel\",{\"1\":{\"71\":1}}],[\"select的方式进行使用\",{\"1\":{\"53\":1}}],[\"select的行为模式主要是对channel是否可读进行轮询\",{\"1\":{\"52\":1}}],[\"select将会结束\",{\"1\":{\"52\":1}}],[\"select确实是随机选择case进行执行\",{\"1\":{\"52\":1}}],[\"select会放在一个无限循环语句中\",{\"1\":{\"52\":1}}],[\"select会被return\",{\"1\":{\"52\":1}}],[\"select所在goroutine才会被阻塞\",{\"1\":{\"52\":1}}],[\"select\",{\"1\":{\"52\":2,\"53\":5,\"71\":1,\"72\":3,\"76\":1}}],[\"select多路监听\",{\"0\":{\"52\":1}}],[\"serialized\",{\"1\":{\"57\":1}}],[\"serving\",{\"1\":{\"57\":1}}],[\"serveerror\",{\"1\":{\"57\":1}}],[\"serve中\",{\"1\":{\"57\":1}}],[\"serve\",{\"1\":{\"57\":5}}],[\"server2\",{\"1\":{\"90\":1}}],[\"server1\",{\"1\":{\"90\":1}}],[\"serverhandler\",{\"1\":{\"57\":5}}],[\"servercontextkey\",{\"1\":{\"57\":1}}],[\"server\",{\"1\":{\"57\":10,\"90\":10}}],[\"servehttp\",{\"1\":{\"57\":8}}],[\"setcookie\",{\"1\":{\"89\":1}}],[\"setexprie\",{\"1\":{\"88\":1}}],[\"set\",{\"1\":{\"86\":8,\"88\":1}}],[\"setreaddeadline\",{\"1\":{\"57\":1}}],[\"settrue\",{\"1\":{\"57\":1}}],[\"setstate\",{\"1\":{\"57\":3}}],[\"sendexpectationfailed\",{\"1\":{\"57\":1}}],[\"sender\",{\"1\":{\"49\":2}}],[\"sender每发送一个数据\",{\"1\":{\"48\":1}}],[\"sender发送一个数据\",{\"1\":{\"48\":1}}],[\"sender端可以向channel中send多个数据\",{\"1\":{\"48\":1}}],[\"sender端向channel中send一个数据\",{\"1\":{\"48\":1}}],[\"send的时候会直接阻塞main\",{\"1\":{\"49\":1}}],[\"send和recv是一个整体行为\",{\"1\":{\"48\":1}}],[\"send操作将导致painc\",{\"1\":{\"47\":1}}],[\"send\",{\"1\":{\"47\":2,\"48\":2,\"49\":3}}],[\"svg\",{\"1\":{\"25\":1}}],[\"读锁又被称为共享锁\",{\"1\":{\"65\":1}}],[\"读取请求内容\",{\"1\":{\"57\":1}}],[\"读\",{\"1\":{\"47\":1}}],[\"发送\",{\"1\":{\"47\":1}}],[\"写锁被称为排它锁\",{\"1\":{\"65\":1}}],[\"写\",{\"1\":{\"47\":1}}],[\"写作日期为\",{\"1\":{\"40\":1}}],[\"声明一个chan\",{\"1\":{\"47\":1}}],[\"声明和创建\",{\"0\":{\"47\":1}}],[\"会退化为轮询策略\",{\"1\":{\"90\":1}}],[\"会话跨域和单点登录\",{\"0\":{\"89\":1}}],[\"会话安全方面php官方手册进行了说明\",{\"1\":{\"88\":1}}],[\"会话是由客户端发起请求\",{\"1\":{\"88\":1}}],[\"会话管理主要有两个部分组成\",{\"1\":{\"88\":1}}],[\"会话管理\",{\"0\":{\"87\":1,\"88\":1}}],[\"会以该函数名开头\",{\"1\":{\"86\":1}}],[\"会导致脚本终止运行\",{\"1\":{\"86\":1}}],[\"会自行创建一个隐式主键\",{\"1\":{\"72\":1}}],[\"会先输入数据\",{\"1\":{\"46\":1}}],[\"会先获取到数据\",{\"1\":{\"46\":1}}],[\"会使用\",{\"1\":{\"13\":1}}],[\"特性\",{\"1\":{\"46\":1}}],[\"features\",{\"1\":{\"88\":1}}],[\"free\",{\"1\":{\"66\":1}}],[\"from\",{\"1\":{\"57\":1,\"71\":1,\"72\":3,\"76\":1}}],[\"frontmatter\",{\"1\":{\"4\":1,\"12\":3,\"40\":1,\"42\":1}}],[\"foo\",{\"0\":{\"63\":1,\"100\":1},\"1\":{\"101\":1}}],[\"format\",{\"1\":{\"80\":1}}],[\"for在循环时\",{\"1\":{\"53\":1}}],[\"for+select\",{\"1\":{\"53\":1}}],[\"for\",{\"1\":{\"48\":2,\"51\":3,\"52\":2,\"53\":5,\"57\":5}}],[\"fullpath\",{\"1\":{\"57\":2}}],[\"function\",{\"1\":{\"57\":1,\"86\":13,\"88\":9}}],[\"func\",{\"1\":{\"48\":4,\"49\":4,\"50\":3,\"51\":5,\"52\":4,\"53\":4,\"57\":9}}],[\"file=\",{\"1\":{\"80\":1}}],[\"file\",{\"1\":{\"79\":1,\"84\":1,\"86\":3}}],[\"find\",{\"1\":{\"57\":2}}],[\"finishrequest\",{\"1\":{\"57\":1}}],[\"fifo\",{\"1\":{\"46\":1,\"48\":1}}],[\"fair\",{\"1\":{\"90\":2}}],[\"failure\",{\"1\":{\"57\":1}}],[\"false\",{\"1\":{\"57\":1,\"86\":1,\"89\":1,\"92\":2,\"93\":1}}],[\"fatalexceptionfromerror\",{\"1\":{\"86\":1}}],[\"fatal\",{\"1\":{\"49\":1,\"51\":1}}],[\"f2\",{\"1\":{\"50\":3}}],[\"f1\",{\"1\":{\"50\":3}}],[\"fmt\",{\"1\":{\"48\":5,\"49\":5,\"50\":2,\"51\":1,\"52\":4}}],[\"在服务端控制层需要针对同一个访问uid\",{\"1\":{\"92\":1}}],[\"在前端和后端服务之间增加一个中间层\",{\"1\":{\"92\":1}}],[\"在某一时间段内只允许用户提交一次请求\",{\"1\":{\"92\":1}}],[\"在某些时候可以自动被关闭\",{\"1\":{\"47\":1}}],[\"在时间范围内\",{\"1\":{\"92\":1}}],[\"在\",{\"1\":{\"90\":1}}],[\"在web开发中\",{\"1\":{\"88\":1}}],[\"在php\",{\"1\":{\"90\":1}}],[\"在php中通过上述代码就可以让a\",{\"1\":{\"89\":1}}],[\"在php中采用\",{\"1\":{\"86\":1}}],[\"在php7以上\",{\"1\":{\"86\":1}}],[\"在主服务器上创建一个复制账号\",{\"1\":{\"80\":1}}],[\"在高并发的情况下建议关闭查询缓存\",{\"1\":{\"78\":1}}],[\"在进行分区查询的时候\",{\"1\":{\"76\":1}}],[\"在内存中直接搜索索引\",{\"1\":{\"73\":1}}],[\"在设计innodb主键的时候\",{\"1\":{\"72\":1}}],[\"在实际业务中可以通过使用相同的列不同的顺序来创建更多的索引\",{\"1\":{\"70\":1}}],[\"在order\",{\"1\":{\"70\":1}}],[\"在并发高的情况下进行读写操作的时候性能很差\",{\"1\":{\"65\":1}}],[\"在select查询中加上limit关键字\",{\"1\":{\"74\":1}}],[\"在serverhandler的servehttp方法中判断server的handler是否为nil\",{\"1\":{\"57\":1}}],[\"在sender和receiver接收到ok消息之前\",{\"1\":{\"48\":1}}],[\"在定时任务未到期之前\",{\"1\":{\"53\":1}}],[\"在使用的时候要正确使用\",{\"1\":{\"53\":1}}],[\"在使用send的时候\",{\"1\":{\"52\":1}}],[\"在go中提供了定时器功能\",{\"1\":{\"53\":1}}],[\"在go的内部行为中\",{\"1\":{\"48\":1}}],[\"在task的do方法中我们使用指向的chan\",{\"1\":{\"51\":1}}],[\"在任务执行之前对chan进行写操作\",{\"1\":{\"51\":1}}],[\"在上面的示例中\",{\"1\":{\"49\":1}}],[\"在多并发操作里是属于协程安全的\",{\"1\":{\"46\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"4\":1}}],[\"概念\",{\"1\":{\"46\":1}}],[\"这两个是同源域名\",{\"1\":{\"89\":1}}],[\"这会带来很多的开销\",{\"1\":{\"76\":1}}],[\"这也就是为什么索引不在key\",{\"1\":{\"73\":1}}],[\"这里我们的handler是由gin框架实现的一个servemux\",{\"1\":{\"57\":1}}],[\"这里涉及到了\",{\"1\":{\"46\":1}}],[\"这样每个访客固定访问一个后端服务器\",{\"1\":{\"90\":1}}],[\"这样每次循环的时候就不会对time\",{\"1\":{\"53\":1}}],[\"这样就可以实现共享session了\",{\"1\":{\"88\":1}}],[\"这样就限制了goruntine的个数\",{\"1\":{\"51\":1}}],[\"这样可以在查询的时候减少分区的扫描\",{\"1\":{\"76\":1}}],[\"这样才能用到索引\",{\"1\":{\"70\":1}}],[\"这就会导致严重的内存泄漏\",{\"1\":{\"53\":1}}],[\"这个产品很好的实现了单点登录\",{\"1\":{\"89\":1}}],[\"这个解决方案是解决了主域名和子域名下的会话管理问题\",{\"1\":{\"89\":1}}],[\"这个类只对致命性错误和语法错误进行防范处理\",{\"1\":{\"86\":1}}],[\"这个值会是\",{\"1\":{\"86\":1}}],[\"这个时候就要考虑到使用集群方案\",{\"1\":{\"90\":1}}],[\"这个时候我们就要考虑到单点登录了\",{\"1\":{\"89\":1}}],[\"这个时候我们想实现多个域名之间的会话管理\",{\"1\":{\"89\":1}}],[\"这个时候我们可以自定义一个错误处理方法来接管php本身的错误处理方式\",{\"1\":{\"86\":1}}],[\"这个时候idx\",{\"1\":{\"72\":1}}],[\"这个机制对调试应用程序\",{\"1\":{\"86\":1}}],[\"这个可以通过阅读框架的源码看下\",{\"1\":{\"84\":1}}],[\"这个就是命令模式下的入口文件\",{\"1\":{\"84\":1}}],[\"这个就是go高并发的原理\",{\"1\":{\"57\":1}}],[\"这个入口文件叫\",{\"1\":{\"84\":1}}],[\"这个方法对主键\",{\"1\":{\"69\":1}}],[\"这个特性会导致\",{\"1\":{\"65\":1}}],[\"这个操作可以让当前case禁用\",{\"1\":{\"52\":1}}],[\"这个是go中特有的\",{\"1\":{\"51\":1}}],[\"这次结束后就结束select\",{\"1\":{\"52\":1}}],[\"这时将会出现死锁问题\",{\"1\":{\"49\":1}}],[\"这有点像我们平常使用的消息队列\",{\"1\":{\"46\":1}}],[\"这是脚注内容\",{\"1\":{\"36\":1}}],[\"cdn加速\",{\"1\":{\"92\":1}}],[\"crc32\",{\"1\":{\"90\":1}}],[\"create\",{\"1\":{\"76\":1}}],[\"class\",{\"1\":{\"86\":5,\"88\":1}}],[\"close并非强制需要使用close\",{\"1\":{\"47\":1}}],[\"close\",{\"1\":{\"47\":1,\"48\":3,\"50\":1,\"51\":1,\"52\":4,\"57\":1,\"88\":2}}],[\"csdn\",{\"1\":{\"77\":1,\"80\":2,\"90\":2}}],[\"cnblogs\",{\"1\":{\"76\":1,\"77\":1,\"80\":1,\"89\":1,\"90\":1}}],[\"c>x\",{\"1\":{\"72\":1}}],[\"cityid\",{\"1\":{\"72\":9}}],[\"city\",{\"1\":{\"71\":3}}],[\"curreq\",{\"1\":{\"57\":1}}],[\"catch\",{\"1\":{\"86\":1}}],[\"callable\",{\"1\":{\"86\":1}}],[\"cache\",{\"1\":{\"78\":2,\"79\":1}}],[\"cannot\",{\"1\":{\"57\":1}}],[\"canwritecontinue\",{\"1\":{\"57\":1}}],[\"cancelctx\",{\"1\":{\"57\":5}}],[\"can\",{\"1\":{\"57\":2}}],[\"case\",{\"1\":{\"52\":4,\"53\":4}}],[\"cc\",{\"1\":{\"57\":3}}],[\"ctx\",{\"1\":{\"57\":9}}],[\"c\",{\"1\":{\"57\":60,\"72\":1,\"86\":1}}],[\"charset=utf8\",{\"1\":{\"76\":1}}],[\"change\",{\"1\":{\"80\":1}}],[\"chan不可被关闭\",{\"1\":{\"51\":1}}],[\"chan<\",{\"1\":{\"51\":1}}],[\"chan进行send\",{\"1\":{\"47\":1}}],[\"chan\",{\"1\":{\"47\":4,\"48\":4,\"49\":4,\"50\":1,\"51\":5,\"52\":2,\"53\":2}}],[\"channel中send数据的操作ch\",{\"1\":{\"49\":1}}],[\"channel中按序receive其中数据\",{\"1\":{\"48\":1}}],[\"channel不会返回ok消息\",{\"1\":{\"48\":1}}],[\"channel不会向sender返回ok\",{\"1\":{\"48\":1}}],[\"channel都会向其返回ok消息\",{\"1\":{\"48\":1}}],[\"channel都会向sender的请求直接返回一个ok消息\",{\"1\":{\"48\":1}}],[\"channel才会向sender和receiver双方发送ok消息\",{\"1\":{\"48\":1}}],[\"channel暂时不会向sender的请求返回ok消息\",{\"1\":{\"48\":1}}],[\"channel可以认为是容量为0的buffered\",{\"1\":{\"48\":1}}],[\"channel分为两种\",{\"1\":{\"48\":1}}],[\"channel的两种分类\",{\"0\":{\"48\":1}}],[\"channel的使用\",{\"0\":{\"45\":1}}],[\"channel是golang在语言层面提供的goroutine间的通信方式\",{\"1\":{\"46\":1}}],[\"channel\",{\"0\":{\"46\":1},\"1\":{\"46\":3,\"48\":8},\"2\":{\"55\":1}}],[\"checkconnerrorwriter\",{\"1\":{\"57\":1}}],[\"ch也是在main\",{\"1\":{\"49\":1}}],[\"ch<\",{\"1\":{\"48\":1}}],[\"ch2读数据\",{\"1\":{\"52\":1}}],[\"ch2\",{\"1\":{\"48\":1,\"52\":8}}],[\"ch1\",{\"1\":{\"48\":1,\"52\":8}}],[\"ch\",{\"1\":{\"47\":3,\"48\":10,\"49\":9,\"50\":4,\"51\":9,\"53\":8}}],[\"cookie\",{\"1\":{\"88\":2}}],[\"core\",{\"1\":{\"86\":3}}],[\"count\",{\"1\":{\"71\":2,\"72\":4}}],[\"could\",{\"1\":{\"57\":1}}],[\"control\",{\"1\":{\"86\":1}}],[\"contentlength\",{\"1\":{\"57\":1}}],[\"context\",{\"1\":{\"57\":12}}],[\"continue\",{\"1\":{\"57\":2}}],[\"connected\",{\"1\":{\"66\":1}}],[\"connections\",{\"1\":{\"79\":1}}],[\"connection\",{\"1\":{\"57\":1}}],[\"connreader\",{\"1\":{\"57\":1}}],[\"conn\",{\"1\":{\"57\":4}}],[\"conncontext\",{\"1\":{\"57\":2}}],[\"connctx\",{\"1\":{\"57\":5}}],[\"conforms\",{\"1\":{\"57\":1}}],[\"construct\",{\"1\":{\"88\":1}}],[\"constants\",{\"1\":{\"86\":1}}],[\"const\",{\"1\":{\"16\":1,\"57\":1}}],[\"color\",{\"1\":{\"25\":1}}],[\"com进行cookie之间的相互传递\",{\"1\":{\"89\":1}}],[\"compile\",{\"1\":{\"86\":4}}],[\"com\",{\"1\":{\"25\":2,\"76\":1,\"77\":1,\"80\":2,\"89\":8,\"90\":1}}],[\"此channel中recv的操作<\",{\"1\":{\"49\":1}}],[\"此时ch是一个nil\",{\"1\":{\"47\":2}}],[\"此页面应当包含\",{\"1\":{\"42\":1}}],[\"此文字有脚注\",{\"1\":{\"21\":1}}],[\"徽章\",{\"1\":{\"41\":1}}],[\"徽章文字\",{\"1\":{\"41\":1}}],[\"php默认会把session存储在服务器的临时目录中\",{\"1\":{\"88\":1}}],[\"phpsessid=q0fm8up72q58ne1b6khf37dlos\",{\"1\":{\"88\":1}}],[\"php官方提供了\",{\"1\":{\"86\":1}}],[\"php提供了很简单两个全局变量来操作cookie和session\",{\"1\":{\"88\":1}}],[\"php提供了\",{\"1\":{\"86\":1}}],[\"php的异常处理基类是\",{\"1\":{\"86\":1}}],[\"php的错误和异常处理\",{\"0\":{\"85\":1}}],[\"php的命令模式也就是cli模式\",{\"1\":{\"84\":1}}],[\"php的命令模式实现\",{\"0\":{\"84\":1}}],[\"php\",{\"0\":{\"106\":1},\"1\":{\"84\":4,\"86\":24,\"88\":7,\"89\":1},\"2\":{\"95\":1}}],[\"php面试总结\",{\"0\":{\"83\":1},\"2\":{\"95\":1}}],[\"port\",{\"1\":{\"88\":1}}],[\"pos设置为0表示从日志开头读起\",{\"1\":{\"80\":1}}],[\"pos=0\",{\"1\":{\"80\":1}}],[\"pool\",{\"1\":{\"57\":4,\"79\":1}}],[\"p\",{\"1\":{\"76\":1,\"77\":1,\"80\":1,\"89\":1}}],[\"p1\",{\"1\":{\"76\":1}}],[\"p0\",{\"1\":{\"76\":1}}],[\"pipelining\",{\"1\":{\"57\":2}}],[\"private\",{\"1\":{\"88\":2}}],[\"primary\",{\"1\":{\"76\":1}}],[\"printf\",{\"1\":{\"51\":1}}],[\"println\",{\"1\":{\"48\":5,\"49\":5,\"50\":2,\"51\":1,\"52\":4,\"53\":4}}],[\"protected\",{\"1\":{\"86\":2}}],[\"protoatleast\",{\"1\":{\"57\":1}}],[\"processlist\",{\"1\":{\"66\":1}}],[\"process\",{\"1\":{\"57\":1}}],[\"password\",{\"1\":{\"80\":1}}],[\"password=\",{\"1\":{\"80\":1}}],[\"paulma\",{\"1\":{\"77\":1}}],[\"pall\",{\"1\":{\"76\":1}}],[\"parse\",{\"1\":{\"86\":3}}],[\"partitions\",{\"1\":{\"76\":1}}],[\"partition\",{\"1\":{\"76\":4}}],[\"params\",{\"1\":{\"57\":3}}],[\"parallel\",{\"1\":{\"57\":1}}],[\"panic\",{\"1\":{\"57\":3}}],[\"path\",{\"1\":{\"57\":1}}],[\"put\",{\"1\":{\"57\":2}}],[\"public\",{\"1\":{\"41\":1,\"86\":4,\"88\":8}}],[\"plugin\",{\"1\":{\"15\":1}}],[\"进行引用\",{\"1\":{\"41\":2}}],[\"标准错误处理程序\",{\"1\":{\"86\":1}}],[\"标题和页面信息\",{\"1\":{\"42\":1}}],[\"标签为\",{\"1\":{\"40\":1}}],[\"标记\",{\"0\":{\"22\":1}}],[\"日志文件大小\",{\"1\":{\"79\":1}}],[\"日\",{\"1\":{\"40\":1}}],[\"月\",{\"1\":{\"40\":1}}],[\"年\",{\"1\":{\"40\":1}}],[\"↩︎\",{\"1\":{\"36\":1}}],[\"幻灯片\",{\"0\":{\"36\":1}}],[\"幻灯片页\",{\"0\":{\"0\":1}}],[\"交互演示\",{\"0\":{\"34\":1,\"35\":1}}],[\"捐赠一杯咖啡\",{\"1\":{\"33\":1}}],[\"向unbuffered\",{\"1\":{\"49\":1}}],[\"向\",{\"1\":{\"33\":1}}],[\"样式化\",{\"0\":{\"33\":1}}],[\"导入文件\",{\"0\":{\"31\":1}}],[\"导航栏\",{\"1\":{\"4\":1,\"42\":1}}],[\"−1\",{\"1\":{\"30\":1}}],[\"rpush\",{\"1\":{\"92\":1}}],[\"rpath\",{\"1\":{\"57\":1}}],[\"ray\",{\"0\":{\"103\":1},\"1\":{\"63\":1,\"102\":1}}],[\"range迭代channel就会一直被阻塞\",{\"1\":{\"51\":1}}],[\"range\",{\"1\":{\"51\":1,\"76\":2}}],[\"row\",{\"1\":{\"80\":1}}],[\"route\",{\"1\":{\"57\":1}}],[\"root\",{\"1\":{\"57\":4}}],[\"r\",{\"1\":{\"57\":5}}],[\"running\",{\"1\":{\"66\":1}}],[\"run\",{\"1\":{\"57\":1}}],[\"runtime\",{\"1\":{\"57\":1}}],[\"runhooks\",{\"1\":{\"57\":3}}],[\"rwc\",{\"1\":{\"57\":6}}],[\"rw\",{\"1\":{\"57\":5}}],[\"redis\",{\"1\":{\"88\":2,\"93\":1}}],[\"register\",{\"1\":{\"86\":2,\"88\":1}}],[\"registeronhiteof\",{\"1\":{\"57\":1}}],[\"reporting\",{\"1\":{\"86\":5}}],[\"replies\",{\"1\":{\"57\":2}}],[\"relay\",{\"1\":{\"80\":3}}],[\"re\",{\"1\":{\"57\":2}}],[\"readcloser\",{\"1\":{\"57\":1}}],[\"reader\",{\"1\":{\"57\":1}}],[\"read\",{\"1\":{\"57\":2,\"79\":1,\"88\":1}}],[\"readrequest\",{\"1\":{\"57\":1}}],[\"remain\",{\"1\":{\"57\":1}}],[\"remoteaddr\",{\"1\":{\"57\":3}}],[\"responses\",{\"1\":{\"57\":1}}],[\"responsewriter\",{\"1\":{\"57\":4}}],[\"resp\",{\"1\":{\"57\":1}}],[\"reset\",{\"1\":{\"57\":4}}],[\"req\",{\"1\":{\"57\":20}}],[\"requesturi\",{\"1\":{\"57\":1}}],[\"requests\",{\"1\":{\"57\":2}}],[\"requestbodyremains\",{\"1\":{\"57\":1}}],[\"request\",{\"1\":{\"57\":7,\"76\":3}}],[\"returned\",{\"1\":{\"57\":2}}],[\"return是退出整个函数\",{\"1\":{\"52\":1}}],[\"return\",{\"1\":{\"48\":1,\"53\":2,\"57\":9,\"86\":2,\"88\":6,\"92\":2,\"93\":1}}],[\"recover\",{\"1\":{\"57\":1}}],[\"receiver\",{\"1\":{\"49\":2}}],[\"receiver被阻塞\",{\"1\":{\"48\":1}}],[\"receiver每次请求channel时\",{\"1\":{\"48\":1}}],[\"receiver端按照队列的方式\",{\"1\":{\"48\":1}}],[\"receiver端一直阻塞\",{\"1\":{\"48\":1}}],[\"receive\",{\"1\":{\"47\":1,\"51\":1}}],[\"receive和close\",{\"1\":{\"47\":1}}],[\"recv操作将返回对应类型的0值以及一个状态码false\",{\"1\":{\"47\":1}}],[\"recv\",{\"1\":{\"47\":1,\"49\":3}}],[\"r−i​\",{\"1\":{\"30\":1}}],[\"r−i+1\",{\"1\":{\"30\":1}}],[\"r+i=1∑r​ωi\",{\"1\":{\"30\":1}}],[\"rgba\",{\"1\":{\"25\":1}}],[\"ωyω​\",{\"1\":{\"30\":2}}],[\"∂ωr∂r​\",{\"1\":{\"30\":1}}],[\"流程图\",{\"0\":{\"28\":1}}],[\"echo\",{\"1\":{\"93\":1}}],[\"echarts\",{\"0\":{\"27\":1}}],[\"exec\",{\"1\":{\"93\":1}}],[\"explame\",{\"1\":{\"89\":1}}],[\"expectcontinuereader\",{\"1\":{\"57\":1}}],[\"expectscontinue\",{\"1\":{\"57\":1}}],[\"expect\",{\"1\":{\"57\":2}}],[\"examples\",{\"1\":{\"88\":1}}],[\"exceptionhandler\",{\"1\":{\"86\":3}}],[\"exceptions\",{\"1\":{\"86\":1}}],[\"exception\",{\"1\":{\"86\":11}}],[\"e\",{\"1\":{\"86\":35}}],[\"either\",{\"1\":{\"57\":1}}],[\"even\",{\"1\":{\"57\":1}}],[\"else\",{\"1\":{\"57\":2}}],[\"erraborthandler\",{\"1\":{\"57\":1}}],[\"err\",{\"1\":{\"57\":12}}],[\"errserverclosed\",{\"1\":{\"57\":1}}],[\"error的错误可以交由set\",{\"1\":{\"86\":1}}],[\"errorhandler\",{\"1\":{\"86\":2}}],[\"errorexception\",{\"1\":{\"86\":5}}],[\"errorfunc\",{\"1\":{\"86\":1}}],[\"error\",{\"1\":{\"49\":1,\"51\":1,\"57\":2,\"86\":31}}],[\"en\",{\"1\":{\"86\":2}}],[\"enable\",{\"1\":{\"69\":1}}],[\"engine=innodb\",{\"1\":{\"76\":1}}],[\"engine\",{\"1\":{\"57\":18,\"76\":3}}],[\"end\",{\"1\":{\"50\":2}}],[\"enhance\",{\"1\":{\"15\":1}}],[\"图表\",{\"0\":{\"26\":1}}],[\"图片增强\",{\"0\":{\"24\":1}}],[\"0\",{\"1\":{\"25\":1,\"48\":1,\"51\":1,\"52\":1,\"53\":2,\"57\":3,\"86\":6,\"90\":6,\"93\":1}}],[\"last\",{\"1\":{\"86\":2}}],[\"less\",{\"1\":{\"76\":3}}],[\"left\",{\"1\":{\"71\":1}}],[\"len\",{\"1\":{\"57\":2}}],[\"let\",{\"1\":{\"57\":1}}],[\"localaddr\",{\"1\":{\"57\":1}}],[\"localaddrcontextkey\",{\"1\":{\"57\":1}}],[\"long\",{\"1\":{\"57\":1,\"79\":1}}],[\"log`\",{\"1\":{\"76\":1}}],[\"logf\",{\"1\":{\"57\":1}}],[\"log\",{\"1\":{\"51\":1,\"53\":4,\"76\":1,\"79\":2,\"80\":6}}],[\"logy\",{\"1\":{\"30\":2}}],[\"logo\",{\"1\":{\"25\":2}}],[\"l\",{\"1\":{\"57\":2}}],[\"ln\",{\"1\":{\"57\":2}}],[\"line\",{\"1\":{\"86\":3}}],[\"link\",{\"1\":{\"25\":1}}],[\"lib\",{\"1\":{\"80\":2}}],[\"list\",{\"1\":{\"84\":2}}],[\"list分区\",{\"1\":{\"76\":1}}],[\"listener\",{\"1\":{\"57\":1}}],[\"listen\",{\"1\":{\"57\":1}}],[\"listenandserve\",{\"1\":{\"57\":3}}],[\"light\",{\"1\":{\"25\":1}}],[\"table\",{\"1\":{\"67\":1,\"68\":2,\"69\":2,\"71\":1,\"72\":1,\"76\":1,\"79\":1}}],[\"taskid\",{\"1\":{\"51\":3}}],[\"task\",{\"1\":{\"51\":6}}],[\"tl\",{\"1\":{\"57\":2}}],[\"try\",{\"1\":{\"86\":1}}],[\"trigger\",{\"1\":{\"86\":2}}],[\"tree索引是有序的\",{\"1\":{\"70\":1}}],[\"tree索引\",{\"1\":{\"70\":1}}],[\"trees\",{\"1\":{\"57\":1}}],[\"tree\",{\"1\":{\"57\":2}}],[\"true\",{\"1\":{\"57\":1,\"88\":4,\"89\":1}}],[\"testcookie\",{\"1\":{\"89\":1}}],[\"testcity\",{\"1\":{\"71\":2,\"72\":5}}],[\"tempdelay\",{\"1\":{\"57\":2}}],[\"tex\",{\"0\":{\"30\":1}}],[\"tcp协议监听端口\",{\"1\":{\"57\":1}}],[\"tcp\",{\"1\":{\"57\":1}}],[\"to\",{\"1\":{\"57\":6,\"80\":1}}],[\"toc\",{\"1\":{\"42\":1}}],[\"think\",{\"1\":{\"84\":2}}],[\"this\",{\"1\":{\"57\":2}}],[\"than\",{\"1\":{\"76\":3}}],[\"that\",{\"1\":{\"57\":1}}],[\"throwable\",{\"1\":{\"86\":1}}],[\"throw\",{\"1\":{\"86\":2}}],[\"throw关键字抛出异常\",{\"1\":{\"86\":1}}],[\"through行为\",{\"1\":{\"52\":1}}],[\"threads\",{\"1\":{\"66\":2}}],[\"their\",{\"1\":{\"57\":1}}],[\"them\",{\"1\":{\"57\":1}}],[\"the\",{\"1\":{\"57\":11}}],[\"there\",{\"1\":{\"25\":2}}],[\"t\",{\"1\":{\"51\":3,\"57\":5}}],[\"types\",{\"1\":{\"86\":2}}],[\"type是否开启缓存\",{\"1\":{\"78\":1}}],[\"type\",{\"1\":{\"51\":1,\"57\":1,\"86\":4}}],[\"time`\",{\"1\":{\"76\":3}}],[\"time参数来设置日志记录行为\",{\"1\":{\"66\":1}}],[\"timer\",{\"1\":{\"53\":3}}],[\"timeout\",{\"1\":{\"53\":2,\"88\":1}}],[\"time\",{\"1\":{\"50\":2,\"51\":2,\"53\":6,\"57\":3,\"76\":2,\"79\":1,\"89\":1}}],[\"title\",{\"1\":{\"25\":1}}],[\"html\",{\"1\":{\"76\":1,\"77\":1,\"80\":1,\"89\":1,\"90\":1}}],[\"httpmethod\",{\"1\":{\"57\":1}}],[\"http包中server\",{\"1\":{\"57\":1}}],[\"http包中有默认的defaultservemux\",{\"1\":{\"57\":1}}],[\"http服务的底层走的是tcp协议\",{\"1\":{\"57\":1}}],[\"http\",{\"1\":{\"57\":17,\"80\":1,\"86\":9,\"88\":3}}],[\"https\",{\"1\":{\"25\":2,\"76\":1,\"77\":2,\"80\":3,\"89\":1,\"90\":3}}],[\"hash也可以看成是轮询的升级版\",{\"1\":{\"90\":1}}],[\"hash失效时\",{\"1\":{\"90\":1}}],[\"hash\",{\"1\":{\"90\":6}}],[\"hash分区\",{\"1\":{\"76\":1}}],[\"have\",{\"1\":{\"57\":1}}],[\"handleexceptions\",{\"1\":{\"86\":2}}],[\"handles\",{\"1\":{\"57\":1}}],[\"handlehttprequest\",{\"1\":{\"57\":3}}],[\"handlershutdown\",{\"1\":{\"86\":2}}],[\"handlers\",{\"1\":{\"57\":6}}],[\"handlerfunc函数\",{\"1\":{\"57\":1}}],[\"handler\",{\"1\":{\"57\":10,\"86\":14,\"88\":1}}],[\"handler接口的实现者\",{\"1\":{\"57\":1}}],[\"handler接口\",{\"1\":{\"57\":2}}],[\"header\",{\"1\":{\"57\":1}}],[\"here\",{\"1\":{\"57\":1}}],[\"hijacked\",{\"1\":{\"57\":2}}],[\"hostip\",{\"1\":{\"80\":1}}],[\"host=\",{\"1\":{\"80\":1}}],[\"how\",{\"1\":{\"57\":1}}],[\"hope\",{\"1\":{\"25\":4,\"33\":1,\"40\":1}}],[\"h2o\",{\"1\":{\"18\":1}}],[\"卡片\",{\"0\":{\"25\":1}}],[\"重要的内容\",{\"1\":{\"22\":1}}],[\"脚注\",{\"0\":{\"21\":1}}],[\"的存储的例子\",{\"1\":{\"88\":1}}],[\"的当前值\",{\"1\":{\"86\":1}}],[\"的路径和文件名\",{\"1\":{\"80\":1}}],[\"的实现\",{\"1\":{\"57\":1}}],[\"的定时任务还是在时间堆中等待触发\",{\"1\":{\"53\":1}}],[\"的组合会导致内存泄露\",{\"1\":{\"53\":1}}],[\"的性能开销很小\",{\"1\":{\"46\":1}}],[\"的发送方和接受方是\",{\"1\":{\"46\":1}}],[\"的\",{\"1\":{\"20\":1,\"40\":1}}],[\"ip绑定\",{\"1\":{\"90\":1}}],[\"ip\",{\"1\":{\"88\":1,\"90\":4}}],[\"ivictor\",{\"1\":{\"80\":1}}],[\"implements\",{\"1\":{\"88\":1}}],[\"implement\",{\"1\":{\"57\":1}}],[\"incr\",{\"1\":{\"92\":1}}],[\"increment\",{\"1\":{\"76\":1}}],[\"ini\",{\"1\":{\"88\":1}}],[\"init\",{\"1\":{\"86\":1}}],[\"initialreadlimitsize\",{\"1\":{\"57\":1}}],[\"innodb\",{\"1\":{\"76\":3,\"79\":2}}],[\"innodb的数据和索引放在一起\",{\"1\":{\"73\":1}}],[\"innodb的索引策略是聚簇索引\",{\"1\":{\"65\":1}}],[\"innodb中使用聚簇索引的方式存储数据\",{\"1\":{\"73\":1}}],[\"innodb存储引擎支持\",{\"1\":{\"72\":1}}],[\"innodb采用聚簇索引的方式存储数据\",{\"1\":{\"65\":1}}],[\"innodb支持热备份\",{\"1\":{\"65\":1}}],[\"innodb支持事务\",{\"1\":{\"65\":1}}],[\"innodb使用mvcc实现并发控制\",{\"1\":{\"65\":1}}],[\"index\",{\"1\":{\"57\":2,\"84\":1,\"86\":1}}],[\"index++\",{\"1\":{\"57\":2}}],[\"in通道只用于接收数据\",{\"1\":{\"51\":1}}],[\"in\",{\"1\":{\"51\":1,\"57\":4,\"86\":1}}],[\"int8\",{\"1\":{\"57\":1}}],[\"interface\",{\"1\":{\"57\":1}}],[\"int64\",{\"1\":{\"51\":2}}],[\"int\",{\"1\":{\"47\":2,\"48\":4,\"49\":3,\"50\":1,\"51\":6,\"52\":4,\"53\":2,\"76\":3,\"86\":1}}],[\"if\",{\"1\":{\"48\":1,\"52\":2,\"57\":23,\"86\":2,\"92\":2,\"93\":1}}],[\"i++\",{\"1\":{\"48\":1,\"51\":2,\"52\":1,\"53\":2,\"57\":1}}],[\"i\",{\"1\":{\"48\":7,\"51\":12,\"52\":8,\"53\":4,\"57\":4}}],[\"ir⋯\",{\"1\":{\"30\":1}}],[\"isfatal\",{\"1\":{\"86\":1}}],[\"is\",{\"1\":{\"25\":2,\"57\":1,\"86\":1}}],[\"id选项\",{\"1\":{\"80\":1}}],[\"idx\",{\"1\":{\"72\":1}}],[\"id\",{\"1\":{\"20\":1,\"72\":1}}],[\"itkingone\",{\"1\":{\"90\":1}}],[\"it\",{\"1\":{\"13\":2,\"57\":2}}],[\"我就是个技术混子\",{\"1\":{\"83\":1}}],[\"我自我感觉回答的很渣\",{\"1\":{\"83\":1}}],[\"我看下这个serverhandler\",{\"1\":{\"57\":1}}],[\"我\",{\"1\":{\"53\":1}}],[\"我们支持\",{\"1\":{\"97\":1,\"101\":1}}],[\"我们定义了几个key\",{\"1\":{\"92\":1}}],[\"我们使用\",{\"1\":{\"92\":1}}],[\"我们在创建秒杀活动的时候就要把商品相关信息写入到缓存中\",{\"1\":{\"92\":1}}],[\"我们一一分析下\",{\"1\":{\"92\":1}}],[\"我们自定义了一个处理类\",{\"1\":{\"86\":1}}],[\"我们可以采用redis\",{\"1\":{\"92\":1}}],[\"我们可以通过set\",{\"1\":{\"86\":1}}],[\"我们可以把它理解为线程\",{\"1\":{\"46\":1}}],[\"我们同样可以使用前缀索引中的方法来比较\",{\"1\":{\"72\":1}}],[\"我们通过代码可以看到\",{\"1\":{\"57\":1}}],[\"我们主要看serve\",{\"1\":{\"57\":1}}],[\"我们看到代码里serverhandler中的\",{\"1\":{\"57\":1}}],[\"我们看到实例化了一个serverhandler并调用了其servehttp方法来处理\",{\"1\":{\"57\":1}}],[\"我们看到这个方法中做了哪些事\",{\"1\":{\"57\":1}}],[\"我们看到这个方法的参数是一个连接的上下文\",{\"1\":{\"57\":1}}],[\"我们看到这个方法两个步骤\",{\"1\":{\"57\":1}}],[\"我们看下gin中怎么实现的\",{\"1\":{\"57\":1}}],[\"我们这个计时器\",{\"1\":{\"53\":1}}],[\"我们本意是在3秒之后停止main\",{\"1\":{\"53\":1}}],[\"我在右对齐\",{\"1\":{\"19\":1}}],[\"我是居中的\",{\"1\":{\"19\":1}}],[\"上个例子中已经采用了原子操作\",{\"1\":{\"93\":1}}],[\"上面例子中\",{\"1\":{\"84\":1}}],[\"上面的示例中\",{\"1\":{\"92\":1}}],[\"上面的例子中\",{\"1\":{\"86\":1}}],[\"上面的错误级别可以参考php官方文档\",{\"1\":{\"86\":1}}],[\"上面的列子很简单\",{\"1\":{\"84\":1}}],[\"上面的代码监听了8080端口来提供http服务\",{\"1\":{\"57\":1}}],[\"上面的代码表示必须f1函数执行完成才能执行f2函数\",{\"1\":{\"50\":1}}],[\"上面的代码我们看到首先声明了一个chan\",{\"1\":{\"47\":1}}],[\"上下角标\",{\"0\":{\"18\":1}}],[\"上一篇\",{\"1\":{\"4\":1}}],[\"危险容器\",{\"1\":{\"16\":1}}],[\"警告容器\",{\"1\":{\"16\":1}}],[\"提交读\",{\"1\":{\"65\":1}}],[\"提示\",{\"1\":{\"41\":1}}],[\"提示容器\",{\"1\":{\"16\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"15\":1}}],[\"=>\",{\"1\":{\"86\":4}}],[\"==\",{\"1\":{\"57\":6}}],[\"=\",{\"1\":{\"16\":1,\"30\":1,\"47\":1,\"48\":7,\"49\":3,\"50\":4,\"51\":8,\"52\":9,\"53\":7,\"57\":55,\"72\":2,\"76\":3,\"80\":3,\"86\":7,\"88\":4,\"92\":1}}],[\"atomicinteger\",{\"1\":{\"92\":1}}],[\"attrs\",{\"0\":{\"20\":1}}],[\"apache\",{\"1\":{\"90\":1}}],[\"ajax模式下错误响应\",{\"1\":{\"86\":1}}],[\"adparking\",{\"1\":{\"80\":1}}],[\"addr\",{\"1\":{\"57\":6}}],[\"add\",{\"1\":{\"50\":1,\"51\":1,\"52\":1,\"71\":1,\"72\":1}}],[\"away\",{\"1\":{\"80\":1}}],[\"array\",{\"1\":{\"86\":4}}],[\"argv\",{\"1\":{\"84\":1}}],[\"articles\",{\"1\":{\"90\":1}}],[\"article\",{\"1\":{\"77\":1,\"80\":2,\"90\":2}}],[\"are\",{\"1\":{\"49\":1,\"51\":1}}],[\"auto\",{\"1\":{\"76\":1}}],[\"alter\",{\"1\":{\"67\":1,\"68\":1,\"69\":1,\"71\":1,\"72\":1}}],[\"also\",{\"1\":{\"57\":1}}],[\"allnoroute\",{\"1\":{\"57\":1}}],[\"all\",{\"1\":{\"49\":1,\"51\":1,\"57\":1,\"86\":3}}],[\"as\",{\"1\":{\"57\":1,\"71\":1,\"72\":2}}],[\"asleep\",{\"1\":{\"49\":1,\"51\":1}}],[\"answer\",{\"1\":{\"57\":1}}],[\"and\",{\"1\":{\"57\":2,\"76\":1}}],[\"another\",{\"1\":{\"57\":1}}],[\"any\",{\"1\":{\"57\":1}}],[\"acid指\",{\"1\":{\"65\":1}}],[\"active\",{\"1\":{\"57\":2}}],[\"accept\",{\"1\":{\"57\":2}}],[\"after进行初始化\",{\"1\":{\"53\":1}}],[\"after\",{\"1\":{\"53\":4}}],[\"a\",{\"1\":{\"16\":1,\"57\":1,\"86\":1,\"89\":2}}],[\"与\",{\"1\":{\"16\":1}}],[\"代码如下\",{\"1\":{\"57\":4}}],[\"代码演示\",{\"0\":{\"32\":1}}],[\"代码块\",{\"0\":{\"17\":1}}],[\"代码\",{\"1\":{\"16\":1}}],[\"包含\",{\"1\":{\"16\":1}}],[\"信息容器\",{\"1\":{\"16\":1}}],[\"自定义会话管理可以实现共享session\",{\"1\":{\"88\":1}}],[\"自定义它们\",{\"1\":{\"42\":1}}],[\"自定义对齐\",{\"0\":{\"19\":1}}],[\"自定义标题\",{\"1\":{\"16\":5}}],[\"自定义容器\",{\"0\":{\"16\":1}}],[\"v20180824\",{\"0\":{\"83\":1}}],[\"v\",{\"1\":{\"52\":5,\"53\":4,\"57\":2}}],[\"value插入秒杀请求\",{\"1\":{\"92\":1}}],[\"value数据结构\",{\"1\":{\"92\":1}}],[\"values\",{\"1\":{\"76\":3}}],[\"value\",{\"1\":{\"57\":5}}],[\"val\",{\"1\":{\"48\":2}}],[\"varchar\",{\"1\":{\"76\":1}}],[\"var\",{\"1\":{\"47\":1,\"57\":1,\"80\":2}}],[\"variable\",{\"1\":{\"16\":1,\"86\":1}}],[\"vue\",{\"0\":{\"35\":1}}],[\"vuepress\",{\"0\":{\"14\":1},\"1\":{\"10\":2,\"12\":2,\"13\":1,\"14\":2,\"15\":1,\"41\":1}}],[\"安全的在\",{\"1\":{\"16\":1}}],[\"mode\",{\"1\":{\"79\":1}}],[\"moxigandashu\",{\"1\":{\"77\":1}}],[\"more\",{\"1\":{\"39\":1}}],[\"mliudong\",{\"1\":{\"76\":1}}],[\"mysql\",{\"1\":{\"80\":3},\"2\":{\"81\":1,\"82\":1}}],[\"mysql5\",{\"1\":{\"77\":1}}],[\"mysql高级特性\",{\"0\":{\"75\":1}}],[\"mysql版本5\",{\"1\":{\"74\":1}}],[\"mysql修改表相关\",{\"0\":{\"67\":1}}],[\"mysql优化相关\",{\"0\":{\"66\":1}}],[\"mysql的数据恢复相较于innodb较差\",{\"1\":{\"65\":1}}],[\"mysql相关知识点浅析\",{\"0\":{\"64\":1}}],[\"myisam通过key\",{\"1\":{\"73\":1}}],[\"myisam却不同\",{\"1\":{\"73\":1}}],[\"myisam和innodb的索引总结\",{\"0\":{\"73\":1}}],[\"myisam和innodb的区别\",{\"0\":{\"65\":1}}],[\"myisam采用索引和列的值分离的方式存储数据\",{\"1\":{\"65\":1}}],[\"myisam崩溃的概率比innodb要大很多\",{\"1\":{\"65\":1}}],[\"myisam支持延迟更新索引键\",{\"1\":{\"65\":1}}],[\"myisam支持全文索引\",{\"1\":{\"65\":1}}],[\"myisam的锁不支持行级锁\",{\"1\":{\"65\":1}}],[\"message\",{\"1\":{\"86\":4}}],[\"merge则说明表的索引策略很糟糕\",{\"1\":{\"71\":1}}],[\"mermaid\",{\"0\":{\"29\":1}}],[\"method\",{\"1\":{\"57\":3,\"90\":1}}],[\"mixed|row|statement\",{\"1\":{\"80\":1}}],[\"mixed\",{\"1\":{\"80\":1}}],[\"might\",{\"1\":{\"57\":1}}],[\"mister\",{\"1\":{\"25\":2}}],[\"multiple\",{\"1\":{\"57\":1}}],[\"mark\",{\"0\":{\"105\":1}}],[\"markdown\",{\"0\":{\"10\":1,\"11\":1,\"12\":1,\"13\":1},\"1\":{\"2\":1,\"10\":2,\"11\":3,\"12\":1,\"13\":3,\"14\":2,\"15\":1,\"16\":1,\"31\":1,\"40\":1,\"41\":2},\"2\":{\"38\":1}}],[\"management\",{\"1\":{\"88\":1}}],[\"manual\",{\"1\":{\"86\":9,\"88\":3}}],[\"masteruser\",{\"1\":{\"80\":1}}],[\"master\",{\"1\":{\"80\":8}}],[\"max\",{\"1\":{\"79\":1}}],[\"maxvalue\",{\"1\":{\"76\":1}}],[\"main\",{\"1\":{\"48\":2,\"49\":3,\"50\":1,\"51\":2,\"52\":1,\"53\":2}}],[\"make\",{\"1\":{\"47\":1,\"48\":4,\"49\":3,\"50\":1,\"51\":2,\"52\":2,\"53\":2,\"57\":1}}],[\"ms\",{\"1\":{\"40\":1}}],[\"mr\",{\"1\":{\"25\":1,\"33\":1}}],[\"md\",{\"1\":{\"15\":1}}],[\"主索引和增量索引都要定时维护\",{\"1\":{\"80\":1}}],[\"主从复制开启步骤\",{\"1\":{\"80\":1}}],[\"主库配置二进制文件地址\",{\"1\":{\"80\":1}}],[\"主库从库配置server\",{\"1\":{\"80\":1}}],[\"主库\",{\"1\":{\"80\":1}}],[\"主键索引\",{\"1\":{\"73\":1}}],[\"主键最好使用整数类型\",{\"1\":{\"66\":1}}],[\"主题包含了一个自定义徽章可以使用\",{\"1\":{\"41\":1}}],[\"主题扩展了更多\",{\"1\":{\"15\":1}}],[\"主题扩展\",{\"0\":{\"15\":1}}],[\"主要通过\",{\"1\":{\"86\":1}}],[\"主要是通过主键来实现\",{\"1\":{\"72\":1}}],[\"主要是实现\",{\"1\":{\"57\":1}}],[\"主要从\",{\"1\":{\"10\":1}}],[\"主要功能与配置演示\",{\"0\":{\"1\":1}}],[\"中主要采用反向代理的方式来实现负载均衡\",{\"1\":{\"90\":1}}],[\"中处理\",{\"1\":{\"86\":1}}],[\"中设置页面信息\",{\"1\":{\"40\":1}}],[\"中使用\",{\"1\":{\"16\":1}}],[\"中的\",{\"1\":{\"14\":1}}],[\"中很重要的一个概念\",{\"1\":{\"12\":1}}],[\"请使用绝对链接\",{\"1\":{\"41\":1}}],[\"请阅读\",{\"1\":{\"14\":1}}],[\"请先阅读\",{\"1\":{\"11\":1}}],[\"对库存的判断出现了问题\",{\"1\":{\"93\":1}}],[\"对代码的修改建议\",{\"1\":{\"86\":1}}],[\"对优化mysql查询至关重要\",{\"1\":{\"66\":1}}],[\"对chan进行了nil赋值\",{\"1\":{\"52\":1}}],[\"对nil\",{\"1\":{\"47\":1}}],[\"对象\",{\"1\":{\"46\":1}}],[\"对于每个用户的秒杀\",{\"1\":{\"92\":1}}],[\"对于读多写少业务\",{\"1\":{\"92\":1}}],[\"对于innodb来说最重要的两个配置为\",{\"1\":{\"79\":1}}],[\"对于引擎是myisam的数据表在迁移或转入大量数据的时候\",{\"1\":{\"67\":1}}],[\"对于这一次的选择\",{\"1\":{\"52\":1}}],[\"对于recv来说\",{\"1\":{\"51\":1}}],[\"对于receiver也一样\",{\"1\":{\"48\":1}}],[\"对于buffered\",{\"1\":{\"48\":1}}],[\"对于unbuffered\",{\"1\":{\"48\":1}}],[\"对于\",{\"1\":{\"41\":1}}],[\"对\",{\"1\":{\"14\":1}}],[\"为了识别当前用户而创建的一种技术手段\",{\"1\":{\"88\":1}}],[\"为了丰富文档写作\",{\"1\":{\"14\":1}}],[\"为数组的键\",{\"1\":{\"86\":1}}],[\"为每个\",{\"1\":{\"12\":1}}],[\"插件来实现\",{\"1\":{\"13\":1}}],[\"扩展\",{\"0\":{\"13\":1,\"14\":1},\"1\":{\"14\":1}}],[\"是否能够正常工作\",{\"1\":{\"90\":1}}],[\"是否能够将请求均匀的发送给后端\",{\"1\":{\"90\":1}}],[\"是否能落到同一台机器\",{\"1\":{\"90\":1}}],[\"是否只读\",{\"1\":{\"79\":1}}],[\"是的\",{\"1\":{\"83\":1}}],[\"是一个合格的servemux了\",{\"1\":{\"57\":1}}],[\"是一个通道\",{\"1\":{\"46\":1}}],[\"是不会被\",{\"1\":{\"53\":1}}],[\"是在换个文件的参数\",{\"1\":{\"84\":1}}],[\"是在\",{\"1\":{\"53\":1}}],[\"是在channel中已有一个数据\",{\"1\":{\"48\":1}}],[\"是引用类型\",{\"1\":{\"46\":1}}],[\"是轻量级的协程\",{\"1\":{\"46\":1}}],[\"是\",{\"1\":{\"12\":1}}],[\"配置好之后\",{\"1\":{\"80\":1}}],[\"配置优化\",{\"0\":{\"79\":1}}],[\"配置\",{\"0\":{\"12\":1}}],[\"演示\",{\"1\":{\"11\":1}}],[\"和在\",{\"1\":{\"86\":1}}],[\"和group\",{\"1\":{\"70\":1,\"71\":1}}],[\"和buffered\",{\"1\":{\"48\":1}}],[\"和\",{\"1\":{\"11\":1,\"40\":1,\"86\":2,\"88\":2,\"89\":2}}],[\"还不会编写\",{\"1\":{\"11\":1}}],[\"介绍\",{\"0\":{\"11\":1,\"97\":1,\"101\":1},\"1\":{\"11\":1,\"12\":1}}],[\"你需要阅读\",{\"1\":{\"12\":1}}],[\"你应该创建和编写\",{\"1\":{\"10\":1}}],[\"你可以把session存储到一个公共的服务器或集群中\",{\"1\":{\"88\":1}}],[\"你可以通过配置\",{\"1\":{\"88\":1}}],[\"你可以通过主题选项和页面\",{\"1\":{\"42\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"4\":1}}],[\"你可以将图片和\",{\"1\":{\"41\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"41\":1}}],[\"你可以在\",{\"1\":{\"40\":1}}],[\"你可以标记\",{\"1\":{\"22\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"10\":1}}],[\"文章标题列表\",{\"1\":{\"42\":1}}],[\"文章加密\",{\"2\":{\"9\":1}}],[\"文件改变它\",{\"1\":{\"88\":1}}],[\"文件夹的图片\",{\"1\":{\"41\":1}}],[\"文件放置在一起\",{\"1\":{\"41\":1}}],[\"文件\",{\"1\":{\"10\":1}}],[\"文件生成页面\",{\"1\":{\"10\":1}}],[\"文字结尾应该有深蓝色的\",{\"1\":{\"41\":1}}],[\"文字\",{\"1\":{\"7\":2}}],[\"文字段落\",{\"1\":{\"7\":24}}],[\"27093465\",{\"1\":{\"90\":1}}],[\"20\",{\"1\":{\"48\":1}}],[\"2020\",{\"1\":{\"40\":1}}],[\"230\",{\"1\":{\"25\":1}}],[\"253\",{\"1\":{\"25\":1}}],[\"2\",{\"1\":{\"7\":14,\"23\":1,\"50\":1,\"52\":1,\"57\":1,\"80\":1,\"86\":3}}],[\"14\",{\"1\":{\"90\":3}}],[\"1400000000\",{\"1\":{\"76\":2}}],[\"168\",{\"1\":{\"90\":6}}],[\"192\",{\"1\":{\"90\":6}}],[\"19th\",{\"1\":{\"18\":1}}],[\"11\",{\"1\":{\"76\":3}}],[\"1是在main\",{\"1\":{\"49\":1}}],[\"100\",{\"1\":{\"51\":2,\"57\":1}}],[\"10\",{\"1\":{\"48\":2,\"51\":2,\"52\":2,\"53\":2,\"57\":1,\"72\":2}}],[\"1500000000\",{\"1\":{\"76\":2}}],[\"15\",{\"1\":{\"25\":1,\"90\":3}}],[\"138\",{\"1\":{\"25\":1}}],[\"1\",{\"1\":{\"7\":12,\"16\":1,\"21\":1,\"23\":1,\"40\":2,\"48\":1,\"49\":5,\"50\":1,\"51\":3,\"57\":3,\"80\":1,\"86\":2,\"92\":2}}],[\"段落\",{\"1\":{\"7\":2}}],[\"密码加密的文章\",{\"0\":{\"7\":1}}],[\"页脚\",{\"1\":{\"4\":1,\"42\":1}}],[\"页面静态化\",{\"1\":{\"92\":1}}],[\"页面结构\",{\"0\":{\"42\":1}}],[\"页面内容\",{\"0\":{\"41\":1}}],[\"页面配置\",{\"0\":{\"39\":1},\"1\":{\"40\":1},\"2\":{\"44\":1}}],[\"页面引入配置\",{\"1\":{\"12\":1}}],[\"页面信息\",{\"0\":{\"40\":1},\"1\":{\"4\":1}}],[\"页面展示\",{\"1\":{\"2\":1,\"31\":1}}],[\"评论\",{\"1\":{\"4\":1,\"42\":1}}],[\"链接\",{\"1\":{\"4\":1,\"16\":1}}],[\"编辑此页链接\",{\"1\":{\"4\":1}}],[\"贡献者\",{\"1\":{\"4\":1,\"42\":1}}],[\"路径导航\",{\"1\":{\"4\":1,\"42\":1}}],[\"侧边栏\",{\"1\":{\"4\":1,\"42\":1}}],[\"布局与功能禁用\",{\"0\":{\"4\":1}}],[\"加密展示\",{\"1\":{\"2\":1,\"31\":1}}],[\"展示\",{\"0\":{\"10\":1},\"1\":{\"2\":1,\"31\":1}}],[\"目录\",{\"0\":{\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
