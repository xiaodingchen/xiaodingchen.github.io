import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as t,c as i,b as n,d as s,e as c,a as l}from"./app-f916d83f.js";const p={},r=l(`<h1 id="简单聊聊内存逃逸" tabindex="-1"><a class="header-anchor" href="#简单聊聊内存逃逸" aria-hidden="true">#</a> 简单聊聊内存逃逸？</h1><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h2><p>知道golang的内存逃逸吗？什么情况下会发生内存逃逸？</p><h2 id="回答" tabindex="-1"><a class="header-anchor" href="#回答" aria-hidden="true">#</a> 回答</h2><p>golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。</p><p>能引起变量逃逸到堆上的典型情况：</p><ul><li><strong>在方法内把局部变量指针返回</strong> 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</li><li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 <code>goroutine</code> 会在 <code>channel</code> 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li><li><strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 <code>[]*string</code> 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li><li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li><li><strong>在 interface 类型上调用方法。</strong> 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。</li></ul><h2 id="举例" tabindex="-1"><a class="header-anchor" href="#举例" aria-hidden="true">#</a> 举例</h2><p><strong>通过一个例子加深理解，接下来尝试下怎么通过 <code>go build -gcflags=-m</code> 查看逃逸的情况。</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>
<span class="token keyword">type</span> A <span class="token keyword">struct</span> <span class="token punctuation">{</span>
 s <span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token comment">// 这是上面提到的 &quot;在方法内把局部变量指针返回&quot; 的情况</span>
<span class="token keyword">func</span> <span class="token function">foo</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>A <span class="token punctuation">{</span>
 a <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> 
 a<span class="token punctuation">.</span>s <span class="token operator">=</span> s
 <span class="token keyword">return</span> a <span class="token comment">//返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 a <span class="token operator">:=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span>
 b <span class="token operator">:=</span> a<span class="token punctuation">.</span>s <span class="token operator">+</span> <span class="token string">&quot; world&quot;</span>
 c <span class="token operator">:=</span> b <span class="token operator">+</span> <span class="token string">&quot;!&quot;</span>
 fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行go build -gcflags=-m main.go</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>go build <span class="token parameter variable">-gcflags</span><span class="token operator">=</span>-m main.go
<span class="token comment"># command-line-arguments</span>
./main.go:7:6: can inline foo
./main.go:13:10: inlining call to foo
./main.go:16:13: inlining call to fmt.Println
/var/folders/45/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/go-build409982591/b001/_gomod_.go:6:6: can inline init.0
./main.go:7:10: leaking param: s
./main.go:8:10: new<span class="token punctuation">(</span>A<span class="token punctuation">)</span> escapes to heap
./main.go:16:13: io.Writer<span class="token punctuation">(</span>os.Stdout<span class="token punctuation">)</span> escapes to heap
./main.go:16:13: c escapes to heap
./main.go:15:9: b + <span class="token string">&quot;!&quot;</span> escapes to heap
./main.go:13:10: main new<span class="token punctuation">(</span>A<span class="token punctuation">)</span> does not escape
./main.go:14:11: main a.s + <span class="token string">&quot; world&quot;</span> does not escape
./main.go:16:13: main <span class="token punctuation">[</span><span class="token punctuation">]</span>interface <span class="token punctuation">{</span><span class="token punctuation">}</span> literal does not escape
<span class="token operator">&lt;</span>autogenerated<span class="token operator">&gt;</span>:1: os.<span class="token punctuation">(</span>*File<span class="token punctuation">)</span>.close .this does not escape
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>./main.go:8:10: new(A) escapes to heap</code> 说明 <code>new(A)</code> 逃逸了,符合上述提到的常见情况中的第一种。</li><li><code>./main.go:14:11: main a.s + &quot; world&quot; does not escape</code> 说明 b 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。</li><li><code>./main.go:15:9: b + &quot;!&quot; escapes to heap</code> 说明 c 变量逃逸，通过<code>fmt.Println(a ...interface{})</code>打印的变量，都会发生逃逸，感兴趣的朋友可以去查查为什么。</li></ul><p>以上操作其实就叫逃逸分析。下篇文章，跟大家聊聊怎么用一个比较trick的方法使变量不逃逸。方便大家在面试官面前秀一波。</p>`,14),d={href:"https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ",target:"_blank",rel:"noopener noreferrer"};function u(m,k){const a=o("ExternalLinkIcon");return t(),i("div",null,[r,n("blockquote",null,[n("p",null,[s("原文 "),n("a",d,[s("https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ"),c(a)])])])])}const b=e(p,[["render",u],["__file","q019.html.vue"]]);export{b as default};
